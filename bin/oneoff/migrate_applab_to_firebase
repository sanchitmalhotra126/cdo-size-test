#!/usr/bin/env ruby

require File.expand_path('../../../deployment', __FILE__)
require 'cdo/db'
require 'cdo/hip_chat'
require 'net/http'
require 'parallel'
require 'uri'

require_relative '../../shared/middleware/helpers/storage_id'
require_relative '../../shared/middleware/helpers/dynamo_table'
require_relative '../../shared/middleware/helpers/property_bag'

puts "CDO.firebase_name: #{CDO.firebase_name}"

MAX_THREADS = 20
LOG_INCREMENT = 100

def put_with_auth(url, data)
  uri = URI.parse("#{url}?auth=#{CDO.firebase_secret}")
  request = Net::HTTP::Put.new(uri)
  request.body = data

  response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: uri.scheme == "https") do |http|
    http.request(request)
  end

  unless response.is_a?(Net::HTTPSuccess)
    raise "Failed to PUT data at #{url} with error #{response.code} '#{response.body}'"
  end
end

def post_with_auth(url, data)
  uri = URI.parse("#{url}?auth=#{CDO.firebase_secret}")
  request = Net::HTTP::Post.new(uri)
  request.body = data

  response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: uri.scheme == "https") do |http|
    http.request(request)
  end

  unless response.is_a?(Net::HTTPSuccess)
    raise "Failed to POST data at #{url} with error #{response.code} '#{response.body}'"
  end
end

# Sets the counters, metadata, and contents of a table in firebase.
#
# @param encrypted_channel_id [String]
# @param properties_data [Hash] Map from property name to JSON-encoded value
def set_firebase_properties(encrypted_channel_id, properties_data)
  channel_url = "https://#{CDO.firebase_name}.firebaseio.com/v3/channels/#{encrypted_channel_id}"
  properties_url = "#{channel_url}/storage/keys.json"
  put_with_auth(properties_url, properties_data.to_json)
end

# Sets the counters, metadata, and contents of a table in firebase.
#
# @param encrypted_channel_id [String] An encrypted, base64-encoded channel id.
# @param table_name [String]
# @param table_records [Hash] Map from record id to json-encoded record
# @params table_columns [Array] Array of column names
def set_firebase_table(encrypted_channel_id, table_name, table_records, table_columns)
  channel_url = "https://#{CDO.firebase_name}.firebaseio.com/v3/channels/#{encrypted_channel_id}"

  storage_url = "#{channel_url}/storage/tables/#{table_name}/records.json"
  storage_data = table_records.to_json
  put_with_auth(storage_url, storage_data)

  counters_url = "#{channel_url}/counters/tables/#{table_name}.json"
  counters_data = {
    lastId: table_records.keys.map(&:to_i).max,
    rowCount: table_records.size
  }.to_json
  put_with_auth(counters_url, counters_data)

  if table_columns
    metadata_url = "#{channel_url}/metadata/tables/#{table_name}/columns.json"
    put_with_auth(metadata_url, 'null')
    table_columns = ['id'] + (table_columns - ['id'])
    table_columns.each do |column_name|
      post_with_auth(metadata_url, {columnName: column_name}.to_json)
    end
  end
end

# http://localhost-studio.code.org:3000/projects/applab/Ezx7frRzCh_QoTetQwzVZQ/edit
# http://localhost.code.org:3000/v3/edit-csp-app/Ezx7frRzCh_QoTetQwzVZQ
def stub_applab_channels
  [
    [1, 4307], # "Remix: My Project" (dynamodb deleted)
    [1, 4385], # Ezx7frRzCh_QoTetQwzVZQ dynamodb with data
    [1, 4386], # EosN50MleCkJgP-52bxCEQ dynamodb no data
    [1, 4388], # 5Rep_hVVFfkCQR283rnQVg firebase with data
    [1, 4389] # 6f5LdZdKnraOtKhxulEj5A firebase no data
  ]
end

# Returns an array of pairs of storage_owner_ids and channel_ids, each representing an applab app.
# There are ~1.1M of these on production.
def fetch_applab_channels
  PEGASUS_DB[:storage_apps].grep(:value, '%applab%').map do |row|
    [row[:storage_id], row[:id]]
  end
end

def up
  HipChat.log 'Fetching a list of applab apps from Pegasus DB. This step may take approximately '\
    '15 minutes to run over ~4.5M rows in storage_apps in production...'
  channels = fetch_applab_channels

  HipChat.log "Searching for #{channels.length} applab projects in DynamoDB using #{MAX_THREADS} threads..."
  Parallel.each_with_index(channels, in_threads: MAX_THREADS) do |channel_data, channel_index|
    begin
      owner_storage_id, channel_id = channel_data
      encrypted_channel_id = storage_encrypt_channel_id(owner_storage_id, channel_id)

      sql_row = PEGASUS_DB[:storage_apps].where(id: channel_id).first
      sql_row_value = JSON.parse(sql_row[:value])
      next if sql_row[:state] == 'deleted' || sql_row_value['useFirebase']

      properties = Hash[DynamoPropertyBag.new(channel_id, nil).to_hash.map{ |k, v| [k, v.to_json] }]
      set_firebase_properties(encrypted_channel_id, properties) unless properties.empty?

      DynamoTable.table_names(channel_id).each do |table_name|
        dynamo_table = DynamoTable.new(encrypted_channel_id, nil, table_name)
        # A hash from record id to json-encoded records
        table_records = Hash[dynamo_table.to_a.map{|row| [row['id'].to_s, row.to_json]}]
        table_columns = dynamo_table.metadata
        table_columns = JSON.parse(table_columns['column_list']) if table_columns
        set_firebase_table(encrypted_channel_id, table_name, table_records, table_columns)
      end

      # For some reason the local variables row and row_value became mismatched with the channel_id
      # when Parallel.each_with_index was configured to use processes. This doesn't
      # appear to be a problem with threads, but check here anyway to prevent disaster.
      raise "parallelization error: attempting to write data from row id #{sql_row[:id]} to channel id #{channel_id}" if sql_row[:id] != channel_id

      # Mark the project as updated in the Pegasus SQL database
      sql_row_value['useFirebase'] = true
      sql_row_value['migratedToFirebase'] = true
      PEGASUS_DB[:storage_apps].where(id: channel_id).update(value: sql_row_value.to_json)
    rescue => e
      HipChat.log("Error processing channel id #{channel_id}: #{e.message}")
      puts e.backtrace
    end
    HipChat.log "#{channel_index} of #{channels.size} projects scanned..." if channel_index % LOG_INCREMENT == 0
  end
  HipChat.log "#{channels.size} projects scanned total"
end

def down
  puts "'rollback' is for development/emergency purposes only and has been disabled."
  # fetch_applab_channels.each do |_, channel_id|
  #   row = PEGASUS_DB[:storage_apps].where(id: channel_id).first
  #   row_value = JSON.parse(row[:value])
  #   if row_value['migratedToFirebase']
  #     row_value.delete('useFirebase')
  #     row_value.delete('migratedToFirebase')
  #     PEGASUS_DB[:storage_apps].where(id: channel_id).update(value: row_value.to_json)
  #   end
  # end
end

if ARGV[0] == 'rollback'
  down
else
  up
end
