#!/usr/bin/env ruby

require_relative '../../../dashboard/config/environment'
require 'aws-sdk'
require 'optparse'
require 'singleton'
require 'tempfile'

# NCES Schools Data Loader
# @see https://nces.ed.gov/ccd/ccddata.asp
# @see https://nces.ed.gov/surveys/pss/pssdata.asp
class NcesSchoolsLoader
  attr_reader :s3_key, :csv_options

  # Initializes an NcesSchoolsLoader instance.
  # @param s3_key [String] the S3 key of the NCES data file
  # @param csv_options [Hash] the options for CSV file parsing
  def initialize(s3_key, csv_options)
    @s3_key = s3_key.freeze
    @csv_options = csv_options.freeze
  end

  # Loads the NCES datafile and merges the resutls into the current dataset.
  # @param merge [Boolean] true if merging the datasets, false otherwise
  def load(merge)
    tmp_file = Tempfile.new(["cdo-nces.", ".dat"])
    err_file = "#{tmp_file.path}.err"
    begin
      puts "Downloading #{s3_key}..."
      client = Aws::S3::Client.new
      open(tmp_file.path, 'wb') do |tmp|
        client.get_object(bucket: 'cdo-nces', key: s3_key) do |chunk|
          tmp.write(chunk)
        end
      end
      counts = {insert: 0, update: 0, failed: 0}
      open(err_file, 'w') do |err|
        CSV.foreach(tmp_file.path, csv_options) do |row|
          begin
            parsed_school = parse(row)
            school = School.find_by_id(parsed_school[:id])
            if school.nil?
              School.new(parsed_school).save! if merge
              counts[:insert] += 1
            else
              school.update!(parsed_school) if merge
              counts[:update] += 1
            end
          rescue
            err << row
            counts[:failed] += 1
          end
        end
      end
      puts " => Processed #{counts[:insert] + counts[:update]} school(s): #{counts}"
      if counts[:failed] > 0
        puts " => Rejected #{counts[:failed]} rows, please check: #{err_file}"
      end
    ensure
      tmp_file.close
      tmp_file.unlink
    end
  end

  # NCES Public/Charter School Directory for 2013-2014
  # @see https://nces.ed.gov/ccd/Data/txt/sc132alay.txt
  class Ccd20132014 < NcesSchoolsLoader
    include Singleton

    def initialize
      super('2013-2014/ccd/sc132a.txt', {col_sep: "\t", headers: true, quote_char: "\x00"})
    end

    def parse(row)
      return {
        id:                 row['NCESSCH'].to_i.to_s,
        school_district_id: row['LEAID'].to_i,
        school_type:        row['CHARTR'] == '1' ? 'charter' : 'public',
        name:               row['SCHNAM'].upcase,
        address_line1:      row['LSTREE'].to_s.upcase.presence,
        address_line2:      nil,
        address_line3:      nil,
        city:               row['LCITY'].to_s.upcase.presence,
        state:              row['LSTATE'].to_s.upcase.presence,
        zip:                row['LZIP']
      }
    end
  end

  # NCES Private School Directory for 2013-2014
  # @see https://nces.ed.gov/surveys/pss/zip/layout2013_14.zip
  class Pss20132014 < NcesSchoolsLoader
    include Singleton

    def initialize
      super('2013-2014/pss/pss1314_pu.csv', {headers: true, encoding: 'ISO-8859-1:UTF-8'})
    end

    def parse(row)
      return {
        id:                 row['PPIN'],
        school_district_id: nil,
        school_type:        'private',
        name:               row['PINST'].upcase,
        address_line1:      row[row['PL_ADD'].nil? ? 'PADDRS' : 'PL_ADD'].to_s.upcase.presence,
        address_line2:      nil,
        address_line3:      nil,
        city:               row[row['PL_CIT'].nil? ? 'PCITY' : 'PL_CIT'].to_s.upcase.presence,
        state:              row[row['PL_STABB'].nil? ? 'PSTABB' : 'PL_STABB'].to_s.upcase.presence,
        zip:                row[row['PL_ZIP'].nil? ? 'PZIP' : 'PL_ZIP']
      }
    end
  end

  # NCES Public/Charter School Directory for 2014-2015
  # @see https://nces.ed.gov/ccd/xls/2014-15%20CCD%20Companion_SCH%20Directory_File_Layout.xlsx
  class Ccd20142015 < NcesSchoolsLoader
    include Singleton

    def initialize
      super('2014-2015/ccd/ccd_sch_029_1415_w_0216601a.txt', {col_sep: "\t", headers: true, quote_char: "\x00"})
    end

    def parse(row)
      return {
        id:                 row['NCESSCH'].to_i.to_s,
        school_district_id: row['LEAID'].to_i,
        school_type:        row['CHARTER_TEXT'][0, 1] == 'Y' ? 'charter' : 'public',
        name:               row['SCH_NAME'].upcase,
        address_line1:      row['LSTREET1'].to_s.upcase.presence,
        address_line2:      row['LSTREET2'].to_s.upcase.presence,
        address_line3:      row['LSTREET3'].to_s.upcase.presence,
        city:               row['LCITY'].to_s.upcase.presence,
        state:              row['LSTATE'].to_s.upcase.presence,
        zip:                row['LZIP']
      }
    end
  end
end

options = {merge: false}
OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} [options]"
  opts.on('-m', '--merge', 'Actually perform the merge.') do
    options[:merge] = true
  end
  opts.on('-h', '--help', 'Prints this help') do
    puts opts
    exit
  end
end.parse!
puts "Called with options: #{options}"

NcesSchoolsLoader::Ccd20132014.instance.load(options[:merge])
NcesSchoolsLoader::Pss20132014.instance.load(options[:merge])
NcesSchoolsLoader::Ccd20142015.instance.load(options[:merge])

tsv_file = Schools.all_to_tsv("#{Dir.tmpdir}/schools.#{Time.now.strftime('%Y%m%d%H%M')}.tsv")
puts "Downloaded schools to: #{tsv_file}"
