#!/usr/bin/env ruby

# This script creates a UserLevel for each sublevel of a LevelGroup level
# (if one does not already exist). Though current production code creates a
# UserLevel for each sublevel, there was a period of time where this was not the
# case.
#
# The script expects a data file of user_level_id's to (possibly) fix. This list
# was generated via the following SQL.
#
#   SELECT user_levels.id AS user_level_id
#   FROM user_scripts
#   INNER JOIN user_levels
#     ON user_levels.user_id = user_scripts.user_id
#       AND user_levels.script_id = user_scripts.script_id
#   WHERE
#     user_scripts.script_id IN (
#       SELECT script_levels.script_id
#       FROM script_levels
#       INNER JOIN levels_script_levels
#         ON levels_script_levels.script_level_id = script_levels.id
#       WHERE levels_script_levels.level_id IN (
#         SELECT id
#         FROM levels
#         WHERE type = "LevelGroup"
#       )
#     )
#   AND
#     user_levels.level_id IN (
#       SELECT id
#       FROM levels
#       WHERE type = "LevelGroup"
#     );
#
# where the script IDs are those scripts containing the level IDs and the level
# IDs are the levels of type LevelGroup.

require_relative '../../../dashboard/config/environment'
require 'digest/md5'

DATA_FILE = '/tmp/user_level_ids.csv'.freeze

# Validates raw_data and extracts the answer data from it. Raises an exception
# if raw_data is not of the appropriate format.
# @param raw_data [Hash] The LevelGroup value (within LevelSource.data) for a
#   sublevel.
# @return [JSON] The JSON to persist in LevelSource.data for the sublevel.
def get_data(raw_data)
  unless raw_data.keys == ['result', 'valid']
    raise "raw_data malformed: #{raw_data}"
  end

  return raw_data['result'].to_json
end

# Retrieves the UserLevel and the (JSON-parsed) LevelSource.data associated with
# a user_level_id. Raises an exception if the UserLevel is missing.
# @param user_level_id [Integer] The ID of the user_level.
# @return [Array[UserLevel, {nil | Hash}]] An array of a UserLevel and the
#   corresponding (JSON-parsed) LevelSource.data.
def get_user_level_and_level_source_data(user_level_id)
  user_level = UserLevel.find_by_id(user_level_id)
  unless user_level
    raise "Missing UserLevel: #{user_level_id}"
  end

  level_source = LevelSource.find_by_id(user_level.level_source_id)
  level_source_data = level_source ? JSON.parse(level_source.data) : nil

  [user_level, level_source_data]
end

# Creates a UserLevel for each sublevel in the LevelGroup UserLevel, if one does
# not already exist. As part of this, creates any necessary LevelSource objects.
# @param user_level [UserLevel] The LevelGroup UserLevel.
# @param sublevel_level_id [Integer] The level_id of the sublevel.
# @param sublevel_raw_data [Hash] The data for the sublevel LevelSource.
def create_sublevel_user_level(user_level, sublevel_level_id, sublevel_raw_data)
  # Determine if there is an existing sublevel UserLevel, continuing if so.
  sublevel_user_level = UserLevel.
    where(
      user_id: user_level.user_id,
      level_id: sublevel_level_id,
      script_id: user_level.script_id
    ).
    first
  return if sublevel_user_level

  # Before creating the sublevel UserLevel, verify the existence of an
  # appropriate LevelSource, creating one if not.
  data = get_data sublevel_raw_data
  md5 = Digest::MD5.hexdigest data
  sublevel_level_source = LevelSource.
    create_with(data: data).
    find_or_create_by(
      md5: md5,
      level_id: sublevel_level_id
    )

  # Actually create the UserLevel for the sublevel.
  UserLevel.create!(
    user_id: user_level.user_id,
    level_id: sublevel_level_id,
    script_id: user_level.script_id,
    level_source_id: sublevel_level_source.id,
    # Since UserLevel.attempts for the LevelGroup encompasses the number of
    # state changes across all answers and the number of submits, we do not
    # try to populate attempts with an accurate number.
    attempts: 2,
    # As UserLevel.created_at and UserLevel.updated_at are use for analysis, we
    # manually set them rather than allow Rails to manage the timestamps.
    created_at: user_level.created_at,
    updated_at: user_level.updated_at,
    # For various reasons (including not telling the answer to the client),
    # regardless of correctness, we purposely set best_result to zero.
    best_result: 0
  )
end

# The main method for the script. Reads the CSV and persists UserLevel and
# LevelSource objects as necessary.
def main
  CSV.foreach(DATA_FILE, headers: true, col_sep: "\t") do |row|
    user_level_id = row['user_level_id'].to_i

    user_level, level_source_data = get_user_level_and_level_source_data(
      user_level_id
    )
    next unless user_level && level_source_data

    ActiveRecord::Base.transaction do
      level_source_data.each do |sublevel_level_id, sublevel_level_raw_data|
        create_sublevel_user_level(
          user_level,
          sublevel_level_id,
          sublevel_level_raw_data
        )
      end
    end
  end
end

main
