#!/usr/bin/env ruby

#
# Script to update the school_info_id in users that may be bad.
#
# What we discovered, is in the SchoolInfoDeduplicator the filter criteria
# wasn't specific enough and in cases where some users did not specify an
# actual school, they may have been matched to a specific school.
#
# For instance, in production, a user specifying only the country and
# school_type, the following query would be generated to match an existing
# school_info:
#
#   SELECT * FROM school_infos
#   WHERE country = 'US' AND school_type = 'public' AND validation_type = 'none'
#   ORDER BY id ASC LIMIT 1
#
# However, because of the order on id, it was matching a school in NJ.
#
# Arguments:
#   --actually-update Indicates to execute the update on the affected users.
#

require_relative '../../../dashboard/config/environment'
require 'tmpdir'

ACTUALLY_UPDATE = (ARGV[0].eql? "--actually-update").freeze
puts "Called with --actually-update=#{ACTUALLY_UPDATE}"

start_time = Time.now

info_count = 0
user_count = 0

school_info_ids = ActiveRecord::Base.connection.execute(%Q{
    SELECT DISTINCT t.id FROM (
      SELECT MIN(id) AS id FROM school_infos WHERE validation_type = 'none' AND country = 'US'
      AND school_type in ('public','charter')
      GROUP BY school_type
    UNION ALL
      SELECT MIN(id) AS id FROM school_infos WHERE validation_type = 'none' AND country = 'US'
      AND school_type in ('public','charter') AND state IS NOT NULL
      GROUP BY school_type, state
    UNION ALL
      SELECT MIN(id) AS id FROM school_infos WHERE validation_type = 'none' AND country = 'US'
      AND school_type in ('public','charter') AND state IS NOT NULL AND school_district_id IS NOT NULL
      GROUP BY school_type, state, school_district_id
    ) t JOIN school_infos si ON si.id = t.id
    WHERE (si.school_id IS NOT NULL OR si.school_name IS NOT NULL)
  }
).pluck(0)

ActiveRecord::Base.record_timestamps = false

users_file = "#{Dir.tmpdir}/#{File.basename(__FILE__)}.#{Time.now.strftime('%Y%m%d%H%M')}.csv"
open(users_file, 'w') do |log|
  log.puts "id,school_info_id"

  school_info_ids.each do |school_info_id|
    users = User.where("user_type = 'teacher' AND school_info_id = ?", school_info_id)
    next unless users.count > 1

    users.each do |user|
      log.puts "#{user.id},#{user.school_info_id}"

      if ACTUALLY_UPDATE
        user.update!(school_info_id: nil)
      end
      user_count += 1
    end

    info_count += 1
  end
end

puts "Updated #{user_count} user(s) from #{info_count} school_info(s) in #{Time.now - start_time} second(s)."
puts "Log written to #{users_file}"
