#!/usr/bin/env ruby

require_relative('../../dashboard/config/environment')
require 'cdo/contact_rollups'
require 'cdo/contact_rollups_validation'
require 'cdo/pardot'
require 'cdo/chat_client'
require 'cdo/only_one'
require 'aws-sdk-rds'

CHAT_CHANNEL = "cron-daily".freeze

DATABASE_CLUSTER_CLONE_ID = "#{CDO.db_cluster_id}-temporary-clone"
DATABASE_CLUSTER_CLONE_INSTANCE_ID = "#{DATABASE_CLUSTER_CLONE_ID}-instance"
DATABASE_CLONE_INSTANCE_TYPE = 'db.r4.2xlarge'

def main
  time_start = Time.now

  # Delete clone database cluster if it was left behind by the last execution of Contact Rollups.
  delete_database_clone
  create_database_clone

  # Build new daily table of contact rollups
  ContactRollups.build_contact_rollups

  # Validate that daily contact rollups meets sanity expectations
  results = ContactRollupsValidation.validate_contact_rollups
  unless results[:pass]
    message = "Contact rollups process failed. "\
              "Validation of daily rollup failed:\n#{results[:output]}"
    ChatClient.message(CHAT_CHANNEL, message)
    # Raise exception so this goes to HoneyBadger
    raise message
  end

  # Sync daily rollup to master rollup and compute deltas
  ContactRollups.sync_contact_rollups_to_main

  # Sync deltas into Pardot
  results = Pardot.sync_contact_rollups_to_pardot

  time_elapsed = (Time.now - time_start).to_i
  message = "Contact rollups process complete. #{results[:num_inserts]} "\
    "inserts and #{results[:num_updates]} updates to Pardot. "\
    "Total time: #{time_elapsed} sec"

  ChatClient.message(CHAT_CHANNEL, message)

  # Any other failures along the way will be unrescued exceptions that
  # go to HoneyBadger
ensure
  delete_database_clone
end

# Delete database cluster clone if it exists.
def delete_database_clone
  rds_client = Aws::RDS::Client.new
  begin
    existing_cluster_response = rds_client.describe_db_clusters({db_cluster_identifier: DATABASE_CLUSTER_CLONE_ID})
    ChatClient.message(CHAT_CHANNEL, "Cluster clone exists and is in state - #{existing_cluster_response.db_clusters.first.status}.  Deleting cluster and its instances.")
    existing_cluster_response.db_clusters.first.db_cluster_members.each do |instance|
      ChatClient.message(CHAT_CHANNEL, "Deleting clone instance - #{instance.db_instance_identifier}")
      rds_client.delete_db_instance(
        {
          db_instance_identifier: instance.db_instance_identifier,
          skip_final_snapshot: true,
        }
      )
      rds_client.wait_until(:db_instance_deleted, {db_instance_identifier: instance.db_instance_identifier}, {max_attempts: 20, delay: 60})
    end
    ChatClient.message(CHAT_CHANNEL, "Deleting clone cluster - #{DATABASE_CLUSTER_CLONE_ID}")
    rds_client.delete_db_cluster(
      {
        db_cluster_identifier: DATABASE_CLUSTER_CLONE_ID,
        skip_final_snapshot: true,
      }
    )
    wait_until_db_cluster_deleted(DATABASE_CLUSTER_CLONE_ID, 10, 60)
  rescue Aws::RDS::Errors::DBClusterNotFoundFault => error
    ChatClient.message(CHAT_CHANNEL, "Cluster #{DATABASE_CLUSTER_CLONE_ID} does not exist from previous execution of Contact Rollups. #{error.message}.  No need to delete it.")
  end
end

# Clone the Aurora database cluster to use for the Contact Rollups batch aggregation queries.
def create_database_clone
  rds_client = Aws::RDS::Client.new
  begin
    ChatClient.message(CHAT_CHANNEL, "Creating clone of database cluster - #{DATABASE_CLUSTER_CLONE_ID}")
    existing_cluster = rds_client.describe_db_clusters({db_cluster_identifier: CDO.db_cluster_id}).db_clusters.first
    rds_client.restore_db_cluster_to_point_in_time(
      {
        db_cluster_identifier: DATABASE_CLUSTER_CLONE_ID,
        restore_type: 'copy-on-write',
        source_db_cluster_identifier: CDO.db_cluster_id,
        use_latest_restorable_time: true,
        db_subnet_group_name: existing_cluster.db_subnet_group,
        vpc_security_group_ids: existing_cluster.vpc_security_groups.map(&:vpc_security_group_id),
        tags: [
          {
            key: 'environment',
            value: CDO.rack_env.to_s,
          },
        ]
      }
    )
    rds_client.create_db_instance(
      {
        db_instance_identifier: DATABASE_CLUSTER_CLONE_INSTANCE_ID,
        db_instance_class: DATABASE_CLONE_INSTANCE_TYPE,
        engine: existing_cluster.engine,
        db_cluster_identifier: DATABASE_CLUSTER_CLONE_ID,
      }
    )
    # Wait 30 minutes.  As of mid-2019, it takes about 15 minutes to provision a clone of the production cluster.
    rds_client.wait_until(:db_instance_available, {db_instance_identifier: DATABASE_CLUSTER_CLONE_INSTANCE_ID}, {max_attempts: 30, delay: 60})
  rescue Aws::Waiters::Errors::WaiterFailed => error
    ChatClient.message(CHAT_CHANNEL, "Error waiting for cluster clone instance to become available. #{error.message}")
  end
  ChatClient.message(CHAT_CHANNEL, "Done creating clone of database cluster.")
end

# The AWS SDK does not currently provide waiters for DBCluster operations.
def wait_until_db_cluster_deleted(db_cluster_id, max_attempts, delay)
  rds_client = Aws::RDS::Client.new
  attempts = 0
  while attempts <= max_attempts
    # describe_db_cluster will Raise a DBClusterNotFound Error when the cluster has been deleted.
    rds_client.describe_db_cluster(db_cluster_id: db_cluster_id)
    attempts += 1
    sleep delay
  end
  raise Error("Timeout after waiting #{max_attempts * delay} seconds for cluster #{DATABASE_CLUSTER_CLONE_ID} deletion to complete.")
rescue Aws::RDS::Errors::DBClusterNotFoundFault => error
  ChatClient.message(CHAT_CHANNEL, "Database Cluster #{db_cluster_id} has been deleted. #{error.message}")
end

main if only_one_running?(__FILE__)
