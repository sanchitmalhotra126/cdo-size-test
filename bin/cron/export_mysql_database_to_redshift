#!/usr/bin/env ruby
require_relative '../../lib/cdo/only_one'
exit unless only_one_running?(__FILE__)

require_relative '../../dashboard/config/environment'
exit unless rack_env?(:production) && CDO.dashboard_hostname == 'studio.code.org'

require 'aws-sdk-databasemigrationservice'
require 'cdo/chat_client'

# Export production Aurora MySQL tables to Redshift once a day.
# 1) Start Data Migration Service (DMS) Replication Tasks, which are configured to drop existing tables in a parallel
# set of `import_` Redshift schemas and then carry out full load of Aurora MySQL tables into the temporary `import_` schemas.
# 2) Verify that all tables have replicated from MySQL to the staging schemas in Redshift within a configurable timeout.
# 3) Drop the existing tables in the main Redshift schemas and rename / move the newly transferred tables into the main
# Redshift schemas.
def main
  ChatClient.message 'cron-daily', 'Beginning export from Aurora MySQL database to Redshift.'
  dms_client = Aws::DatabaseMigrationService::Client.new
  replication_tasks = dms_client.describe_replication_tasks({without_settings: true}).replication_tasks
  production_tasks = replication_tasks.select do |task|
    dms_client.
      list_tags_for_resource({resource_arn: task.replication_task_arn}).
      tag_list.
      any? {|tag| tag.key == 'environment' && tag.value == 'production'}
  end

  # Spawn one thread for each replication task, so we can start and monitor them independently.
  threads = []
  Thread.abort_on_exception = true
  production_tasks.each do |task|
    threads << Thread.new {execute_replication_task(task.replication_task_arn)}
  end
  threads.each(&:join)

  ChatClient.message'cron-daily', "Completed export from Aurora MySQL database to Redshift."
rescue StandardError => error
  ChatClient.message'cron-daily', "Error during export from Aurora MySQL database to Redshift #{error.message}", color: 'red'
  raise error
end

# Start a replication task and wait until it completes, raising an error if the task did not complete within a
# configurable time period or did not complete successfully.
# @replication_task_arn [String]
def execute_replication_task(replication_task_arn)
  ChatClient.message 'cron-daily', "Starting DMS Replication Task: #{replication_task_arn}"
  dms_client = Aws::DatabaseMigrationService::Client.new
  start_task_response = dms_client.start_replication_task(
    {
      replication_task_arn: replication_task_arn,
      start_replication_task_type: "start-replication"
    }
  )
  ChatClient.message 'cron-daily', "Start DMS Task Response: #{replication_task_arn} - #{start_task_response}"
  dms_client.wait_until(
    :replication_task_stopped,
    {
      filters: [
        {
          name: 'replication-task-arn',
          value: replication_task_arn
        }
      ]
    }
  ) do |waiter|
    # Poll once an hour for 36 hours.
    waiter.max_attempts = 36
    waiter.delay = 3600
  end
  task_status = dms_client.describe_replication_tasks(
    {
      filters: [
        {
          name: 'replication-task-arn',
          value: replication_task_arn
        }
      ]
    },
    max_records: 1,
    without_settings: true
  ).replication_task[0]
  # TODO: (suresh) Check detailed task status and raise error if it did not complete successfully.
  ChatClient.message 'cron-daily', "DMS Task Completed: #{replication_task_arn} - #{task_status}"
rescue Aws::Waiters::Errors::WaiterFailed => error
  # TODO: (suresh) Customize error handling for failed waiter.
  ChatClient.message 'cron-daily', "Error executing DMS Replication Task #{replication_task_arn} - #{error.message}", color: 'red'
  raise error
rescue StandardError => error
  ChatClient.message 'cron-daily', "Error executing DMS Replication Task #{replication_task_arn} - #{error.message}", color: 'red'
  raise error
end

main
