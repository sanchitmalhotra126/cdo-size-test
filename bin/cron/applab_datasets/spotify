#!/usr/bin/env ruby
require_relative '../only_one'
abort 'Script already running' unless only_one_running?(__FILE__)

# This script fetches spotify data from api.spotify and uploads to the shared firebase channel.
require_relative '../../../deployment'
require 'ostruct'
require_relative '../../../shared/middleware/helpers/firebase_helper'
require 'cdo/profanity_filter'
require 'rest-client'

BASE_URL = 'https://api.spotify.com/v1'

#PLAYLIST IDs
VIRAL_50_GLOBAL_ID = '37i9dQZEVXbLiRSasKsNU9'
VIRAL_50_USA_ID = '37i9dQZEVXbKuaTI1Z1Afx'
TOP_50_GLOBAL_ID = '37i9dQZEVXbMDoHDwVN2tF'
TOP_50_USA_ID = '37i9dQZEVXbLRQDuF5jeBp'

PROFANITY_LOCALE = 'en-US'

CHART_TYPE = {
  TOP_50: 'TOP_50',
  VIRAL_50: 'VIRAL_50',
}

def get_token
  client_id = CDO.spotify_api_client_id
  client_secret = CDO.spotify_api_client_secret
  url = "https://accounts.spotify.com/api/token"
  headers = {
    'authorization' => 'Basic ' + Base64.strict_encode64(client_id + ':' + client_secret),
    'content-type' => 'application/x-www-form-urlencoded',
  }
  form = {
    'grant_type' => 'client_credentials'
  }
  auth_response = JSON.parse(RestClient.post(url, form, headers))
  $token = auth_response['access_token']
end

def get_playlist_data(chart_type, playlist_id)
  # Filters for the query: a comma-separated list of the fields to return
  field_query = 'fields=tracks.items(track(name,href,artists,popularity))'
  url = "#{BASE_URL}/playlists/#{playlist_id}?#{field_query}"
  response = RestClient.get(url, {authorization: "Bearer #{$token}"})
  return unless response.code == 200

  items = JSON.parse(response)['tracks']['items']
  columns = ['id', 'Track Name', 'Artist', 'Position', 'URL']
  if chart_type === CHART_TYPE[:TOP_50] then columns << 'Popularity' end # Only include Popularity for Top Charts

  regex = generate_profanity_regex(items)
  records = {}
  id = 1

  items.each do |item|
    track = item['track']
    next if track.nil? || regex&.match?(get_string_to_check(track)) # skip track if it is nil or contains profanity

    record = OpenStruct.new
    record.id = id
    record.Position = id # list of track items returned in order of popularity
    record['Track Name'] = track['name']
    record.Artist = track['artists'][0]['name'] # first will be main artist, featured artists included in record name
    if chart_type === CHART_TYPE[:TOP_50] then record.Popularity = track['popularity'] end
    record.URL = track['href']

    records[id] = record.to_h.to_json
    id += 1
  end

  return records, columns
end

# Only check artist and track names for profanity
def get_string_to_check(track)
  if track.nil?
    return ""
  else
    return "#{track['name']} - #{track['artists'][0]['name']}"
  end
end

# Generates a case-insensitive regex of profanities in the entire dataset
# to match each item against.
def generate_profanity_regex(items)
  str = items.reduce('') {|acc, item| acc + get_string_to_check(item['track'])}
  profanities = ProfanityFilter.find_potential_profanities(str, PROFANITY_LOCALE) || []
  profanities.empty? ? nil : /(#{profanities.join("|")})/i
end

def main
  get_token
  # fb = FirebaseHelper.new('shared')

  records, columns = get_playlist_data(CHART_TYPE[:TOP_50], TOP_50_GLOBAL_ID)
  puts 'TOP 50 GLOBAL', records, columns

  records, columns = get_playlist_data(CHART_TYPE[:TOP_50], TOP_50_USA_ID)
  puts 'TOP 50 USA', records, columns

  records, columns = get_playlist_data(CHART_TYPE[:VIRAL_50], VIRAL_50_GLOBAL_ID)
  puts 'VIRAL 50 GLOBAL', records, columns

  records, columns = get_playlist_data(CHART_TYPE[:VIRAL_50], VIRAL_50_USA_ID)
  puts 'VIRAL 50 USA', records, columns

  #TODO: create a test DB or check that the table will save as expected?

  # fb.upload_live_table('Viral 50 Worldwide', records, columns)
end

main
