#!/usr/bin/env ruby
# A script to analyze a range of CircleCI builds for known failures.
# For available options, run ./search-circle-builds -h

require 'pp'
require 'json'
require 'memoist'
require 'open-uri'
require 'optparse'

CIRCLE_API_BASE = 'https://circleci.com/api/v1.1/project/github/code-dot-org/code-dot-org'
RUN_UI_TESTS_STEP_STRING = 'run_tests'
RUN_UI_TESTS_CONTAINER = 1

KNOWN_FAIL_TYPES = [
    {
        search_string: 'ConnectionTimeoutError',
        step_string: RUN_UI_TESTS_STEP_STRING,
        container: RUN_UI_TESTS_CONTAINER
    },
    {
        search_string: 'io_fillbuf',
        step_string: RUN_UI_TESTS_STEP_STRING,
        container: RUN_UI_TESTS_CONTAINER
    },
    {
        search_string: 'invalid base64',
        step_string: RUN_UI_TESTS_STEP_STRING,
        container: RUN_UI_TESTS_CONTAINER
    },
]

extend Memoist

def get_build(id)
  JSON.parse(open("#{CIRCLE_API_BASE}/#{id}").read)
end

memoize :get_build

def output_url(build, container, step_includes)
  build['steps'].select { |o| o['name'].include? step_includes }[0]['actions'][container]['output_url']
end

memoize :output_url

#
def get_output(id, container, step_includes)
  JSON.parse(open(output_url(get_build(id), container, step_includes)).read)
rescue => _
end

memoize :get_output

options = {}
OptionParser.new do |opts|
  opts.banner = 'Usage: ./search-circle-builds [options]'

  opts.on('--start StartBuildNumber', String, 'Start searching at build #') do |n|
    options[:start_build] = n.to_i
  end
  opts.on('--end EndBuildNumber', String, 'End searching at build #') do |n|
    options[:end_build] = n.to_i
  end
  opts.on('--grep "String to Search for"', String, 'Search for given string') do |grep_string|
    options[:grep_string] = grep_string
  end
  opts.on('--grep-container ', String, 'Search given container # for grep string') do |grep_container|
    options[:grep_container] = grep_container.to_i
  end
  options[:grep_container] ||= RUN_UI_TESTS_CONTAINER
  opts.on('--grep-step ', String, 'Search given step (substring) for grep string') do |grep_step|
    options[:grep_step] = grep_step
  end
  options[:grep_step] ||= RUN_UI_TESTS_STEP_STRING
  opts.on_tail('-h', '--help', 'Show this message') do
    puts opts
    exit
  end
end.parse!

start_build = options[:start_build]
end_build = options[:end_build]

builds = (start_build..end_build).to_a

fail_types_to_check = KNOWN_FAIL_TYPES

if options[:grep_string]
  fail_types_to_check = [{
                             search_string: options[:grep_string],
                             step_string: options[:grep_step],
                             container: options[:grep_container]
                         }]
end

def describe_fail_type(f)
  "#{f[:search_string]} in container #{f[:container]} step #{f[:step_string]}"
end

fail_types_list = fail_types_to_check.map { |f| describe_fail_type(f) }.join "\n"
puts "Checking builds #{builds.join ', '} for output:\n#{fail_types_list}"

builds.each do |build|
  fail_types_to_check.each do |known_fail|
    output = get_output(build, known_fail[:container], known_fail[:step_string])

    begin
      if output[0]['message'].include? known_fail[:search_string]
        puts "Build https://circleci.com/gh/code-dot-org/code-dot-org/#{build} output contains: #{known_fail[:search_string]}"
      end
    rescue => _
    end
  end
end

exit(0)
