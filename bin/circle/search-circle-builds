#!/usr/bin/env ruby
# A script to analyze a range of CircleCI builds for known failures.
# For available options, run ./search-circle-builds -h

require 'pp'
require 'json'
require 'memoist'
require 'open-uri'
require 'optparse'

CIRCLE_API_BASE = 'https://circleci.com/api/v1.1/project/github/code-dot-org/code-dot-org'
RUN_UI_TESTS_STEP_STRING = 'run_tests'
RUN_UI_TESTS_CONTAINER = 1

KNOWN_FAIL_TYPES = [
    {
        search_string: 'ConnectionTimeoutError',
        step_string: RUN_UI_TESTS_STEP_STRING,
        container: RUN_UI_TESTS_CONTAINER
    },
    {
        search_string: 'io_fillbuf',
        step_string: RUN_UI_TESTS_STEP_STRING,
        container: RUN_UI_TESTS_CONTAINER
    },
    {
        search_string: 'invalid base64',
        step_string: RUN_UI_TESTS_STEP_STRING,
        container: RUN_UI_TESTS_CONTAINER
    },
]

extend Memoist

# @param [Fixnum] build_id The CircleCI build #
# @return [Object] build descriptor object from the CircleCI API
#   Example output JSON: https://gist.github.com/bcjordan/02f7c2906b524fa86ec75b19f9a72cd2
def get_build(build_id)
  JSON.parse(open("#{CIRCLE_API_BASE}/#{build_id}").read)
end

memoize :get_build

# Returns the full output URL for a given build step
# @param [Fixnum] build_object The build information object from the Circle API
# @param [Fixnum] container_id The container ID #
# @param [String] grep_for_step The build step to search for (e.g. "rake install")
def build_step_output_url(build_object, container_id, grep_for_step)
  build_object['steps'].select { |o| o['name'].include? grep_for_step }[0]['actions'][container_id]['output_url']
end

memoize :build_step_output_url

# @param [Fixnum] build_id The build ID #
# @param [Fixnum] container_id The container ID #
# @param [String] grep_for_step The build step to search for (e.g. "rake install")
# @return [Object, nil] full build output JSON object from CircleCI, or nil if error in retrieval
#   Example output JSON: https://gist.github.com/bcjordan/8349fbb1edc284839b42ae53ad19b68a
def get_output(build_id, container_id, grep_for_step)
  JSON.parse(open(build_step_output_url(get_build(build_id), container_id, grep_for_step)).read)
rescue => _
end

memoize :get_output

options = {}
OptionParser.new do |opts|
  opts.banner = 'Usage: ./search-circle-builds [options]'

  opts.on('--start StartBuildNumber', String, 'Start searching at build #') do |n|
    options[:start_build] = n.to_i
  end
  opts.on('--end EndBuildNumber', String, 'End searching at build #') do |n|
    options[:end_build] = n.to_i
  end
  opts.on('--grep "String to Search for"', String, 'Search for given string') do |grep_string|
    options[:grep_string] = grep_string
  end
  opts.on('--whole-lines', TrueClass, 'Print entire lines of found strings in output') do |is_true|
    options[:whole_lines] = is_true
  end
  opts.on('--grep-container ', String, 'Search given container # for grep string') do |grep_container|
    options[:grep_container] = grep_container.to_i
  end
  options[:grep_container] ||= RUN_UI_TESTS_CONTAINER
  opts.on('--grep-step ', String, 'Search given step (substring) for grep string') do |grep_step|
    options[:grep_step] = grep_step
  end
  options[:grep_step] ||= RUN_UI_TESTS_STEP_STRING
  opts.on_tail('-h', '--help', 'Show this message') do
    puts opts
    exit
  end
end.parse!

start_build = options[:start_build]
end_build = options[:end_build]

builds = (start_build..end_build).to_a

fail_types_to_check = KNOWN_FAIL_TYPES

if options[:grep_string]
  fail_types_to_check = [{
    search_string: options[:grep_string],
    step_string: options[:grep_step],
    container: options[:grep_container]
  }]
end

def describe_fail_type(f)
  "#{f[:search_string]} in container #{f[:container]} step #{f[:step_string]}"
end

fail_types_list = fail_types_to_check.map { |f| describe_fail_type(f) }.join "\n"
puts "Checking builds #{builds.join ', '} for output:\n#{fail_types_list}"

builds.each do |build|
  fail_types_to_check.each do |known_fail|
    output = get_output(build, known_fail[:container], known_fail[:step_string])

    begin
      full_output_string = output[0]['message']
      if full_output_string.include? known_fail[:search_string]
        if options[:whole_lines]
          lines = []
          full_output_string.split("\n").each do |line|
            lines << line if line.include? known_fail[:search_string]
          end
          puts "Build https://circleci.com/gh/code-dot-org/code-dot-org/#{build} output contains lines:"
          lines.each{|l| puts l}
        else
          puts "Build https://circleci.com/gh/code-dot-org/code-dot-org/#{build} output contains: #{known_fail[:search_string]}"
        end
      end
    rescue => _
    end
  end
end

exit(0)
