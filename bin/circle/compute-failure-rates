#!/usr/bin/env ruby
# A script to analyze a range of CircleCI builds for known failures.
# For available options, run ./search-circle-builds -h

require 'optparse'
require_relative './circle_project'

class Hash
  # Like Enumerable::map but returns a Hash instead of an Array
  def hmap(&block)
    Hash[self.map {|k, v| yield k, v }]
  end
end

options = {}
OptionParser.new do |opts|
  opts.banner = 'Usage: ./compute-failure-rates [options]'

  opts.separator <<-EXAMPLES

  Examples:

    Default behavior, view stats for the last 30 builds:
    ./compute-failure-rates

    View stats for 30 builds ending at build 123:
    ./compute-failure-rates --end 123

    View stats for all builds since (and including) build 123:
    ./compute-failure-rates --start 123

    View status for builds in range 123-456 inclusive:
    ./compute-failure-rates --start 123 --end 456

  Options:
  EXAMPLES

  opts.on('--start StartBuildNumber', String, 'Start searching at build #. Default: Get 30 builds.') do |n|
    options[:start_build] = n.to_i
  end
  opts.on('--end EndBuildNumber', String, 'End searching at build #. Default: Latest build.') do |n|
    options[:end_build] = n.to_i
  end
  opts.on_tail('-h', '--help', 'Show this message') do
    puts opts
    exit
  end
end.parse!

@project = CircleProject.new('code-dot-org/code-dot-org')

# Download and format the build information we need
build_range = @project.build_range_from_options(options)
build_infos = @project.get_builds(build_range).map do |build|
  next if build['queued_at'].nil? || build['branch'].nil? || build['outcome'].nil?
  {
    build_num: build['build_num'],
    queued_at: DateTime.parse(build['queued_at']),
    branch: build['branch'],
    succeeded: build['outcome'] == 'success'
  }
end

# Group the builds by date
builds_by_date = build_infos.compact.group_by do |build_info|
  build_info[:queued_at].strftime('%Y-%m-%d')
end

# Compute map of stats for each date
stats_by_date = builds_by_date.hmap do |date, build_infos_for_date|
  total_builds = build_infos_for_date.size
  total_failed_builds = build_infos_for_date.reject {|i| i[:succeeded]}.size

  pipeline_builds = build_infos_for_date.select {|i| ['staging', 'test', 'production'].include?(i[:branch])}
  total_pipeline_builds = pipeline_builds.size
  total_failed_pipeline_builds = pipeline_builds.reject {|i| i[:succeeded]}.size

  branch_builds = build_infos_for_date.reject {|i| ['staging', 'test', 'production'].include?(i[:branch])}
  total_branch_builds = branch_builds.size
  total_failed_branch_builds = branch_builds.reject {|i| i[:succeeded]}.size

  [date, {
    total_failure_rate: Float(total_failed_builds) / total_builds,
    pipeline_failure_rate: Float(total_failed_pipeline_builds) / total_pipeline_builds,
    branch_failure_rate: Float(total_failed_branch_builds) / total_branch_builds
  }]
end

# Print build stats
puts "Failure rates for builds #{build_range} by date (1.0 = 100% failures)"
puts "%-10s %10s %10s %10s" % ['Date', 'Branch', 'Pipeline', 'Overall']
stats_by_date.each do |date, stats|
  puts "%-10s %10.3f %10.3f %10.3f" % [date, stats[:branch_failure_rate].round(3), stats[:pipeline_failure_rate].round(3), stats[:total_failure_rate].round(3)]
end

exit(0)
