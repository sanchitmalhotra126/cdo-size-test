#!/usr/bin/env ruby
# A script to analyze a range of CircleCI builds for known failures.
# For available options, run ./search-circle-builds -h

require 'pp'
require 'json'
require 'memoist'
require 'open-uri'
require 'optparse'
require 'parallel'
require 'ruby-progressbar'

CIRCLE_API_BASE = 'https://circleci.com/api/v1.1/project/github/code-dot-org/code-dot-org'

extend Memoist

class Hash
  # Like Enumerable::map but returns a Hash instead of an Array
  def hmap(&block)
    Hash[self.map {|k, v| yield k, v }]
  end

  # Drop a key from the hash, returning the hash (destructive)
  def omit!(key)
    self.tap {|hs| hs.delete(key)}
  end
end

# @param [Fixnum] build_id The CircleCI build #
# @return [Object] build descriptor object from the CircleCI API
#   Example output JSON: https://gist.github.com/bcjordan/02f7c2906b524fa86ec75b19f9a72cd2
def get_build(build_id)
  JSON.parse(open("#{CIRCLE_API_BASE}/#{build_id}").read)
end

memoize :get_build

# Returns the full output URL for a given build step
# @param [Fixnum] build_object The build information object from the Circle API
# @param [Fixnum] container_id The container ID #
# @param [String] grep_for_step The build step to search for (e.g. "rake install")
def build_step_output_url(build_object, container_id, grep_for_step)
  build_object['steps'].select { |o| o['name'].include? grep_for_step }[0]['actions'][container_id]['output_url']
end

memoize :build_step_output_url

# @param [Fixnum] build_id The build ID #
# @param [Fixnum] container_id The container ID #
# @param [String] grep_for_step The build step to search for (e.g. "rake install")
# @return [Object, nil] full build output JSON object from CircleCI, or nil if error in retrieval
#   Example output JSON: https://gist.github.com/bcjordan/8349fbb1edc284839b42ae53ad19b68a
def get_output(build_id, container_id, grep_for_step)
  JSON.parse(open(build_step_output_url(get_build(build_id), container_id, grep_for_step)).read)
rescue => _
end

memoize :get_output

options = {}
OptionParser.new do |opts|
  opts.banner = 'Usage: ./search-circle-builds [options]'

  opts.on('--start StartBuildNumber', String, 'Start searching at build #') do |n|
    options[:start_build] = n.to_i
  end
  opts.on('--end EndBuildNumber', String, 'End searching at build #') do |n|
    options[:end_build] = n.to_i
  end
  opts.on_tail('-h', '--help', 'Show this message') do
    puts opts
    exit
  end
end.parse!

start_build = options[:start_build]
end_build = options[:end_build]

build_nums = (start_build..end_build).to_a

# Download the build information we need
build_infos = Parallel.map(build_nums, progress: 'Downloading...') do |build_num|
  build = get_build(build_num)
  next if build['queued_at'].nil? || build['branch'].nil? || build['outcome'].nil?
  {
    build_num: build_num,
    queued_at: DateTime.parse(build['queued_at']),
    branch: build['branch'],
    succeeded: build['outcome'] == 'success'
  }
end

# Group the builds by date
builds_by_date = build_infos.compact.group_by do |build_info|
  build_info[:queued_at].strftime('%Y-%m-%d')
end

# Compute map of stats for each date
stats_by_date = builds_by_date.hmap do |date, build_infos_for_date|
  total_builds = build_infos_for_date.size
  total_failed_builds = build_infos_for_date.reject {|i| i[:succeeded]}.size

  pipeline_builds = build_infos_for_date.select {|i| ['staging', 'test', 'production'].include?(i[:branch])}
  total_pipeline_builds = pipeline_builds.size
  total_failed_pipeline_builds = pipeline_builds.reject {|i| i[:succeeded]}.size

  branch_builds = build_infos_for_date.reject {|i| ['staging', 'test', 'production'].include?(i[:branch])}
  total_branch_builds = branch_builds.size
  total_failed_branch_builds = branch_builds.reject {|i| i[:succeeded]}.size

  [date, {
    total_failure_rate: Float(total_failed_builds) / total_builds,
    pipeline_failure_rate: Float(total_failed_pipeline_builds) / total_pipeline_builds,
    branch_failure_rate: Float(total_failed_branch_builds) / total_branch_builds
  }]
end

# Print build stats
puts "Failure rates by date (1.0 = 100% failures)"
puts "%-10s %10s %10s %10s" % ['Date', 'Branch', 'Pipeline', 'Overall']
stats_by_date.each do |date, stats|
  puts "%-10s %10s %10s %10s" % [date, stats[:branch_failure_rate].round(3), stats[:pipeline_failure_rate].round(3), stats[:total_failure_rate].round(3)]
end

exit(0)
