#!/usr/bin/env ruby
# A script to analyze a range of CircleCI builds for known failures.
# For available options, run ./search-circle-builds -h

require 'pp'
require 'json'
require 'memoist'
require 'open-uri'
require 'optparse'
require 'parallel'
require 'ruby-progressbar'
require_relative './circle_project'

CIRCLE_API_BASE = 'https://circleci.com/api/v1.1/project/github/code-dot-org/code-dot-org'

@project = CircleProject.new('code-dot-org/code-dot-org')

extend Memoist

class Hash
  # Like Enumerable::map but returns a Hash instead of an Array
  def hmap(&block)
    Hash[self.map {|k, v| yield k, v }]
  end

  # Drop a key from the hash, returning the hash (destructive)
  def omit!(key)
    self.tap {|hs| hs.delete(key)}
  end
end

# @return [Hash<build_num:Integer, build_descriptor:Object>] 30 most recent
#         build descriptors from the CircleCI API
def get_recent_builds
  builds = @project.get_recent_builds
  Hash[builds.collect {|b| [b['build_num'], b]}]
end

# @return [Integer] The most recent build number in the project
def latest_build_num
  @project.get_latest_build_num
end

memoize :get_recent_builds

# @param [Fixnum] build_id The CircleCI build #
# @return [Object] build descriptor object from the CircleCI API
#   Example output JSON: https://gist.github.com/bcjordan/02f7c2906b524fa86ec75b19f9a72cd2
def get_build(build_id)
  @project.get_build(build_id)
end

memoize :get_build

options = {}
OptionParser.new do |opts|
  opts.banner = 'Usage: ./compute-failure-rates [options]'

  opts.separator <<-EXAMPLES

  Examples:

    Default behavior, view stats for the last 30 builds:
    ./compute-failure-rates

    View stats for 30 builds ending at build 123:
    ./compute-failure-rates --end 123

    View stats for all builds since (and including) build 123:
    ./compute-failure-rates --start 123

    View status for builds in range 123-456 inclusive:
    ./compute-failure-rates --start 123 --end 456

  Options:
  EXAMPLES

  opts.on('--start StartBuildNumber', String, 'Start searching at build #. Default: Get 30 builds.') do |n|
    options[:start_build] = n.to_i
  end
  opts.on('--end EndBuildNumber', String, 'End searching at build #. Default: Latest build.') do |n|
    options[:end_build] = n.to_i
  end
  opts.on_tail('-h', '--help', 'Show this message') do
    puts opts
    exit
  end
end.parse!

# Default end build should be the most recent build
end_build = options[:end_build] || latest_build_num
# Default start build should give us 30 builds up to the end build.
# This allows us to make only one API call in the all-defaults case, since
# the recent builds API call returns 30 builds.
start_build = options[:start_build] || end_build - 29
build_nums = (start_build..end_build).to_a

# Download the build information we need
build_infos = Parallel.map(build_nums, progress: 'Downloading...', in_processes: 50) do |build_num|
  build = get_recent_builds[build_num] || get_build(build_num)
  next if build['queued_at'].nil? || build['branch'].nil? || build['outcome'].nil?
  {
    build_num: build_num,
    queued_at: DateTime.parse(build['queued_at']),
    branch: build['branch'],
    succeeded: build['outcome'] == 'success'
  }
end

# Group the builds by date
builds_by_date = build_infos.compact.group_by do |build_info|
  build_info[:queued_at].strftime('%Y-%m-%d')
end

# Compute map of stats for each date
stats_by_date = builds_by_date.hmap do |date, build_infos_for_date|
  total_builds = build_infos_for_date.size
  total_failed_builds = build_infos_for_date.reject {|i| i[:succeeded]}.size

  pipeline_builds = build_infos_for_date.select {|i| ['staging', 'test', 'production'].include?(i[:branch])}
  total_pipeline_builds = pipeline_builds.size
  total_failed_pipeline_builds = pipeline_builds.reject {|i| i[:succeeded]}.size

  branch_builds = build_infos_for_date.reject {|i| ['staging', 'test', 'production'].include?(i[:branch])}
  total_branch_builds = branch_builds.size
  total_failed_branch_builds = branch_builds.reject {|i| i[:succeeded]}.size

  [date, {
    total_failure_rate: Float(total_failed_builds) / total_builds,
    pipeline_failure_rate: Float(total_failed_pipeline_builds) / total_pipeline_builds,
    branch_failure_rate: Float(total_failed_branch_builds) / total_branch_builds
  }]
end

# Print build stats
puts "Failure rates for builds #{start_build}..#{end_build} by date (1.0 = 100% failures)"
puts "%-10s %10s %10s %10s" % ['Date', 'Branch', 'Pipeline', 'Overall']
stats_by_date.each do |date, stats|
  puts "%-10s %10.3f %10.3f %10.3f" % [date, stats[:branch_failure_rate].round(3), stats[:pipeline_failure_rate].round(3), stats[:total_failure_rate].round(3)]
end

exit(0)
