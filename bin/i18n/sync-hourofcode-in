#!/usr/bin/env ruby
require_relative '../../dashboard/config/environment'
require_relative 'i18n_script_utils'
require 'fileutils'

# Pulls in all strings that need to be translated. Pulls source
# files from pegasus/sites.v3/hourofcode.com and collects them
# to a single source folder i18n/locales/source.

def pull_in_files_for_translation
  orig_dir = "pegasus/sites.v3/hourofcode.com/public"
  dest_dir = "i18n/locales/source/hourofcode"

  # Copy the file containing developer-added strings
  Dir.mkdir(dest_dir) unless Dir.exist?(dest_dir)
  FileUtils.cp("pegasus/sites.v3/hourofcode.com/i18n/en.yml", dest_dir)

  # Copy the markdown files representing individual page content
  Dir.glob(File.join(orig_dir, "**/*.{md,md.partial}")).each do |file|
    dest = file.sub(orig_dir, dest_dir)
    if File.extname(dest) == '.partial'
      dest = File.join(File.dirname(dest), File.basename(dest, '.partial'))
    end

    FileUtils.mkdir_p(File.dirname(dest))
    FileUtils.cp(file, dest)
    sanitize(dest)
  end
end

def sanitize(path)
  # YAML headers can include a lot of things we don't want translators to mess
  # with or worry about; layout, navigation settings, social media tags, etc.
  # However, they also include things like page titles that we DO want
  # translators to be able to translate, so we can't ignore them completely.
  # Instead, here we reduce the headers down to contain only the keys we care
  # about and then in the out step we reinflate the received headers with the
  # values from the original source.
  header, content, _line = Documents.new.helpers.parse_yaml_header(path)
  header.slice!("title")
  open(path, 'w') do |f|
    unless header.empty?
      f.write(I18nScriptUtils.to_crowdin_yaml(header))
      f.write("---\n\n")
    end
    f.write(content)
  end
end

pull_in_files_for_translation
