#!/usr/bin/env ruby

# Pulls in all strings that need to be translated. Pulls source
# files from blockly-core, apps, pegasus, and dashboard
# as well as instructions for levelbuilder supported levels and
# collects them to the single source folder i18n/locales/source.

require File.expand_path('../../../dashboard/config/environment', __FILE__)
require File.expand_path('../../../pegasus/src/env', __FILE__)
require 'fileutils'
require 'json'
require 'yaml'
require 'tempfile'

require_relative 'i18n_script_utils'

def sync_in
  localize_interim_level_content
  localize_block_content
  run_bash_script "bin/i18n-codeorg/in.sh"
  redact_level_content
  redact_block_content
end

def copy_to_yml(label, data)
  File.open("dashboard/config/locales/#{label}.en.yml", "w+") do |f|
    f.write(to_crowdin_yaml({"en" => {"data" => {label => data}}}))
  end
end

# sanitize a string before uploading to crowdin. Currently only performs
# CRLF -> LF conversion, but could be extended to do more
def sanitize(string)
  return string.gsub(/\r(\n)?/, "\n")
end

def redact_translated_data(path, plugins = nil)
  source = "i18n/locales/source/#{path}"
  backup = "i18n/locales/original/#{path}"
  FileUtils.mkdir_p(File.dirname(backup))
  FileUtils.cp(source, backup)
  redact(source, source, plugins)
end

def redact_block_content
  redact_translated_data('dashboard/blocks.yml', 'blockfield')
end

def get_dsl_i18n_strings(level)
  return {} unless level.is_a?(DSLDefined)
  text = level.dsl_text
  return {} unless text
  _, i18n = level.class.dsl_class.parse(text, '')
  i18n
end

def localize_interim_level_content
  # Rewrite autogenerated 'dsls.en.yml' i18n file with new master-copy English strings
  yml_file = Rails.root.join("config/locales/dsls.en.yml")
  dsl_i18n_strings = {}

  # We have to run this specifically from the Rails directory because
  # get_dsl_i18n_strings relies on level.dsl_text which relies on
  # level.filename which relies on running a shell command
  Dir.chdir(Rails.root) do
    Script.all.each do |script|
      next unless ScriptConstants.i18n? script.name

      script_strings = {
        "display_name" => {},
        "short_instructions" => {},
        "long_instructions" => {},
        "failure_message_overrides" => {},
        "authored_hints" => {},
        "callouts" => {},
        "block_categories" => {},
        "function_names" => {}
      }

      script.levels.each do |level|
        url = get_level_url_key(script, level)
        if level.is_a?(DSLDefined)
          level.contained_levels.each do |contained_level|
            dsl_i18n_strings.deep_merge! get_dsl_i18n_strings(contained_level)
          end

          dsl_i18n_strings.deep_merge! get_dsl_i18n_strings(level)
        else
          # display_name
          if level.display_name
            script_strings['display_name'][url] = level.display_name
          end
          # short_instructions
          if level.short_instructions
            script_strings['short_instructions'][url] = level.short_instructions
          end
          # long_instructions
          if level.long_instructions
            script_strings['long_instructions'][url] = level.short_instructions
          end

          # failure_message_overrides
          #if level.failure_message_override
          #  script_strings['failure_message_overrides'][url] = level.failure_message_override
          #end

          # authored_hints
          if level.authored_hints
            authored_hints = JSON.parse(level.authored_hints)
            script_strings['authored_hints'][url] = Hash.new unless authored_hints.empty?
            authored_hints.each do |hint|
              script_strings['authored_hints'][url][hint['hint_id']] = hint['hint_markdown']
            end
          end
          # callouts
          if level.callout_json
            callouts = JSON.parse(level.callout_json)
            script_strings['callouts'][url] = Hash.new unless callouts.empty?
            callouts.each do |callout|
              script_strings['callouts'][url][callout['localization_key']] = callout['callout_text']
            end
          end

          level_xml = Nokogiri::XML(level.to_xml, &:noblanks)
          blocks = level_xml.xpath('//blocks').first
          if blocks
            ## Categories
            block_categories = blocks.xpath('//category')
            script_strings['block_categories'][url] = Hash.new unless block_categories.empty?
            block_categories.each do |category|
              name = category.attr('name')
              script_strings['block_categories'][url][name] = name if name
            end

            ## Function Names
            functions = blocks.xpath("//block[@type=\"procedures_defnoreturn\"]")
            script_strings['function_names'][url] = Hash.new unless functions.empty?
            functions.each do |function|
              name = function.at_xpath('./title[@name="NAME"]')
              script_strings['function_names'][url][name.content] = name.content if name
            end
          end

        end
      end

      script_strings.delete_if {|_key, value| value.nil? || value.try(:empty)}

      script_i18n_directory = "../i18n/locales/source/course_content"
      if script.version_year
        script_i18n_directory = "#{script_i18n_directory}/#{script.version_year}"
      end
      Dir.mkdir script_i18n_directory unless Dir.exist? script_i18n_directory
      script_i18n_filename = "#{script_i18n_directory}/#{script.name}.yml"
      File.open(script_i18n_filename, 'w') do |file|
        file.write(to_crowdin_yaml({"en" => {"data" => script_strings}}))
      end
    end
  end

  i18n_warning = "# Autogenerated English-language level-definition locale file. Do not edit by hand or commit to version control.\n"
  File.write(yml_file, i18n_warning + dsl_i18n_strings.deep_sort.to_yaml(line_width: -1))
end

# Pull in various fields for custom blocks from .json files and save them to
# blocks.en.yml.
def localize_block_content
  blocks = {}

  Dir.glob('dashboard/config/blocks/**/*.json').sort.each do |file|
    name = File.basename(file, '.*')
    config = JSON.parse(File.read(file))['config']
    blocks[name] = {
      'text' => config['blockText'],
    }

    next unless config['args']

    args_with_options = {}
    config['args'].each do |arg|
      next if !arg['options'] || arg['options'].empty?

      options = args_with_options[arg['name']] = {}
      arg['options'].each do |option_tuple|
        options[option_tuple.last] = option_tuple.first
      end
    end
    blocks[name]['options'] = args_with_options unless args_with_options.empty?
  end

  copy_to_yml('blocks', blocks)
end

def redact_level_content
  #  %w(
  #    authored_hints
  #    short_instructions
  #    long_instructions
  #  ).each do |content_type|
  #    redact_translated_data("dashboard/#{content_type}.yml")
  #  end
  Dir.glob("i18n/locales/source/course_content/**/*.yml").each do |source|
    backup = source.sub("source", "original")
    FileUtils.mkdir_p(File.dirname(backup))
    FileUtils.cp(source, backup)
    redact(source, source)
  end
end

# Pull in various fields for levelbuilder levels from .level files and
# save them to [field_name].en.yml files to be translated. Fields included:
#   short instructions
#   long instructions
#   failure message override
#   authored hints
#   callouts
#
# See Blockly.get_localized_property in dashboard models for usage
def localize_level_content
  level_display_name = Hash.new
  level_short_instructions = Hash.new
  level_long_instructions = Hash.new
  level_failure_message_overrides = Hash.new
  level_authored_hints = Hash.new
  level_callouts = Hash.new
  level_block_categories = Hash.new
  level_function_names = Hash.new

  Dir.glob("dashboard/config/scripts/levels/*.level").sort.each do |file|
    level_name = File.basename(file, ".*")
    File.open(file) do |data|
      level_xml = Nokogiri::XML(data, &:noblanks)

      # Properties
      config = JSON.parse(level_xml.xpath('//../config').first.text)
      next unless config["properties"]

      ## Display Name
      if display_name = config["properties"]["display_name"]
        level_display_name[level_name] = sanitize(display_name)
      end

      ## Instructions
      if short_instructions = (config["properties"]["short_instructions"] || config["properties"]["instructions"])
        level_short_instructions[level_name] = sanitize(short_instructions)
      end

      ## Markdown Instructions
      if long_instructions = (config["properties"]["long_instructions"] || config["properties"]["markdown_instructions"])
        level_long_instructions[level_name] = sanitize(long_instructions)
      end

      ## Failure message overrides
      if failure_message_overrides = config["properties"]["failure_message_override"]
        level_failure_message_overrides["#{level_name}_failure_message_override"] = sanitize(failure_message_overrides)
      end

      ## Authored Hints
      if authored_hints_json = config["properties"]["authored_hints"]
        level_authored_hints["#{level_name}_authored_hint"] = JSON.parse(authored_hints_json).reduce({}) do |memo, hint|
          memo[hint['hint_id']] = hint['hint_markdown'] unless hint['hint_id'].empty?
          memo
        end
      end

      ## Callouts
      if callouts_json = config["properties"]["callout_json"]
        level_callouts["#{level_name}_callout"] = JSON.parse(callouts_json).reduce({}) do |memo, callout|
          memo[callout['localization_key']] = callout['callout_text'] unless callout['localization_key'].empty?
          memo
        end
      end

      # Blocks
      blocks = level_xml.xpath('//blocks').first
      if blocks
        ## Categories
        blocks.xpath('//category').each do |category|
          name = category.attr('name')
          level_block_categories[name] = name if name
        end

        ## Function Names
        blocks.xpath("//block[@type=\"procedures_defnoreturn\"]").each do |function|
          name = function.at_xpath('./title[@name="NAME"]')
          level_function_names[name.content] = name.content if name
        end
      end
    end
  end

  copy_to_yml("display_name", level_display_name)
  copy_to_yml("short_instructions", level_short_instructions)
  copy_to_yml("long_instructions", level_long_instructions)
  copy_to_yml("failure_message_overrides", level_failure_message_overrides)
  copy_to_yml("authored_hints", level_authored_hints)
  copy_to_yml("callouts", level_callouts)
  copy_to_yml("block_categories", level_block_categories)
  copy_to_yml("function_names", level_function_names)
end

sync_in if __FILE__ == $0
