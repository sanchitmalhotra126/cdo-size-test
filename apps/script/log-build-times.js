/**
 * @file Decorate a grunt module to track and log durations for all of its
 *       steps, and (when possible) to upload those logs to New Relic.
 */
var newrelic = require('newrelic'); // Wants to be first.
var chalk = require('chalk');
var fs = require('fs');
var execSync = require('child_process').execSync;
var path = require('path');
var timeGrunt = require('time-grunt-nowatch');
var yaml = require('js-yaml');

var LOG_FILE_NAME = 'build-times.log';
var LOG_FILE_PATH = path.join(__dirname, '../', LOG_FILE_NAME);
var LOCALS_YML_PATH = path.join(__dirname, '../../', 'locals.yml');

/**
 * Decorate the given grunt module to record and report build durations.
 *
 * @example Gruntfile.js
 *   module.exports = function (grunt) {
 *     logBuildTimes(grunt);
 *     grunt.registerTask(build, function () {...});
 *   };
 */
module.exports = function logBuildTimes(grunt) {
  timeGrunt(grunt, false, function (stats, log) {
    log(chalk.underline('New Relic Logging'));
    writeStatsToLogFile(stats, log);
    uploadLoggedStatsToNewRelic(log);
  });
};

/**
 * Writes build time statistics generated by time-grunt-nowatch to a log file.
 * @param {object} stats
 * @param {function} consoleLog
 */
function writeStatsToLogFile(stats, consoleLog) {
  try {
    fs.appendFileSync(LOG_FILE_PATH, JSON.stringify([
      new Date().toString(),
      getUserEmail(),
      stats
    ])+'\n');
    consoleLog('Build statistics added to ' + LOG_FILE_NAME);
  } catch (e) {
    consoleLog(chalk.red("Failed to write to " + LOG_FILE_NAME + " file: " + e));
  }
}

/**
 * Reads the log file and attempts to upload it to New Relic.  If successful,
 * truncates the log file.
 * @param {function} consoleLog
 */
function uploadLoggedStatsToNewRelic(consoleLog) {
  if (!getNewRelicLicenseKey()) {
    // we will skip logging to new relic.
    consoleLog(chalk.yellow(
        "Add new_relic_license_key to your locals.yml file to\n" +
        "have your build times logged to new relic. Talk to paul@code.org\n" +
        "for more information."
    ));
    return;
  }

  try {
    var rawData = fs.readFileSync(LOG_FILE_PATH, 'utf-8');
    var dataToLog = parseCollectedData(rawData);
  } catch (e) {
    consoleLog(chalk.yellow("Unable to parse " + LOG_FILE_NAME + ". Skipping New Relic upload"));
    return;
  }

  if (dataToLog.length > 0) {
    consoleLog("Logging " + dataToLog.length + " build time events to new relic ");
    var failed = false;
    dataToLog.forEach(function (data) {
      try {
        newrelic.recordCustomEvent("apps_build", data);
      } catch (e) {
        consoleLog(chalk.red("Failed to upload to new relic: "+e));
        failed = true;
      }
    });
    if (!failed) {
      consoleLog(chalk.green('OK'));
      fs.truncateSync(LOG_FILE_PATH);
    }
  }
}

/**
 * Given the raw contents of the log file as a string, parses it and returns
 * an array of log entry objects (filtered to 'exec' tasks) ready to upload
 * to New Relic.
 * @param {string} data
 * @returns {{task: string, totalTime: number, email: string, logTimestamp: number}[]}
 */
function parseCollectedData(data) {
  var lines = data.split('\n');
  return lines.reduce(function (collectedData, nextLine) {
    if (!nextLine) {
      return collectedData;
    }
    var data = JSON.parse(nextLine);
    var email = data[1];
    var stats = data[2];
    var timestamp = Math.floor(new Date(data[0]).getTime() / 1000); // seconds since epoch
    var formattedRecords = stats.map(function (stat) {
      return {
        task: stat[0],
        totalTime: stat[1],
        email: email,
        logTimestamp: timestamp
      };
    }).filter(function (data) {
      return /^exec/.test(data.task);
    });
    return collectedData.concat(formattedRecords);
  }, []);
}

/**
 * Retrieve the New Relic License Key from locals.yml, if it exists.
 * If locals.yml does not exist, or the key does not exist, return undefined.
 */
var getNewRelicLicenseKey = once(function () {
  try {
    var locals = yaml.safeLoad(fs.readFileSync(LOCALS_YML_PATH));
    return locals.new_relic_license_key;
  } catch (e) {
    // No locals.yml found, assume no license key is available.
    return undefined;
  }
});

/**
 * Retrieve the git user's email address.  Return 'unknown' if we are unable
 * to get this information.
 */
var getUserEmail = once(function () {
  try {
    return execSync('git config --get user.email').toString().trim();
  } catch (e) {
    // I guess we are not in a git checkout, or don't have git installed.
    return 'unknown';
  }
});

/**
 * Creates a function that is restricted to invoking func once. Repeat calls to
 * the function return the value of the first invocation.
 * @see https://lodash.com/docs#once
 */
function once(fn) {
  var called, returnValue;
  return function () {
    if (!called) {
      returnValue = fn.apply(this, arguments);
      called = true;
    }
    return returnValue;
  };
}
