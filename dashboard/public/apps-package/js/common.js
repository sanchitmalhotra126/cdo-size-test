require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/home/ubuntu/staging/apps/build/js/level_base.js":[function(require,module,exports){
// Functions for checking required blocks.

/**
 * Generate a required blocks dictionary for a call to a procedure that does
 * not have a return value.
 * @param {string} name The name of the procedure being called.
 * @return {Object} A required blocks dictionary able to check for and
 *     generate the specified block.
 */
'use strict';

exports.call = function (name) {
  return {
    test: function test(block) {
      return block.type == 'procedures_callnoreturn' && block.getTitleValue('NAME').toLowerCase() == name.toLowerCase();
    },
    type: 'procedures_callnoreturn',
    titles: { 'NAME': name }
  };
};

/**
 * Generate a required blocks dictionary for a call to a procedure with a
 * single argument.
 * @param {string} func_name The name of the procedure being called.
 * @return {Object} A required blocks dictionary able to check for and
 *     generate the specified block.
 */
exports.callWithArg = function (func_name, arg_name) {
  return {
    test: function test(block) {
      return block.type == 'procedures_callnoreturn' && block.getTitleValue('NAME').toLowerCase() == func_name.toLowerCase();
    },
    type: 'procedures_callnoreturn',
    extra: '<mutation name="' + func_name + '"><arg name="' + arg_name + '"></arg></mutation>'
  };
};

/**
 * Generate a required blocks dictionary for the definition of a procedure
 * that does not have a return value.  This does not check if any arguments
 * are defined for the procedure.
 * @param {string} name The name of the procedure being defined.
 * @return {Object} A required blocks dictionary able to check for and
 *     generate the specified block.
 */
exports.define = function (name) {
  return {
    test: function test(block) {
      return block.type == 'procedures_defnoreturn' && block.getTitleValue('NAME').toLowerCase() == name.toLowerCase();
    },
    type: 'procedures_defnoreturn',
    titles: { 'NAME': name }
  };
};

},{}],"/home/ubuntu/staging/apps/node_modules/canvg/canvg.js":[function(require,module,exports){
/*
 * canvg.js - Javascript SVG parser and renderer on Canvas
 * MIT Licensed
 * Gabe Lerner (gabelerner@gmail.com)
 * http://code.google.com/p/canvg/
 *
 * Requires: rgbcolor.js - http://www.phpied.com/rgb-color-parser-in-javascript/
 */
 (function ( global, factory ) {

	'use strict';

	// export as AMD...
	if ( typeof define !== 'undefined' && define.amd ) {
		define('canvgModule', [ 'rgbcolor', 'stackblur' ], factory );
	}

	// ...or as browserify
	else if ( typeof module !== 'undefined' && module.exports ) {
		module.exports = factory( require( 'rgbcolor' ), require( 'stackblur' ) );
	}

	global.canvg = factory( global.RGBColor, global.stackBlur );

}( typeof window !== 'undefined' ? window : this, function ( RGBColor, stackBlur ) {

	// canvg(target, s)
	// empty parameters: replace all 'svg' elements on page with 'canvas' elements
	// target: canvas element or the id of a canvas element
	// s: svg string, url to svg file, or xml document
	// opts: optional hash of options
	//		 ignoreMouse: true => ignore mouse events
	//		 ignoreAnimation: true => ignore animations
	//		 ignoreDimensions: true => does not try to resize canvas
	//		 ignoreClear: true => does not clear canvas
	//		 offsetX: int => draws at a x offset
	//		 offsetY: int => draws at a y offset
	//		 scaleWidth: int => scales horizontally to width
	//		 scaleHeight: int => scales vertically to height
	//		 renderCallback: function => will call the function after the first render is completed
	//		 forceRedraw: function => will call the function on every frame, if it returns true, will redraw
	var canvg = function (target, s, opts) {
		// no parameters
		if (target == null && s == null && opts == null) {
			var svgTags = document.querySelectorAll('svg');
			for (var i=0; i<svgTags.length; i++) {
				var svgTag = svgTags[i];
				var c = document.createElement('canvas');
				c.width = svgTag.clientWidth;
				c.height = svgTag.clientHeight;
				svgTag.parentNode.insertBefore(c, svgTag);
				svgTag.parentNode.removeChild(svgTag);
				var div = document.createElement('div');
				div.appendChild(svgTag);
				canvg(c, div.innerHTML);
			}
			return;
		}

		if (typeof target == 'string') {
			target = document.getElementById(target);
		}

		// store class on canvas
		if (target.svg != null) target.svg.stop();
		var svg = build(opts || {});
		// on i.e. 8 for flash canvas, we can't assign the property so check for it
		if (!(target.childNodes.length == 1 && target.childNodes[0].nodeName == 'OBJECT')) target.svg = svg;

		var ctx = target.getContext('2d');
		if (typeof s.documentElement != 'undefined') {
			// load from xml doc
			svg.loadXmlDoc(ctx, s);
		}
		else if (s.substr(0,1) == '<') {
			// load from xml string
			svg.loadXml(ctx, s);
		}
		else {
			// load from url
			svg.load(ctx, s);
		}
	}

	// see https://developer.mozilla.org/en-US/docs/Web/API/Element.matches
	var matchesSelector;
	if (typeof Element.prototype.matches != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.matches(selector);
		};
	} else if (typeof Element.prototype.webkitMatchesSelector != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.webkitMatchesSelector(selector);
		};
	} else if (typeof Element.prototype.mozMatchesSelector != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.mozMatchesSelector(selector);
		};
	} else if (typeof Element.prototype.msMatchesSelector != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.msMatchesSelector(selector);
		};
	} else if (typeof Element.prototype.oMatchesSelector != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.oMatchesSelector(selector);
		};
	} else {
		// requires Sizzle: https://github.com/jquery/sizzle/wiki/Sizzle-Documentation
		// or jQuery: http://jquery.com/download/
		// or Zepto: http://zeptojs.com/#
		// without it, this is a ReferenceError

		if (typeof jQuery === 'function' || typeof Zepto === 'function') {
			matchesSelector = function (node, selector) {
				return $(node).is(selector);
			};
		}

		if (typeof matchesSelector === 'undefined') {
			matchesSelector = Sizzle.matchesSelector;
		}
	}

	// slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/gi;
	var pseudoClassWithBracketsRegex = /(:[\w-]+\([^\)]*\))/gi;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	function getSelectorSpecificity(selector) {
		var typeCount = [0, 0, 0];
		var findMatch = function(regex, type) {
			var matches = selector.match(regex);
			if (matches == null) {
				return;
			}
			typeCount[type] += matches.length;
			selector = selector.replace(regex, ' ');
		};

		selector = selector.replace(/:not\(([^\)]*)\)/g, '     $1 ');
		selector = selector.replace(/{[^]*/gm, ' ');
		findMatch(attributeRegex, 1);
		findMatch(idRegex, 0);
		findMatch(classRegex, 1);
		findMatch(pseudoElementRegex, 2);
		findMatch(pseudoClassWithBracketsRegex, 1);
		findMatch(pseudoClassRegex, 1);
		selector = selector.replace(/[\*\s\+>~]/g, ' ');
		selector = selector.replace(/[#\.]/g, ' ');
		findMatch(elementRegex, 2);
		return typeCount.join('');
	}

	function build(opts) {
		var svg = { opts: opts };

		svg.FRAMERATE = 30;
		svg.MAX_VIRTUAL_PIXELS = 30000;

		svg.log = function(msg) {};
		if (svg.opts['log'] == true && typeof console != 'undefined') {
			svg.log = function(msg) { console.log(msg); };
		};

		// globals
		svg.init = function(ctx) {
			var uniqueId = 0;
			svg.UniqueId = function () { uniqueId++; return 'canvg' + uniqueId;	};
			svg.Definitions = {};
			svg.Styles = {};
			svg.StylesSpecificity = {};
			svg.Animations = [];
			svg.Images = [];
			svg.ctx = ctx;
			svg.ViewPort = new (function () {
				this.viewPorts = [];
				this.Clear = function() { this.viewPorts = []; }
				this.SetCurrent = function(width, height) { this.viewPorts.push({ width: width, height: height }); }
				this.RemoveCurrent = function() { this.viewPorts.pop(); }
				this.Current = function() { return this.viewPorts[this.viewPorts.length - 1]; }
				this.width = function() { return this.Current().width; }
				this.height = function() { return this.Current().height; }
				this.ComputeSize = function(d) {
					if (d != null && typeof d == 'number') return d;
					if (d == 'x') return this.width();
					if (d == 'y') return this.height();
					return Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2);
				}
			});
		}
		svg.init();

		// images loaded
		svg.ImagesLoaded = function() {
			for (var i=0; i<svg.Images.length; i++) {
				if (!svg.Images[i].loaded) return false;
			}
			return true;
		}

		// trim
		svg.trim = function(s) { return s.replace(/^\s+|\s+$/g, ''); }

		// compress spaces
		svg.compressSpaces = function(s) { return s.replace(/[\s\r\t\n]+/gm,' '); }

		// ajax
		svg.ajax = function(url) {
			var AJAX;
			if(window.XMLHttpRequest){AJAX=new XMLHttpRequest();}
			else{AJAX=new ActiveXObject('Microsoft.XMLHTTP');}
			if(AJAX){
			   AJAX.open('GET',url,false);
			   AJAX.send(null);
			   return AJAX.responseText;
			}
			return null;
		}

		// parse xml
		svg.parseXml = function(xml) {
			if (typeof Windows != 'undefined' && typeof Windows.Data != 'undefined' && typeof Windows.Data.Xml != 'undefined') {
				var xmlDoc = new Windows.Data.Xml.Dom.XmlDocument();
				var settings = new Windows.Data.Xml.Dom.XmlLoadSettings();
				settings.prohibitDtd = false;
				xmlDoc.loadXml(xml, settings);
				return xmlDoc;
			}
			else if (window.DOMParser)
			{
				var parser = new DOMParser();
				return parser.parseFromString(xml, 'text/xml');
			}
			else
			{
				xml = xml.replace(/<!DOCTYPE svg[^>]*>/, '');
				var xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
				xmlDoc.async = 'false';
				xmlDoc.loadXML(xml);
				return xmlDoc;
			}
		}

		svg.Property = function(name, value) {
			this.name = name;
			this.value = value;
		}
			svg.Property.prototype.getValue = function() {
				return this.value;
			}

			svg.Property.prototype.hasValue = function() {
				return (this.value != null && this.value !== '');
			}

			// return the numerical value of the property
			svg.Property.prototype.numValue = function() {
				if (!this.hasValue()) return 0;

				var n = parseFloat(this.value);
				if ((this.value + '').match(/%$/)) {
					n = n / 100.0;
				}
				return n;
			}

			svg.Property.prototype.valueOrDefault = function(def) {
				if (this.hasValue()) return this.value;
				return def;
			}

			svg.Property.prototype.numValueOrDefault = function(def) {
				if (this.hasValue()) return this.numValue();
				return def;
			}

			// color extensions
				// augment the current color value with the opacity
				svg.Property.prototype.addOpacity = function(opacityProp) {
					var newValue = this.value;
					if (opacityProp.value != null && opacityProp.value != '' && typeof this.value == 'string') { // can only add opacity to colors, not patterns
						var color = new RGBColor(this.value);
						if (color.ok) {
							newValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacityProp.numValue() + ')';
						}
					}
					return new svg.Property(this.name, newValue);
				}

			// definition extensions
				// get the definition from the definitions table
				svg.Property.prototype.getDefinition = function() {
					var name = this.value.match(/#([^\)'"]+)/);
					if (name) { name = name[1]; }
					if (!name) { name = this.value; }
					return svg.Definitions[name];
				}

				svg.Property.prototype.isUrlDefinition = function() {
					return this.value.indexOf('url(') == 0
				}

				svg.Property.prototype.getFillStyleDefinition = function(e, opacityProp) {
					var def = this.getDefinition();

					// gradient
					if (def != null && def.createGradient) {
						return def.createGradient(svg.ctx, e, opacityProp);
					}

					// pattern
					if (def != null && def.createPattern) {
						if (def.getHrefAttribute().hasValue()) {
							var pt = def.attribute('patternTransform');
							def = def.getHrefAttribute().getDefinition();
							if (pt.hasValue()) { def.attribute('patternTransform', true).value = pt.value; }
						}
						return def.createPattern(svg.ctx, e);
					}

					return null;
				}

			// length extensions
				svg.Property.prototype.getDPI = function(viewPort) {
					return 96.0; // TODO: compute?
				}

				svg.Property.prototype.getEM = function(viewPort) {
					var em = 12;

					var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
					if (fontSize.hasValue()) em = fontSize.toPixels(viewPort);

					return em;
				}

				svg.Property.prototype.getUnits = function() {
					var s = this.value+'';
					return s.replace(/[0-9\.\-]/g,'');
				}

				// get the length as pixels
				svg.Property.prototype.toPixels = function(viewPort, processPercent) {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/em$/)) return this.numValue() * this.getEM(viewPort);
					if (s.match(/ex$/)) return this.numValue() * this.getEM(viewPort) / 2.0;
					if (s.match(/px$/)) return this.numValue();
					if (s.match(/pt$/)) return this.numValue() * this.getDPI(viewPort) * (1.0 / 72.0);
					if (s.match(/pc$/)) return this.numValue() * 15;
					if (s.match(/cm$/)) return this.numValue() * this.getDPI(viewPort) / 2.54;
					if (s.match(/mm$/)) return this.numValue() * this.getDPI(viewPort) / 25.4;
					if (s.match(/in$/)) return this.numValue() * this.getDPI(viewPort);
					if (s.match(/%$/)) return this.numValue() * svg.ViewPort.ComputeSize(viewPort);
					var n = this.numValue();
					if (processPercent && n < 1.0) return n * svg.ViewPort.ComputeSize(viewPort);
					return n;
				}

			// time extensions
				// get the time as milliseconds
				svg.Property.prototype.toMilliseconds = function() {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/s$/)) return this.numValue() * 1000;
					if (s.match(/ms$/)) return this.numValue();
					return this.numValue();
				}

			// angle extensions
				// get the angle as radians
				svg.Property.prototype.toRadians = function() {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/deg$/)) return this.numValue() * (Math.PI / 180.0);
					if (s.match(/grad$/)) return this.numValue() * (Math.PI / 200.0);
					if (s.match(/rad$/)) return this.numValue();
					return this.numValue() * (Math.PI / 180.0);
				}

			// text extensions
				// get the text baseline
				var textBaselineMapping = {
					'baseline': 'alphabetic',
					'before-edge': 'top',
					'text-before-edge': 'top',
					'middle': 'middle',
					'central': 'middle',
					'after-edge': 'bottom',
					'text-after-edge': 'bottom',
					'ideographic': 'ideographic',
					'alphabetic': 'alphabetic',
					'hanging': 'hanging',
					'mathematical': 'alphabetic'
				};
				svg.Property.prototype.toTextBaseline = function () {
					if (!this.hasValue()) return null;
					return textBaselineMapping[this.value];
				}

		// fonts
		svg.Font = new (function() {
			this.Styles = 'normal|italic|oblique|inherit';
			this.Variants = 'normal|small-caps|inherit';
			this.Weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';

			this.CreateFont = function(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
				var f = inherit != null ? this.Parse(inherit) : this.CreateFont('', '', '', '', '', svg.ctx.font);
				return {
					fontFamily: fontFamily || f.fontFamily,
					fontSize: fontSize || f.fontSize,
					fontStyle: fontStyle || f.fontStyle,
					fontWeight: fontWeight || f.fontWeight,
					fontVariant: fontVariant || f.fontVariant,
					toString: function () { return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(' ') }
				}
			}

			var that = this;
			this.Parse = function(s) {
				var f = {};
				var d = svg.trim(svg.compressSpaces(s || '')).split(' ');
				var set = { fontSize: false, fontStyle: false, fontWeight: false, fontVariant: false }
				var ff = '';
				for (var i=0; i<d.length; i++) {
					if (!set.fontStyle && that.Styles.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontStyle = d[i]; set.fontStyle = true; }
					else if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontVariant = d[i]; set.fontStyle = set.fontVariant = true;	}
					else if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1) {	if (d[i] != 'inherit') f.fontWeight = d[i]; set.fontStyle = set.fontVariant = set.fontWeight = true; }
					else if (!set.fontSize) { if (d[i] != 'inherit') f.fontSize = d[i].split('/')[0]; set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true; }
					else { if (d[i] != 'inherit') ff += d[i]; }
				} if (ff != '') f.fontFamily = ff;
				return f;
			}
		});

		// points and paths
		svg.ToNumberArray = function(s) {
			var a = svg.trim(svg.compressSpaces((s || '').replace(/,/g, ' '))).split(' ');
			for (var i=0; i<a.length; i++) {
				a[i] = parseFloat(a[i]);
			}
			return a;
		}
		svg.Point = function(x, y) {
			this.x = x;
			this.y = y;
		}
			svg.Point.prototype.angleTo = function(p) {
				return Math.atan2(p.y - this.y, p.x - this.x);
			}

			svg.Point.prototype.applyTransform = function(v) {
				var xp = this.x * v[0] + this.y * v[2] + v[4];
				var yp = this.x * v[1] + this.y * v[3] + v[5];
				this.x = xp;
				this.y = yp;
			}

		svg.CreatePoint = function(s) {
			var a = svg.ToNumberArray(s);
			return new svg.Point(a[0], a[1]);
		}
		svg.CreatePath = function(s) {
			var a = svg.ToNumberArray(s);
			var path = [];
			for (var i=0; i<a.length; i+=2) {
				path.push(new svg.Point(a[i], a[i+1]));
			}
			return path;
		}

		// bounding box
		svg.BoundingBox = function(x1, y1, x2, y2) { // pass in initial points if you want
			this.x1 = Number.NaN;
			this.y1 = Number.NaN;
			this.x2 = Number.NaN;
			this.y2 = Number.NaN;

			this.x = function() { return this.x1; }
			this.y = function() { return this.y1; }
			this.width = function() { return this.x2 - this.x1; }
			this.height = function() { return this.y2 - this.y1; }

			this.addPoint = function(x, y) {
				if (x != null) {
					if (isNaN(this.x1) || isNaN(this.x2)) {
						this.x1 = x;
						this.x2 = x;
					}
					if (x < this.x1) this.x1 = x;
					if (x > this.x2) this.x2 = x;
				}

				if (y != null) {
					if (isNaN(this.y1) || isNaN(this.y2)) {
						this.y1 = y;
						this.y2 = y;
					}
					if (y < this.y1) this.y1 = y;
					if (y > this.y2) this.y2 = y;
				}
			}
			this.addX = function(x) { this.addPoint(x, null); }
			this.addY = function(y) { this.addPoint(null, y); }

			this.addBoundingBox = function(bb) {
				this.addPoint(bb.x1, bb.y1);
				this.addPoint(bb.x2, bb.y2);
			}

			this.addQuadraticCurve = function(p0x, p0y, p1x, p1y, p2x, p2y) {
				var cp1x = p0x + 2/3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)
				var cp1y = p0y + 2/3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)
				var cp2x = cp1x + 1/3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)
				var cp2y = cp1y + 1/3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)
				this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y,	cp2y, p2x, p2y);
			}

			this.addBezierCurve = function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
				// from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
				var p0 = [p0x, p0y], p1 = [p1x, p1y], p2 = [p2x, p2y], p3 = [p3x, p3y];
				this.addPoint(p0[0], p0[1]);
				this.addPoint(p3[0], p3[1]);

				for (i=0; i<=1; i++) {
					var f = function(t) {
						return Math.pow(1-t, 3) * p0[i]
						+ 3 * Math.pow(1-t, 2) * t * p1[i]
						+ 3 * (1-t) * Math.pow(t, 2) * p2[i]
						+ Math.pow(t, 3) * p3[i];
					}

					var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
					var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
					var c = 3 * p1[i] - 3 * p0[i];

					if (a == 0) {
						if (b == 0) continue;
						var t = -c / b;
						if (0 < t && t < 1) {
							if (i == 0) this.addX(f(t));
							if (i == 1) this.addY(f(t));
						}
						continue;
					}

					var b2ac = Math.pow(b, 2) - 4 * c * a;
					if (b2ac < 0) continue;
					var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
					if (0 < t1 && t1 < 1) {
						if (i == 0) this.addX(f(t1));
						if (i == 1) this.addY(f(t1));
					}
					var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
					if (0 < t2 && t2 < 1) {
						if (i == 0) this.addX(f(t2));
						if (i == 1) this.addY(f(t2));
					}
				}
			}

			this.isPointInBox = function(x, y) {
				return (this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2);
			}

			this.addPoint(x1, y1);
			this.addPoint(x2, y2);
		}

		// transforms
		svg.Transform = function(v) {
			var that = this;
			this.Type = {}

			// translate
			this.Type.translate = function(s) {
				this.p = svg.CreatePoint(s);
				this.apply = function(ctx) {
					ctx.translate(this.p.x || 0.0, this.p.y || 0.0);
				}
				this.unapply = function(ctx) {
					ctx.translate(-1.0 * this.p.x || 0.0, -1.0 * this.p.y || 0.0);
				}
				this.applyToPoint = function(p) {
					p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
				}
			}

			// rotate
			this.Type.rotate = function(s) {
				var a = svg.ToNumberArray(s);
				this.angle = new svg.Property('angle', a[0]);
				this.cx = a[1] || 0;
				this.cy = a[2] || 0;
				this.apply = function(ctx) {
					ctx.translate(this.cx, this.cy);
					ctx.rotate(this.angle.toRadians());
					ctx.translate(-this.cx, -this.cy);
				}
				this.unapply = function(ctx) {
					ctx.translate(this.cx, this.cy);
					ctx.rotate(-1.0 * this.angle.toRadians());
					ctx.translate(-this.cx, -this.cy);
				}
				this.applyToPoint = function(p) {
					var a = this.angle.toRadians();
					p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
					p.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);
					p.applyTransform([1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0]);
				}
			}

			this.Type.scale = function(s) {
				this.p = svg.CreatePoint(s);
				this.apply = function(ctx) {
					ctx.scale(this.p.x || 1.0, this.p.y || this.p.x || 1.0);
				}
				this.unapply = function(ctx) {
					ctx.scale(1.0 / this.p.x || 1.0, 1.0 / this.p.y || this.p.x || 1.0);
				}
				this.applyToPoint = function(p) {
					p.applyTransform([this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0]);
				}
			}

			this.Type.matrix = function(s) {
				this.m = svg.ToNumberArray(s);
				this.apply = function(ctx) {
					ctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);
				}
				this.unapply = function(ctx) {
					var a = this.m[0];
					var b = this.m[2];
					var c = this.m[4];
					var d = this.m[1];
					var e = this.m[3];
					var f = this.m[5];
					var g = 0.0;
					var h = 0.0;
					var i = 1.0;
					var det = 1 / (a*(e*i-f*h)-b*(d*i-f*g)+c*(d*h-e*g));
					ctx.transform(
						det*(e*i-f*h),
						det*(f*g-d*i),
						det*(c*h-b*i),
						det*(a*i-c*g),
						det*(b*f-c*e),
						det*(c*d-a*f)
					);
				}
				this.applyToPoint = function(p) {
					p.applyTransform(this.m);
				}
			}

			this.Type.SkewBase = function(s) {
				this.base = that.Type.matrix;
				this.base(s);
				this.angle = new svg.Property('angle', s);
			}
			this.Type.SkewBase.prototype = new this.Type.matrix;

			this.Type.skewX = function(s) {
				this.base = that.Type.SkewBase;
				this.base(s);
				this.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0];
			}
			this.Type.skewX.prototype = new this.Type.SkewBase;

			this.Type.skewY = function(s) {
				this.base = that.Type.SkewBase;
				this.base(s);
				this.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0];
			}
			this.Type.skewY.prototype = new this.Type.SkewBase;

			this.transforms = [];

			this.apply = function(ctx) {
				for (var i=0; i<this.transforms.length; i++) {
					this.transforms[i].apply(ctx);
				}
			}

			this.unapply = function(ctx) {
				for (var i=this.transforms.length-1; i>=0; i--) {
					this.transforms[i].unapply(ctx);
				}
			}

			this.applyToPoint = function(p) {
				for (var i=0; i<this.transforms.length; i++) {
					this.transforms[i].applyToPoint(p);
				}
			}

			var data = svg.trim(svg.compressSpaces(v)).replace(/\)([a-zA-Z])/g, ') $1').replace(/\)(\s?,\s?)/g,') ').split(/\s(?=[a-z])/);
			for (var i=0; i<data.length; i++) {
				var type = svg.trim(data[i].split('(')[0]);
				var s = data[i].split('(')[1].replace(')','');
				var transformType = this.Type[type];
				if (typeof transformType != 'undefined') {
					var transform = new transformType(s);
					transform.type = type;
					this.transforms.push(transform);
				}
			}
		}

		// aspect ratio
		svg.AspectRatio = function(ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {
			// aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
			aspectRatio = svg.compressSpaces(aspectRatio);
			aspectRatio = aspectRatio.replace(/^defer\s/,''); // ignore defer
			var align = aspectRatio.split(' ')[0] || 'xMidYMid';
			var meetOrSlice = aspectRatio.split(' ')[1] || 'meet';

			// calculate scale
			var scaleX = width / desiredWidth;
			var scaleY = height / desiredHeight;
			var scaleMin = Math.min(scaleX, scaleY);
			var scaleMax = Math.max(scaleX, scaleY);
			if (meetOrSlice == 'meet') { desiredWidth *= scaleMin; desiredHeight *= scaleMin; }
			if (meetOrSlice == 'slice') { desiredWidth *= scaleMax; desiredHeight *= scaleMax; }

			refX = new svg.Property('refX', refX);
			refY = new svg.Property('refY', refY);
			if (refX.hasValue() && refY.hasValue()) {
				ctx.translate(-scaleMin * refX.toPixels('x'), -scaleMin * refY.toPixels('y'));
			}
			else {
				// align
				if (align.match(/^xMid/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width / 2.0 - desiredWidth / 2.0, 0);
				if (align.match(/YMid$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height / 2.0 - desiredHeight / 2.0);
				if (align.match(/^xMax/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width - desiredWidth, 0);
				if (align.match(/YMax$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height - desiredHeight);
			}

			// scale
			if (align == 'none') ctx.scale(scaleX, scaleY);
			else if (meetOrSlice == 'meet') ctx.scale(scaleMin, scaleMin);
			else if (meetOrSlice == 'slice') ctx.scale(scaleMax, scaleMax);

			// translate
			ctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY);
		}

		// elements
		svg.Element = {}

		svg.EmptyProperty = new svg.Property('EMPTY', '');

		svg.Element.ElementBase = function(node) {
			this.attributes = {};
			this.styles = {};
			this.stylesSpecificity = {};
			this.children = [];

			// get or create attribute
			this.attribute = function(name, createIfNotExists) {
				var a = this.attributes[name];
				if (a != null) return a;

				if (createIfNotExists == true) { a = new svg.Property(name, ''); this.attributes[name] = a; }
				return a || svg.EmptyProperty;
			}

			this.getHrefAttribute = function() {
				for (var a in this.attributes) {
					if (a == 'href' || a.match(/:href$/)) {
						return this.attributes[a];
					}
				}
				return svg.EmptyProperty;
			}

			// get or create style, crawls up node tree
			this.style = function(name, createIfNotExists, skipAncestors) {
				var s = this.styles[name];
				if (s != null) return s;

				var a = this.attribute(name);
				if (a != null && a.hasValue()) {
					this.styles[name] = a; // move up to me to cache
					return a;
				}

				if (skipAncestors != true) {
					var p = this.parent;
					if (p != null) {
						var ps = p.style(name);
						if (ps != null && ps.hasValue()) {
							return ps;
						}
					}
				}

				if (createIfNotExists == true) { s = new svg.Property(name, ''); this.styles[name] = s; }
				return s || svg.EmptyProperty;
			}

			// base render
			this.render = function(ctx) {
				// don't render display=none
				if (this.style('display').value == 'none') return;

				// don't render visibility=hidden
				if (this.style('visibility').value == 'hidden') return;

				ctx.save();
				if (this.style('mask').hasValue()) { // mask
					var mask = this.style('mask').getDefinition();
					if (mask != null) mask.apply(ctx, this);
				}
				else if (this.style('filter').hasValue()) { // filter
					var filter = this.style('filter').getDefinition();
					if (filter != null) filter.apply(ctx, this);
				}
				else {
					this.setContext(ctx);
					this.renderChildren(ctx);
					this.clearContext(ctx);
				}
				ctx.restore();
			}

			// base set context
			this.setContext = function(ctx) {
				// OVERRIDE ME!
			}

			// base clear context
			this.clearContext = function(ctx) {
				// OVERRIDE ME!
			}

			// base render children
			this.renderChildren = function(ctx) {
				for (var i=0; i<this.children.length; i++) {
					this.children[i].render(ctx);
				}
			}

			this.addChild = function(childNode, create) {
				var child = childNode;
				if (create) child = svg.CreateElement(childNode);
				child.parent = this;
				if (child.type != 'title') { this.children.push(child);	}
			}

			this.addStylesFromStyleDefinition = function () {
				// add styles
				for (var selector in svg.Styles) {
					if (selector[0] != '@' && matchesSelector(node, selector)) {
						var styles = svg.Styles[selector];
						var specificity = svg.StylesSpecificity[selector];
						if (styles != null) {
							for (var name in styles) {
								var existingSpecificity = this.stylesSpecificity[name];
								if (typeof existingSpecificity == 'undefined') {
									existingSpecificity = '000';
								}
								if (specificity > existingSpecificity) {
									this.styles[name] = styles[name];
									this.stylesSpecificity[name] = specificity;
								}
							}
						}
					}
				}
			};
			
			// Microsoft Edge fix
			var allUppercase = new RegExp("^[A-Z\-]+$");
			var normalizeAttributeName = function (name) {
				if (allUppercase.test(name)) {
					return name.toLowerCase();
				}
				return name;
			};

			if (node != null && node.nodeType == 1) { //ELEMENT_NODE
				// add attributes
				for (var i=0; i<node.attributes.length; i++) {
					var attribute = node.attributes[i];
					var nodeName = normalizeAttributeName(attribute.nodeName);
					this.attributes[nodeName] = new svg.Property(nodeName, attribute.value);
				}

				this.addStylesFromStyleDefinition();

				// add inline styles
				if (this.attribute('style').hasValue()) {
					var styles = this.attribute('style').value.split(';');
					for (var i=0; i<styles.length; i++) {
						if (svg.trim(styles[i]) != '') {
							var style = styles[i].split(':');
							var name = svg.trim(style[0]);
							var value = svg.trim(style[1]);
							this.styles[name] = new svg.Property(name, value);
						}
					}
				}

				// add id
				if (this.attribute('id').hasValue()) {
					if (svg.Definitions[this.attribute('id').value] == null) {
						svg.Definitions[this.attribute('id').value] = this;
					}
				}

				// add children
				for (var i=0; i<node.childNodes.length; i++) {
					var childNode = node.childNodes[i];
					if (childNode.nodeType == 1) this.addChild(childNode, true); //ELEMENT_NODE
					if (this.captureTextNodes && (childNode.nodeType == 3 || childNode.nodeType == 4)) {
						var text = childNode.value || childNode.text || childNode.textContent || '';
						if (svg.compressSpaces(text) != '') {
							this.addChild(new svg.Element.tspan(childNode), false); // TEXT_NODE
						}
					}
				}
			}
		}

		svg.Element.RenderedElementBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.setContext = function(ctx) {
				// fill
				if (this.style('fill').isUrlDefinition()) {
					var fs = this.style('fill').getFillStyleDefinition(this, this.style('fill-opacity'));
					if (fs != null) ctx.fillStyle = fs;
				}
				else if (this.style('fill').hasValue()) {
					var fillStyle = this.style('fill');
					if (fillStyle.value == 'currentColor') fillStyle.value = this.style('color').value;
					if (fillStyle.value != 'inherit') ctx.fillStyle = (fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value);
				}
				if (this.style('fill-opacity').hasValue()) {
					var fillStyle = new svg.Property('fill', ctx.fillStyle);
					fillStyle = fillStyle.addOpacity(this.style('fill-opacity'));
					ctx.fillStyle = fillStyle.value;
				}

				// stroke
				if (this.style('stroke').isUrlDefinition()) {
					var fs = this.style('stroke').getFillStyleDefinition(this, this.style('stroke-opacity'));
					if (fs != null) ctx.strokeStyle = fs;
				}
				else if (this.style('stroke').hasValue()) {
					var strokeStyle = this.style('stroke');
					if (strokeStyle.value == 'currentColor') strokeStyle.value = this.style('color').value;
					if (strokeStyle.value != 'inherit') ctx.strokeStyle = (strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value);
				}
				if (this.style('stroke-opacity').hasValue()) {
					var strokeStyle = new svg.Property('stroke', ctx.strokeStyle);
					strokeStyle = strokeStyle.addOpacity(this.style('stroke-opacity'));
					ctx.strokeStyle = strokeStyle.value;
				}
				if (this.style('stroke-width').hasValue()) {
					var newLineWidth = this.style('stroke-width').toPixels();
					ctx.lineWidth = newLineWidth == 0 ? 0.001 : newLineWidth; // browsers don't respect 0
			    }
				if (this.style('stroke-linecap').hasValue()) ctx.lineCap = this.style('stroke-linecap').value;
				if (this.style('stroke-linejoin').hasValue()) ctx.lineJoin = this.style('stroke-linejoin').value;
				if (this.style('stroke-miterlimit').hasValue()) ctx.miterLimit = this.style('stroke-miterlimit').value;
				if (this.style('stroke-dasharray').hasValue() && this.style('stroke-dasharray').value != 'none') {
					var gaps = svg.ToNumberArray(this.style('stroke-dasharray').value);
					if (typeof ctx.setLineDash != 'undefined') { ctx.setLineDash(gaps); }
					else if (typeof ctx.webkitLineDash != 'undefined') { ctx.webkitLineDash = gaps; }
					else if (typeof ctx.mozDash != 'undefined' && !(gaps.length==1 && gaps[0]==0)) { ctx.mozDash = gaps; }

					var offset = this.style('stroke-dashoffset').numValueOrDefault(1);
					if (typeof ctx.lineDashOffset != 'undefined') { ctx.lineDashOffset = offset; }
					else if (typeof ctx.webkitLineDashOffset != 'undefined') { ctx.webkitLineDashOffset = offset; }
					else if (typeof ctx.mozDashOffset != 'undefined') { ctx.mozDashOffset = offset; }
				}

				// font
				if (typeof ctx.font != 'undefined') {
					ctx.font = svg.Font.CreateFont(
						this.style('font-style').value,
						this.style('font-variant').value,
						this.style('font-weight').value,
						this.style('font-size').hasValue() ? this.style('font-size').toPixels() + 'px' : '',
						this.style('font-family').value).toString();
				}

				// transform
				if (this.style('transform', false, true).hasValue()) {
					var transform = new svg.Transform(this.style('transform', false, true).value);
					transform.apply(ctx);
				}

				// clip
				if (this.style('clip-path', false, true).hasValue()) {
					var clip = this.style('clip-path', false, true).getDefinition();
					if (clip != null) clip.apply(ctx);
				}

				// opacity
				if (this.style('opacity').hasValue()) {
					ctx.globalAlpha = this.style('opacity').numValue();
				}
			}
		}
		svg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;

		svg.Element.PathElementBase = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.path = function(ctx) {
				if (ctx != null) ctx.beginPath();
				return new svg.BoundingBox();
			}

			this.renderChildren = function(ctx) {
				this.path(ctx);
				svg.Mouse.checkPath(this, ctx);
				if (ctx.fillStyle != '') {
					if (this.style('fill-rule').valueOrDefault('inherit') != 'inherit') { ctx.fill(this.style('fill-rule').value); }
					else { ctx.fill(); }
				}
				if (ctx.strokeStyle != '') ctx.stroke();

				var markers = this.getMarkers();
				if (markers != null) {
					if (this.style('marker-start').isUrlDefinition()) {
						var marker = this.style('marker-start').getDefinition();
						marker.render(ctx, markers[0][0], markers[0][1]);
					}
					if (this.style('marker-mid').isUrlDefinition()) {
						var marker = this.style('marker-mid').getDefinition();
						for (var i=1;i<markers.length-1;i++) {
							marker.render(ctx, markers[i][0], markers[i][1]);
						}
					}
					if (this.style('marker-end').isUrlDefinition()) {
						var marker = this.style('marker-end').getDefinition();
						marker.render(ctx, markers[markers.length-1][0], markers[markers.length-1][1]);
					}
				}
			}

			this.getBoundingBox = function() {
				return this.path();
			}

			this.getMarkers = function() {
				return null;
			}
		}
		svg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;

		// svg element
		svg.Element.svg = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.baseClearContext = this.clearContext;
			this.clearContext = function(ctx) {
				this.baseClearContext(ctx);
				svg.ViewPort.RemoveCurrent();
			}

			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				// initial values and defaults
				ctx.strokeStyle = 'rgba(0,0,0,0)';
				ctx.lineCap = 'butt';
				ctx.lineJoin = 'miter';
				ctx.miterLimit = 4;
				if (typeof ctx.font != 'undefined' && typeof window.getComputedStyle != 'undefined') {
					ctx.font = window.getComputedStyle(ctx.canvas).getPropertyValue('font');
				}

				this.baseSetContext(ctx);

				// create new view port
				if (!this.attribute('x').hasValue()) this.attribute('x', true).value = 0;
				if (!this.attribute('y').hasValue()) this.attribute('y', true).value = 0;
				ctx.translate(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'));

				var width = svg.ViewPort.width();
				var height = svg.ViewPort.height();

				if (!this.attribute('width').hasValue()) this.attribute('width', true).value = '100%';
				if (!this.attribute('height').hasValue()) this.attribute('height', true).value = '100%';
				if (typeof this.root == 'undefined') {
					width = this.attribute('width').toPixels('x');
					height = this.attribute('height').toPixels('y');

					var x = 0;
					var y = 0;
					if (this.attribute('refX').hasValue() && this.attribute('refY').hasValue()) {
						x = -this.attribute('refX').toPixels('x');
						y = -this.attribute('refY').toPixels('y');
					}

					if (this.attribute('overflow').valueOrDefault('hidden') != 'visible') {
						ctx.beginPath();
						ctx.moveTo(x, y);
						ctx.lineTo(width, y);
						ctx.lineTo(width, height);
						ctx.lineTo(x, height);
						ctx.closePath();
						ctx.clip();
					}
				}
				svg.ViewPort.SetCurrent(width, height);

				// viewbox
				if (this.attribute('viewBox').hasValue()) {
					var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
					var minX = viewBox[0];
					var minY = viewBox[1];
					width = viewBox[2];
					height = viewBox[3];

					svg.AspectRatio(ctx,
									this.attribute('preserveAspectRatio').value,
									svg.ViewPort.width(),
									width,
									svg.ViewPort.height(),
									height,
									minX,
									minY,
									this.attribute('refX').value,
									this.attribute('refY').value);

					svg.ViewPort.RemoveCurrent();
					svg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);
				}
			}
		}
		svg.Element.svg.prototype = new svg.Element.RenderedElementBase;

		// rect element
		svg.Element.rect = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.path = function(ctx) {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				var rx = this.attribute('rx').toPixels('x');
				var ry = this.attribute('ry').toPixels('y');
				if (this.attribute('rx').hasValue() && !this.attribute('ry').hasValue()) ry = rx;
				if (this.attribute('ry').hasValue() && !this.attribute('rx').hasValue()) rx = ry;
				rx = Math.min(rx, width / 2.0);
				ry = Math.min(ry, height / 2.0);
				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(x + rx, y);
					ctx.lineTo(x + width - rx, y);
					ctx.quadraticCurveTo(x + width, y, x + width, y + ry)
					ctx.lineTo(x + width, y + height - ry);
					ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height)
					ctx.lineTo(x + rx, y + height);
					ctx.quadraticCurveTo(x, y + height, x, y + height - ry)
					ctx.lineTo(x, y + ry);
					ctx.quadraticCurveTo(x, y, x + rx, y)
					ctx.closePath();
				}

				return new svg.BoundingBox(x, y, x + width, y + height);
			}
		}
		svg.Element.rect.prototype = new svg.Element.PathElementBase;

		// circle element
		svg.Element.circle = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.path = function(ctx) {
				var cx = this.attribute('cx').toPixels('x');
				var cy = this.attribute('cy').toPixels('y');
				var r = this.attribute('r').toPixels();

				if (ctx != null) {
					ctx.beginPath();
					ctx.arc(cx, cy, r, 0, Math.PI * 2, true);
					ctx.closePath();
				}

				return new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r);
			}
		}
		svg.Element.circle.prototype = new svg.Element.PathElementBase;

		// ellipse element
		svg.Element.ellipse = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.path = function(ctx) {
				var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
				var rx = this.attribute('rx').toPixels('x');
				var ry = this.attribute('ry').toPixels('y');
				var cx = this.attribute('cx').toPixels('x');
				var cy = this.attribute('cy').toPixels('y');

				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(cx, cy - ry);
					ctx.bezierCurveTo(cx + (KAPPA * rx), cy - ry,  cx + rx, cy - (KAPPA * ry), cx + rx, cy);
					ctx.bezierCurveTo(cx + rx, cy + (KAPPA * ry), cx + (KAPPA * rx), cy + ry, cx, cy + ry);
					ctx.bezierCurveTo(cx - (KAPPA * rx), cy + ry, cx - rx, cy + (KAPPA * ry), cx - rx, cy);
					ctx.bezierCurveTo(cx - rx, cy - (KAPPA * ry), cx - (KAPPA * rx), cy - ry, cx, cy - ry);
					ctx.closePath();
				}

				return new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
			}
		}
		svg.Element.ellipse.prototype = new svg.Element.PathElementBase;

		// line element
		svg.Element.line = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.getPoints = function() {
				return [
					new svg.Point(this.attribute('x1').toPixels('x'), this.attribute('y1').toPixels('y')),
					new svg.Point(this.attribute('x2').toPixels('x'), this.attribute('y2').toPixels('y'))];
			}

			this.path = function(ctx) {
				var points = this.getPoints();

				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(points[0].x, points[0].y);
					ctx.lineTo(points[1].x, points[1].y);
				}

				return new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y);
			}

			this.getMarkers = function() {
				var points = this.getPoints();
				var a = points[0].angleTo(points[1]);
				return [[points[0], a], [points[1], a]];
			}
		}
		svg.Element.line.prototype = new svg.Element.PathElementBase;

		// polyline element
		svg.Element.polyline = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.points = svg.CreatePath(this.attribute('points').value);
			this.path = function(ctx) {
				var bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);
				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(this.points[0].x, this.points[0].y);
				}
				for (var i=1; i<this.points.length; i++) {
					bb.addPoint(this.points[i].x, this.points[i].y);
					if (ctx != null) ctx.lineTo(this.points[i].x, this.points[i].y);
				}
				return bb;
			}

			this.getMarkers = function() {
				var markers = [];
				for (var i=0; i<this.points.length - 1; i++) {
					markers.push([this.points[i], this.points[i].angleTo(this.points[i+1])]);
				}
				if (markers.length > 0) {
					markers.push([this.points[this.points.length-1], markers[markers.length-1][1]]);
				}
				return markers;
			}
		}
		svg.Element.polyline.prototype = new svg.Element.PathElementBase;

		// polygon element
		svg.Element.polygon = function(node) {
			this.base = svg.Element.polyline;
			this.base(node);

			this.basePath = this.path;
			this.path = function(ctx) {
				var bb = this.basePath(ctx);
				if (ctx != null) {
					ctx.lineTo(this.points[0].x, this.points[0].y);
					ctx.closePath();
				}
				return bb;
			}
		}
		svg.Element.polygon.prototype = new svg.Element.polyline;

		// path element
		svg.Element.path = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			var d = this.attribute('d').value;
			// TODO: convert to real lexer based on http://www.w3.org/TR/SVG11/paths.html#PathDataBNF
			d = d.replace(/,/gm,' '); // get rid of all commas
			// As the end of a match can also be the start of the next match, we need to run this replace twice.
			for(var i=0; i<2; i++)
				d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm,'$1 $2'); // suffix commands with spaces
			d = d.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // prefix commands with spaces
			d = d.replace(/([0-9])([+\-])/gm,'$1 $2'); // separate digits on +- signs
			// Again, we need to run this twice to find all occurances
			for(var i=0; i<2; i++)
				d = d.replace(/(\.[0-9]*)(\.)/gm,'$1 $2'); // separate digits when they start with a comma
			d = d.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm,'$1 $3 $4 '); // shorthand elliptical arc path syntax
			d = svg.compressSpaces(d); // compress multiple spaces
			d = svg.trim(d);
			this.PathParser = new (function(d) {
				this.tokens = d.split(' ');

				this.reset = function() {
					this.i = -1;
					this.command = '';
					this.previousCommand = '';
					this.start = new svg.Point(0, 0);
					this.control = new svg.Point(0, 0);
					this.current = new svg.Point(0, 0);
					this.points = [];
					this.angles = [];
				}

				this.isEnd = function() {
					return this.i >= this.tokens.length - 1;
				}

				this.isCommandOrEnd = function() {
					if (this.isEnd()) return true;
					return this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;
				}

				this.isRelativeCommand = function() {
					switch(this.command)
					{
						case 'm':
						case 'l':
						case 'h':
						case 'v':
						case 'c':
						case 's':
						case 'q':
						case 't':
						case 'a':
						case 'z':
							return true;
							break;
					}
					return false;
				}

				this.getToken = function() {
					this.i++;
					return this.tokens[this.i];
				}

				this.getScalar = function() {
					return parseFloat(this.getToken());
				}

				this.nextCommand = function() {
					this.previousCommand = this.command;
					this.command = this.getToken();
				}

				this.getPoint = function() {
					var p = new svg.Point(this.getScalar(), this.getScalar());
					return this.makeAbsolute(p);
				}

				this.getAsControlPoint = function() {
					var p = this.getPoint();
					this.control = p;
					return p;
				}

				this.getAsCurrentPoint = function() {
					var p = this.getPoint();
					this.current = p;
					return p;
				}

				this.getReflectedControlPoint = function() {
					if (this.previousCommand.toLowerCase() != 'c' &&
					    this.previousCommand.toLowerCase() != 's' &&
						this.previousCommand.toLowerCase() != 'q' &&
						this.previousCommand.toLowerCase() != 't' ){
						return this.current;
					}

					// reflect point
					var p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);
					return p;
				}

				this.makeAbsolute = function(p) {
					if (this.isRelativeCommand()) {
						p.x += this.current.x;
						p.y += this.current.y;
					}
					return p;
				}

				this.addMarker = function(p, from, priorTo) {
					// if the last angle isn't filled in because we didn't have this point yet ...
					if (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length-1] == null) {
						this.angles[this.angles.length-1] = this.points[this.points.length-1].angleTo(priorTo);
					}
					this.addMarkerAngle(p, from == null ? null : from.angleTo(p));
				}

				this.addMarkerAngle = function(p, a) {
					this.points.push(p);
					this.angles.push(a);
				}

				this.getMarkerPoints = function() { return this.points; }
				this.getMarkerAngles = function() {
					for (var i=0; i<this.angles.length; i++) {
						if (this.angles[i] == null) {
							for (var j=i+1; j<this.angles.length; j++) {
								if (this.angles[j] != null) {
									this.angles[i] = this.angles[j];
									break;
								}
							}
						}
					}
					return this.angles;
				}
			})(d);

			this.path = function(ctx) {
				var pp = this.PathParser;
				pp.reset();

				var bb = new svg.BoundingBox();
				if (ctx != null) ctx.beginPath();
				while (!pp.isEnd()) {
					pp.nextCommand();
					switch (pp.command) {
					case 'M':
					case 'm':
						var p = pp.getAsCurrentPoint();
						pp.addMarker(p);
						bb.addPoint(p.x, p.y);
						if (ctx != null) ctx.moveTo(p.x, p.y);
						pp.start = pp.current;
						while (!pp.isCommandOrEnd()) {
							var p = pp.getAsCurrentPoint();
							pp.addMarker(p, pp.start);
							bb.addPoint(p.x, p.y);
							if (ctx != null) ctx.lineTo(p.x, p.y);
						}
						break;
					case 'L':
					case 'l':
						while (!pp.isCommandOrEnd()) {
							var c = pp.current;
							var p = pp.getAsCurrentPoint();
							pp.addMarker(p, c);
							bb.addPoint(p.x, p.y);
							if (ctx != null) ctx.lineTo(p.x, p.y);
						}
						break;
					case 'H':
					case 'h':
						while (!pp.isCommandOrEnd()) {
							var newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);
							pp.addMarker(newP, pp.current);
							pp.current = newP;
							bb.addPoint(pp.current.x, pp.current.y);
							if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
						}
						break;
					case 'V':
					case 'v':
						while (!pp.isCommandOrEnd()) {
							var newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());
							pp.addMarker(newP, pp.current);
							pp.current = newP;
							bb.addPoint(pp.current.x, pp.current.y);
							if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
						}
						break;
					case 'C':
					case 'c':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var p1 = pp.getPoint();
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, p1);
							bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'S':
					case 's':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var p1 = pp.getReflectedControlPoint();
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, p1);
							bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'Q':
					case 'q':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, cntrl);
							bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'T':
					case 't':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var cntrl = pp.getReflectedControlPoint();
							pp.control = cntrl;
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, cntrl);
							bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'A':
					case 'a':
						while (!pp.isCommandOrEnd()) {
						    var curr = pp.current;
							var rx = pp.getScalar();
							var ry = pp.getScalar();
							var xAxisRotation = pp.getScalar() * (Math.PI / 180.0);
							var largeArcFlag = pp.getScalar();
							var sweepFlag = pp.getScalar();
							var cp = pp.getAsCurrentPoint();

							// Conversion from endpoint to center parameterization
							// http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
							// x1', y1'
							var currp = new svg.Point(
								Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,
								-Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0
							);
							// adjust radii
							var l = Math.pow(currp.x,2)/Math.pow(rx,2)+Math.pow(currp.y,2)/Math.pow(ry,2);
							if (l > 1) {
								rx *= Math.sqrt(l);
								ry *= Math.sqrt(l);
							}
							// cx', cy'
							var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(
								((Math.pow(rx,2)*Math.pow(ry,2))-(Math.pow(rx,2)*Math.pow(currp.y,2))-(Math.pow(ry,2)*Math.pow(currp.x,2))) /
								(Math.pow(rx,2)*Math.pow(currp.y,2)+Math.pow(ry,2)*Math.pow(currp.x,2))
							);
							if (isNaN(s)) s = 0;
							var cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
							// cx, cy
							var centp = new svg.Point(
								(curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,
								(curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y
							);
							// vector magnitude
							var m = function(v) { return Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2)); }
							// ratio between two vectors
							var r = function(u, v) { return (u[0]*v[0]+u[1]*v[1]) / (m(u)*m(v)) }
							// angle between two vectors
							var a = function(u, v) { return (u[0]*v[1] < u[1]*v[0] ? -1 : 1) * Math.acos(r(u,v)); }
							// initial angle
							var a1 = a([1,0], [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry]);
							// angle delta
							var u = [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry];
							var v = [(-currp.x-cpp.x)/rx,(-currp.y-cpp.y)/ry];
							var ad = a(u, v);
							if (r(u,v) <= -1) ad = Math.PI;
							if (r(u,v) >= 1) ad = 0;

							// for markers
							var dir = 1 - sweepFlag ? 1.0 : -1.0;
							var ah = a1 + dir * (ad / 2.0);
							var halfWay = new svg.Point(
								centp.x + rx * Math.cos(ah),
								centp.y + ry * Math.sin(ah)
							);
							pp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
							pp.addMarkerAngle(cp, ah - dir * Math.PI);

							bb.addPoint(cp.x, cp.y); // TODO: this is too naive, make it better
							if (ctx != null) {
								var r = rx > ry ? rx : ry;
								var sx = rx > ry ? 1 : rx / ry;
								var sy = rx > ry ? ry / rx : 1;

								ctx.translate(centp.x, centp.y);
								ctx.rotate(xAxisRotation);
								ctx.scale(sx, sy);
								ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
								ctx.scale(1/sx, 1/sy);
								ctx.rotate(-xAxisRotation);
								ctx.translate(-centp.x, -centp.y);
							}
						}
						break;
					case 'Z':
					case 'z':
						if (ctx != null) ctx.closePath();
						pp.current = pp.start;
					}
				}

				return bb;
			}

			this.getMarkers = function() {
				var points = this.PathParser.getMarkerPoints();
				var angles = this.PathParser.getMarkerAngles();

				var markers = [];
				for (var i=0; i<points.length; i++) {
					markers.push([points[i], angles[i]]);
				}
				return markers;
			}
		}
		svg.Element.path.prototype = new svg.Element.PathElementBase;

		// pattern element
		svg.Element.pattern = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.createPattern = function(ctx, element) {
				var width = this.attribute('width').toPixels('x', true);
				var height = this.attribute('height').toPixels('y', true);

				// render me using a temporary svg element
				var tempSvg = new svg.Element.svg();
				tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
				tempSvg.attributes['width'] = new svg.Property('width', width + 'px');
				tempSvg.attributes['height'] = new svg.Property('height', height + 'px');
				tempSvg.attributes['transform'] = new svg.Property('transform', this.attribute('patternTransform').value);
				tempSvg.children = this.children;

				var c = document.createElement('canvas');
				c.width = width;
				c.height = height;
				var cctx = c.getContext('2d');
				if (this.attribute('x').hasValue() && this.attribute('y').hasValue()) {
					cctx.translate(this.attribute('x').toPixels('x', true), this.attribute('y').toPixels('y', true));
				}
				// render 3x3 grid so when we transform there's no white space on edges
				for (var x=-1; x<=1; x++) {
					for (var y=-1; y<=1; y++) {
						cctx.save();
						tempSvg.attributes['x'] = new svg.Property('x', x * c.width);
						tempSvg.attributes['y'] = new svg.Property('y', y * c.height);
						tempSvg.render(cctx);
						cctx.restore();
					}
				}
				var pattern = ctx.createPattern(c, 'repeat');
				return pattern;
			}
		}
		svg.Element.pattern.prototype = new svg.Element.ElementBase;

		// marker element
		svg.Element.marker = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.baseRender = this.render;
			this.render = function(ctx, point, angle) {
				ctx.translate(point.x, point.y);
				if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(angle);
				if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(ctx.lineWidth, ctx.lineWidth);
				ctx.save();

				// render me using a temporary svg element
				var tempSvg = new svg.Element.svg();
				tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
				tempSvg.attributes['refX'] = new svg.Property('refX', this.attribute('refX').value);
				tempSvg.attributes['refY'] = new svg.Property('refY', this.attribute('refY').value);
				tempSvg.attributes['width'] = new svg.Property('width', this.attribute('markerWidth').value);
				tempSvg.attributes['height'] = new svg.Property('height', this.attribute('markerHeight').value);
				tempSvg.attributes['fill'] = new svg.Property('fill', this.attribute('fill').valueOrDefault('black'));
				tempSvg.attributes['stroke'] = new svg.Property('stroke', this.attribute('stroke').valueOrDefault('none'));
				tempSvg.children = this.children;
				tempSvg.render(ctx);

				ctx.restore();
				if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(1/ctx.lineWidth, 1/ctx.lineWidth);
				if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(-angle);
				ctx.translate(-point.x, -point.y);
			}
		}
		svg.Element.marker.prototype = new svg.Element.ElementBase;

		// definitions element
		svg.Element.defs = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.render = function(ctx) {
				// NOOP
			}
		}
		svg.Element.defs.prototype = new svg.Element.ElementBase;

		// base for gradients
		svg.Element.GradientBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.stops = [];
			for (var i=0; i<this.children.length; i++) {
				var child = this.children[i];
				if (child.type == 'stop') this.stops.push(child);
			}

			this.getGradient = function() {
				// OVERRIDE ME!
			}
			
			this.gradientUnits = function () {
				return this.attribute('gradientUnits').valueOrDefault('objectBoundingBox');
			}
			
			this.attributesToInherit = ['gradientUnits'];
			
			this.inheritStopContainer = function (stopsContainer) {
				for (var i=0; i<this.attributesToInherit.length; i++) {
					var attributeToInherit = this.attributesToInherit[i];
					if (!this.attribute(attributeToInherit).hasValue() && stopsContainer.attribute(attributeToInherit).hasValue()) {
						this.attribute(attributeToInherit, true).value = stopsContainer.attribute(attributeToInherit).value;
					}
				}
			}

			this.createGradient = function(ctx, element, parentOpacityProp) {
				var stopsContainer = this;
				if (this.getHrefAttribute().hasValue()) {
					stopsContainer = this.getHrefAttribute().getDefinition();
					this.inheritStopContainer(stopsContainer);
				}

				var addParentOpacity = function (color) {
					if (parentOpacityProp.hasValue()) {
						var p = new svg.Property('color', color);
						return p.addOpacity(parentOpacityProp).value;
					}
					return color;
				};

				var g = this.getGradient(ctx, element);
				if (g == null) return addParentOpacity(stopsContainer.stops[stopsContainer.stops.length - 1].color);
				for (var i=0; i<stopsContainer.stops.length; i++) {
					g.addColorStop(stopsContainer.stops[i].offset, addParentOpacity(stopsContainer.stops[i].color));
				}

				if (this.attribute('gradientTransform').hasValue()) {
					// render as transformed pattern on temporary canvas
					var rootView = svg.ViewPort.viewPorts[0];

					var rect = new svg.Element.rect();
					rect.attributes['x'] = new svg.Property('x', -svg.MAX_VIRTUAL_PIXELS/3.0);
					rect.attributes['y'] = new svg.Property('y', -svg.MAX_VIRTUAL_PIXELS/3.0);
					rect.attributes['width'] = new svg.Property('width', svg.MAX_VIRTUAL_PIXELS);
					rect.attributes['height'] = new svg.Property('height', svg.MAX_VIRTUAL_PIXELS);

					var group = new svg.Element.g();
					group.attributes['transform'] = new svg.Property('transform', this.attribute('gradientTransform').value);
					group.children = [ rect ];

					var tempSvg = new svg.Element.svg();
					tempSvg.attributes['x'] = new svg.Property('x', 0);
					tempSvg.attributes['y'] = new svg.Property('y', 0);
					tempSvg.attributes['width'] = new svg.Property('width', rootView.width);
					tempSvg.attributes['height'] = new svg.Property('height', rootView.height);
					tempSvg.children = [ group ];

					var c = document.createElement('canvas');
					c.width = rootView.width;
					c.height = rootView.height;
					var tempCtx = c.getContext('2d');
					tempCtx.fillStyle = g;
					tempSvg.render(tempCtx);
					return tempCtx.createPattern(c, 'no-repeat');
				}

				return g;
			}
		}
		svg.Element.GradientBase.prototype = new svg.Element.ElementBase;

		// linear gradient element
		svg.Element.linearGradient = function(node) {
			this.base = svg.Element.GradientBase;
			this.base(node);
			
			this.attributesToInherit.push('x1');
			this.attributesToInherit.push('y1');
			this.attributesToInherit.push('x2');
			this.attributesToInherit.push('y2');

			this.getGradient = function(ctx, element) {
				var bb = this.gradientUnits() == 'objectBoundingBox' ? element.getBoundingBox() : null;

				if (!this.attribute('x1').hasValue()
				 && !this.attribute('y1').hasValue()
				 && !this.attribute('x2').hasValue()
				 && !this.attribute('y2').hasValue()) {
					this.attribute('x1', true).value = 0;
					this.attribute('y1', true).value = 0;
					this.attribute('x2', true).value = 1;
					this.attribute('y2', true).value = 0;
				 }

				var x1 = (this.gradientUnits() == 'objectBoundingBox'
					? bb.x() + bb.width() * this.attribute('x1').numValue()
					: this.attribute('x1').toPixels('x'));
				var y1 = (this.gradientUnits() == 'objectBoundingBox'
					? bb.y() + bb.height() * this.attribute('y1').numValue()
					: this.attribute('y1').toPixels('y'));
				var x2 = (this.gradientUnits() == 'objectBoundingBox'
					? bb.x() + bb.width() * this.attribute('x2').numValue()
					: this.attribute('x2').toPixels('x'));
				var y2 = (this.gradientUnits() == 'objectBoundingBox'
					? bb.y() + bb.height() * this.attribute('y2').numValue()
					: this.attribute('y2').toPixels('y'));

				if (x1 == x2 && y1 == y2) return null;
				return ctx.createLinearGradient(x1, y1, x2, y2);
			}
		}
		svg.Element.linearGradient.prototype = new svg.Element.GradientBase;

		// radial gradient element
		svg.Element.radialGradient = function(node) {
			this.base = svg.Element.GradientBase;
			this.base(node);
			
			this.attributesToInherit.push('cx');
			this.attributesToInherit.push('cy');
			this.attributesToInherit.push('r');
			this.attributesToInherit.push('fx');
			this.attributesToInherit.push('fy');

			this.getGradient = function(ctx, element) {
				var bb = element.getBoundingBox();

				if (!this.attribute('cx').hasValue()) this.attribute('cx', true).value = '50%';
				if (!this.attribute('cy').hasValue()) this.attribute('cy', true).value = '50%';
				if (!this.attribute('r').hasValue()) this.attribute('r', true).value = '50%';

				var cx = (this.gradientUnits() == 'objectBoundingBox'
					? bb.x() + bb.width() * this.attribute('cx').numValue()
					: this.attribute('cx').toPixels('x'));
				var cy = (this.gradientUnits() == 'objectBoundingBox'
					? bb.y() + bb.height() * this.attribute('cy').numValue()
					: this.attribute('cy').toPixels('y'));

				var fx = cx;
				var fy = cy;
				if (this.attribute('fx').hasValue()) {
					fx = (this.gradientUnits() == 'objectBoundingBox'
					? bb.x() + bb.width() * this.attribute('fx').numValue()
					: this.attribute('fx').toPixels('x'));
				}
				if (this.attribute('fy').hasValue()) {
					fy = (this.gradientUnits() == 'objectBoundingBox'
					? bb.y() + bb.height() * this.attribute('fy').numValue()
					: this.attribute('fy').toPixels('y'));
				}

				var r = (this.gradientUnits() == 'objectBoundingBox'
					? (bb.width() + bb.height()) / 2.0 * this.attribute('r').numValue()
					: this.attribute('r').toPixels());

				return ctx.createRadialGradient(fx, fy, 0, cx, cy, r);
			}
		}
		svg.Element.radialGradient.prototype = new svg.Element.GradientBase;

		// gradient stop element
		svg.Element.stop = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.offset = this.attribute('offset').numValue();
			if (this.offset < 0) this.offset = 0;
			if (this.offset > 1) this.offset = 1;

			var stopColor = this.style('stop-color', true);
			if (stopColor.value === '') stopColor.value = '#000';
			if (this.style('stop-opacity').hasValue()) stopColor = stopColor.addOpacity(this.style('stop-opacity'));
			this.color = stopColor.value;
		}
		svg.Element.stop.prototype = new svg.Element.ElementBase;

		// animation base element
		svg.Element.AnimateBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			svg.Animations.push(this);

			this.duration = 0.0;
			this.begin = this.attribute('begin').toMilliseconds();
			this.maxDuration = this.begin + this.attribute('dur').toMilliseconds();

			this.getProperty = function() {
				var attributeType = this.attribute('attributeType').value;
				var attributeName = this.attribute('attributeName').value;

				if (attributeType == 'CSS') {
					return this.parent.style(attributeName, true);
				}
				return this.parent.attribute(attributeName, true);
			};

			this.initialValue = null;
			this.initialUnits = '';
			this.removed = false;

			this.calcValue = function() {
				// OVERRIDE ME!
				return '';
			}

			this.update = function(delta) {
				// set initial value
				if (this.initialValue == null) {
					this.initialValue = this.getProperty().value;
					this.initialUnits = this.getProperty().getUnits();
				}

				// if we're past the end time
				if (this.duration > this.maxDuration) {
					// loop for indefinitely repeating animations
					if (this.attribute('repeatCount').value == 'indefinite'
					 || this.attribute('repeatDur').value == 'indefinite') {
						this.duration = 0.0
					}
					else if (this.attribute('fill').valueOrDefault('remove') == 'freeze' && !this.frozen) {
						this.frozen = true;
						this.parent.animationFrozen = true;
						this.parent.animationFrozenValue = this.getProperty().value;
					}
					else if (this.attribute('fill').valueOrDefault('remove') == 'remove' && !this.removed) {
						this.removed = true;
						this.getProperty().value = this.parent.animationFrozen ? this.parent.animationFrozenValue : this.initialValue;
						return true;
					}
					return false;
				}
				this.duration = this.duration + delta;

				// if we're past the begin time
				var updated = false;
				if (this.begin < this.duration) {
					var newValue = this.calcValue(); // tween

					if (this.attribute('type').hasValue()) {
						// for transform, etc.
						var type = this.attribute('type').value;
						newValue = type + '(' + newValue + ')';
					}

					this.getProperty().value = newValue;
					updated = true;
				}

				return updated;
			}

			this.from = this.attribute('from');
			this.to = this.attribute('to');
			this.values = this.attribute('values');
			if (this.values.hasValue()) this.values.value = this.values.value.split(';');

			// fraction of duration we've covered
			this.progress = function() {
				var ret = { progress: (this.duration - this.begin) / (this.maxDuration - this.begin) };
				if (this.values.hasValue()) {
					var p = ret.progress * (this.values.value.length - 1);
					var lb = Math.floor(p), ub = Math.ceil(p);
					ret.from = new svg.Property('from', parseFloat(this.values.value[lb]));
					ret.to = new svg.Property('to', parseFloat(this.values.value[ub]));
					ret.progress = (p - lb) / (ub - lb);
				}
				else {
					ret.from = this.from;
					ret.to = this.to;
				}
				return ret;
			}
		}
		svg.Element.AnimateBase.prototype = new svg.Element.ElementBase;

		// animate element
		svg.Element.animate = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);

			this.calcValue = function() {
				var p = this.progress();

				// tween value linearly
				var newValue = p.from.numValue() + (p.to.numValue() - p.from.numValue()) * p.progress;
				return newValue + this.initialUnits;
			};
		}
		svg.Element.animate.prototype = new svg.Element.AnimateBase;

		// animate color element
		svg.Element.animateColor = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);

			this.calcValue = function() {
				var p = this.progress();
				var from = new RGBColor(p.from.value);
				var to = new RGBColor(p.to.value);

				if (from.ok && to.ok) {
					// tween color linearly
					var r = from.r + (to.r - from.r) * p.progress;
					var g = from.g + (to.g - from.g) * p.progress;
					var b = from.b + (to.b - from.b) * p.progress;
					return 'rgb('+parseInt(r,10)+','+parseInt(g,10)+','+parseInt(b,10)+')';
				}
				return this.attribute('from').value;
			};
		}
		svg.Element.animateColor.prototype = new svg.Element.AnimateBase;

		// animate transform element
		svg.Element.animateTransform = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);

			this.calcValue = function() {
				var p = this.progress();

				// tween value linearly
				var from = svg.ToNumberArray(p.from.value);
				var to = svg.ToNumberArray(p.to.value);
				var newValue = '';
				for (var i=0; i<from.length; i++) {
					newValue += from[i] + (to[i] - from[i]) * p.progress + ' ';
				}
				return newValue;
			};
		}
		svg.Element.animateTransform.prototype = new svg.Element.animate;

		// font element
		svg.Element.font = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.horizAdvX = this.attribute('horiz-adv-x').numValue();

			this.isRTL = false;
			this.isArabic = false;
			this.fontFace = null;
			this.missingGlyph = null;
			this.glyphs = [];
			for (var i=0; i<this.children.length; i++) {
				var child = this.children[i];
				if (child.type == 'font-face') {
					this.fontFace = child;
					if (child.style('font-family').hasValue()) {
						svg.Definitions[child.style('font-family').value] = this;
					}
				}
				else if (child.type == 'missing-glyph') this.missingGlyph = child;
				else if (child.type == 'glyph') {
					if (child.arabicForm != '') {
						this.isRTL = true;
						this.isArabic = true;
						if (typeof this.glyphs[child.unicode] == 'undefined') this.glyphs[child.unicode] = [];
						this.glyphs[child.unicode][child.arabicForm] = child;
					}
					else {
						this.glyphs[child.unicode] = child;
					}
				}
			}
		}
		svg.Element.font.prototype = new svg.Element.ElementBase;

		// font-face element
		svg.Element.fontface = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.ascent = this.attribute('ascent').value;
			this.descent = this.attribute('descent').value;
			this.unitsPerEm = this.attribute('units-per-em').numValue();
		}
		svg.Element.fontface.prototype = new svg.Element.ElementBase;

		// missing-glyph element
		svg.Element.missingglyph = function(node) {
			this.base = svg.Element.path;
			this.base(node);

			this.horizAdvX = 0;
		}
		svg.Element.missingglyph.prototype = new svg.Element.path;

		// glyph element
		svg.Element.glyph = function(node) {
			this.base = svg.Element.path;
			this.base(node);

			this.horizAdvX = this.attribute('horiz-adv-x').numValue();
			this.unicode = this.attribute('unicode').value;
			this.arabicForm = this.attribute('arabic-form').value;
		}
		svg.Element.glyph.prototype = new svg.Element.path;

		// text element
		svg.Element.text = function(node) {
			this.captureTextNodes = true;
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				this.baseSetContext(ctx);

				var textBaseline = this.style('dominant-baseline').toTextBaseline();
				if (textBaseline == null) textBaseline = this.style('alignment-baseline').toTextBaseline();
				if (textBaseline != null) ctx.textBaseline = textBaseline;
			}

			this.getBoundingBox = function () {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
				return new svg.BoundingBox(x, y - fontSize, x + Math.floor(fontSize * 2.0 / 3.0) * this.children[0].getText().length, y);
			}

			this.renderChildren = function(ctx) {
				this.x = this.attribute('x').toPixels('x');
				this.y = this.attribute('y').toPixels('y');
				if (this.attribute('dx').hasValue()) this.x += this.attribute('dx').toPixels('x');
				if (this.attribute('dy').hasValue()) this.y += this.attribute('dy').toPixels('y');
				this.x += this.getAnchorDelta(ctx, this, 0);
				for (var i=0; i<this.children.length; i++) {
					this.renderChild(ctx, this, this, i);
				}
			}

			this.getAnchorDelta = function (ctx, parent, startI) {
				var textAnchor = this.style('text-anchor').valueOrDefault('start');
				if (textAnchor != 'start') {
					var width = 0;
					for (var i=startI; i<parent.children.length; i++) {
						var child = parent.children[i];
						if (i > startI && child.attribute('x').hasValue()) break; // new group
						width += child.measureTextRecursive(ctx);
					}
					return -1 * (textAnchor == 'end' ? width : width / 2.0);
				}
				return 0;
			}

			this.renderChild = function(ctx, textParent, parent, i) {
				var child = parent.children[i];
				if (child.attribute('x').hasValue()) {
					child.x = child.attribute('x').toPixels('x') + textParent.getAnchorDelta(ctx, parent, i);
					if (child.attribute('dx').hasValue()) child.x += child.attribute('dx').toPixels('x');
				}
				else {
					if (child.attribute('dx').hasValue()) textParent.x += child.attribute('dx').toPixels('x');
					child.x = textParent.x;
				}
				textParent.x = child.x + child.measureText(ctx);

				if (child.attribute('y').hasValue()) {
					child.y = child.attribute('y').toPixels('y');
					if (child.attribute('dy').hasValue()) child.y += child.attribute('dy').toPixels('y');
				}
				else {
					if (child.attribute('dy').hasValue()) textParent.y += child.attribute('dy').toPixels('y');
					child.y = textParent.y;
				}
				textParent.y = child.y;

				child.render(ctx);

				for (var i=0; i<child.children.length; i++) {
					textParent.renderChild(ctx, textParent, child, i);
				}
			}
		}
		svg.Element.text.prototype = new svg.Element.RenderedElementBase;

		// text base
		svg.Element.TextElementBase = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.getGlyph = function(font, text, i) {
				var c = text[i];
				var glyph = null;
				if (font.isArabic) {
					var arabicForm = 'isolated';
					if ((i==0 || text[i-1]==' ') && i<text.length-2 && text[i+1]!=' ') arabicForm = 'terminal';
					if (i>0 && text[i-1]!=' ' && i<text.length-2 && text[i+1]!=' ') arabicForm = 'medial';
					if (i>0 && text[i-1]!=' ' && (i == text.length-1 || text[i+1]==' ')) arabicForm = 'initial';
					if (typeof font.glyphs[c] != 'undefined') {
						glyph = font.glyphs[c][arabicForm];
						if (glyph == null && font.glyphs[c].type == 'glyph') glyph = font.glyphs[c];
					}
				}
				else {
					glyph = font.glyphs[c];
				}
				if (glyph == null) glyph = font.missingGlyph;
				return glyph;
			}

			this.renderChildren = function(ctx) {
				var customFont = this.parent.style('font-family').getDefinition();
				if (customFont != null) {
					var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
					var fontStyle = this.parent.style('font-style').valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);
					var text = this.getText();
					if (customFont.isRTL) text = text.split("").reverse().join("");

					var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
					for (var i=0; i<text.length; i++) {
						var glyph = this.getGlyph(customFont, text, i);
						var scale = fontSize / customFont.fontFace.unitsPerEm;
						ctx.translate(this.x, this.y);
						ctx.scale(scale, -scale);
						var lw = ctx.lineWidth;
						ctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;
						if (fontStyle == 'italic') ctx.transform(1, 0, .4, 1, 0, 0);
						glyph.render(ctx);
						if (fontStyle == 'italic') ctx.transform(1, 0, -.4, 1, 0, 0);
						ctx.lineWidth = lw;
						ctx.scale(1/scale, -1/scale);
						ctx.translate(-this.x, -this.y);

						this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;
						if (typeof dx[i] != 'undefined' && !isNaN(dx[i])) {
							this.x += dx[i];
						}
					}
					return;
				}

				if (ctx.fillStyle != '') ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y);
				if (ctx.strokeStyle != '') ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);
			}

			this.getText = function() {
				// OVERRIDE ME
			}

			this.measureTextRecursive = function(ctx) {
				var width = this.measureText(ctx);
				for (var i=0; i<this.children.length; i++) {
					width += this.children[i].measureTextRecursive(ctx);
				}
				return width;
			}

			this.measureText = function(ctx) {
				var customFont = this.parent.style('font-family').getDefinition();
				if (customFont != null) {
					var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
					var measure = 0;
					var text = this.getText();
					if (customFont.isRTL) text = text.split("").reverse().join("");
					var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
					for (var i=0; i<text.length; i++) {
						var glyph = this.getGlyph(customFont, text, i);
						measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
						if (typeof dx[i] != 'undefined' && !isNaN(dx[i])) {
							measure += dx[i];
						}
					}
					return measure;
				}

				var textToMeasure = svg.compressSpaces(this.getText());
				if (!ctx.measureText) return textToMeasure.length * 10;

				ctx.save();
				this.setContext(ctx);
				var width = ctx.measureText(textToMeasure).width;
				ctx.restore();
				return width;
			}
		}
		svg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;

		// tspan
		svg.Element.tspan = function(node) {
			this.captureTextNodes = true;
			this.base = svg.Element.TextElementBase;
			this.base(node);

			this.text = svg.compressSpaces(node.value || node.text || node.textContent || '');
			this.getText = function() {
				// if this node has children, then they own the text
				if (this.children.length > 0) { return ''; }
				return this.text;
			}
		}
		svg.Element.tspan.prototype = new svg.Element.TextElementBase;

		// tref
		svg.Element.tref = function(node) {
			this.base = svg.Element.TextElementBase;
			this.base(node);

			this.getText = function() {
				var element = this.getHrefAttribute().getDefinition();
				if (element != null) return element.children[0].getText();
			}
		}
		svg.Element.tref.prototype = new svg.Element.TextElementBase;

		// a element
		svg.Element.a = function(node) {
			this.base = svg.Element.TextElementBase;
			this.base(node);

			this.hasText = node.childNodes.length > 0;
			for (var i=0; i<node.childNodes.length; i++) {
				if (node.childNodes[i].nodeType != 3) this.hasText = false;
			}

			// this might contain text
			this.text = this.hasText ? node.childNodes[0].value : '';
			this.getText = function() {
				return this.text;
			}

			this.baseRenderChildren = this.renderChildren;
			this.renderChildren = function(ctx) {
				if (this.hasText) {
					// render as text element
					this.baseRenderChildren(ctx);
					var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
					svg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.toPixels('y'), this.x + this.measureText(ctx), this.y));
				}
				else if (this.children.length > 0) {
					// render as temporary group
					var g = new svg.Element.g();
					g.children = this.children;
					g.parent = this;
					g.render(ctx);
				}
			}

			this.onclick = function() {
				window.open(this.getHrefAttribute().value);
			}

			this.onmousemove = function() {
				svg.ctx.canvas.style.cursor = 'pointer';
			}
		}
		svg.Element.a.prototype = new svg.Element.TextElementBase;

		// image element
		svg.Element.image = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			var href = this.getHrefAttribute().value;
			if (href == '') { return; }
			var isSvg = href.match(/\.svg$/)

			svg.Images.push(this);
			this.loaded = false;
			if (!isSvg) {
				this.img = document.createElement('img');
				if (svg.opts['useCORS'] == true) { this.img.crossOrigin = 'Anonymous'; }
				var self = this;
				this.img.onload = function() { self.loaded = true; }
				this.img.onerror = function() { svg.log('ERROR: image "' + href + '" not found'); self.loaded = true; }
				this.img.src = href;
			}
			else {
				this.img = svg.ajax(href);
				this.loaded = true;
			}

			this.renderChildren = function(ctx) {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');

				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				if (width == 0 || height == 0) return;

				ctx.save();
				if (isSvg) {
					ctx.drawSvg(this.img, x, y, width, height);
				}
				else {
					ctx.translate(x, y);
					svg.AspectRatio(ctx,
									this.attribute('preserveAspectRatio').value,
									width,
									this.img.width,
									height,
									this.img.height,
									0,
									0);
					ctx.drawImage(this.img, 0, 0);
				}
				ctx.restore();
			}

			this.getBoundingBox = function() {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				return new svg.BoundingBox(x, y, x + width, y + height);
			}
		}
		svg.Element.image.prototype = new svg.Element.RenderedElementBase;

		// group element
		svg.Element.g = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.getBoundingBox = function() {
				var bb = new svg.BoundingBox();
				for (var i=0; i<this.children.length; i++) {
					bb.addBoundingBox(this.children[i].getBoundingBox());
				}
				return bb;
			};
		}
		svg.Element.g.prototype = new svg.Element.RenderedElementBase;

		// symbol element
		svg.Element.symbol = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.render = function(ctx) {
				// NO RENDER
			};
		}
		svg.Element.symbol.prototype = new svg.Element.RenderedElementBase;

		// style element
		svg.Element.style = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			// text, or spaces then CDATA
			var css = ''
			for (var i=0; i<node.childNodes.length; i++) {
			  css += node.childNodes[i].data;
			}
			css = css.replace(/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, ''); // remove comments
			css = svg.compressSpaces(css); // replace whitespace
			var cssDefs = css.split('}');
			for (var i=0; i<cssDefs.length; i++) {
				if (svg.trim(cssDefs[i]) != '') {
					var cssDef = cssDefs[i].split('{');
					var cssClasses = cssDef[0].split(',');
					var cssProps = cssDef[1].split(';');
					for (var j=0; j<cssClasses.length; j++) {
						var cssClass = svg.trim(cssClasses[j]);
						if (cssClass != '') {
							var props = svg.Styles[cssClass] || {};
							for (var k=0; k<cssProps.length; k++) {
								var prop = cssProps[k].indexOf(':');
								var name = cssProps[k].substr(0, prop);
								var value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);
								if (name != null && value != null) {
									props[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value));
								}
							}
							svg.Styles[cssClass] = props;
							svg.StylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);
							if (cssClass == '@font-face') {
								var fontFamily = props['font-family'].value.replace(/"/g,'');
								var srcs = props['src'].value.split(',');
								for (var s=0; s<srcs.length; s++) {
									if (srcs[s].indexOf('format("svg")') > 0) {
										var urlStart = srcs[s].indexOf('url');
										var urlEnd = srcs[s].indexOf(')', urlStart);
										var url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);
										var doc = svg.parseXml(svg.ajax(url));
										var fonts = doc.getElementsByTagName('font');
										for (var f=0; f<fonts.length; f++) {
											var font = svg.CreateElement(fonts[f]);
											svg.Definitions[fontFamily] = font;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		svg.Element.style.prototype = new svg.Element.ElementBase;

		// use element
		svg.Element.use = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				this.baseSetContext(ctx);
				if (this.attribute('x').hasValue()) ctx.translate(this.attribute('x').toPixels('x'), 0);
				if (this.attribute('y').hasValue()) ctx.translate(0, this.attribute('y').toPixels('y'));
			}

			var element = this.getHrefAttribute().getDefinition();

			this.path = function(ctx) {
				if (element != null) element.path(ctx);
			}

			this.getBoundingBox = function() {
				if (element != null) return element.getBoundingBox();
			}

			this.renderChildren = function(ctx) {
				if (element != null) {
					var tempSvg = element;
					if (element.type == 'symbol') {
						// render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)
						tempSvg = new svg.Element.svg();
						tempSvg.type = 'svg';
						tempSvg.attributes['viewBox'] = new svg.Property('viewBox', element.attribute('viewBox').value);
						tempSvg.attributes['preserveAspectRatio'] = new svg.Property('preserveAspectRatio', element.attribute('preserveAspectRatio').value);
						tempSvg.attributes['overflow'] = new svg.Property('overflow', element.attribute('overflow').value);
						tempSvg.children = element.children;
					}
					if (tempSvg.type == 'svg') {
						// if symbol or svg, inherit width/height from me
						if (this.attribute('width').hasValue()) tempSvg.attributes['width'] = new svg.Property('width', this.attribute('width').value);
						if (this.attribute('height').hasValue()) tempSvg.attributes['height'] = new svg.Property('height', this.attribute('height').value);
					}
					var oldParent = tempSvg.parent;
					tempSvg.parent = null;
					tempSvg.render(ctx);
					tempSvg.parent = oldParent;
				}
			}
		}
		svg.Element.use.prototype = new svg.Element.RenderedElementBase;

		// mask element
		svg.Element.mask = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx, element) {
				// render as temp svg
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');

				if (width == 0 && height == 0) {
					var bb = new svg.BoundingBox();
					for (var i=0; i<this.children.length; i++) {
						bb.addBoundingBox(this.children[i].getBoundingBox());
					}
					var x = Math.floor(bb.x1);
					var y = Math.floor(bb.y1);
					var width = Math.floor(bb.width());
					var	height = Math.floor(bb.height());
				}

				// temporarily remove mask to avoid recursion
				var mask = element.attribute('mask').value;
				element.attribute('mask').value = '';

					var cMask = document.createElement('canvas');
					cMask.width = x + width;
					cMask.height = y + height;
					var maskCtx = cMask.getContext('2d');
					this.renderChildren(maskCtx);

					var c = document.createElement('canvas');
					c.width = x + width;
					c.height = y + height;
					var tempCtx = c.getContext('2d');
					element.render(tempCtx);
					tempCtx.globalCompositeOperation = 'destination-in';
					tempCtx.fillStyle = maskCtx.createPattern(cMask, 'no-repeat');
					tempCtx.fillRect(0, 0, x + width, y + height);

					ctx.fillStyle = tempCtx.createPattern(c, 'no-repeat');
					ctx.fillRect(0, 0, x + width, y + height);

				// reassign mask
				element.attribute('mask').value = mask;
			}

			this.render = function(ctx) {
				// NO RENDER
			}
		}
		svg.Element.mask.prototype = new svg.Element.ElementBase;

		// clip element
		svg.Element.clipPath = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx) {
				var oldBeginPath = CanvasRenderingContext2D.prototype.beginPath;
				CanvasRenderingContext2D.prototype.beginPath = function () { };

				var oldClosePath = CanvasRenderingContext2D.prototype.closePath;
				CanvasRenderingContext2D.prototype.closePath = function () { };

				oldBeginPath.call(ctx);
				for (var i=0; i<this.children.length; i++) {
					var child = this.children[i];
					if (typeof child.path != 'undefined') {
						var transform = null;
						if (child.style('transform', false, true).hasValue()) {
							transform = new svg.Transform(child.style('transform', false, true).value);
							transform.apply(ctx);
						}
						child.path(ctx);
						CanvasRenderingContext2D.prototype.closePath = oldClosePath;
						if (transform) { transform.unapply(ctx); }
					}
				}
				oldClosePath.call(ctx);
				ctx.clip();

				CanvasRenderingContext2D.prototype.beginPath = oldBeginPath;
				CanvasRenderingContext2D.prototype.closePath = oldClosePath;
			}

			this.render = function(ctx) {
				// NO RENDER
			}
		}
		svg.Element.clipPath.prototype = new svg.Element.ElementBase;

		// filters
		svg.Element.filter = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx, element) {
				// render as temp svg
				var bb = element.getBoundingBox();
				var x = Math.floor(bb.x1);
				var y = Math.floor(bb.y1);
				var width = Math.floor(bb.width());
				var	height = Math.floor(bb.height());

				// temporarily remove filter to avoid recursion
				var filter = element.style('filter').value;
				element.style('filter').value = '';

				var px = 0, py = 0;
				for (var i=0; i<this.children.length; i++) {
					var efd = this.children[i].extraFilterDistance || 0;
					px = Math.max(px, efd);
					py = Math.max(py, efd);
				}

				var c = document.createElement('canvas');
				c.width = width + 2*px;
				c.height = height + 2*py;
				var tempCtx = c.getContext('2d');
				tempCtx.translate(-x + px, -y + py);
				element.render(tempCtx);

				// apply filters
				for (var i=0; i<this.children.length; i++) {
					if (typeof this.children[i].apply == 'function') {
						this.children[i].apply(tempCtx, 0, 0, width + 2*px, height + 2*py);
					}
				}

				// render on me
				ctx.drawImage(c, 0, 0, width + 2*px, height + 2*py, x - px, y - py, width + 2*px, height + 2*py);

				// reassign filter
				element.style('filter', true).value = filter;
			}

			this.render = function(ctx) {
				// NO RENDER
			}
		}
		svg.Element.filter.prototype = new svg.Element.ElementBase;

		svg.Element.feMorphology = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx, x, y, width, height) {
				// TODO: implement
			}
		}
		svg.Element.feMorphology.prototype = new svg.Element.ElementBase;

		svg.Element.feComposite = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx, x, y, width, height) {
				// TODO: implement
			}
		}
		svg.Element.feComposite.prototype = new svg.Element.ElementBase;

		svg.Element.feColorMatrix = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			var matrix = svg.ToNumberArray(this.attribute('values').value);
			switch (this.attribute('type').valueOrDefault('matrix')) { // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement
				case 'saturate':
					var s = matrix[0];
					matrix = [0.213+0.787*s,0.715-0.715*s,0.072-0.072*s,0,0,
							  0.213-0.213*s,0.715+0.285*s,0.072-0.072*s,0,0,
							  0.213-0.213*s,0.715-0.715*s,0.072+0.928*s,0,0,
							  0,0,0,1,0,
							  0,0,0,0,1];
					break;
				case 'hueRotate':
					var a = matrix[0] * Math.PI / 180.0;
					var c = function (m1,m2,m3) { return m1 + Math.cos(a)*m2 + Math.sin(a)*m3; };
					matrix = [c(0.213,0.787,-0.213),c(0.715,-0.715,-0.715),c(0.072,-0.072,0.928),0,0,
							  c(0.213,-0.213,0.143),c(0.715,0.285,0.140),c(0.072,-0.072,-0.283),0,0,
							  c(0.213,-0.213,-0.787),c(0.715,-0.715,0.715),c(0.072,0.928,0.072),0,0,
							  0,0,0,1,0,
							  0,0,0,0,1];
					break;
				case 'luminanceToAlpha':
					matrix = [0,0,0,0,0,
							  0,0,0,0,0,
							  0,0,0,0,0,
							  0.2125,0.7154,0.0721,0,0,
							  0,0,0,0,1];
					break;
			}

			function imGet(img, x, y, width, height, rgba) {
				return img[y*width*4 + x*4 + rgba];
			}

			function imSet(img, x, y, width, height, rgba, val) {
				img[y*width*4 + x*4 + rgba] = val;
			}

			function m(i, v) {
				var mi = matrix[i];
				return mi * (mi < 0 ? v - 255 : v);
			}

			this.apply = function(ctx, x, y, width, height) {
				// assuming x==0 && y==0 for now
				var srcData = ctx.getImageData(0, 0, width, height);
				for (var y = 0; y < height; y++) {
					for (var x = 0; x < width; x++) {
						var r = imGet(srcData.data, x, y, width, height, 0);
						var g = imGet(srcData.data, x, y, width, height, 1);
						var b = imGet(srcData.data, x, y, width, height, 2);
						var a = imGet(srcData.data, x, y, width, height, 3);
						imSet(srcData.data, x, y, width, height, 0, m(0,r)+m(1,g)+m(2,b)+m(3,a)+m(4,1));
						imSet(srcData.data, x, y, width, height, 1, m(5,r)+m(6,g)+m(7,b)+m(8,a)+m(9,1));
						imSet(srcData.data, x, y, width, height, 2, m(10,r)+m(11,g)+m(12,b)+m(13,a)+m(14,1));
						imSet(srcData.data, x, y, width, height, 3, m(15,r)+m(16,g)+m(17,b)+m(18,a)+m(19,1));
					}
				}
				ctx.clearRect(0, 0, width, height);
				ctx.putImageData(srcData, 0, 0);
			}
		}
		svg.Element.feColorMatrix.prototype = new svg.Element.ElementBase;

		svg.Element.feGaussianBlur = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.blurRadius = Math.floor(this.attribute('stdDeviation').numValue());
			this.extraFilterDistance = this.blurRadius;

			this.apply = function(ctx, x, y, width, height) {
				if (typeof stackBlur.canvasRGBA == 'undefined') {
					svg.log('ERROR: StackBlur.js must be included for blur to work');
					return;
				}

				// StackBlur requires canvas be on document
				ctx.canvas.id = svg.UniqueId();
				ctx.canvas.style.display = 'none';
				document.body.appendChild(ctx.canvas);
				stackBlur.canvasRGBA(ctx.canvas.id, x, y, width, height, this.blurRadius);
				document.body.removeChild(ctx.canvas);
			}
		}
		svg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase;

		// title element, do nothing
		svg.Element.title = function(node) {
		}
		svg.Element.title.prototype = new svg.Element.ElementBase;

		// desc element, do nothing
		svg.Element.desc = function(node) {
		}
		svg.Element.desc.prototype = new svg.Element.ElementBase;

		svg.Element.MISSING = function(node) {
			svg.log('ERROR: Element \'' + node.nodeName + '\' not yet implemented.');
		}
		svg.Element.MISSING.prototype = new svg.Element.ElementBase;

		// element factory
		svg.CreateElement = function(node) {
			var className = node.nodeName.replace(/^[^:]+:/,''); // remove namespace
			className = className.replace(/\-/g,''); // remove dashes
			var e = null;
			if (typeof svg.Element[className] != 'undefined') {
				e = new svg.Element[className](node);
			}
			else {
				e = new svg.Element.MISSING(node);
			}

			e.type = node.nodeName;
			return e;
		}

		// load from url
		svg.load = function(ctx, url) {
			svg.loadXml(ctx, svg.ajax(url));
		}

		// load from xml
		svg.loadXml = function(ctx, xml) {
			svg.loadXmlDoc(ctx, svg.parseXml(xml));
		}

		svg.loadXmlDoc = function(ctx, dom) {
			svg.init(ctx);

			var mapXY = function(p) {
				var e = ctx.canvas;
				while (e) {
					p.x -= e.offsetLeft;
					p.y -= e.offsetTop;
					e = e.offsetParent;
				}
				if (window.scrollX) p.x += window.scrollX;
				if (window.scrollY) p.y += window.scrollY;
				return p;
			}

			// bind mouse
			if (svg.opts['ignoreMouse'] != true) {
				ctx.canvas.onclick = function(e) {
					var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
					svg.Mouse.onclick(p.x, p.y);
				};
				ctx.canvas.onmousemove = function(e) {
					var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
					svg.Mouse.onmousemove(p.x, p.y);
				};
			}

			var e = svg.CreateElement(dom.documentElement);
			e.root = true;
			e.addStylesFromStyleDefinition();

			// render loop
			var isFirstRender = true;
			var draw = function() {
				svg.ViewPort.Clear();
				if (ctx.canvas.parentNode) svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight);

				if (svg.opts['ignoreDimensions'] != true) {
					// set canvas size
					if (e.style('width').hasValue()) {
						ctx.canvas.width = e.style('width').toPixels('x');
						ctx.canvas.style.width = ctx.canvas.width + 'px';
					}
					if (e.style('height').hasValue()) {
						ctx.canvas.height = e.style('height').toPixels('y');
						ctx.canvas.style.height = ctx.canvas.height + 'px';
					}
				}
				var cWidth = ctx.canvas.clientWidth || ctx.canvas.width;
				var cHeight = ctx.canvas.clientHeight || ctx.canvas.height;
				if (svg.opts['ignoreDimensions'] == true && e.style('width').hasValue() && e.style('height').hasValue()) {
					cWidth = e.style('width').toPixels('x');
					cHeight = e.style('height').toPixels('y');
				}
				svg.ViewPort.SetCurrent(cWidth, cHeight);

				if (svg.opts['offsetX'] != null) e.attribute('x', true).value = svg.opts['offsetX'];
				if (svg.opts['offsetY'] != null) e.attribute('y', true).value = svg.opts['offsetY'];
				if (svg.opts['scaleWidth'] != null || svg.opts['scaleHeight'] != null) {
					var xRatio = null, yRatio = null, viewBox = svg.ToNumberArray(e.attribute('viewBox').value);

					if (svg.opts['scaleWidth'] != null) {
						if (e.attribute('width').hasValue()) xRatio = e.attribute('width').toPixels('x') / svg.opts['scaleWidth'];
						else if (!isNaN(viewBox[2])) xRatio = viewBox[2] / svg.opts['scaleWidth'];
					}

					if (svg.opts['scaleHeight'] != null) {
						if (e.attribute('height').hasValue()) yRatio = e.attribute('height').toPixels('y') / svg.opts['scaleHeight'];
						else if (!isNaN(viewBox[3])) yRatio = viewBox[3] / svg.opts['scaleHeight'];
					}

					if (xRatio == null) { xRatio = yRatio; }
					if (yRatio == null) { yRatio = xRatio; }

					e.attribute('width', true).value = svg.opts['scaleWidth'];
					e.attribute('height', true).value = svg.opts['scaleHeight'];
					e.style('transform', true, true).value += ' scale('+(1.0/xRatio)+','+(1.0/yRatio)+')';
				}

				// clear and render
				if (svg.opts['ignoreClear'] != true) {
					ctx.clearRect(0, 0, cWidth, cHeight);
				}
				e.render(ctx);
				if (isFirstRender) {
					isFirstRender = false;
					if (typeof svg.opts['renderCallback'] == 'function') svg.opts['renderCallback'](dom);
				}
			}

			var waitingForImages = true;
			if (svg.ImagesLoaded()) {
				waitingForImages = false;
				draw();
			}
			svg.intervalID = setInterval(function() {
				var needUpdate = false;

				if (waitingForImages && svg.ImagesLoaded()) {
					waitingForImages = false;
					needUpdate = true;
				}

				// need update from mouse events?
				if (svg.opts['ignoreMouse'] != true) {
					needUpdate = needUpdate | svg.Mouse.hasEvents();
				}

				// need update from animations?
				if (svg.opts['ignoreAnimation'] != true) {
					for (var i=0; i<svg.Animations.length; i++) {
						needUpdate = needUpdate | svg.Animations[i].update(1000 / svg.FRAMERATE);
					}
				}

				// need update from redraw?
				if (typeof svg.opts['forceRedraw'] == 'function') {
					if (svg.opts['forceRedraw']() == true) needUpdate = true;
				}

				// render if needed
				if (needUpdate) {
					draw();
					svg.Mouse.runEvents(); // run and clear our events
				}
			}, 1000 / svg.FRAMERATE);
		}

		svg.stop = function() {
			if (svg.intervalID) {
				clearInterval(svg.intervalID);
			}
		}

		svg.Mouse = new (function() {
			this.events = [];
			this.hasEvents = function() { return this.events.length != 0; }

			this.onclick = function(x, y) {
				this.events.push({ type: 'onclick', x: x, y: y,
					run: function(e) { if (e.onclick) e.onclick(); }
				});
			}

			this.onmousemove = function(x, y) {
				this.events.push({ type: 'onmousemove', x: x, y: y,
					run: function(e) { if (e.onmousemove) e.onmousemove(); }
				});
			}

			this.eventElements = [];

			this.checkPath = function(element, ctx) {
				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					if (ctx.isPointInPath && ctx.isPointInPath(e.x, e.y)) this.eventElements[i] = element;
				}
			}

			this.checkBoundingBox = function(element, bb) {
				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					if (bb.isPointInBox(e.x, e.y)) this.eventElements[i] = element;
				}
			}

			this.runEvents = function() {
				svg.ctx.canvas.style.cursor = '';

				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					var element = this.eventElements[i];
					while (element) {
						e.run(element);
						element = element.parent;
					}
				}

				// done running, clear
				this.events = [];
				this.eventElements = [];
			}
		});

		return svg;
	};

	if (typeof CanvasRenderingContext2D  != 'undefined') {
		CanvasRenderingContext2D.prototype.drawSvg = function(s, dx, dy, dw, dh, opts) {
			var cOpts = {
				ignoreMouse: true,
				ignoreAnimation: true,
				ignoreDimensions: true,
				ignoreClear: true,
				offsetX: dx,
				offsetY: dy,
				scaleWidth: dw,
				scaleHeight: dh
			}
			
			for(var prop in opts) {
				if(opts.hasOwnProperty(prop)){
					cOpts[prop] = opts[prop];
				}
			}
			canvg(this.canvas, s, cOpts);
		}
	}

	return canvg;

}));

},{"rgbcolor":"/home/ubuntu/staging/apps/node_modules/rgbcolor/index.js","stackblur":"/home/ubuntu/staging/apps/node_modules/stackblur/index.js"}],"/home/ubuntu/staging/apps/node_modules/stackblur/index.js":[function(require,module,exports){
/*

StackBlur - a fast almost Gaussian Blur For Canvas

Version: 	0.5
Author:		Mario Klingemann
Contact: 	mario@quasimondo.com
Website:	http://www.quasimondo.com/StackBlurForCanvas
Twitter:	@quasimondo

In case you find this class useful - especially in commercial projects -
I am not totally unhappy for a small donation to my PayPal account
mario@quasimondo.de

Or support me on flattr: 
https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

Copyright (c) 2010 Mario Klingemann

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

var mul_table = [
        512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
        454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
        482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
        437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
        497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
        320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
        446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
        329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
        505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
        399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
        324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
        268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
        451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
        385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
        332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
        289,287,285,282,280,278,275,273,271,269,267,265,263,261,259];
        
   
var shg_table = [
	     9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 
		17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 
		19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
		23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 ];

function blur( pixels, width, height, radius )
{
	if ( isNaN(radius) || radius < 1 ) return;
	radius |= 0;

	var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, 
	r_out_sum, g_out_sum, b_out_sum, a_out_sum,
	r_in_sum, g_in_sum, b_in_sum, a_in_sum, 
	pr, pg, pb, pa, rbs;
			
	var div = radius + radius + 1;
	var w4 = width << 2;
	var widthMinus1  = width - 1;
	var heightMinus1 = height - 1;
	var radiusPlus1  = radius + 1;
	var sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2;
	
	var stackStart = new BlurStack();
	var stack = stackStart;
	for ( i = 1; i < div; i++ )
	{
		stack = stack.next = new BlurStack();
		if ( i == radiusPlus1 ) var stackEnd = stack;
	}
	stack.next = stackStart;
	var stackIn = null;
	var stackOut = null;
	
	yw = yi = 0;
	
	var mul_sum = mul_table[radius];
	var shg_sum = shg_table[radius];
	
	for ( y = 0; y < height; y++ )
	{
		r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
		
		r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
		g_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );
		b_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );
		a_out_sum = radiusPlus1 * ( pa = pixels[yi+3] );
		
		r_sum += sumFactor * pr;
		g_sum += sumFactor * pg;
		b_sum += sumFactor * pb;
		a_sum += sumFactor * pa;
		
		stack = stackStart;
		
		for( i = 0; i < radiusPlus1; i++ )
		{
			stack.r = pr;
			stack.g = pg;
			stack.b = pb;
			stack.a = pa;
			stack = stack.next;
		}
		
		for( i = 1; i < radiusPlus1; i++ )
		{
			p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
			r_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );
			g_sum += ( stack.g = ( pg = pixels[p+1])) * rbs;
			b_sum += ( stack.b = ( pb = pixels[p+2])) * rbs;
			a_sum += ( stack.a = ( pa = pixels[p+3])) * rbs;
			
			r_in_sum += pr;
			g_in_sum += pg;
			b_in_sum += pb;
			a_in_sum += pa;
			
			stack = stack.next;
		}
		
		
		stackIn = stackStart;
		stackOut = stackEnd;
		for ( x = 0; x < width; x++ )
		{
			pixels[yi+3] = pa = (a_sum * mul_sum) >> shg_sum;
			if ( pa != 0 )
			{
				pa = 255 / pa;
				pixels[yi]   = ((r_sum * mul_sum) >> shg_sum) * pa;
				pixels[yi+1] = ((g_sum * mul_sum) >> shg_sum) * pa;
				pixels[yi+2] = ((b_sum * mul_sum) >> shg_sum) * pa;
			} else {
				pixels[yi] = pixels[yi+1] = pixels[yi+2] = 0;
			}
			
			r_sum -= r_out_sum;
			g_sum -= g_out_sum;
			b_sum -= b_out_sum;
			a_sum -= a_out_sum;
			
			r_out_sum -= stackIn.r;
			g_out_sum -= stackIn.g;
			b_out_sum -= stackIn.b;
			a_out_sum -= stackIn.a;
			
			p =  ( yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;
			
			r_in_sum += ( stackIn.r = pixels[p]);
			g_in_sum += ( stackIn.g = pixels[p+1]);
			b_in_sum += ( stackIn.b = pixels[p+2]);
			a_in_sum += ( stackIn.a = pixels[p+3]);
			
			r_sum += r_in_sum;
			g_sum += g_in_sum;
			b_sum += b_in_sum;
			a_sum += a_in_sum;
			
			stackIn = stackIn.next;
			
			r_out_sum += ( pr = stackOut.r );
			g_out_sum += ( pg = stackOut.g );
			b_out_sum += ( pb = stackOut.b );
			a_out_sum += ( pa = stackOut.a );
			
			r_in_sum -= pr;
			g_in_sum -= pg;
			b_in_sum -= pb;
			a_in_sum -= pa;
			
			stackOut = stackOut.next;

			yi += 4;
		}
		yw += width;
	}

	
	for ( x = 0; x < width; x++ )
	{
		g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
		
		yi = x << 2;
		r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
		g_out_sum = radiusPlus1 * ( pg = pixels[yi+1]);
		b_out_sum = radiusPlus1 * ( pb = pixels[yi+2]);
		a_out_sum = radiusPlus1 * ( pa = pixels[yi+3]);
		
		r_sum += sumFactor * pr;
		g_sum += sumFactor * pg;
		b_sum += sumFactor * pb;
		a_sum += sumFactor * pa;
		
		stack = stackStart;
		
		for( i = 0; i < radiusPlus1; i++ )
		{
			stack.r = pr;
			stack.g = pg;
			stack.b = pb;
			stack.a = pa;
			stack = stack.next;
		}
		
		yp = width;
		
		for( i = 1; i <= radius; i++ )
		{
			yi = ( yp + x ) << 2;
			
			r_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );
			g_sum += ( stack.g = ( pg = pixels[yi+1])) * rbs;
			b_sum += ( stack.b = ( pb = pixels[yi+2])) * rbs;
			a_sum += ( stack.a = ( pa = pixels[yi+3])) * rbs;
		   
			r_in_sum += pr;
			g_in_sum += pg;
			b_in_sum += pb;
			a_in_sum += pa;
			
			stack = stack.next;
		
			if( i < heightMinus1 )
			{
				yp += width;
			}
		}
		
		yi = x;
		stackIn = stackStart;
		stackOut = stackEnd;
		for ( y = 0; y < height; y++ )
		{
			p = yi << 2;
			pixels[p+3] = pa = (a_sum * mul_sum) >> shg_sum;
			if ( pa > 0 )
			{
				pa = 255 / pa;
				pixels[p]   = ((r_sum * mul_sum) >> shg_sum ) * pa;
				pixels[p+1] = ((g_sum * mul_sum) >> shg_sum ) * pa;
				pixels[p+2] = ((b_sum * mul_sum) >> shg_sum ) * pa;
			} else {
				pixels[p] = pixels[p+1] = pixels[p+2] = 0;
			}
			
			r_sum -= r_out_sum;
			g_sum -= g_out_sum;
			b_sum -= b_out_sum;
			a_sum -= a_out_sum;
		   
			r_out_sum -= stackIn.r;
			g_out_sum -= stackIn.g;
			b_out_sum -= stackIn.b;
			a_out_sum -= stackIn.a;
			
			p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;
			
			r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
			g_sum += ( g_in_sum += ( stackIn.g = pixels[p+1]));
			b_sum += ( b_in_sum += ( stackIn.b = pixels[p+2]));
			a_sum += ( a_in_sum += ( stackIn.a = pixels[p+3]));
		   
			stackIn = stackIn.next;
			
			r_out_sum += ( pr = stackOut.r );
			g_out_sum += ( pg = stackOut.g );
			b_out_sum += ( pb = stackOut.b );
			a_out_sum += ( pa = stackOut.a );
			
			r_in_sum -= pr;
			g_in_sum -= pg;
			b_in_sum -= pb;
			a_in_sum -= pa;
			
			stackOut = stackOut.next;
			
			yi += width;
		}
	}
}

function BlurStack()
{
	this.r = 0;
	this.g = 0;
	this.b = 0;
	this.a = 0;
	this.next = null;
}

module.exports = blur;
},{}],"/home/ubuntu/staging/apps/node_modules/rgbcolor/index.js":[function(require,module,exports){
/*
	Based on rgbcolor.js by Stoyan Stefanov <sstoo@gmail.com>
	http://www.phpied.com/rgb-color-parser-in-javascript/
*/

module.exports = function(color_string) {
    this.ok = false;
    this.alpha = 1.0;

    // strip any leading #
    if (color_string.charAt(0) == '#') { // remove # if any
        color_string = color_string.substr(1,6);
    }

    color_string = color_string.replace(/ /g,'');
    color_string = color_string.toLowerCase();

    // before getting into regexps, try simple matches
    // and overwrite the input
    var simple_colors = {
        aliceblue: 'f0f8ff',
        antiquewhite: 'faebd7',
        aqua: '00ffff',
        aquamarine: '7fffd4',
        azure: 'f0ffff',
        beige: 'f5f5dc',
        bisque: 'ffe4c4',
        black: '000000',
        blanchedalmond: 'ffebcd',
        blue: '0000ff',
        blueviolet: '8a2be2',
        brown: 'a52a2a',
        burlywood: 'deb887',
        cadetblue: '5f9ea0',
        chartreuse: '7fff00',
        chocolate: 'd2691e',
        coral: 'ff7f50',
        cornflowerblue: '6495ed',
        cornsilk: 'fff8dc',
        crimson: 'dc143c',
        cyan: '00ffff',
        darkblue: '00008b',
        darkcyan: '008b8b',
        darkgoldenrod: 'b8860b',
        darkgray: 'a9a9a9',
        darkgreen: '006400',
        darkkhaki: 'bdb76b',
        darkmagenta: '8b008b',
        darkolivegreen: '556b2f',
        darkorange: 'ff8c00',
        darkorchid: '9932cc',
        darkred: '8b0000',
        darksalmon: 'e9967a',
        darkseagreen: '8fbc8f',
        darkslateblue: '483d8b',
        darkslategray: '2f4f4f',
        darkturquoise: '00ced1',
        darkviolet: '9400d3',
        deeppink: 'ff1493',
        deepskyblue: '00bfff',
        dimgray: '696969',
        dodgerblue: '1e90ff',
        feldspar: 'd19275',
        firebrick: 'b22222',
        floralwhite: 'fffaf0',
        forestgreen: '228b22',
        fuchsia: 'ff00ff',
        gainsboro: 'dcdcdc',
        ghostwhite: 'f8f8ff',
        gold: 'ffd700',
        goldenrod: 'daa520',
        gray: '808080',
        green: '008000',
        greenyellow: 'adff2f',
        honeydew: 'f0fff0',
        hotpink: 'ff69b4',
        indianred : 'cd5c5c',
        indigo : '4b0082',
        ivory: 'fffff0',
        khaki: 'f0e68c',
        lavender: 'e6e6fa',
        lavenderblush: 'fff0f5',
        lawngreen: '7cfc00',
        lemonchiffon: 'fffacd',
        lightblue: 'add8e6',
        lightcoral: 'f08080',
        lightcyan: 'e0ffff',
        lightgoldenrodyellow: 'fafad2',
        lightgrey: 'd3d3d3',
        lightgreen: '90ee90',
        lightpink: 'ffb6c1',
        lightsalmon: 'ffa07a',
        lightseagreen: '20b2aa',
        lightskyblue: '87cefa',
        lightslateblue: '8470ff',
        lightslategray: '778899',
        lightsteelblue: 'b0c4de',
        lightyellow: 'ffffe0',
        lime: '00ff00',
        limegreen: '32cd32',
        linen: 'faf0e6',
        magenta: 'ff00ff',
        maroon: '800000',
        mediumaquamarine: '66cdaa',
        mediumblue: '0000cd',
        mediumorchid: 'ba55d3',
        mediumpurple: '9370d8',
        mediumseagreen: '3cb371',
        mediumslateblue: '7b68ee',
        mediumspringgreen: '00fa9a',
        mediumturquoise: '48d1cc',
        mediumvioletred: 'c71585',
        midnightblue: '191970',
        mintcream: 'f5fffa',
        mistyrose: 'ffe4e1',
        moccasin: 'ffe4b5',
        navajowhite: 'ffdead',
        navy: '000080',
        oldlace: 'fdf5e6',
        olive: '808000',
        olivedrab: '6b8e23',
        orange: 'ffa500',
        orangered: 'ff4500',
        orchid: 'da70d6',
        palegoldenrod: 'eee8aa',
        palegreen: '98fb98',
        paleturquoise: 'afeeee',
        palevioletred: 'd87093',
        papayawhip: 'ffefd5',
        peachpuff: 'ffdab9',
        peru: 'cd853f',
        pink: 'ffc0cb',
        plum: 'dda0dd',
        powderblue: 'b0e0e6',
        purple: '800080',
        red: 'ff0000',
        rosybrown: 'bc8f8f',
        royalblue: '4169e1',
        saddlebrown: '8b4513',
        salmon: 'fa8072',
        sandybrown: 'f4a460',
        seagreen: '2e8b57',
        seashell: 'fff5ee',
        sienna: 'a0522d',
        silver: 'c0c0c0',
        skyblue: '87ceeb',
        slateblue: '6a5acd',
        slategray: '708090',
        snow: 'fffafa',
        springgreen: '00ff7f',
        steelblue: '4682b4',
        tan: 'd2b48c',
        teal: '008080',
        thistle: 'd8bfd8',
        tomato: 'ff6347',
        turquoise: '40e0d0',
        violet: 'ee82ee',
        violetred: 'd02090',
        wheat: 'f5deb3',
        white: 'ffffff',
        whitesmoke: 'f5f5f5',
        yellow: 'ffff00',
        yellowgreen: '9acd32'
    };
    color_string = simple_colors[color_string] || color_string;
    // emd of simple type-in colors

    // array of color definition objects
    var color_defs = [
        {
            re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
            example: ['rgba(123, 234, 45, 0.8)', 'rgba(255,234,245,1.0)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3]),
                    parseFloat(bits[4])
                ];
            }
        },
        {
            re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3])
                ];
            }
        },
        {
            re: /^(\w{2})(\w{2})(\w{2})$/,
            example: ['#00ff00', '336699'],
            process: function (bits){
                return [
                    parseInt(bits[1], 16),
                    parseInt(bits[2], 16),
                    parseInt(bits[3], 16)
                ];
            }
        },
        {
            re: /^(\w{1})(\w{1})(\w{1})$/,
            example: ['#fb0', 'f0f'],
            process: function (bits){
                return [
                    parseInt(bits[1] + bits[1], 16),
                    parseInt(bits[2] + bits[2], 16),
                    parseInt(bits[3] + bits[3], 16)
                ];
            }
        }
    ];

    // search through the definitions to find a match
    for (var i = 0; i < color_defs.length; i++) {
        var re = color_defs[i].re;
        var processor = color_defs[i].process;
        var bits = re.exec(color_string);
        if (bits) {
            var channels = processor(bits);
            this.r = channels[0];
            this.g = channels[1];
            this.b = channels[2];
            if (channels.length > 3) {
                this.alpha = channels[3];
            }
            this.ok = true;
        }

    }

    // validate/cleanup values
    this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
    this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
    this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);
    this.alpha = (this.alpha < 0) ? 0 : ((this.alpha > 1.0 || isNaN(this.alpha)) ? 1.0 : this.alpha);

    // some getters
    this.toRGB = function () {
        return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
    }
    this.toRGBA = function () {
        return 'rgba(' + this.r + ', ' + this.g + ', ' + this.b + ', ' + this.alpha + ')';
    }
    this.toHex = function () {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (r.length == 1) r = '0' + r;
        if (g.length == 1) g = '0' + g;
        if (b.length == 1) b = '0' + b;
        return '#' + r + g + b;
    }

    // help
    this.getHelpXML = function () {

        var examples = new Array();
        // add regexps
        for (var i = 0; i < color_defs.length; i++) {
            var example = color_defs[i].example;
            for (var j = 0; j < example.length; j++) {
                examples[examples.length] = example[j];
            }
        }
        // add type-in colors
        for (var sc in simple_colors) {
            examples[examples.length] = sc;
        }

        var xml = document.createElement('ul');
        xml.setAttribute('id', 'rgbcolor-examples');
        for (var i = 0; i < examples.length; i++) {
            try {
                var list_item = document.createElement('li');
                var list_color = new RGBColor(examples[i]);
                var example_div = document.createElement('div');
                example_div.style.cssText =
                        'margin: 3px; '
                        + 'border: 1px solid black; '
                        + 'background:' + list_color.toHex() + '; '
                        + 'color:' + list_color.toHex()
                ;
                example_div.appendChild(document.createTextNode('test'));
                var list_item_value = document.createTextNode(
                    ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
                );
                list_item.appendChild(example_div);
                list_item.appendChild(list_item_value);
                xml.appendChild(list_item);

            } catch(e){}
        }
        return xml;

    }

}

},{}],"/home/ubuntu/staging/apps/build/js/canvg/svg_todataurl.js":[function(require,module,exports){
/**
	The missing SVG.toDataURL library for your SVG elements.

	Usage: SVGElement.toDataURL( type, { options } )

	Returns: the data URL, except when using native PNG renderer (needs callback).

	type	MIME type of the exported data.
			Default: image/svg+xml.
			Must support: image/png.
			Additional: image/jpeg.

	options is a map of options: {
		callback: function(dataURL)
			Callback function which is called when the data URL is ready.
			This is only necessary when using native PNG renderer.
			Default: undefined.

		[the rest of the options only apply when type="image/png" or type="image/jpeg"]

		renderer: "native"|"canvg"
			PNG renderer to use. Native renderer¹ might cause a security exception.
			Default: canvg if available, otherwise native.

		keepNonSafe: true|false
			Export non-safe (image and foreignObject) elements.
			This will set the Canvas origin-clean property to false, if this data is transferred to Canvas.
			Default: false, to keep origin-clean true.
			NOTE: not currently supported and is just ignored.

		keepOutsideViewport: true|false
			Export all drawn content, even if not visible.
			Default: false, export only visible viewport, similar to Canvas toDataURL().
			NOTE: only supported with canvg renderer.
	}

	See original paper¹ for more info on SVG to Canvas exporting.

	¹ http://svgopen.org/2010/papers/62-From_SVG_to_Canvas_and_Back/#svg_to_canvas
*/

"use strict";

SVGElement.prototype.toDataURL = function (type, options) {
	var _svg = this;

	function debug(s) {
		// We could find to a way to make this display depending on environment, but
		// for now I think it's okay to just disable.
		// console.log("SVG.toDataURL:", s);
	}

	function exportSVG() {
		var svg_xml = XMLSerialize(_svg);
		var svg_dataurl = base64dataURLencode(svg_xml);
		debug(type + " length: " + svg_dataurl.length);

		// NOTE double data carrier
		if (options.callback) options.callback(svg_dataurl);
		return svg_dataurl;
	}

	function XMLSerialize(svg) {

		// quick-n-serialize an SVG dom, needed for IE9 where there's no XMLSerializer nor SVG.xml
		// s: SVG dom, which is the <svg> elemennt
		function XMLSerializerForIE(s) {
			var out = "";

			out += "<" + s.nodeName;
			for (var n = 0; n < s.attributes.length; n++) {
				out += " " + s.attributes[n].name + "=" + "'" + s.attributes[n].value + "'";
			}

			if (s.hasChildNodes()) {
				out += ">\n";

				for (var n = 0; n < s.childNodes.length; n++) {
					out += XMLSerializerForIE(s.childNodes[n]);
				}

				out += "</" + s.nodeName + ">" + "\n";
			} else out += " />\n";

			return out;
		}

		if (window.XMLSerializer) {
			debug("using standard XMLSerializer.serializeToString");
			return new XMLSerializer().serializeToString(svg);
		} else {
			debug("using custom XMLSerializerForIE");
			return XMLSerializerForIE(svg);
		}
	}

	function base64dataURLencode(s) {
		var b64 = "data:image/svg+xml;base64,";

		// https://developer.mozilla.org/en/DOM/window.btoa
		if (window.btoa) {
			debug("using window.btoa for base64 encoding");
			b64 += btoa(s);
		} else {
			debug("using custom base64 encoder");
			b64 += Base64.encode(s);
		}

		return b64;
	}

	function exportImage(type) {
		var canvas = document.createElement("canvas");
		var ctx = canvas.getContext('2d');

		// TODO: if (options.keepOutsideViewport), do some translation magic?

		var svg_img = new Image();
		var svg_xml = XMLSerialize(_svg);
		svg_img.src = base64dataURLencode(svg_xml);

		svg_img.onload = function () {
			debug("exported image size: " + [svg_img.width, svg_img.height]);
			canvas.width = svg_img.width;
			canvas.height = svg_img.height;
			ctx.drawImage(svg_img, 0, 0);

			// SECURITY_ERR WILL HAPPEN NOW
			var png_dataurl = canvas.toDataURL(type);
			debug(type + " length: " + png_dataurl.length);

			if (options.callback) options.callback(png_dataurl);else debug("WARNING: no callback set, so nothing happens.");
		};

		svg_img.onerror = function () {
			console.log("Can't export! Maybe your browser doesn't support " + "SVG in img element or SVG input for Canvas drawImage?\n" + "http://en.wikipedia.org/wiki/SVG#Native_support");
		};

		// NOTE: will not return anything
	}

	function exportImageCanvg(type) {
		var canvas = document.createElement("canvas");
		var ctx = canvas.getContext('2d');
		var svg_xml = XMLSerialize(_svg);

		// NOTE: canvg gets the SVG element dimensions incorrectly if not specified as attributes
		//debug("detected svg dimensions " + [_svg.clientWidth, _svg.clientHeight])
		//debug("canvas dimensions " + [canvas.width, canvas.height])

		var keepBB = options.keepOutsideViewport;
		if (keepBB) var bb = _svg.getBBox();

		// NOTE: this canvg call is synchronous and blocks (no it does not)
		canvg(canvas, svg_xml, {
			ignoreMouse: true, ignoreAnimation: true,
			offsetX: keepBB ? -bb.x : undefined,
			offsetY: keepBB ? -bb.y : undefined,
			scaleWidth: keepBB ? bb.width + bb.x : undefined,
			scaleHeight: keepBB ? bb.height + bb.y : undefined,
			renderCallback: function renderCallback() {
				debug("exported image dimensions " + [canvas.width, canvas.height]);
				var png_dataurl = canvas.toDataURL(type);
				debug(type + " length: " + png_dataurl.length);

				if (options.callback) options.callback(png_dataurl);
			}
		});

		// NOTE: return in addition to callback
		return canvas.toDataURL(type);
	}

	// BEGIN MAIN

	if (!type) type = "image/svg+xml";
	if (!options) options = {};

	if (options.keepNonSafe) debug("NOTE: keepNonSafe is NOT supported and will be ignored!");
	if (options.keepOutsideViewport) debug("NOTE: keepOutsideViewport is only supported with canvg exporter.");

	switch (type) {
		case "image/svg+xml":
			return exportSVG();
			break;

		case "image/png":
		case "image/jpeg":

			if (!options.renderer) {
				if (window.canvg) options.renderer = "canvg";else options.renderer = "native";
			}

			switch (options.renderer) {
				case "canvg":
					debug("using canvg renderer for png export");
					return exportImageCanvg(type);
					break;

				case "native":
					debug("using native renderer for png export. THIS MIGHT FAIL.");
					return exportImage(type);
					break;

				default:
					debug("unknown png renderer given, doing noting (" + options.renderer + ")");
			}

			break;

		default:
			debug("Sorry! Exporting as '" + type + "' is not supported!");
	}
};

},{}],"/home/ubuntu/staging/apps/build/js/sharedFunctionalBlocks.js":[function(require,module,exports){
/**
 * A set of functional blocks
 */
'use strict';

var utils = require('./utils');
var _ = utils.getLodash();
var msg = require('./locale');

var ARITHMETIC_TITLE_FONT_SIZE = 25;

exports.install = function (blockly, generator, gensym) {
  installPlus(blockly, generator, gensym);
  installMinus(blockly, generator, gensym);
  installTimes(blockly, generator, gensym);
  installDividedBy(blockly, generator, gensym);
  installGreaterThan(blockly, generator, gensym);
  installLessThan(blockly, generator, gensym);
  installNumberEquals(blockly, generator, gensym);
  installStringEquals(blockly, generator, gensym);
  installLogicalAnd(blockly, generator, gensym);
  installLogicalOr(blockly, generator, gensym);
  installLogicalNot(blockly, generator, gensym);
  installBoolean(blockly, generator, gensym);
  installMathNumber(blockly, generator, gensym);
  installString(blockly, generator, gensym);
  installCond(blockly, generator);
  installSqrt(blockly, generator);
  installPow(blockly, generator);
  installSquared(blockly, generator);
};

function installPlus(blockly, generator, gensym) {
  blockly.Blocks.functional_plus = {

    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, '+', blockly.BlockValueType.NUMBER, [{ name: 'ARG1', type: blockly.BlockValueType.NUMBER }, { name: 'ARG2', type: blockly.BlockValueType.NUMBER }], { titleFontSize: ARITHMETIC_TITLE_FONT_SIZE });
    }
  };

  generator.functional_plus = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || 0;
    return "(" + arg1 + " + " + arg2 + ")";
  };
}

function installMinus(blockly, generator, gensym) {
  blockly.Blocks.functional_minus = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, '-', blockly.BlockValueType.NUMBER, [{ name: 'ARG1', type: blockly.BlockValueType.NUMBER }, { name: 'ARG2', type: blockly.BlockValueType.NUMBER }], { titleFontSize: ARITHMETIC_TITLE_FONT_SIZE });
    }
  };

  generator.functional_minus = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || 0;
    return "(" + arg1 + " - " + arg2 + ")";
  };
}

function installTimes(blockly, generator, gensym) {
  blockly.Blocks.functional_times = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, '*', blockly.BlockValueType.NUMBER, [{ name: 'ARG1', type: blockly.BlockValueType.NUMBER }, { name: 'ARG2', type: blockly.BlockValueType.NUMBER }], { titleFontSize: ARITHMETIC_TITLE_FONT_SIZE });
    }
  };

  generator.functional_times = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || 0;
    return "(" + arg1 + " * " + arg2 + ")";
  };
}

function installDividedBy(blockly, generator, gensym) {
  blockly.Blocks.functional_dividedby = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, '/', blockly.BlockValueType.NUMBER, [{ name: 'ARG1', type: blockly.BlockValueType.NUMBER }, { name: 'ARG2', type: blockly.BlockValueType.NUMBER }], { titleFontSize: ARITHMETIC_TITLE_FONT_SIZE });
    }
  };

  generator.functional_dividedby = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || 0;
    return "(" + arg1 + " / " + arg2 + ")";
  };
}

// Install comparators

function installGreaterThan(blockly, generator, gensym) {
  blockly.Blocks.functional_greater_than = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, '>', blockly.BlockValueType.BOOLEAN, [{ name: 'ARG1', type: blockly.BlockValueType.NUMBER }, { name: 'ARG2', type: blockly.BlockValueType.NUMBER }]);
    }
  };

  generator.functional_greater_than = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || 0;
    return '(' + arg1 + " > " + arg2 + ')';
  };
}

function installLessThan(blockly, generator, gensym) {
  blockly.Blocks.functional_less_than = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, '<', blockly.BlockValueType.BOOLEAN, [{ name: 'ARG1', type: blockly.BlockValueType.NUMBER }, { name: 'ARG2', type: blockly.BlockValueType.NUMBER }]);
    }
  };

  generator.functional_less_than = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || 0;
    return '(' + arg1 + " < " + arg2 + ')';
  };
}

function installNumberEquals(blockly, generator, gensym) {
  blockly.Blocks.functional_number_equals = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, '=', blockly.BlockValueType.BOOLEAN, [{ name: 'ARG1', type: blockly.BlockValueType.NUMBER }, { name: 'ARG2', type: blockly.BlockValueType.NUMBER }]);
    }
  };

  generator.functional_number_equals = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || 0;
    return '(' + arg1 + " == " + arg2 + ')';
  };
}

function installStringEquals(blockly, generator, gensym) {
  blockly.Blocks.functional_string_equals = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, msg.stringEquals(), blockly.BlockValueType.BOOLEAN, [{ name: 'ARG1', type: blockly.BlockValueType.STRING }, { name: 'ARG2', type: blockly.BlockValueType.STRING }]);
    }
  };

  generator.functional_string_equals = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || '';
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || '';
    return '(' + arg1 + " == " + arg2 + ')';
  };
}

// Install boolean operators

function installLogicalAnd(blockly, generator, gensym) {
  blockly.Blocks.functional_logical_and = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, 'and', blockly.BlockValueType.BOOLEAN, [{ name: 'ARG1', type: blockly.BlockValueType.BOOLEAN }, { name: 'ARG2', type: blockly.BlockValueType.BOOLEAN }]);
    }
  };

  generator.functional_logical_and = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || 0;
    return '(' + arg1 + " && " + arg2 + ')';
  };
}

function installLogicalOr(blockly, generator, gensym) {
  blockly.Blocks.functional_logical_or = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, 'or', blockly.BlockValueType.BOOLEAN, [{ name: 'ARG1', type: blockly.BlockValueType.BOOLEAN }, { name: 'ARG2', type: blockly.BlockValueType.BOOLEAN }]);
    }
  };

  generator.functional_logical_or = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || 0;
    return '(' + arg1 + " || " + arg2 + ')';
  };
}

function installLogicalNot(blockly, generator, gensym) {
  blockly.Blocks.functional_logical_not = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, 'not', blockly.BlockValueType.BOOLEAN, [{ name: 'ARG1', type: blockly.BlockValueType.BOOLEAN }]);
    }
  };

  generator.functional_logical_not = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    return '!(' + arg1 + ')';
  };
}

function installBoolean(blockly, generator, gensym) {
  blockly.Blocks.functional_boolean = {
    // Boolean value.
    init: function init() {
      this.setFunctional(true, {
        headerHeight: 0,
        rowBuffer: 3
      });
      this.setHSV.apply(this, blockly.FunctionalTypeColors[blockly.BlockValueType.BOOLEAN]);
      var values = blockly.Blocks.functional_boolean.VALUES;
      this.appendDummyInput().appendTitle(new blockly.FieldDropdown(values), 'VAL').setAlign(Blockly.ALIGN_CENTRE);
      this.setFunctionalOutput(true, blockly.BlockValueType.BOOLEAN);
    }
  };

  blockly.Blocks.functional_boolean.VALUES = [[msg.booleanTrue(), 'true'], [msg.booleanFalse(), 'false']];

  generator.functional_boolean = function () {
    return this.getTitleValue('VAL');
  };
}

function installMathNumber(blockly, generator, gensym) {
  blockly.Blocks.functional_math_number = {
    // Numeric value.
    init: function init() {
      this.setFunctional(true, {
        headerHeight: 0,
        rowBuffer: 3
      });
      this.setHSV.apply(this, blockly.FunctionalTypeColors[blockly.BlockValueType.NUMBER]);
      this.appendDummyInput().appendTitle(new Blockly.FieldTextInput('0', Blockly.FieldTextInput.numberValidator), 'NUM').setAlign(Blockly.ALIGN_CENTRE);
      this.setFunctionalOutput(true, blockly.BlockValueType.NUMBER);
    }
  };

  generator.functional_math_number = function () {
    return this.getTitleValue('NUM');
  };

  blockly.Blocks.functional_math_number_dropdown = {
    // Numeric value.
    init: function init() {
      this.setFunctional(true, {
        headerHeight: 0,
        rowBuffer: 3
      });
      this.setHSV.apply(this, blockly.FunctionalTypeColors[blockly.BlockValueType.NUMBER]);
      this.appendDummyInput().appendTitle(new Blockly.FieldDropdown(), 'NUM').setAlign(Blockly.ALIGN_CENTRE);
      this.setFunctionalOutput(true, blockly.BlockValueType.NUMBER);
    }
  };

  generator.functional_math_number_dropdown = generator.functional_math_number;
}

function installString(blockly, generator) {
  blockly.Blocks.functional_string = {
    init: function init() {
      this.setFunctional(true, {
        headerHeight: 0,
        rowBuffer: 3
      });
      this.setHSV.apply(this, blockly.FunctionalTypeColors[blockly.BlockValueType.STRING]);
      this.appendDummyInput().appendTitle(new Blockly.FieldLabel('"')).appendTitle(new Blockly.FieldTextInput(''), 'VAL').appendTitle(new Blockly.FieldLabel('"')).setAlign(Blockly.ALIGN_CENTRE);
      this.setFunctionalOutput(true, blockly.BlockValueType.STRING);
    }
  };

  generator.functional_string = function () {
    return blockly.JavaScript.quote_(this.getTitleValue('VAL'));
  };
}

function installSqrt(blockly, generator) {
  blockly.Blocks.functional_sqrt = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, 'sqrt', 'Number', [{ name: 'ARG1', type: 'Number' }]);
    }
  };

  generator.functional_sqrt = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    return 'Math.sqrt(' + arg1 + ')';
  };
}

function installPow(blockly, generator) {
  blockly.Blocks.functional_pow = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, 'pow', 'Number', [{ name: 'ARG1', type: 'Number' }, { name: 'ARG2', type: 'Number' }]);
    }
  };

  generator.functional_pow = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || 0;
    return 'Math.pow(' + arg1 + ', ' + arg2 + ')';
  };
}

function installSquared(blockly, generator) {
  blockly.Blocks.functional_squared = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, 'sqr', 'Number', [{ name: 'ARG1', type: 'Number' }]);
    }
  };

  generator.functional_squared = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    return arg1 + ' * ' + arg1;
  };
}

/**
 * Implements the cond block. numPairs represents the number of
 * condition-value pairs before the default value.
 */
function installCond(blockly, generator) {
  // TODO(brent) - rtl
  var types = [Blockly.BlockValueType.NONE, Blockly.BlockValueType.NUMBER, Blockly.BlockValueType.STRING, Blockly.BlockValueType.IMAGE, Blockly.BlockValueType.BOOLEAN];

  // Generates the following blocks:
  // functional_cond (deprecated)
  // functional_cond_number
  // functional_cond_string
  // functional_cond_boolean
  // functional_cond_image
  types.forEach(function (type) {
    installCondForType(blockly, generator, type);
  });
}

function installCondForType(blockly, generator, type) {
  var blockName = 'functional_cond';
  if (type !== Blockly.BlockValueType.NONE) {
    blockName += '_' + type.toLowerCase();
  }

  blockly.Blocks[blockName] = {
    helpUrl: '',
    init: function init() {
      this.pairs_ = [];
      this.setFunctional(true, {
        headerHeight: 30
      });

      var options = {
        fixedSize: { height: 35 }
      };

      this.setHSV.apply(this, Blockly.FunctionalTypeColors[type]);

      var plusField = new Blockly.FieldIcon('+');
      Blockly.bindEvent_(plusField.getRootElement(), 'mousedown', this, this.addConditionalRow);

      this.appendDummyInput().appendTitle(new Blockly.FieldLabel('cond', options)).setAlign(Blockly.ALIGN_CENTRE);

      this.appendDummyInput('ELSE').appendTitle(new Blockly.FieldLabel('else', options));
      var defaultInput = this.appendFunctionalInput('DEFAULT').setInline(true);
      defaultInput.setHSV.apply(defaultInput, Blockly.FunctionalTypeColors[type]);

      this.appendDummyInput('PLUS').appendTitle(plusField).setInline(true);

      this.setFunctionalOutput(true, type === Blockly.BlockValueType.NONE ? undefined : type);

      this.addConditionalRow();
    },

    /**
     * Add another condition/value pair to the end.
     */
    addConditionalRow: function addConditionalRow() {
      // id is either the last value plus 1, or if we have no values yet 0
      // we can't just have pairs_.length, since there could be gaps
      var id = this.pairs_.length > 0 ? _(this.pairs_).last() * 1 + 1 : 0;
      this.pairs_.push(id);

      var cond = this.appendFunctionalInput('COND' + id);
      cond.setHSV.apply(cond, blockly.FunctionalTypeColors[blockly.BlockValueType.BOOLEAN]);
      cond.setCheck(blockly.BlockValueType.BOOLEAN);
      this.moveInputBefore('COND' + id, 'ELSE');

      var input = this.appendFunctionalInput('VALUE' + id).setInline(true);
      input.setHSV.apply(input, Blockly.FunctionalTypeColors[type]);
      this.moveInputBefore('VALUE' + id, 'ELSE');

      var minusInput = this.appendDummyInput('MINUS' + id).setInline(true);

      if (this.pairs_.length > 1) {
        var minusField = new Blockly.FieldIcon('-');
        Blockly.bindEvent_(minusField.getRootElement(), 'mousedown', this, _.bind(this.removeConditionalRow, this, id));
        minusInput.appendTitle(minusField);
      }

      this.moveInputBefore('MINUS' + id, 'ELSE');
    },

    /**
     * Remove the condition/value pair with the given id. No-op if no row with
     * that id.
     */
    removeConditionalRow: function removeConditionalRow(id) {
      var index = this.pairs_.indexOf(id);
      if (!_(this.pairs_).contains(id) || this.pairs_.length === 1) {
        return;
      }
      this.pairs_.splice(index, 1);

      var cond = this.getInput('COND' + id);
      var child = cond.connection.targetBlock();
      if (child) {
        child.dispose();
      }
      this.removeInput('COND' + id);

      var val = this.getInput('VALUE' + id);
      child = val.connection.targetBlock();
      if (child) {
        child.dispose();
      }
      this.removeInput('VALUE' + id);

      this.removeInput('MINUS' + id);
    },

    /**
     * Serialize pairs so that we can deserialize with the same ids
     */
    mutationToDom: function mutationToDom() {
      if (this.pairs_.length <= 1) {
        return null;
      }
      var container = document.createElement('mutation');
      container.setAttribute('pairs', this.pairs_.join(','));
      return container;
    },

    /**
     * Deserialize and cause our block to have same ids
     */
    domToMutation: function domToMutation(element) {
      var i;
      var pairs = element.getAttribute('pairs');
      if (!pairs) {
        return;
      }

      pairs = pairs.split(',').map(function (item) {
        return parseInt(item, 10);
      });

      // Our pairs, which are used to name rows, are not necessarily contiguous.
      // We ensure that we end up with the same set of pairs by adding lots
      // of rows, and then deleting the unneeded ones (simulating what happened
      // to originally create this block)
      var lastRow = _(pairs).last();
      for (i = 1; i <= lastRow; i++) {
        this.addConditionalRow();
      }

      for (i = 0; i < lastRow; i++) {
        if (!_(pairs).contains(i)) {
          this.removeConditionalRow(i);
        }
      }
    }
  };

  /**
   * // generates code like:
   * function() {
   *   if (cond1) { return value1; }
   *   else if (cond2) {return value2; }
   *   ...
   *   else { return default; }
   * }()
   */
  generator[blockName] = function () {
    var cond, value, defaultValue;
    var code = '(function () {\n  ';
    for (var i = 0; i < this.pairs_.length; i++) {
      if (i > 0) {
        code += 'else ';
      }
      var id = this.pairs_[i];
      cond = Blockly.JavaScript.statementToCode(this, 'COND' + id, false) || false;
      value = Blockly.JavaScript.statementToCode(this, 'VALUE' + id, false) || '';
      code += 'if (' + cond + ') { return ' + value + '; }\n  ';
    }
    defaultValue = Blockly.JavaScript.statementToCode(this, 'DEFAULT', false) || '';
    code += 'else { return ' + defaultValue + '; }\n';
    code += '})()';
    return code;
  };
}

},{"./locale":"/home/ubuntu/staging/apps/build/js/locale.js","./utils":"/home/ubuntu/staging/apps/build/js/utils.js"}],"/home/ubuntu/staging/apps/build/js/templates/AppView.jsx":[function(require,module,exports){
'use strict';

var ProtectedStatefulDiv = require('./ProtectedStatefulDiv.jsx');
var StudioAppWrapper = require('./StudioAppWrapper.jsx');

/**
 * Top-level React wrapper for our standard blockly apps.
 */
var AppView = React.createClass({
  displayName: 'AppView',

  propTypes: {
    assetUrl: React.PropTypes.func.isRequired,
    isEmbedView: React.PropTypes.bool.isRequired,
    isShareView: React.PropTypes.bool.isRequired,
    renderCodeWorkspace: React.PropTypes.func.isRequired,
    renderVisualizationColumn: React.PropTypes.func.isRequired,
    onMount: React.PropTypes.func.isRequired
  },

  componentDidMount: function componentDidMount() {
    this.props.onMount();
  },

  render: function render() {
    return React.createElement(
      StudioAppWrapper,
      {
        assetUrl: this.props.assetUrl,
        isEmbedView: this.props.isEmbedView,
        isShareView: this.props.isShareView },
      React.createElement(ProtectedStatefulDiv, {
        id: 'visualizationColumn',
        renderContents: this.props.renderVisualizationColumn }),
      React.createElement(ProtectedStatefulDiv, { id: 'visualizationResizeBar', className: 'fa fa-ellipsis-v' }),
      React.createElement(ProtectedStatefulDiv, {
        id: 'codeWorkspace',
        renderContents: this.props.renderCodeWorkspace })
    );
  }
});
module.exports = AppView;

},{"./ProtectedStatefulDiv.jsx":"/home/ubuntu/staging/apps/build/js/templates/ProtectedStatefulDiv.jsx","./StudioAppWrapper.jsx":"/home/ubuntu/staging/apps/build/js/templates/StudioAppWrapper.jsx"}],"/home/ubuntu/staging/apps/build/js/templates/visualizationColumn.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
var msg = require('../locale');
var hideRunButton = locals.hideRunButton || false;
; buf.push('\n\n');6; var gameButtons = function() {; buf.push('<div id="gameButtons">\n  <button id="runButton" class="launch blocklyLaunch ', escape((7,  hideRunButton ? 'invisible' : '')), '">\n    <div>', escape((8,  msg.runProgram() )), '</div>\n    <img src="', escape((9,  assetUrl('media/1x1.gif') )), '" class="run26"/>\n  </button>\n  <button id="resetButton" class="launch blocklyLaunch" style="display: none">\n    <div>', escape((12,  msg.resetProgram() )), '</div>\n    <img src="', escape((13,  assetUrl('media/1x1.gif') )), '" class="reset26"/>\n  </button>\n  ');15; if (data.controls) { ; buf.push('\n    ', (16,  data.controls ), '\n  ');17; } ; buf.push('\n  ');18; if (!data.pinWorkspaceToBottom && data.extraControlRows) { ; buf.push('\n    ', (19,  data.extraControlRows ), '\n  ');20; } ; buf.push('\n</div>\n');22; };; buf.push('\n<div id="visualization">\n  ', (24,  data.visualization ), '\n</div>\n\n');27; gameButtons() ; buf.push('\n\n<div id="belowVisualization">\n\n  <div id="bubble" class="clearfix">\n    <table id="prompt-table">\n      <tr>\n        <td id="prompt-icon-cell" style="display: none">\n          <img id="prompt-icon"/>\n        </td>\n        <td id="prompt-cell">\n          <p id="prompt">\n          <p id="prompt2" style="display:none">\n          </p>\n        </td>\n      </tr>\n    </table>\n    ');44; if (data.inputOutputTable) { ; buf.push('\n      <div id="input-table">\n        <table>\n          <tr>\n            <th>Input</th>\n            <th>Output</th>\n          </tr>\n          ');51; for (var i = 0; i < data.inputOutputTable.length; i++) { ; buf.push('\n          <tr>\n            <td>', (53,  data.inputOutputTable[i][0] ), '</td>\n            <td>', (54,  data.inputOutputTable[i][1] ), '</td>\n          </tr>\n          ');56; } ; buf.push('\n        </table>\n      </div>\n    ');59; } ; buf.push('\n    <div id="ani-gif-preview-wrapper">\n      <div id="ani-gif-preview">\n      </div>\n    </div>\n  </div>\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js","ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/codeWorkspace.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
var msg = require('../locale');
; buf.push('\n\n<div id="codeWorkspaceWrapper">\n  <div id="headers" dir="', escape((6,  data.localeDirection )), '">\n    <div id="codeModeHeaders">\n      <div id="toolbox-header" class="workspace-header">\n        <i id="hide-toolbox-icon" style="display:none;" class="fa fa-chevron-circle-right"></i>\n        <span>', escape((10,  data.editCode ? msg.toolboxHeaderDroplet() : msg.toolboxHeader() )), '</span>\n      </div>\n      <div id="show-toolbox-header" class="workspace-header" style="display:none;">\n        <i id="show-toolbox-icon" class="fa fa-chevron-circle-right"></i>\n        <span>', escape((14,  msg.showToolbox() )), '</span>\n      </div>\n      <div id="show-code-header" class="workspace-header workspace-header-button"><span><img src="', escape((16,  assetUrl('media/applab/blocks_glyph.gif') )), '" class="blocks-glyph" /><i class="fa fa-code"></i>', escape((16,  msg.showCodeHeader() )), '</span></div>\n      ');17; if (!data.readonlyWorkspace) { ; buf.push('\n        <div id="clear-puzzle-header" class="workspace-header workspace-header-button"><span><i class="fa fa-undo"></i>', escape((18,  msg.clearPuzzle() )), '</span></div>\n      ');19; } ; buf.push('\n      <div id="versions-header" class="workspace-header workspace-header-button"><span><i class="fa fa-clock-o"></i>', escape((20,  msg.showVersionsHeader() )), '</span></div>\n      <div id="workspace-header" class="workspace-header">\n        <span id="workspace-header-span">\n          ', escape((23,  data.readonlyWorkspace ? msg.readonlyWorkspaceHeader() : msg.workspaceHeaderShort() )), '\n        </span>\n        <div id="blockCounter">\n          <div id="blockUsed" class=', escape((26,  data.blockCounterClass )), '>\n            ', escape((27,  data.blockUsed )), '\n          </div>\n          <span>/</span>\n          <span id="idealBlockNumber">', escape((30,  data.idealBlockNumber )), '</span>\n          <span> ', escape((31,  msg.blocks() )), '</span>\n        </div>\n      </div>\n    </div>\n  </div>\n  ');36; if (data.editCode) { ; buf.push('\n    <div id="codeTextbox"></div>\n  ');38; } ; buf.push('\n  ');39; if (data.pinWorkspaceToBottom && data.extraControlRows) { ; buf.push('\n    ', (40,  data.extraControlRows ), '\n  ');41; } ; buf.push('\n</div>\n');43; if (data.hasDesignMode) { ; buf.push('\n  <div id="designWorkspace" style="display:none;">\n</div>\n');46; } ; buf.push('\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js","ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/skins.js":[function(require,module,exports){
// avatar: A 1029x51 set of 21 avatar images.

'use strict';

exports.load = function (assetUrl, id) {
  var skinUrl = function skinUrl(path) {
    if (path !== undefined) {
      return assetUrl('media/skins/' + id + '/' + path);
    } else {
      return null;
    }
  };

  var skin = {
    id: id,
    assetUrl: skinUrl,
    // Images
    avatar: skinUrl('avatar.png'),
    avatar_2x: skinUrl('avatar_2x.png'),
    goal: skinUrl('goal.png'),
    obstacle: skinUrl('obstacle.png'),
    smallStaticAvatar: skinUrl('small_static_avatar.png'),
    staticAvatar: skinUrl('static_avatar.png'),
    winAvatar: skinUrl('win_avatar.png'),
    failureAvatar: skinUrl('failure_avatar.png'),
    decorationAnimation: skinUrl('decoration_animation.png'),
    decorationAnimation_2x: skinUrl('decoration_animation_2x.png'),
    repeatImage: assetUrl('media/common_images/repeat-arrows.png'),
    leftArrow: assetUrl('media/common_images/moveleft.png'),
    downArrow: assetUrl('media/common_images/movedown.png'),
    upArrow: assetUrl('media/common_images/moveup.png'),
    rightArrow: assetUrl('media/common_images/moveright.png'),
    leftJumpArrow: assetUrl('media/common_images/jumpleft.png'),
    downJumpArrow: assetUrl('media/common_images/jumpdown.png'),
    upJumpArrow: assetUrl('media/common_images/jumpup.png'),
    rightJumpArrow: assetUrl('media/common_images/jumpright.png'),
    northLineDraw: assetUrl('media/common_images/draw-north.png'),
    southLineDraw: assetUrl('media/common_images/draw-south.png'),
    eastLineDraw: assetUrl('media/common_images/draw-east.png'),
    westLineDraw: assetUrl('media/common_images/draw-west.png'),
    shortLineDraw: assetUrl('media/common_images/draw-short.png'),
    longLineDraw: assetUrl('media/common_images/draw-long.png'),
    shortLineDrawRight: assetUrl('media/common_images/draw-short-right.png'),
    longLineDrawRight: assetUrl('media/common_images/draw-long-right.png'),
    longLine: assetUrl('media/common_images/move-long.png'),
    shortLine: assetUrl('media/common_images/move-short.png'),
    soundIcon: assetUrl('media/common_images/play-sound.png'),
    clickIcon: assetUrl('media/common_images/when-click-hand.png'),
    startIcon: assetUrl('media/common_images/when-run.png'),
    runArrow: assetUrl('media/common_images/run-arrow.png'),
    endIcon: assetUrl('media/common_images/end-icon.png'),
    speedFast: assetUrl('media/common_images/speed-fast.png'),
    speedMedium: assetUrl('media/common_images/speed-medium.png'),
    speedSlow: assetUrl('media/common_images/speed-slow.png'),
    scoreCard: assetUrl('media/common_images/increment-score-75percent.png'),
    rainbowMenu: assetUrl('media/common_images/rainbow-menuicon.png'),
    ropeMenu: assetUrl('media/common_images/rope-menuicon.png'),
    squigglyMenu: assetUrl('media/common_images/squiggly-menuicon.png'),
    swirlyMenu: assetUrl('media/common_images/swirlyline-menuicon.png'),
    patternDefault: assetUrl('media/common_images/defaultline-menuicon.png'),
    rainbowLine: assetUrl('media/common_images/rainbow.png'),
    ropeLine: assetUrl('media/common_images/rope.png'),
    squigglyLine: assetUrl('media/common_images/squiggly.png'),
    swirlyLine: assetUrl('media/common_images/swirlyline.png'),
    randomPurpleIcon: assetUrl('media/common_images/random-purple.png'),

    // Sounds
    startSound: [skinUrl('start.mp3'), skinUrl('start.ogg')],
    winSound: [skinUrl('win.mp3'), skinUrl('win.ogg')],
    failureSound: [skinUrl('failure.mp3'), skinUrl('failure.ogg')],

    // Stickers
    stickers: {
      elephant: assetUrl('media/common_images/stickers/elephant.png'),
      dragon: assetUrl('media/common_images/stickers/dragon.png'),
      triceratops: assetUrl('media/common_images/stickers/triceratops.png'),
      monkey: assetUrl('media/common_images/stickers/monkey.png'),
      cat: assetUrl('media/common_images/stickers/cat.png'),
      turtle: assetUrl('media/common_images/stickers/turtle.png'),
      goat: assetUrl('media/common_images/stickers/goat.png'),
      zebra: assetUrl('media/common_images/stickers/zebra.png'),
      hippo: assetUrl('media/common_images/stickers/hippo.png'),
      bunny: assetUrl('media/common_images/stickers/bunny.png'),
      peacock: assetUrl('media/common_images/stickers/peacock.png'),
      llama: assetUrl('media/common_images/stickers/llama.png'),
      giraffe: assetUrl('media/common_images/stickers/giraffe.png'),
      mouse: assetUrl('media/common_images/stickers/mouse.png'),
      beaver: assetUrl('media/common_images/stickers/beaver.png'),
      bat: assetUrl('media/common_images/stickers/bat.png'),
      grasshopper: assetUrl('media/common_images/stickers/grasshopper.png'),
      chicken: assetUrl('media/common_images/stickers/chicken.png'),
      moose: assetUrl('media/common_images/stickers/moose.png'),
      owl: assetUrl('media/common_images/stickers/owl.png'),
      penguin: assetUrl('media/common_images/stickers/penguin.png'),
      lion: assetUrl('media/common_images/stickers/lion.png'),
      robot: assetUrl('media/common_images/stickers/robot.png'),
      rocket: assetUrl('media/common_images/stickers/rocket.png')
    }
  };

  return skin;
};

},{}],"/home/ubuntu/staging/apps/build/js/assetManagement/getAssetDropdown.js":[function(require,module,exports){
/* global Dialog, dashboard, Applab */
// TODO (josh) - don't pass `Dialog` into `createModalDialog`.

'use strict';

var assetListStore = require('./assetListStore');
var showAssetManager = require('./show');
var commonMsg = require('../locale');
var utils = require('../utils');

/**
 * Returns a list of options (optionally filtered by type) for code-mode
 * asset dropdowns.
 */
module.exports = function (typeFilter) {
  var options = assetListStore.list(typeFilter).map(function (asset) {
    return {
      text: utils.quote(asset.filename),
      display: utils.quote(asset.filename)
    };
  });
  var handleChooseClick = function handleChooseClick(callback) {
    showAssetManager(function (filename) {
      callback(utils.quote(filename));
    }, typeFilter);
  };
  options.push({
    text: commonMsg.choosePrefix(),
    display: '<span class="chooseAssetDropdownOption">' + commonMsg.choosePrefix() + '</a>',
    click: handleChooseClick
  });
  return options;
};

},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js","../utils":"/home/ubuntu/staging/apps/build/js/utils.js","./assetListStore":"/home/ubuntu/staging/apps/build/js/assetManagement/assetListStore.js","./show":"/home/ubuntu/staging/apps/build/js/assetManagement/show.js"}],"/home/ubuntu/staging/apps/build/js/timeoutList.js":[function(require,module,exports){
"use strict";

var timeoutList = [];

/**
 * call setTimeout and track the returned id
 */
exports.setTimeout = function (fn, time) {
  var timeout = window.setTimeout.apply(window, arguments);
  timeoutList.push(timeout);
  return timeout;
};

/**
 * Clears all timeouts in our timeoutList and resets the timeoutList
 */
exports.clearTimeouts = function () {
  timeoutList.forEach(window.clearTimeout, window);
  timeoutList = [];
};

/**
 * Clears a timeout and removes the item from the timeoutList
 */
exports.clearTimeout = function (id) {
  window.clearTimeout(id);
  // List removal requires IE9+
  var index = timeoutList.indexOf(id);
  if (index > -1) {
    timeoutList.splice(index, 1);
  }
};

var intervalList = [];

/**
 * call setInterval and track the returned id
 */
exports.setInterval = function (fn, time) {
  var interval = window.setInterval.apply(window, arguments);
  intervalList.push(interval);
  return interval;
};

/**
 * Clears all interval timeouts in our intervalList and resets the intervalList
 */
exports.clearIntervals = function () {
  intervalList.forEach(window.clearInterval, window);
  intervalList = [];
};

/**
 * Clears a timeout and removes the item from the intervalList
 */
exports.clearInterval = function (id) {
  window.clearInterval(id);
  // List removal requires IE9+
  var index = intervalList.indexOf(id);
  if (index > -1) {
    intervalList.splice(index, 1);
  }
};

},{}],"/home/ubuntu/staging/apps/node_modules/lodash/dist/lodash.js":[function(require,module,exports){
(function (global){
/**
 * @license
 * Lo-Dash 2.4.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
      descriptor.value = null;
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * https://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.2';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return _;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = _;
    }
  }
  else {
    // in a browser or Rhino
    root._ = _;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/stream-browserify/index.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/events/events.js","inherits":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js","readable-stream/duplex.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/duplex.js","readable-stream/passthrough.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/passthrough.js","readable-stream/readable.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/readable.js","readable-stream/transform.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/transform.js","readable-stream/writable.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/writable.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/writable.js":[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/transform.js":[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/readable.js":[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = require('stream');
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_passthrough.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_passthrough.js","./lib/_stream_readable.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_transform.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_writable.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js","stream":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/stream-browserify/index.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/passthrough.js":[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_passthrough.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_passthrough.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js","core-util-is":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","inherits":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (!util.isNullOrUndefined(data))
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('prefinish', function() {
    if (util.isFunction(this._flush))
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","core-util-is":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","inherits":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/duplex.js":[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,require('_process'))

},{"./_stream_readable":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js","_process":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/process/browser.js","core-util-is":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","inherits":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (util.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (!util.isFunction(cb))
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.buffer.length)
      clearBuffer(this, state);
  }
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      util.isString(chunk)) {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (util.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, false, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      state.pendingcb--;
      cb(er);
    });
  else {
    state.pendingcb--;
    cb(er);
  }

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.buffer.length) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  if (stream._writev && state.buffer.length > 1) {
    // Fast case, write everything using _writev()
    var cbs = [];
    for (var c = 0; c < state.buffer.length; c++)
      cbs.push(state.buffer[c].callback);

    // count the one we are adding, as well.
    // TODO(isaacs) clean this up
    state.pendingcb++;
    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    });

    // Clear buffer
    state.buffer = [];
  } else {
    // Slow case, write chunks one-by-one
    for (var c = 0; c < state.buffer.length; c++) {
      var entry = state.buffer[c];
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);

      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        c++;
        break;
      }
    }

    if (c < state.buffer.length)
      state.buffer = state.buffer.slice(c);
    else
      state.buffer.length = 0;
  }

  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));

};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (util.isFunction(chunk)) {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (!util.isNullOrUndefined(chunk))
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else
      prefinish(stream, state);
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require('_process'))

},{"./_stream_duplex":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","_process":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/process/browser.js","buffer":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/buffer/index.js","core-util-is":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","inherits":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js","stream":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/stream-browserify/index.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_readable.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;


/*<replacement>*/
var debug = require('util');
if (debug && debug.debuglog) {
  debug = debug.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  var Duplex = require('./_stream_duplex');

  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (util.isString(chunk) && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (util.isNullOrUndefined(chunk)) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      if (!addToFront)
        state.reading = false;

      // if we want the data now, just emit it.
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);

        if (state.needReadable)
          emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || util.isNull(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (!util.isNumber(n) || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (util.isNull(ret)) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (!util.isNull(ret))
    this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      process.nextTick(function() {
        emitReadable_(stream);
      });
    else
      emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      debug('false write response, pause',
            src._readableState.awaitDrain);
      src._readableState.awaitDrain++;
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        var self = this;
        process.nextTick(function() {
          debug('readable nexttick read 0');
          self.read(0);
        });
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    if (!state.reading) {
      debug('resume read 0');
      this.read(0);
    }
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(function() {
      resume_(stream, state);
    });
  }
}

function resume_(stream, state) {
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))

},{"./_stream_duplex":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","_process":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/process/browser.js","buffer":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/buffer/index.js","core-util-is":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","events":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/events/events.js","inherits":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js","isarray":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/isarray/index.js","stream":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/stream-browserify/index.js","string_decoder/":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/string_decoder/index.js","util":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/browser-resolve/empty.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/string_decoder/index.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/buffer/index.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js":[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,{"isBuffer":require("../../../../insert-module-globals/node_modules/is-buffer/index.js")})

},{"../../../../insert-module-globals/node_modules/is-buffer/index.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/insert-module-globals/node_modules/is-buffer/index.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/insert-module-globals/node_modules/is-buffer/index.js":[function(require,module,exports){
/**
 * Determine if an object is Buffer
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install is-buffer`
 */

module.exports = function (obj) {
  return !!(obj != null &&
    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
      (obj.constructor &&
      typeof obj.constructor.isBuffer === 'function' &&
      obj.constructor.isBuffer(obj))
    ))
}

},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/isarray/index.js":[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/buffer/index.js":[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

function typedArraySupport () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js","ieee754":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js","is-array":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js":[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js":[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js":[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/browser-resolve/empty.js":[function(require,module,exports){
arguments[4]["/home/ubuntu/staging/apps/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/events/events.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"/home/ubuntu/staging/apps/build/js/assetManagement/show.js":[function(require,module,exports){
/* global Dialog, dashboard, Applab */
// TODO (josh) - don't pass `Dialog` into `createModalDialog`.

'use strict';

var AssetManager = require('./AssetManager.jsx');
var studioApp = require('../StudioApp').singleton;

/**
 * Display the "Manage Assets" modal.
 * @param assetChosen {Function} Called when the user chooses an asset. The
 *   "Choose" button in the UI only appears if this optional param is provided.
 * @param typeFilter {String} The type of assets to show and allow to be
 *   uploaded.
 */
module.exports = function (assetChosen, typeFilter) {
  var codeDiv = document.createElement('div');
  var showChoseImageButton = assetChosen && typeof assetChosen === 'function';
  var dialog = studioApp.createModalDialog({
    contentDiv: codeDiv,
    defaultBtnSelector: 'again-button',
    id: 'manageAssetsModal'
  });
  ReactDOM.render(React.createElement(AssetManager, {
    typeFilter: typeFilter,
    channelId: dashboard.project.getCurrentId(),
    uploadsEnabled: !dashboard.project.exceedsAbuseThreshold(),
    assetChosen: showChoseImageButton ? function (fileWithPath) {
      dialog.hide();
      assetChosen(fileWithPath);
    } : null
  }), codeDiv);

  dialog.show();
};

},{"../StudioApp":"/home/ubuntu/staging/apps/build/js/StudioApp.js","./AssetManager.jsx":"/home/ubuntu/staging/apps/build/js/assetManagement/AssetManager.jsx"}],"/home/ubuntu/staging/apps/build/js/assetManagement/AssetManager.jsx":[function(require,module,exports){
'use strict';

var assetsApi = require('../clientApi').assets;
var AssetRow = require('./AssetRow.jsx');
var AssetUploader = require('./AssetUploader.jsx');
var assetListStore = require('./assetListStore');

var errorMessages = {
  403: 'Quota exceeded. Please delete some files and try again.',
  413: 'The file is too large.',
  415: 'This type of file is not supported.',
  500: 'The server responded with an error.',
  unknown: 'An unknown error occurred.'
};

var errorUploadDisabled = "This project has been reported for abusive content, " + "so uploading new assets is disabled.";

function getErrorMessage(status) {
  return errorMessages[status] || errorMessages.unknown;
}

/**
 * A component for managing hosted assets.
 */
module.exports = React.createClass({
  displayName: 'exports',

  propTypes: {
    assetChosen: React.PropTypes.func,
    typeFilter: React.PropTypes.string,
    channelId: React.PropTypes.string.isRequired,
    uploadsEnabled: React.PropTypes.bool.isRequired
  },

  getInitialState: function getInitialState() {
    return {
      assets: null,
      statusMessage: this.props.uploadsEnabled ? '' : errorUploadDisabled
    };
  },

  componentWillMount: function componentWillMount() {
    // TODO: Use Dave's client api when it's finished.
    assetsApi.ajax('GET', '', this.onAssetListReceived, this.onAssetListFailure);
  },

  /**
   * Called after the component mounts, when the server responds with the
   * current list of assets.
   * @param xhr
   */
  onAssetListReceived: function onAssetListReceived(xhr) {
    assetListStore.reset(JSON.parse(xhr.responseText));
    this.setState({ assets: assetListStore.list(this.props.typeFilter) });
  },

  /**
   * Called after the component mounts, if the server responds with an error
   * when loading the current list of assets.
   * @param xhr
   */
  onAssetListFailure: function onAssetListFailure(xhr) {
    this.setState({ statusMessage: 'Error loading asset list: ' + getErrorMessage(xhr.status) });
  },

  onUploadStart: function onUploadStart() {
    this.setState({ statusMessage: 'Uploading...' });
  },

  onUploadDone: function onUploadDone(result) {
    assetListStore.add(result);
    this.setState({
      assets: assetListStore.list(this.props.typeFilter),
      statusMessage: 'File "' + result.filename + '" successfully uploaded!'
    });
  },

  onUploadError: function onUploadError(status) {
    this.setState({ statusMessage: 'Error uploading file: ' + getErrorMessage(status) });
  },

  deleteAssetRow: function deleteAssetRow(name) {
    this.setState({
      assets: assetListStore.remove(name),
      statusMessage: 'File "' + name + '" successfully deleted!'
    });
  },

  render: function render() {
    var uploadButton = React.createElement(
      'div',
      null,
      React.createElement(AssetUploader, {
        uploadsEnabled: this.props.uploadsEnabled,
        typeFilter: this.props.typeFilter,
        channelId: this.props.channelId,
        onUploadStart: this.onUploadStart,
        onUploadDone: this.onUploadDone,
        onUploadError: this.onUploadError }),
      React.createElement(
        'span',
        { style: { margin: '0 10px' }, id: 'manage-asset-status' },
        this.state.statusMessage
      )
    );

    var assetList;
    // If `this.state.assets` is null, the asset list is still loading. If it's
    // empty, the asset list has loaded and there are no assets in the current
    // channel (matching the `typeFilter`, if one was provided).
    if (this.state.assets === null) {
      assetList = React.createElement(
        'div',
        { style: { margin: '1em 0', textAlign: 'center' } },
        React.createElement('i', { className: 'fa fa-spinner fa-spin', style: { fontSize: '32px' } })
      );
    } else if (this.state.assets.length === 0) {
      assetList = React.createElement(
        'div',
        null,
        React.createElement(
          'div',
          { style: { margin: '1em 0' } },
          'Your assets will appear here. Click "Upload File" to add a new asset for this project.'
        ),
        uploadButton
      );
    } else {
      var rows = this.state.assets.map((function (asset) {
        var choose = this.props.assetChosen && this.props.assetChosen.bind(this, asset.filename);

        return React.createElement(AssetRow, {
          key: asset.filename,
          name: asset.filename,
          type: asset.category,
          size: asset.size,
          onChoose: choose,
          onDelete: this.deleteAssetRow.bind(this, asset.filename) });
      }).bind(this));

      assetList = React.createElement(
        'div',
        null,
        React.createElement(
          'div',
          { style: { maxHeight: '330px', overflowY: 'scroll', margin: '1em 0', paddingRight: '15px' } },
          React.createElement(
            'table',
            { style: { width: '100%' } },
            React.createElement(
              'tbody',
              null,
              rows
            )
          )
        ),
        uploadButton
      );
    }

    var title = this.props.assetChosen ? React.createElement(
      'p',
      { className: 'dialog-title' },
      'Choose Assets'
    ) : React.createElement(
      'p',
      { className: 'dialog-title' },
      'Manage Assets'
    );

    return React.createElement(
      'div',
      { className: 'modal-content', style: { margin: 0 } },
      title,
      assetList
    );
  }
});

},{"../clientApi":"/home/ubuntu/staging/apps/build/js/clientApi.js","./AssetRow.jsx":"/home/ubuntu/staging/apps/build/js/assetManagement/AssetRow.jsx","./AssetUploader.jsx":"/home/ubuntu/staging/apps/build/js/assetManagement/AssetUploader.jsx","./assetListStore":"/home/ubuntu/staging/apps/build/js/assetManagement/assetListStore.js"}],"/home/ubuntu/staging/apps/build/js/assetManagement/AssetUploader.jsx":[function(require,module,exports){

/**
 * A component for managing hosted assets.
 */
'use strict';

module.exports = React.createClass({
  displayName: 'exports',

  propTypes: {
    onUploadStart: React.PropTypes.func.isRequired,
    onUploadDone: React.PropTypes.func.isRequired,
    channelId: React.PropTypes.string.isRequired,
    typeFilter: React.PropTypes.string,
    uploadsEnabled: React.PropTypes.bool.isRequired
  },

  componentDidMount: function componentDidMount() {
    var props = this.props;

    $(this.refs.uploader).fileupload({
      dataType: 'json',
      url: '/v3/assets/' + props.channelId + '/',
      // prevent fileupload from replacing the input DOM element, which
      // React does not like
      replaceFileInput: false,
      add: function add(e, data) {
        props.onUploadStart();
        data.submit();
      },
      done: function done(e, data) {
        props.onUploadDone(data.result);
      },
      error: function error(e, data) {
        props.onUploadError(e.status);
      }
    });
  },

  componentWillUnmount: function componentWillUnmount() {
    $(this.refs.uploader).fileupload('destroy');
  },

  /**
   * We've hidden the <input type="file"/> and replaced it with a big button.
   * Forward clicks on the button to the hidden file input.
   */
  fileUploadClicked: function fileUploadClicked() {
    this.refs.uploader.click();
  },

  render: function render() {
    // NOTE: IE9 will ignore accept, which means on this browser we can end
    // up uploading files that dont match typeFilter
    return React.createElement(
      'span',
      null,
      React.createElement('input', {
        ref: 'uploader',
        type: 'file',
        style: { display: 'none' },
        accept: (this.props.typeFilter || '*') + '/*' }),
      React.createElement(
        'button',
        {
          onClick: this.fileUploadClicked,
          className: 'share',
          id: 'upload-asset',
          disabled: !this.props.uploadsEnabled },
        React.createElement('i', { className: 'fa fa-upload' }),
        ' Upload File'
      )
    );
  }
});

},{}],"/home/ubuntu/staging/apps/build/js/assetManagement/AssetRow.jsx":[function(require,module,exports){
'use strict';

var assetsApi = require('../clientApi').assets;
var AssetThumbnail = require('./AssetThumbnail.jsx');

/**
 * A single row in the AssetManager, describing one asset.
 */
module.exports = React.createClass({
  displayName: 'exports',

  propTypes: {
    name: React.PropTypes.string.isRequired,
    type: React.PropTypes.oneOf(['image', 'audio', 'video']).isRequired,
    size: React.PropTypes.number,
    onChoose: React.PropTypes.func,
    onDelete: React.PropTypes.func.isRequired
  },

  getInitialState: function getInitialState() {
    return {
      action: 'normal',
      actionText: ''
    };
  },

  /**
   * Confirm the user actually wants to delete this asset.
   */
  confirmDelete: function confirmDelete() {
    this.setState({ action: 'confirming delete', actionText: '' });
  },

  /**
   * This user didn't want to delete this asset.
   */
  cancelDelete: function cancelDelete() {
    this.setState({ action: 'normal', actionText: '' });
  },

  /**
   * Delete this asset and notify the parent to remove this row. If the delete
   * fails, flip back to 'confirming delete' and display a message.
   */
  handleDelete: function handleDelete() {
    this.setState({ action: 'deleting', actionText: '' });

    // TODO: Use Dave's client api when it's finished.
    assetsApi.ajax('DELETE', this.props.name, this.props.onDelete, (function () {
      this.setState({ action: 'confirming delete',
        actionText: 'Error deleting file.' });
    }).bind(this));
  },

  render: function render() {
    var actions, flex;
    // `flex` is the "Choose" button in file-choose mode, or the filesize.
    if (this.props.onChoose) {
      flex = React.createElement(
        'button',
        { onClick: this.props.onChoose },
        'Choose'
      );
    } else {
      var size = (this.props.size / 1000).toFixed(2);
      flex = size + ' kb';
    }

    switch (this.state.action) {
      case 'normal':
        var src = assetsApi.basePath(this.props.name);
        actions = React.createElement(
          'td',
          { width: '250', style: { textAlign: 'right' } },
          flex,
          React.createElement(
            'a',
            { href: src,
              target: '_blank',
              style: { backgroundColor: 'transparent' } },
            React.createElement(
              'button',
              null,
              React.createElement('i', { className: 'fa fa-eye' })
            )
          ),
          React.createElement(
            'button',
            { className: 'btn-danger', onClick: this.confirmDelete },
            React.createElement('i', { className: 'fa fa-trash-o' })
          ),
          this.state.actionText
        );
        break;
      case 'confirming delete':
        actions = React.createElement(
          'td',
          { width: '250', style: { textAlign: 'right' } },
          React.createElement(
            'button',
            { className: 'btn-danger', onClick: this.handleDelete },
            'Delete File'
          ),
          React.createElement(
            'button',
            { onClick: this.cancelDelete },
            'Cancel'
          ),
          this.state.actionText
        );
        break;
      case 'deleting':
        actions = React.createElement(
          'td',
          { width: '250', style: { textAlign: 'right' } },
          React.createElement('i', { className: 'fa fa-spinner fa-spin', style: {
              fontSize: '32px',
              marginRight: '15px'
            } })
        );
        break;
    }

    return React.createElement(
      'tr',
      { className: 'assetRow', onDoubleClick: this.props.onChoose },
      React.createElement(AssetThumbnail, { type: this.props.type, name: this.props.name }),
      React.createElement(
        'td',
        null,
        this.props.name
      ),
      actions
    );
  }
});

},{"../clientApi":"/home/ubuntu/staging/apps/build/js/clientApi.js","./AssetThumbnail.jsx":"/home/ubuntu/staging/apps/build/js/assetManagement/AssetThumbnail.jsx"}],"/home/ubuntu/staging/apps/build/js/assetManagement/AssetThumbnail.jsx":[function(require,module,exports){
'use strict';

var assetsApi = require('../clientApi').assets;

var defaultIcons = {
  image: 'fa fa-picture-o',
  audio: 'fa fa-music',
  video: 'fa fa-video-camera',
  unknown: 'fa fa-question'
};

var assetThumbnailStyle = {
  width: 'auto',
  maxWidth: '100%',
  height: 'auto',
  maxHeight: '100%',
  marginTop: '50%',
  transform: 'translateY(-50%)',
  msTransform: 'translateY(-50%)',
  WebkitTransform: 'translateY(-50%)'
};

var assetIconStyle = {
  margin: '15px 0',
  fontSize: '32px'
};

module.exports = React.createClass({
  displayName: 'exports',

  propTypes: {
    name: React.PropTypes.string.isRequired,
    type: React.PropTypes.oneOf(['image', 'audio', 'video']).isRequired
  },

  render: function render() {
    var type = this.props.type;
    var name = this.props.name;

    return React.createElement(
      'td',
      { width: '80' },
      React.createElement(
        'div',
        { className: 'assetThumbnail', style: {
            width: '60px',
            height: '60px',
            margin: '10px auto',
            background: '#eee',
            border: '1px solid #ccc',
            textAlign: 'center'
          } },
        type === 'image' ? React.createElement('img', { src: assetsApi.basePath(name), style: assetThumbnailStyle }) : React.createElement('i', { className: defaultIcons[type] || defaultIcons.unknown, style: assetIconStyle })
      )
    );
  }
});

},{"../clientApi":"/home/ubuntu/staging/apps/build/js/clientApi.js"}],"/home/ubuntu/staging/apps/build/js/templates/StudioAppWrapper.jsx":[function(require,module,exports){
'use strict';

var RotateContainer = require('../templates/RotateContainer.jsx');

/**
 * Wrapper component for all Code Studio app types, which provides rotate
 * container and clear-div but otherwise just renders children.
 */
var StudioAppWrapper = React.createClass({
  displayName: 'StudioAppWrapper',

  propTypes: {
    assetUrl: React.PropTypes.func.isRequired,
    isEmbedView: React.PropTypes.bool.isRequired,
    isShareView: React.PropTypes.bool.isRequired
  },

  requiresLandscape: function requiresLandscape() {
    return !(this.props.isEmbedView || this.props.isShareView);
  },

  render: function render() {
    return React.createElement(
      'div',
      null,
      this.requiresLandscape() && React.createElement(RotateContainer, { assetUrl: this.props.assetUrl }),
      this.props.children,
      React.createElement('div', { className: 'clear' })
    );
  }
});
module.exports = StudioAppWrapper;

},{"../templates/RotateContainer.jsx":"/home/ubuntu/staging/apps/build/js/templates/RotateContainer.jsx"}],"/home/ubuntu/staging/apps/build/js/templates/RotateContainer.jsx":[function(require,module,exports){
'use strict';

var msg = require('../locale');

/**
 * "Rotate your device" overlay.
 */
var RotateContainer = React.createClass({
  displayName: 'RotateContainer',

  propTypes: {
    assetUrl: React.PropTypes.func.isRequired
  },

  render: function render() {
    return React.createElement(
      'div',
      { id: 'rotateContainer', style: this.getStyle() },
      React.createElement(
        'div',
        { id: 'rotateText' },
        React.createElement(
          'p',
          null,
          msg.rotateText(),
          React.createElement('br', null),
          msg.orientationLock()
        )
      )
    );
  },

  getStyle: function getStyle() {
    return {
      backgroundImage: 'url(' + this.props.assetUrl('media/turnphone_horizontal.png') + ')'
    };
  }
});
module.exports = RotateContainer;

},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js"}],"/home/ubuntu/staging/apps/build/js/templates/ProtectedStatefulDiv.jsx":[function(require,module,exports){
'use strict';

/**
 * A div DOM element that will never update its contents and will throw an
 * exception if it is ever unmounted, enforcing that it must always be rendered
 * because its contents may contain state that the application is depending on.
 *
 * Useful when React is wrapping external libraries or parts of our UI that are
 * not yet driven by React.
 */

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var ProtectedStatefulDiv = React.createClass({
  displayName: 'ProtectedStatefulDiv',

  propTypes: {
    renderContents: React.PropTypes.func
  },

  shouldComponentUpdate: function shouldComponentUpdate() {
    return false;
  },

  componentDidMount: function componentDidMount() {
    if (typeof this.props.renderContents === 'function') {
      this.refs.root.innerHTML = this.props.renderContents();
    }
  },

  componentWillUnmount: function componentWillUnmount() {
    throw new Error("Unmounting a ProtectedStatefulDiv is not allowed.");
  },

  render: function render() {
    return React.createElement('div', _extends({}, this.props, { ref: 'root' }));
  }
});
module.exports = ProtectedStatefulDiv;

},{}],"/home/ubuntu/staging/apps/build/js/appMain.js":[function(require,module,exports){
'use strict';

var utils = require('./utils');
var _ = utils.getLodash();
var requiredBlockUtils = require('./required_block_utils');
var studioApp = require('./StudioApp').singleton;
var authoredHintUtils = require('./authoredHintUtils');

// TODO (br-pair) : This is to expose methods we need in the global namespace
// for testing purpose. Would be nice to eliminate this eventually.
window.__TestInterface = {
  loadBlocks: _.bind(studioApp.loadBlocks, studioApp),
  arrangeBlockPosition: _.bind(studioApp.arrangeBlockPosition, studioApp),
  getDropletContents: function getDropletContents() {
    return _.bind(studioApp.editor.getValue, studioApp.editor)();
  },
  getDroplet: function getDroplet() {
    return studioApp.editor;
  },
  // Set to true to ignore onBeforeUnload events
  ignoreOnBeforeUnload: false
};

var addReadyListener = require('./dom').addReadyListener;
var blocksCommon = require('./blocksCommon');

module.exports = function (app, levels, options) {

  // If a levelId is not provided, then options.level is specified in full.
  // Otherwise, options.level overrides resolved level on a per-property basis.
  if (options.levelId) {
    var level = levels[options.levelId];
    options.level = options.level || {};
    options.level.id = options.levelId;
    for (var prop in options.level) {
      level[prop] = options.level[prop];
    }

    if (options.level.levelBuilderRequiredBlocks) {
      level.requiredBlocks = requiredBlockUtils.makeTestsFromBuilderRequiredBlocks(options.level.levelBuilderRequiredBlocks);
    }
    if (options.level.levelBuilderRecommendedBlocks) {
      level.recommendedBlocks = requiredBlockUtils.makeTestsFromBuilderRequiredBlocks(options.level.levelBuilderRecommendedBlocks);
    }

    if (options.level.authoredHints) {
      level.authoredHints = authoredHintUtils.generateAuthoredHints(options.level.authoredHints);
    }

    options.level = level;
  }

  studioApp.configure(options);

  options.skin = options.skinsModule.load(studioApp.assetUrl, options.skinId);

  if (studioApp.isUsingBlockly()) {
    var blockInstallOptions = {
      skin: options.skin,
      isK1: options.level && options.level.isK1,
      level: options.level
    };

    if (options.level && options.level.edit_blocks) {
      utils.wrapNumberValidatorsForLevelBuilder();
    }

    blocksCommon.install(Blockly, blockInstallOptions);
    options.blocksModule.install(Blockly, blockInstallOptions);
  }

  addReadyListener(function () {
    if (options.readonly) {
      if (app.initReadonly) {
        app.initReadonly(options);
      } else {
        studioApp.initReadonly(options);
      }
    } else {
      app.init(options);
      if (options.onInitialize) {
        options.onInitialize();
      }
    }
  });
};

},{"./StudioApp":"/home/ubuntu/staging/apps/build/js/StudioApp.js","./authoredHintUtils":"/home/ubuntu/staging/apps/build/js/authoredHintUtils.js","./blocksCommon":"/home/ubuntu/staging/apps/build/js/blocksCommon.js","./dom":"/home/ubuntu/staging/apps/build/js/dom.js","./required_block_utils":"/home/ubuntu/staging/apps/build/js/required_block_utils.js","./utils":"/home/ubuntu/staging/apps/build/js/utils.js"}],"/home/ubuntu/staging/apps/build/js/required_block_utils.js":[function(require,module,exports){
/* global Text */

'use strict';

var xml = require('./xml');
var blockUtils = require('./block_utils');
var utils = require('./utils');
var msg = require('./locale');
var _ = utils.getLodash();

/**
 * Create the textual XML for a math_number block.
 * @param {number|string} number The numeric amount, expressed as a
 *     number or string.  Non-numeric strings may also be specified,
 *     such as '???'.
 * @return {string} The textual representation of a math_number block.
 */
exports.makeMathNumber = function (number) {
  return '<block type="math_number"><title name="NUM">' + number + '</title></block>';
};

/**
 * Generate a required blocks dictionary for a simple block that does not
 * have any parameters or values.
 * @param {string} block_type The block type.
 * @return {Object} A required blocks dictionary able to check for and
 *     generate the specified block.
 */
exports.simpleBlock = function (block_type) {
  return { test: function test(block) {
      return block.type == block_type;
    },
    type: block_type };
};

/**
 * Generate a required blocks dictionary for a repeat loop.  This does not
 * test for the specified repeat count but includes it in the suggested block.
 * @param {number|string} count The suggested repeat count.
 * @return {Object} A required blocks dictionary able to check for and
 *     generate the specified block.
 */
exports.repeat = function (count) {
  // This checks for a controls_repeat block rather than looking for 'for',
  // since the latter may be generated by Turtle 2's draw_a_square.
  return { test: function test(block) {
      return block.type == 'controls_repeat';
    },
    type: 'controls_repeat', titles: { 'TIMES': count } };
};

/**
 * Generate a required blocks dictionary for a simple repeat loop.  This does not
 * test for the specified repeat count but includes it in the suggested block.
 * @param {number|string} count The suggested repeat count.
 * @return {Object} A required blocks dictionary able to check for and
 *     generate the specified block.
 */
exports.repeatSimpleBlock = function (count) {
  return { test: function test(block) {
      return block.type == 'controls_repeat_simplified';
    },
    type: 'controls_repeat_simplified', titles: { 'TIMES': count } };
};

/**
 * Returns an array of required blocks by comparing a list of blocks with
 * a list of app specific block tests (defined in <app>/requiredBlocks.js)
 */
exports.makeTestsFromBuilderRequiredBlocks = function (customRequiredBlocks) {
  var blocksXml = xml.parseElement(customRequiredBlocks);

  var requiredBlocksTests = [];
  Array.prototype.forEach.call(blocksXml.childNodes, function (childNode) {
    // Only look at element nodes
    if (childNode.nodeType !== 1) {
      return;
    }
    switch (childNode.getAttribute('type')) {
      case 'pick_one':
        requiredBlocksTests.push(testsFromPickOne(childNode));
        break;
      case 'procedures_defnoreturn':
      case 'procedures_defreturn':
        requiredBlocksTests.push(testsFromProcedure(childNode));
        break;
      case 'functional_definition':
        break;
      case 'functional_call':
        requiredBlocksTests.push(testsFromFunctionalCall(childNode, blocksXml));
        break;
      default:
        requiredBlocksTests.push([testFromBlock(childNode)]);
    }
  });

  return requiredBlocksTests;
};

/**
 * Given xml for a single block generates a block test
 */
function testFromBlock(node) {
  return {
    test: function test(userBlock) {
      // Encode userBlock while ignoring child statements
      var userElement = Blockly.Xml.blockToDom(userBlock, true);
      return elementsEquivalent(node, userElement);
    },
    blockDisplayXML: xml.serialize(node)
  };
}

/**
 * Given xml for a pick_one block, generates a test that checks that at least
 * one of the child blocks is used.  If none are used, the first option will be
 * displayed as feedback
 */
function testsFromPickOne(node) {
  var tests = [];
  // child of pick_one is a statement block.  we want first child of that
  var statement = node.getElementsByTagName('statement')[0];
  var block = statement.getElementsByTagName('block')[0];
  var next;
  do {
    // if we have a next block, we want to generate our test without that
    next = block.getElementsByTagName('next')[0];
    if (next) {
      block.removeChild(next);
    }
    tests.push(testFromBlock(block));
    if (next) {
      block = next.getElementsByTagName('block')[0];
    }
  } while (next);
  return tests;
}

/**
 * Given xml for a procedure block, generates tests that check for required
 * number of params not declared
 */
function testsFromProcedure(node) {
  var paramCount = node.querySelectorAll('mutation > arg').length;
  var emptyBlock = node.cloneNode(true);
  emptyBlock.removeChild(emptyBlock.lastChild);
  return [{
    // Ensure that all required blocks match a block with the same number of
    // params. There's no guarantee users will name their function the same as
    // the required block, so only match on number of params.
    test: function test(userBlock) {
      if (userBlock.type === node.getAttribute('type')) {
        return paramCount === userBlock.parameterNames_.length;
      }
      // Block isn't the same type, return false to keep searching.
      return false;
    },
    message: msg.errorRequiredParamsMissing(),
    blockDisplayXML: '<xml></xml>'
  }];
}

function testsFromFunctionalCall(node, blocksXml) {
  var name = node.querySelector('mutation').getAttribute('name');
  var argElements = node.querySelectorAll('arg');
  var types = [];
  for (var i = 0; i < argElements.length; i++) {
    types.push(argElements[i].getAttribute('type'));
  }

  var definition = _.find(blocksXml.childNodes, function (sibling) {
    if (sibling.getAttribute('type') !== 'functional_definition') {
      return false;
    }
    var nameElement = sibling.querySelector('title[name="NAME"]');
    if (!nameElement) {
      return false;
    }
    return nameElement.textContent === name;
  });

  if (!definition) {
    throw new Error('No matching definition for functional_call');
  }

  return [{
    test: function test(userBlock) {
      if (userBlock.type !== 'functional_call' || userBlock.getCallName() !== name) {
        return false;
      }
      var userTypes = userBlock.getParamTypes();
      return _.isEqual(userTypes, types);
    },
    blockDisplayXML: xml.serialize(definition) + xml.serialize(node)
  }];
}

/**
 * Checks two DOM elements to see whether or not they are equivalent
 * We consider them equivalent if they have the same tagName, attributes,
 * and children
 */
function elementsEquivalent(expected, given) {
  if (!(expected instanceof Element && given instanceof Element)) {
    // if we expect ???, allow match with anything
    if (expected instanceof Text && expected.textContent === '???') {
      return true;
    }
    return expected.isEqualNode(given);
  }
  // Not fully clear to me why, but blockToDom seems to return us an element
  // with a tagName in all caps
  if (expected.tagName.toLowerCase() !== given.tagName.toLowerCase()) {
    return false;
  }

  if (!attributesEquivalent(expected, given)) {
    return false;
  }

  if (!childrenEquivalent(expected, given)) {
    return false;
  }

  return true;
}

/**
 * A list of attributes we want to ignore when comparing attributes, and a
 * function for easily determining whether an attribute is in the list.
 */
var ignorableAttributes = ['deletable', 'movable', 'editable', 'inline', 'uservisible', 'usercreated', 'id'];

ignorableAttributes.contains = function (attr) {
  return ignorableAttributes.indexOf(attr.name) !== -1;
};

/**
 * Checks whether the attributes for two different elements are equivalent
 */
function attributesEquivalent(expected, given) {
  var attributes1 = _.reject(expected.attributes, ignorableAttributes.contains);
  var attributes2 = _.reject(given.attributes, ignorableAttributes.contains);
  if (attributes1.length !== attributes2.length) {
    return false;
  }
  for (var i = 0; i < attributes1.length; i++) {
    var attr1 = attributes1[i];
    var attr2 = attributes2[i];
    if (attr1.name !== attr2.name) {
      return false;
    }
    if (attr1.value !== attr2.value) {
      return false;
    }
  }
  return true;
}

/**
 * Checks whether the children of two different elements are equivalent
 */
function childrenEquivalent(expected, given) {
  var children1 = expected.childNodes;
  var children2 = given.childNodes;
  if (children1.length !== children2.length) {
    return false;
  }
  for (var i = 0; i < children1.length; i++) {
    if (!elementsEquivalent(children1[i], children2[i])) {
      return false;
    }
  }
  return true;
}

/**
 * Checks if two blocks are "equivalent"
 * Currently means their type and all of their titles match exactly
 * @param blockA
 * @param blockB
 */
exports.blocksMatch = function (blockA, blockB) {
  var typesMatch = blockA.type === blockB.type;
  var titlesMatch = exports.blockTitlesMatch(blockA, blockB);
  return typesMatch && titlesMatch;
};

/**
 * Compares two blocks' titles, returns true if they all match
 * @returns {boolean}
 * @param blockA
 * @param blockB
 */
exports.blockTitlesMatch = function (blockA, blockB) {
  var blockATitles = blockA.getTitles();
  var blockBTitles = blockB.getTitles();

  var nameCompare = function nameCompare(a, b) {
    return a.name < b.name;
  };
  blockATitles.sort(nameCompare);
  blockBTitles.sort(nameCompare);

  for (var i = 0; i < blockATitles.length || i < blockBTitles.length; i++) {
    var blockATitle = blockATitles[i];
    var blockBTitle = blockBTitles[i];
    if (!blockATitle || !blockBTitle || !titlesMatch(blockATitle, blockBTitle)) {
      return false;
    }
  }
  return true;
};

var titlesMatch = function titlesMatch(titleA, titleB) {
  return titleB.name === titleA.name && titleB.getValue() === titleA.getValue();
};

},{"./block_utils":"/home/ubuntu/staging/apps/build/js/block_utils.js","./locale":"/home/ubuntu/staging/apps/build/js/locale.js","./utils":"/home/ubuntu/staging/apps/build/js/utils.js","./xml":"/home/ubuntu/staging/apps/build/js/xml.js"}],"/home/ubuntu/staging/apps/build/js/blocksCommon.js":[function(require,module,exports){
/**
 * Defines blocks useful in multiple blockly apps
 */
'use strict';

var commonMsg = require('./locale');

/**
 * Install extensions to Blockly's language and JavaScript generator
 * @param blockly instance of Blockly
 */
exports.install = function (blockly, blockInstallOptions) {
  var skin = blockInstallOptions.skin;
  var isK1 = blockInstallOptions.isK1;

  installControlsRepeatSimplified(blockly, skin);
  installControlsRepeatDropdown(blockly);
  installNumberDropdown(blockly);
  installPickOne(blockly);
  installCategory(blockly);
  installWhenRun(blockly, skin, isK1);
};

function installControlsRepeatSimplified(blockly, skin) {
  // Re-uses the repeat block generator from core
  blockly.JavaScript.controls_repeat_simplified = blockly.JavaScript.controls_repeat;
  blockly.JavaScript.controls_repeat_simplified_dropdown = blockly.JavaScript.controls_repeat;

  blockly.Blocks.controls_repeat_simplified = {
    // Repeat n times (internal number) with simplified UI
    init: function init() {
      this.setHelpUrl(blockly.Msg.CONTROLS_REPEAT_HELPURL);
      this.setHSV(322, 0.90, 0.95);
      this.appendDummyInput().appendTitle(blockly.Msg.CONTROLS_REPEAT_TITLE_REPEAT).appendTitle(new blockly.FieldTextInput('10', blockly.FieldTextInput.nonnegativeIntegerValidator), 'TIMES');
      this.appendStatementInput('DO').appendTitle(new blockly.FieldImage(skin.repeatImage));
      this.setPreviousStatement(true);
      this.setNextStatement(true);
      this.setTooltip(blockly.Msg.CONTROLS_REPEAT_TOOLTIP);
    }
  };

  blockly.Blocks.controls_repeat_simplified_dropdown = {
    // Repeat n times (internal number) with simplified UI
    init: function init() {
      this.setHelpUrl(blockly.Msg.CONTROLS_REPEAT_HELPURL);
      this.setHSV(322, 0.90, 0.95);
      this.appendDummyInput().appendTitle(blockly.Msg.CONTROLS_REPEAT_TITLE_REPEAT).appendTitle(new blockly.FieldDropdown(), 'TIMES');
      this.appendStatementInput('DO').appendTitle(new blockly.FieldImage(skin.repeatImage));
      this.setPreviousStatement(true);
      this.setNextStatement(true);
      this.setTooltip(blockly.Msg.CONTROLS_REPEAT_TOOLTIP);
    }
  };
}

function installControlsRepeatDropdown(blockly) {
  blockly.JavaScript.controls_repeat_dropdown = blockly.JavaScript.controls_repeat;

  blockly.Blocks.controls_repeat_dropdown = {
    // Repeat n times (internal number) with a customizable dropdown of # choices.
    init: function init() {
      this.setHelpUrl(blockly.Msg.CONTROLS_REPEAT_HELPURL);
      this.setHSV(322, 0.90, 0.95);
      this.appendDummyInput().appendTitle(blockly.Msg.CONTROLS_REPEAT_TITLE_REPEAT).appendTitle(new blockly.FieldDropdown(), 'TIMES').appendTitle(blockly.Msg.CONTROLS_REPEAT_TITLE_TIMES);
      this.appendStatementInput('DO').appendTitle(blockly.Msg.CONTROLS_REPEAT_INPUT_DO);
      this.setPreviousStatement(true);
      this.setNextStatement(true);
      this.setTooltip(blockly.Msg.CONTROLS_REPEAT_TOOLTIP);
    }
  };
}

function installNumberDropdown(blockly) {
  blockly.JavaScript.math_number_dropdown = blockly.JavaScript.math_number;

  blockly.Blocks.math_number_dropdown = {
    // Numeric value with a customizable dropdown.
    init: function init() {
      this.setHelpUrl(blockly.Msg.MATH_NUMBER_HELPURL);
      this.setHSV(258, 0.35, 0.62);
      this.appendDummyInput().appendTitle(new blockly.FieldDropdown(), 'NUM');
      this.setOutput(true, Blockly.BlockValueType.NUMBER);
      this.setTooltip(blockly.Msg.MATH_NUMBER_TOOLTIP);
    }
  };
}

// A "Pick 1" block for level editing, where you want to require that one of a
// set of blocks is used.
function installPickOne(blockly) {
  blockly.Blocks.pick_one = {
    // Repeat n times (internal number).
    init: function init() {
      this.setHSV(322, 0.90, 0.95);

      // Not localized as this is only used by level builders
      this.appendDummyInput().appendTitle('Pick one (Use only in required blocks)');
      this.appendStatementInput('PICK');
    }
  };

  blockly.JavaScript.pick_one = function () {
    return '\n';
  };
}

// A "Category" block for level editing, for delineating category groups.
function installCategory(blockly) {
  blockly.Blocks.category = {
    // Repeat n times (internal number).
    init: function init() {
      this.setHSV(322, 0.90, 0.95);
      this.setInputsInline(true);

      // Not localized as this is only used by level builders
      this.appendDummyInput().appendTitle('Category').appendTitle(new blockly.FieldTextInput('Name'), 'CATEGORY');
      this.setPreviousStatement(false);
      this.setNextStatement(false);
    }
  };

  blockly.JavaScript.category = function () {
    return '\n';
  };
}

function installWhenRun(blockly, skin, isK1) {
  blockly.Blocks.when_run = {
    // Block to handle event where mouse is clicked
    helpUrl: '',
    init: function init() {
      this.setHSV(39, 1.00, 0.99);
      if (isK1) {
        this.appendDummyInput().appendTitle(commonMsg.whenRun()).appendTitle(new blockly.FieldImage(skin.runArrow));
      } else {
        this.appendDummyInput().appendTitle(commonMsg.whenRun());
      }
      this.setPreviousStatement(false);
      this.setNextStatement(true);
    },
    shouldBeGrayedOut: function shouldBeGrayedOut() {
      return false;
    }
  };

  blockly.JavaScript.when_run = function () {
    // Generate JavaScript for handling click event.
    return '\n';
  };
}

},{"./locale":"/home/ubuntu/staging/apps/build/js/locale.js"}],"/home/ubuntu/staging/apps/build/js/StudioApp.js":[function(require,module,exports){
/* global Blockly, ace:true, droplet, marked, dashboard, addToHome */

'use strict';

var aceMode = require('./acemode/mode-javascript_codeorg');
var parseXmlElement = require('./xml').parseElement;
var utils = require('./utils');
var dropletUtils = require('./dropletUtils');
var _ = utils.getLodash();
var dom = require('./dom');
var constants = require('./constants.js');
var msg = require('./locale');
var blockUtils = require('./block_utils');
var DropletTooltipManager = require('./blockTooltips/DropletTooltipManager');
var url = require('url');
var FeedbackUtils = require('./feedback');
var VersionHistory = require('./templates/VersionHistory.jsx');
var Alert = require('./templates/alert.jsx');
var codegen = require('./codegen');
var puzzleRatingUtils = require('./puzzleRatingUtils');
var logToCloud = require('./logToCloud');
var AuthoredHints = require('./authoredHints');
var Instructions = require('./templates/Instructions.jsx');
var WireframeSendToPhone = require('./templates/WireframeSendToPhone.jsx');
var assetsApi = require('./clientApi').assets;
var assetPrefix = require('./assetManagement/assetPrefix');
var assetListStore = require('./assetManagement/assetListStore');
var copyrightStrings;

/**
* The minimum width of a playable whole blockly game.
*/
var MIN_WIDTH = 900;
var DEFAULT_MOBILE_NO_PADDING_SHARE_WIDTH = 320;
var MAX_VISUALIZATION_WIDTH = 400;
var MIN_VISUALIZATION_WIDTH = 200;

var ENGLISH_LOCALE = 'en_us';

/**
 * Treat mobile devices with screen.width less than the value below as phones.
 */
var MAX_PHONE_WIDTH = 500;

var StudioApp = function StudioApp() {
  this.feedback_ = new FeedbackUtils(this);
  this.authoredHintsController_ = new AuthoredHints(this);

  /**
  * The parent directory of the apps. Contains common.js.
  */
  this.BASE_URL = undefined;

  /**
  * The current locale code.
  */
  this.LOCALE = ENGLISH_LOCALE;

  this.enableShowCode = true;
  this.editCode = false;
  this.usingBlockly_ = true;

  /**
   * @type {AudioPlayer}
   */
  this.cdoSounds = null;
  this.Dialog = null;
  /**
   * @type {?Droplet.Editor}
   */
  this.editor = null;
  /**
   * @type {?DropletTooltipManager}
   */
  this.dropletTooltipManager = null;

  // @type {string} for all of these
  this.icon = undefined;
  this.smallIcon = undefined;
  this.winIcon = undefined;
  this.failureIcon = undefined;

  // The following properties get their non-default values set by the application.

  /**
   * Whether to alert user to empty blocks, short-circuiting all other tests.
   * @member {boolean}
   */
  this.checkForEmptyBlocks_ = false;

  /**
  * The ideal number of blocks to solve this level.  Users only get 2
  * stars if they use more than this number.
  * @type {number}
  */
  this.IDEAL_BLOCK_NUM = undefined;

  /**
   * @typedef {Object} TestableBlock
   * @property {string|function} test - A test whether the block is
   *           present, either:
   *           - A string, in which case the string is searched for in
   *             the generated code.
   *           - A single-argument function is called on each user-added
   *             block individually.  If any call returns true, the block
   *             is deemed present.  "User-added" blocks are ones that are
   *             neither disabled or undeletable.
   * @property {string} type - The type of block to be produced for
   *           display to the user if the test failed.
   * @property {Object} [titles] - A dictionary, where, for each
   *           KEY-VALUE pair, this is added to the block definition:
   *           <title name="KEY">VALUE</title>.
   * @property {Object} [value] - A dictionary, where, for each
   *           KEY-VALUE pair, this is added to the block definition:
   *           <value name="KEY">VALUE</value>
   * @property {string} [extra] - A string that should be blacked
   *           between the "block" start and end tags.
   */

  /**
  * @type {!TestableBlock[]}
  */
  this.requiredBlocks_ = [];

  /**
  * The number of required blocks to give hints about at any one time.
  * Set this to Infinity to show all.
  * @type {number}
  */
  this.maxRequiredBlocksToFlag_ = 1;

  /**
  * @type {!TestableBlock[]}
  */
  this.recommendedBlocks_ = [];

  /**
  * The number of recommended blocks to give hints about at any one time.
  * Set this to Infinity to show all.
  * @type {number}
  */
  this.maxRecommendedBlocksToFlag_ = 1;

  /**
  * The number of attempts (how many times the run button has been pressed)
  * @type {?number}
  */
  this.attempts = 0;

  /**
  * Stores the time at init. The delta to current time is used for logging
  * and reporting to capture how long it took to arrive at an attempt.
  * @type {?number}
  */
  this.initTime = undefined;

  /**
  * Enumeration of user program execution outcomes.
  */
  this.ResultType = constants.ResultType;

  /**
  * Enumeration of test results.
  */
  this.TestResults = constants.TestResults;

  /**
   * If true, we don't show blockspace. Used when viewing shared levels
   */
  this.hideSource = false;

  /**
   * If true, we're viewing a shared level.
   */
  this.share = false;

  /**
   * By default, we center our embedded levels. Can be overriden by apps.
   */
  this.centerEmbedded = true;

  /**
   * If set to true, we use our wireframe share (or chromeless share on mobile)
   */
  this.wireframeShare = false;

  this.onAttempt = undefined;
  this.onContinue = undefined;
  this.onResetPressed = undefined;
  this.backToPreviousLevel = undefined;
  this.sendToPhone = undefined;
  this.enableShowBlockCount = true;

  this.disableSocialShare = false;
  this.noPadding = false;

  this.MIN_WORKSPACE_HEIGHT = undefined;
};
module.exports = StudioApp;
StudioApp.singleton = new StudioApp();

/**
 * Configure StudioApp options
 */
StudioApp.prototype.configure = function (options) {
  this.BASE_URL = options.baseUrl;
  this.LOCALE = options.locale || this.LOCALE;
  // NOTE: editCode (which currently implies droplet) and usingBlockly_ are
  // currently mutually exclusive.
  this.editCode = options.level && options.level.editCode;
  this.usingBlockly_ = !this.editCode;

  // TODO (bbuchanan) : Replace this editorless-hack with setting an editor enum
  // or (even better) inject an appropriate editor-adaptor.
  if (options.isEditorless) {
    this.editCode = false;
    this.usingBlockly_ = false;
  }

  this.cdoSounds = options.cdoSounds;
  this.Dialog = options.Dialog;

  // Bind assetUrl to the instance so that we don't need to depend on callers
  // binding correctly as they pass this function around.
  this.assetUrl = _.bind(this.assetUrl_, this);

  this.maxVisualizationWidth = options.maxVisualizationWidth || MAX_VISUALIZATION_WIDTH;
  this.minVisualizationWidth = options.minVisualizationWidth || MIN_VISUALIZATION_WIDTH;
};

StudioApp.prototype.hasInstructionsToShow = function (config) {
  return !!(config.level.instructions || config.level.aniGifURL);
};

/**
 * Common startup tasks for all apps. Happens after configure.
 */
StudioApp.prototype.init = function (config) {
  if (!config) {
    config = {};
  }

  config.getCode = this.getCode.bind(this);
  copyrightStrings = config.copyrightStrings;

  if (config.isLegacyShare && config.hideSource) {
    $("body").addClass("legacy-share-view");
    if (dom.isMobile()) {
      $('#main-logo').hide();
    }
    if (dom.isIOS() && !window.navigator.standalone) {
      addToHome.show(true);
    }
  }

  this.setConfigValues_(config);

  this.configureDom(config);

  if (config.usesAssets) {
    assetPrefix.init(config);

    // Pre-populate asset list
    assetsApi.ajax('GET', '', function (xhr) {
      assetListStore.reset(JSON.parse(xhr.responseText));
    }, function () {
      // Unable to load asset list
    });
  }

  if (config.hideSource) {
    this.handleHideSource_({
      containerId: config.containerId,
      embed: config.embed,
      level: config.level,
      level_source_id: config.level_source_id,
      phone_share_url: config.send_to_phone_url,
      sendToPhone: config.sendToPhone,
      twitter: config.twitter,
      app: config.app,
      isLegacyShare: config.isLegacyShare
    });
  }

  if (config.share) {
    this.handleSharing_({
      makeUrl: config.makeUrl,
      makeString: config.makeString,
      makeImage: config.makeImage,
      makeYourOwn: config.makeYourOwn
    });
  }

  this.authoredHintsController_.init(config.level.authoredHints, config.scriptId, config.serverLevelId);
  if (config.authoredHintViewRequestsUrl) {
    this.authoredHintsController_.submitHints(config.authoredHintViewRequestsUrl);
  }

  if (config.puzzleRatingsUrl) {
    puzzleRatingUtils.submitCachedPuzzleRatings(config.puzzleRatingsUrl);
  }

  // Record time at initialization.
  this.initTime = new Date().getTime();

  // Fixes viewport for small screens.
  var viewport = document.querySelector('meta[name="viewport"]');
  if (viewport) {
    this.fixViewportForSmallScreens_(viewport, config);
  }

  var showCode = document.getElementById('show-code-header');
  if (showCode && this.enableShowCode) {
    dom.addClickTouchEvent(showCode, _.bind(function () {
      if (this.editCode) {
        var result;
        var nonDropletError = false;
        // are we trying to toggle from blocks to text (or the opposite)
        var fromBlocks = this.editor.currentlyUsingBlocks;
        try {
          result = this.editor.toggleBlocks();
        } catch (err) {
          nonDropletError = true;
          result = { error: err };
        }
        if (result && result.error) {
          logToCloud.addPageAction(logToCloud.PageAction.DropletTransitionError, {
            dropletError: !nonDropletError,
            fromBlocks: fromBlocks
          });
          this.feedback_.showToggleBlocksError(this.Dialog);
        }
        this.onDropletToggle_();
      } else {
        this.feedback_.showGeneratedCode(this.Dialog, config.appStrings);
      }
    }, this));
  }

  var blockCount = document.getElementById('blockCounter');
  if (blockCount && !this.enableShowBlockCount) {
    blockCount.style.display = 'none';
  }

  this.setIconsFromSkin(config.skin);

  if (config.level.instructionsIcon) {
    this.icon = config.skin[config.level.instructionsIcon];
    this.winIcon = config.skin[config.level.instructionsIcon];
  }

  if (config.showInstructionsWrapper) {
    config.showInstructionsWrapper(_.bind(function () {
      var shouldAutoClose = !!config.level.aniGifURL;
      this.showInstructions_(config.level, shouldAutoClose, false);
    }, this));
  }

  // In embed mode, the display scales down when the width of the
  // visualizationColumn goes below the min width
  if (config.embed && config.centerEmbedded) {
    var resized = false;
    var resize = function resize() {
      var vizCol = document.getElementById('visualizationColumn');
      var width = vizCol.offsetWidth;
      var height = vizCol.offsetHeight;
      var displayWidth = DEFAULT_MOBILE_NO_PADDING_SHARE_WIDTH;
      var scale = Math.min(width / displayWidth, height / displayWidth);
      var viz = document.getElementById('visualization');
      viz.style['transform-origin'] = 'left top';
      viz.style['-webkit-transform'] = 'scale(' + scale + ')';
      viz.style['max-height'] = displayWidth * scale + 'px';
      viz.style.display = 'block';
      vizCol.style.width = '';
      vizCol.style.maxWidth = displayWidth + 'px';
      // Needs to run twice on initialization
      if (!resized) {
        resized = true;
        resize();
      }
    };
    // Depends on ResizeSensor.js
    var ResizeSensor = require('./ResizeSensor');
    ResizeSensor(document.getElementById('visualizationColumn'), resize);
  }

  var orientationHandler = function orientationHandler() {
    window.scrollTo(0, 0); // Browsers like to mess with scroll on rotate.
  };
  window.addEventListener('orientationchange', orientationHandler);
  orientationHandler();

  if (config.loadAudio) {
    config.loadAudio();
  }

  var promptDiv = document.getElementById('prompt');
  var prompt2Div = document.getElementById('prompt2');
  if (config.level.instructions) {
    var instructionsHtml = this.substituteInstructionImages(config.level.instructions);
    $(promptDiv).html(instructionsHtml);
  }
  if (config.level.instructions2) {
    var instructions2Html = this.substituteInstructionImages(config.level.instructions2);
    $(prompt2Div).html(instructions2Html);
    $(prompt2Div).show();
  }

  if (this.hasInstructionsToShow(config)) {
    var promptIcon = document.getElementById('prompt-icon');
    if (this.smallIcon) {
      promptIcon.src = this.smallIcon;
      $('#prompt-icon-cell').show();
    }

    var bubble = document.getElementById('bubble');

    this.authoredHintsController_.display(promptIcon, bubble, (function () {
      this.showInstructions_(config.level, false, true);
    }).bind(this));
  }

  var aniGifPreview = document.getElementById('ani-gif-preview');
  if (config.level.aniGifURL) {
    aniGifPreview.style.backgroundImage = "url('" + config.level.aniGifURL + "')";
    var promptTable = document.getElementById('prompt-table');
    promptTable.className += " with-ani-gif";
  } else {
    var wrapper = document.getElementById('ani-gif-preview-wrapper');
    wrapper.style.display = 'none';
  }

  if (this.editCode) {
    this.handleEditCode_(config);
  }

  if (this.isUsingBlockly()) {
    this.handleUsingBlockly_(config);
  } else {
    // handleUsingBlockly_ already does an onResize. We still want that goodness
    // if we're not blockly
    this.onResize();
  }

  var vizResizeBar = document.getElementById('visualizationResizeBar');
  if (vizResizeBar) {
    dom.addMouseDownTouchEvent(vizResizeBar, _.bind(this.onMouseDownVizResizeBar, this));

    // Can't use dom.addMouseUpTouchEvent() because it will preventDefault on
    // all touchend events on the page, breaking click events...
    document.body.addEventListener('mouseup', _.bind(this.onMouseUpVizResizeBar, this));
    var mouseUpTouchEventName = dom.getTouchEventName('mouseup');
    if (mouseUpTouchEventName) {
      document.body.addEventListener(mouseUpTouchEventName, _.bind(this.onMouseUpVizResizeBar, this));
    }
  }

  window.addEventListener('resize', _.bind(this.onResize, this));

  this.reset(true);

  // Add display of blocks used.
  this.setIdealBlockNumber_();

  // TODO (cpirich): implement block count for droplet (for now, blockly only)
  if (this.isUsingBlockly()) {
    Blockly.mainBlockSpaceEditor.addChangeListener(_.bind(function () {
      this.updateBlockCount();
    }, this));

    if (config.level.openFunctionDefinition) {
      this.openFunctionDefinition_(config);
    }
  }

  // Bind listener to 'Clear Puzzle' button
  var hideIcon = utils.valueOr(config.skin.hideIconInClearPuzzle, false);
  var clearPuzzleHeader = document.getElementById('clear-puzzle-header');
  if (clearPuzzleHeader) {
    dom.addClickTouchEvent(clearPuzzleHeader, (function () {
      this.feedback_.showClearPuzzleConfirmation(this.Dialog, hideIcon, (function () {
        this.handleClearPuzzle(config);
      }).bind(this));
    }).bind(this));
  }

  // Bind listener to 'Version History' button
  var versionsHeader = document.getElementById('versions-header');
  if (versionsHeader) {
    dom.addClickTouchEvent(versionsHeader, (function () {
      var codeDiv = document.createElement('div');
      var dialog = this.createModalDialog({
        Dialog: this.Dialog,
        contentDiv: codeDiv,
        defaultBtnSelector: 'again-button',
        id: 'showVersionsModal'
      });
      ReactDOM.render(React.createElement(VersionHistory, {
        handleClearPuzzle: this.handleClearPuzzle.bind(this, config)
      }), codeDiv);

      dialog.show();
    }).bind(this));
  }

  if (this.isUsingBlockly() && Blockly.contractEditor) {
    Blockly.contractEditor.registerTestsFailedOnCloseHandler((function () {
      this.feedback_.showSimpleDialog(this.Dialog, {
        headerText: undefined,
        bodyText: msg.examplesFailedOnClose(),
        cancelText: msg.ignore(),
        confirmText: msg.tryAgain(),
        onConfirm: null,
        onCancel: function onCancel() {
          Blockly.contractEditor.hideIfOpen();
        }
      });

      // return true to indicate to blockly-core that we'll own closing the
      // contract editor
      return true;
    }).bind(this));
  }

  if (config.isLegacyShare && config.hideSource) {
    this.setupLegacyShareView();
  }
};

/**
 * Create a phone frame and container. Scale shared content (everything currently inside the visualization column)
 * to container width, fit container to the phone frame and add share footer.
 */
StudioApp.prototype.setupLegacyShareView = function () {
  var vizContainer = document.createElement('div');
  vizContainer.id = 'visualizationContainer';
  var vizColumn = document.getElementById('visualizationColumn');
  if (dom.isMobile()) {
    $(vizContainer).width($(vizColumn).width());
  }
  $(vizContainer).append(vizColumn.children);

  var phoneFrameScreen = document.createElement('div');
  phoneFrameScreen.id = 'phoneFrameScreen';
  $(phoneFrameScreen).append(vizContainer);
  $(vizColumn).append(phoneFrameScreen);

  this.renderShareFooter_(phoneFrameScreen);
  if (dom.isMobile) {
    // re-scale on resize events to adjust to orientation and navbar changes
    $(window).resize(this.scaleLegacyShare);
  }
  this.scaleLegacyShare();
};

StudioApp.prototype.scaleLegacyShare = function () {
  var vizContainer = document.getElementById('visualizationContainer');
  var vizColumn = document.getElementById('visualizationColumn');
  var phoneFrameScreen = document.getElementById('phoneFrameScreen');
  var vizWidth = $(vizContainer).width();

  // On mobile, scale phone frame to full screen (portrait). Otherwise use given dimensions from css.
  if (dom.isMobile()) {
    var screenWidth = Math.min(window.innerWidth, window.innerHeight);
    var screenHeight = Math.max(window.innerWidth, window.innerHeight);
    $(phoneFrameScreen).width(screenWidth);
    $(phoneFrameScreen).height(screenHeight);
    $(vizColumn).width(screenWidth);
  }

  var frameWidth = $(phoneFrameScreen).width();
  var scale = frameWidth / vizWidth;
  applyTransformOrigin(vizContainer, 'left top');
  applyTransformScale(vizContainer, 'scale(' + scale + ')');
};

StudioApp.prototype.substituteInstructionImages = function (htmlText) {
  if (htmlText) {
    for (var prop in this.skin.instructions2ImageSubstitutions) {
      var value = this.skin.instructions2ImageSubstitutions[prop];
      var substitutionHtml = '<span class="instructionsImageContainer"><img src="' + value + '" class="instructionsImage"/></span>';
      var re = new RegExp('\\[' + prop + '\\]', 'g');
      htmlText = htmlText.replace(re, substitutionHtml);
    }
  }

  return htmlText;
};

StudioApp.prototype.getCode = function () {
  if (!this.editCode) {
    throw "getCode() requires editCode";
  }
  if (this.hideSource) {
    return this.startBlocks_;
  } else {
    return this.editor.getValue();
  }
};

StudioApp.prototype.setIconsFromSkin = function (skin) {
  this.icon = skin.staticAvatar;
  this.smallIcon = skin.smallStaticAvatar;
  this.winIcon = skin.winAvatar;
  this.failureIcon = skin.failureAvatar;
};

/**
 * Reset the puzzle back to its initial state.
 * Search aliases: "Start Over", startOver
 * @param {Object} config - same config object passed to studioApp.init().
 */
StudioApp.prototype.handleClearPuzzle = function (config) {
  if (this.isUsingBlockly()) {
    if (Blockly.functionEditor) {
      Blockly.functionEditor.hideIfOpen();
    }
    Blockly.mainBlockSpace.clear();
    this.setStartBlocks_(config, false);
    if (config.level.openFunctionDefinition) {
      this.openFunctionDefinition_(config);
    }
  } else {
    var resetValue = '';
    if (config.level.startBlocks) {
      // Don't pass CRLF pairs to droplet until they fix CR handling:
      resetValue = config.level.startBlocks.replace(/\r\n/g, '\n');
    }
    // TODO (bbuchanan): This getValue() call is a workaround for a Droplet bug,
    // See https://github.com/droplet-editor/droplet/issues/137
    // Calling getValue() updates the cached ace editor value, which can be
    // out-of-date in droplet and cause an incorrect early-out.
    // Remove this line once that bug is fixed and our Droplet lib is updated.
    this.editor.getValue();
    this.editor.setValue(resetValue);
  }
  if (config.afterClearPuzzle) {
    config.afterClearPuzzle();
  }
};

/**
 * TRUE if the current app uses blockly (as opposed to editCode or another
 * editor)
 * @return {boolean}
 */
StudioApp.prototype.isUsingBlockly = function () {
  return this.usingBlockly_;
};

/**
 *
 */
StudioApp.prototype.handleSharing_ = function (options) {
  // 1. Move the buttons, 2. Hide the slider in the share page for mobile.
  var belowVisualization = document.getElementById('belowVisualization');
  if (dom.isMobile()) {
    var sliderCell = document.getElementById('slider-cell');
    if (sliderCell) {
      sliderCell.style.display = 'none';
    }
    if (belowVisualization) {
      var visualization = document.getElementById('visualization');
      belowVisualization.style.display = 'none';
      visualization.style.marginBottom = '0px';
    }
  }

  // Show flappy upsale on desktop and mobile.  Show learn upsale only on desktop
  var upSale = document.createElement('div');
  if (options.makeYourOwn) {
    upSale.innerHTML = require('./templates/makeYourOwn.html.ejs')({
      data: {
        makeUrl: options.makeUrl,
        makeString: options.makeString,
        makeImage: options.makeImage
      }
    });
    if (this.noPadding) {
      upSale.style.marginLeft = '10px';
    }
    belowVisualization.appendChild(upSale);
  } else if (typeof options.makeYourOwn === 'undefined') {
    upSale.innerHTML = require('./templates/learn.html.ejs')({
      assetUrl: this.assetUrl
    });
    belowVisualization.appendChild(upSale);
  }
};

StudioApp.prototype.renderShareFooter_ = function (container) {
  var footerDiv = document.createElement('div');
  footerDiv.setAttribute('id', 'footerDiv');
  container.appendChild(footerDiv);

  var reactProps = {
    i18nDropdown: '',
    copyrightInBase: false,
    copyrightStrings: copyrightStrings,
    baseMoreMenuString: window.dashboard.i18n.t('footer.built_on_code_studio'),
    baseStyle: {
      paddingLeft: 0,
      width: $("#visualization").width()
    },
    className: 'dark',
    menuItems: [{
      text: window.dashboard.i18n.t('footer.try_hour_of_code'),
      link: 'https://code.org/learn',
      newWindow: true
    }, {
      text: window.dashboard.i18n.t('footer.how_it_works'),
      link: location.href + "/edit",
      newWindow: false
    }, {
      text: window.dashboard.i18n.t('footer.copyright'),
      link: '#',
      copyright: true
    }, {
      text: window.dashboard.i18n.t('footer.tos'),
      link: "https://code.org/tos",
      newWindow: true
    }, {
      text: window.dashboard.i18n.t('footer.privacy'),
      link: "https://code.org/privacy",
      newWindow: true
    }],
    phoneFooter: true
  };

  ReactDOM.render(React.createElement(window.dashboard.SmallFooter, reactProps), footerDiv);
};

/**
 * Get the url of path appended to BASE_URL
 */
StudioApp.prototype.assetUrl_ = function (path) {
  if (this.BASE_URL === undefined) {
    throw new Error('StudioApp BASE_URL has not been set. ' + 'Call configure() first');
  }
  return this.BASE_URL + path;
};

/**
 * Reset the playing field to the start position and kill any pending
 * animation tasks.  This will typically be replaced by an application.
 * @param {boolean} shouldPlayOpeningAnimation True if an opening animation is
 *   to be played.
 */
StudioApp.prototype.reset = function (shouldPlayOpeningAnimation) {
  // TODO (bbuchanan): Look for comon reset logic we can pull here
  // Override in app subclass
};

/**
 * Override to change run behavior.
 */
StudioApp.prototype.runButtonClick = function () {};

/**
 * Toggle whether run button or reset button is shown
 * @param {string} button Button to show, either "run" or "reset"
 */
StudioApp.prototype.toggleRunReset = function (button) {
  var showRun = button === 'run';
  if (button !== 'run' && button !== 'reset') {
    throw "Unexpected input";
  }

  var run = document.getElementById('runButton');
  var reset = document.getElementById('resetButton');
  run.style.display = showRun ? 'inline-block' : 'none';
  run.disabled = !showRun;
  reset.style.display = !showRun ? 'inline-block' : 'none';
  reset.disabled = showRun;

  // Toggle soft-buttons (all have the 'arrow' class set):
  $('.arrow').prop("disabled", showRun);
};

/**
 * Attempts to associate a set of audio files to a given name
 * Handles the case where cdoSounds does not exist, e.g. in tests
 * and grunt dev preview mode
 * @param {Object} audioConfig sound configuration
 */
StudioApp.prototype.registerAudio = function (audioConfig) {
  if (!this.cdoSounds) {
    return;
  }

  this.cdoSounds.register(audioConfig);
};

/**
 * Attempts to associate a set of audio files to a given name
 * Handles the case where cdoSounds does not exist, e.g. in tests
 * and grunt dev preview mode
 * @param {Array.<string>} filenames file paths for sounds
 * @param {string} name ID to associate sound effect with
 */
StudioApp.prototype.loadAudio = function (filenames, name) {
  if (!this.cdoSounds) {
    return;
  }

  this.cdoSounds.registerByFilenamesAndID(filenames, name);
};

/**
 * Attempts to play a sound effect
 * @param {string} name sound ID
 * @param {Object} options for sound playback
 * @param {number} options.volume value between 0.0 and 1.0 specifying volume
 * @param {function} [options.onEnded]
 */
StudioApp.prototype.playAudio = function (name, options) {
  if (!this.cdoSounds) {
    return;
  }

  options = options || {};
  var defaultOptions = { volume: 0.5 };
  var newOptions = utils.extend(defaultOptions, options);
  this.cdoSounds.play(name, newOptions);
};

/**
 * Stops looping a given sound
 * @param {string} name ID of sound
 */
StudioApp.prototype.stopLoopingAudio = function (name) {
  if (!this.cdoSounds) {
    return;
  }

  this.cdoSounds.stopLoopingAudio(name);
};

/**
* @param {Object} options Configuration parameters for Blockly. Parameters are
* optional and include:
*  - {string} path The root path to the /apps directory, defaults to the
*    the directory in which this script is located.
*  - {boolean} rtl True if the current language right to left.
*  - {DomElement} toolbox The element in which to insert the toolbox,
*    defaults to the element with 'toolbox'.
*  - {boolean} trashcan True if the trashcan should be displayed, defaults to
*    true.
* @param {Element} div The parent div in which to insert Blockly.
*/
StudioApp.prototype.inject = function (div, options) {
  var defaults = {
    assetUrl: this.assetUrl,
    rtl: this.isRtl(),
    toolbox: document.getElementById('toolbox'),
    trashcan: true,
    customSimpleDialog: this.feedback_.showSimpleDialog.bind(this.feedback_, this.Dialog)
  };
  Blockly.inject(div, utils.extend(defaults, options), this.cdoSounds);
};

/**
 * Returns true if the current HTML page is in right-to-left language mode.
 */
StudioApp.prototype.isRtl = function () {
  var head = document.getElementsByTagName('head')[0];
  if (head && head.parentElement) {
    var dir = head.parentElement.getAttribute('dir');
    return dir && dir.toLowerCase() === 'rtl';
  } else {
    return false;
  }
};

/**
 * @return {string} Locale direction string based on app direction.
 */
StudioApp.prototype.localeDirection = function () {
  return this.isRtl() ? 'rtl' : 'ltr';
};

/**
* Initialize Blockly for a readonly iframe.  Called on page load. No sounds.
* XML argument may be generated from the console with:
* Blockly.Xml.domToText(Blockly.Xml.blockSpaceToDom(Blockly.mainBlockSpace)).slice(5, -6)
*/
StudioApp.prototype.initReadonly = function (options) {
  Blockly.inject(document.getElementById('codeWorkspace'), {
    assetUrl: this.assetUrl,
    readOnly: true,
    rtl: this.isRtl(),
    scrollbars: false
  });
  this.loadBlocks(options.blocks);
};

/**
* Load the editor with blocks.
* @param {string} blocksXml Text representation of blocks.
*/
StudioApp.prototype.loadBlocks = function (blocksXml) {
  var xml = parseXmlElement(blocksXml);
  Blockly.Xml.domToBlockSpace(Blockly.mainBlockSpace, xml);
};

/**
* Applies the specified arrangement to top startBlocks. If any
* individual blocks have x or y properties set in the XML, those values
* take priority. If no arrangement for a particular block type is
* specified, blocks are automatically positioned by Blockly.
*
* Note that, currently, only bounce and flappy use arrangements.
*
* @param {string} startBlocks String representation of start blocks xml.
* @param {Object.<Object>} arrangement A map from block type to position.
* @return {string} String representation of start blocks xml, including
*    block position.
*/
StudioApp.prototype.arrangeBlockPosition = function (startBlocks, arrangement) {

  var type, xmlChild;

  var xml = parseXmlElement(startBlocks);

  var xmlChildNodes = xml.childNodes || [];
  arrangement = arrangement || {};

  for (var i = 0; i < xmlChildNodes.length; i++) {
    xmlChild = xmlChildNodes[i];

    // Only look at element nodes
    if (xmlChild.nodeType === 1) {
      // look to see if we have a predefined arrangement for this type
      type = xmlChild.getAttribute('type');
      if (arrangement[type]) {
        if (arrangement[type].x && !xmlChild.hasAttribute('x')) {
          xmlChild.setAttribute('x', arrangement[type].x);
        }
        if (arrangement[type].y && !xmlChild.hasAttribute('y')) {
          xmlChild.setAttribute('y', arrangement[type].y);
        }
      }
    }
  }
  return Blockly.Xml.domToText(xml);
};

StudioApp.prototype.createModalDialog = function (options) {
  options.Dialog = utils.valueOr(options.Dialog, this.Dialog);
  return this.feedback_.createModalDialog(options);
};

/**
 * Simple passthrough to AuthoredHints.displayMissingBlockHints
 * @param {String[]} blocks An array of XML strings representing the
 *        missing recommended Blockly Blocks for which we want to
 *        display hints.
 */
StudioApp.prototype.displayMissingBlockHints = function (blocks) {
  this.authoredHintsController_.displayMissingBlockHints(blocks);
};

StudioApp.prototype.onReportComplete = function (response) {
  this.authoredHintsController_.finishHints(response);
};

StudioApp.prototype.showInstructions_ = function (level, autoClose, showHints) {
  var instructionsDiv = document.createElement('div');
  var renderedMarkdown;
  var headerElement;

  var puzzleTitle = msg.puzzleTitle({
    stage_total: level.stage_total,
    puzzle_number: level.puzzle_number
  });

  var markdownMode = window.marked && level.markdownInstructions && this.LOCALE === ENGLISH_LOCALE;

  if (markdownMode) {
    var markdownWithImages = this.substituteInstructionImages(level.markdownInstructions);
    renderedMarkdown = marked(markdownWithImages);
    instructionsDiv.className += ' markdown-instructions-container';
    headerElement = document.createElement('h1');
    headerElement.className = 'markdown-level-header-text dialog-title';
    headerElement.innerHTML = puzzleTitle;
    if (!this.icon) {
      headerElement.className += ' no-modal-icon';
    }
  }

  var authoredHints;
  if (showHints) {
    authoredHints = this.authoredHintsController_.getHintsDisplay();
  }

  var instructionsContent = React.createElement(Instructions, {
    puzzleTitle: puzzleTitle,
    instructions: this.substituteInstructionImages(level.instructions),
    instructions2: this.substituteInstructionImages(level.instructions2),
    renderedMarkdown: renderedMarkdown,
    markdownClassicMargins: level.markdownInstructionsWithClassicMargins,
    aniGifURL: level.aniGifURL,
    authoredHints: authoredHints
  });

  // Create a div to eventually hold this content, and add it to the
  // overall container. We don't want to render directly into the
  // container just yet, because our React component could contain some
  // elements that don't want to be rendered until they are in the DOM
  var instructionsReactContainer = document.createElement('div');
  instructionsReactContainer.className = 'instructions-container';
  instructionsDiv.appendChild(instructionsReactContainer);

  var buttons = document.createElement('div');
  buttons.innerHTML = require('./templates/buttons.html.ejs')({
    data: {
      ok: true
    }
  });

  instructionsDiv.appendChild(buttons);

  // If there is an instructions block on the screen, we want the instructions dialog to
  // shrink down to that instructions block when it's dismissed.
  // We then want to flash the instructions block.
  var hideOptions = null;
  var endTargetSelector = "#bubble";

  if ($(endTargetSelector).length) {
    hideOptions = {};
    hideOptions.endTarget = endTargetSelector;
  }

  var hideFn = _.bind(function () {
    // Momentarily flash the instruction block white then back to regular.
    if ($(endTargetSelector).length) {
      $(endTargetSelector).css({ "background-color": "rgba(255,255,255,1)" }).delay(500).animate({ "background-color": "rgba(0,0,0,0)" }, 1000);
    }
    // Set focus to ace editor when instructions close:
    if (this.editCode && this.editor && !this.editor.currentlyUsingBlocks) {
      this.editor.aceEditor.focus();
    }

    // Fire a custom event on the document so that other code can respond
    // to instructions being closed.
    var event = document.createEvent('Event');
    event.initEvent('instructionsHidden', true, true);
    document.dispatchEvent(event);
  }, this);

  this.instructionsDialog = this.createModalDialog({
    markdownMode: markdownMode,
    contentDiv: instructionsDiv,
    icon: this.icon,
    defaultBtnSelector: '#ok-button',
    onHidden: hideFn,
    scrollContent: true,
    scrollableSelector: ".instructions-container",
    header: headerElement
  });

  // Now that our elements are guaranteed to be in the DOM, we can
  // render in our react components
  $(this.instructionsDialog.div).on('show.bs.modal', function () {
    ReactDOM.render(instructionsContent, instructionsReactContainer);
  });

  if (autoClose) {
    setTimeout(_.bind(function () {
      this.instructionsDialog.hide();
    }, this), 32000);
  }

  var okayButton = buttons.querySelector('#ok-button');
  if (okayButton) {
    dom.addClickTouchEvent(okayButton, _.bind(function () {
      if (this.instructionsDialog) {
        this.instructionsDialog.hide();
      }
    }, this));
  }

  this.instructionsDialog.show({ hideOptions: hideOptions });

  if (renderedMarkdown) {
    // process <details> tags with polyfill jQuery plugin
    $('details').details();
  }

  // Fire a custom event on the document so that other code can respond
  // to instructions being shown.
  var event = document.createEvent('Event');
  event.initEvent('instructionsShown', true, true);
  document.dispatchEvent(event);
};

/**
*  Resizes the blockly workspace.
*/
StudioApp.prototype.onResize = function () {
  var workspaceWidth = document.getElementById('codeWorkspace').clientWidth;

  // Keep blocks static relative to the right edge in RTL mode
  if (this.isUsingBlockly() && Blockly.RTL) {
    if (this.lastWorkspaceWidth && this.lastWorkspaceWidth !== workspaceWidth) {
      var blockOffset = workspaceWidth - this.lastWorkspaceWidth;
      Blockly.mainBlockSpace.getTopBlocks().forEach(function (topBlock) {
        topBlock.moveBy(blockOffset, 0);
      });
    }
  }
  this.lastWorkspaceWidth = workspaceWidth;

  // Droplet toolbox width varies as the window size changes, so refresh:
  this.resizeToolboxHeader();

  // Content below visualization is a resizing scroll area in pinned mode
  onResizeSmallFooter();
};

/**
 * Resizes the content area below the visualization in pinned (viewport height)
 * view mode.
 */
function resizePinnedBelowVisualizationArea() {
  var pinnedBelowVisualization = document.querySelector('#visualizationColumn.pin_bottom #belowVisualization');
  if (!pinnedBelowVisualization) {
    return;
  }

  var playSpaceHeader = document.getElementById('playSpaceHeader');
  var visualization = document.getElementById('visualization');
  var gameButtons = document.getElementById('gameButtons');
  var smallFooter = document.querySelector('#page-small-footer .small-footer-base');

  var top = 0;
  if (playSpaceHeader) {
    top += $(playSpaceHeader).outerHeight(true);
  }

  if (visualization) {
    top += $(visualization).outerHeight(true);
  }

  if (gameButtons) {
    top += $(gameButtons).outerHeight(true);
  }

  var bottom = 0;
  if (smallFooter) {
    var codeApp = $('#codeApp');
    bottom += $(smallFooter).outerHeight(true);
    // Footer is relative to the document, not codeApp, so we need to
    // remove the codeApp bottom offset to get the correct margin.
    bottom -= parseInt(codeApp.css('bottom'), 10);
  }

  pinnedBelowVisualization.style.top = top + 'px';
  pinnedBelowVisualization.style.bottom = bottom + 'px';
}

/**
 * Debounced onResize operations that update the layout to support sizing
 * to viewport height and using the small footer.
 * @type {Function}
 */
var onResizeSmallFooter = _.debounce(function () {
  resizePinnedBelowVisualizationArea();
}, 10);

StudioApp.prototype.onMouseDownVizResizeBar = function (event) {
  // When we see a mouse down in the resize bar, start tracking mouse moves:

  if (!this.onMouseMoveBoundHandler) {
    this.onMouseMoveBoundHandler = _.bind(this.onMouseMoveVizResizeBar, this);
    document.body.addEventListener('mousemove', this.onMouseMoveBoundHandler);
    this.mouseMoveTouchEventName = dom.getTouchEventName('mousemove');
    if (this.mouseMoveTouchEventName) {
      document.body.addEventListener(this.mouseMoveTouchEventName, this.onMouseMoveBoundHandler);
    }

    event.preventDefault();
  }
};

function applyTransformScaleToChildren(element, scale) {
  for (var i = 0; i < element.children.length; i++) {
    applyTransformScale(element.children[i], scale);
  }
}
function applyTransformScale(element, scale) {
  element.style.transform = scale;
  element.style.msTransform = scale;
  element.style.webkitTransform = scale;
}
function applyTransformOrigin(element, origin) {
  element.style.transformOrigin = origin;
  element.style.msTransformOrigin = origin;
  element.style.webkitTransformOrigin = origin;
}

/**
*  Handle mouse moves while dragging the visualization resize bar. We set
*  styles on each of the elements directly, overriding the normal responsive
*  classes that would typically adjust width and scale.
*/
StudioApp.prototype.onMouseMoveVizResizeBar = function (event) {
  var visualizationResizeBar = document.getElementById('visualizationResizeBar');

  var rect = visualizationResizeBar.getBoundingClientRect();
  var offset;
  var newVizWidth;
  if (this.isRtl()) {
    offset = window.innerWidth - (window.pageXOffset + rect.left + rect.width / 2) - parseInt(window.getComputedStyle(visualizationResizeBar).right, 10);
    newVizWidth = window.innerWidth - event.pageX - offset;
  } else {
    offset = window.pageXOffset + rect.left + rect.width / 2 - parseInt(window.getComputedStyle(visualizationResizeBar).left, 10);
    newVizWidth = event.pageX - offset;
  }
  this.resizeVisualization(newVizWidth);
};

/**
 * Resize the visualization to the given width
 */
StudioApp.prototype.resizeVisualization = function (width) {
  var codeWorkspace = document.getElementById('codeWorkspace');
  var visualization = document.getElementById('visualization');
  var visualizationResizeBar = document.getElementById('visualizationResizeBar');
  var visualizationColumn = document.getElementById('visualizationColumn');
  var visualizationEditor = document.getElementById('visualizationEditor');

  var oldVizWidth = $(visualizationColumn).width();
  var newVizWidth = Math.max(this.minVisualizationWidth, Math.min(this.maxVisualizationWidth, width));
  var newVizWidthString = newVizWidth + 'px';
  var newVizHeightString = newVizWidth / this.vizAspectRatio + 'px';
  var vizSideBorderWidth = visualization.offsetWidth - visualization.clientWidth;

  if (this.isRtl()) {
    visualizationResizeBar.style.right = newVizWidthString;
    codeWorkspace.style.right = newVizWidthString;
  } else {
    visualizationResizeBar.style.left = newVizWidthString;
    codeWorkspace.style.left = newVizWidthString;
  }
  visualizationResizeBar.style.lineHeight = newVizHeightString;
  // Add extra width to visualizationColumn if visualization has a border:
  visualizationColumn.style.maxWidth = newVizWidth + vizSideBorderWidth + 'px';
  visualization.style.maxWidth = newVizWidthString;
  visualization.style.maxHeight = newVizHeightString;

  // We don't get the benefits of our responsive styling, so set height
  // explicitly
  if (!utils.browserSupportsCssMedia()) {
    visualization.style.height = newVizHeightString;
    visualization.style.width = newVizWidthString;
  }
  var scale = newVizWidth / this.nativeVizWidth;

  applyTransformScaleToChildren(visualization, 'scale(' + scale + ')');
  if (visualizationEditor) {
    visualizationEditor.style.marginLeft = newVizWidthString;
  }

  if (oldVizWidth < 230 && newVizWidth >= 230) {
    $('#soft-buttons').removeClass('soft-buttons-compact');
  } else if (oldVizWidth > 230 && newVizWidth <= 230) {
    $('#soft-buttons').addClass('soft-buttons-compact');
  }

  var smallFooter = document.querySelector('#page-small-footer .small-footer-base');
  if (smallFooter) {
    smallFooter.style.maxWidth = newVizWidthString;

    // If the small print and language selector are on the same line,
    // the small print should float right.  Otherwise, it should float left.
    var languageSelector = smallFooter.querySelector('form');
    var smallPrint = smallFooter.querySelector('small');
    if (languageSelector && smallPrint.offsetTop === languageSelector.offsetTop) {
      smallPrint.style.float = 'right';
    } else {
      smallPrint.style.float = 'left';
    }
  }

  // Fire resize so blockly and droplet handle this type of resize properly:
  utils.fireResizeEvent();
};

StudioApp.prototype.onMouseUpVizResizeBar = function (event) {
  // If we have been tracking mouse moves, remove the handler now:
  if (this.onMouseMoveBoundHandler) {
    document.body.removeEventListener('mousemove', this.onMouseMoveBoundHandler);
    if (this.mouseMoveTouchEventName) {
      document.body.removeEventListener(this.mouseMoveTouchEventName, this.onMouseMoveBoundHandler);
    }
    this.onMouseMoveBoundHandler = null;
  }
};

/**
*  Updates the width of the toolbox-header to match the width of the toolbox
*  or palette in the workspace below the header.
*/
StudioApp.prototype.resizeToolboxHeader = function () {
  var toolboxWidth = 0;
  if (this.editCode && this.editor && this.editor.paletteEnabled) {
    // If in the droplet editor, set toolboxWidth based on the block palette width:
    var categories = document.querySelector('.droplet-palette-wrapper');
    toolboxWidth = categories.getBoundingClientRect().width;
  } else if (this.isUsingBlockly()) {
    toolboxWidth = Blockly.mainBlockSpaceEditor.getToolboxWidth();
  }
  document.getElementById('toolbox-header').style.width = toolboxWidth + 'px';
};

/**
* Highlight the block (or clear highlighting).
* @param {?string} id ID of block that triggered this action.
* @param {boolean} spotlight Optional.  Highlight entire block if true
*/
StudioApp.prototype.highlight = function (id, spotlight) {
  if (this.isUsingBlockly()) {
    if (id) {
      var m = id.match(/^block_id_(\d+)$/);
      if (m) {
        id = m[1];
      }
    }

    Blockly.mainBlockSpace.highlightBlock(id, spotlight);
  }
};

/**
* Remove highlighting from all blocks
*/
StudioApp.prototype.clearHighlighting = function () {
  if (this.isUsingBlockly()) {
    this.highlight(null);
  } else if (this.editCode && this.editor) {
    // Clear everything (step highlighting, errors, etc.)
    codegen.clearDropletAceHighlighting(this.editor, true);
  }
};

/**
* Display feedback based on test results.  The test results must be
* explicitly provided.
* @param {{feedbackType: number}} Test results (a constant property of
*     this.TestResults).
*/
StudioApp.prototype.displayFeedback = function (options) {
  options.Dialog = this.Dialog;
  options.onContinue = this.onContinue;
  options.backToPreviousLevel = this.backToPreviousLevel;
  options.sendToPhone = this.sendToPhone;

  // Special test code for edit blocks.
  if (options.level.edit_blocks) {
    options.feedbackType = this.TestResults.EDIT_BLOCKS;
  }

  this.feedback_.displayFeedback(options, this.requiredBlocks_, this.maxRequiredBlocksToFlag_, this.recommendedBlocks_, this.maxRecommendedBlocksToFlag_);
};

/**
 * Runs the tests and returns results.
 * @param {boolean} levelComplete Was the level completed successfully?
 * @param {Object} options
 * @return {number} The appropriate property of TestResults.
 */
StudioApp.prototype.getTestResults = function (levelComplete, options) {
  return this.feedback_.getTestResults(levelComplete, this.requiredBlocks_, this.recommendedBlocks_, this.checkForEmptyBlocks_, options);
};

// Builds the dom to get more info from the user. After user enters info
// and click "create level" onAttemptCallback is called to deliver the info
// to the server.
StudioApp.prototype.builderForm_ = function (onAttemptCallback) {
  var builderDetails = document.createElement('div');
  builderDetails.innerHTML = require('./templates/builder.html.ejs')();
  var dialog = this.createModalDialog({
    contentDiv: builderDetails,
    icon: this.icon
  });
  var createLevelButton = document.getElementById('create-level-button');
  dom.addClickTouchEvent(createLevelButton, function () {
    var instructions = builderDetails.querySelector('[name="instructions"]').value;
    var name = builderDetails.querySelector('[name="level_name"]').value;
    var query = url.parse(window.location.href, true).query;
    onAttemptCallback(utils.extend({
      "instructions": instructions,
      "name": name
    }, query));
  });

  dialog.show({ backdrop: 'static' });
};

/**
* Report back to the server, if available.
* @param {object} options - parameter block which includes:
* {string} app The name of the application.
* {number} id A unique identifier generated when the page was loaded.
* {string} level The ID of the current level.
* {number} result An indicator of the success of the code.
* {number} testResult More specific data on success or failure of code.
* {boolean} submitted Whether the (submittable) level is being submitted.
* {string} program The user program, which will get URL-encoded.
* {function} onComplete Function to be called upon completion.
*/
StudioApp.prototype.report = function (options) {
  // copy from options: app, level, result, testResult, program, onComplete
  var report = $.extend({}, options, {
    pass: this.feedback_.canContinueToNextLevel(options.testResult),
    time: new Date().getTime() - this.initTime,
    attempt: this.attempts,
    lines: this.feedback_.getNumBlocksUsed()
  });

  this.lastTestResult = options.testResult;

  // If hideSource is enabled, the user is looking at a shared level that
  // they cannot have modified. In that case, don't report it to the service
  // or call the onComplete() callback expected. The app will just sit
  // there with the Reset button as the only option.
  var self = this;
  if (!(this.hideSource && this.share)) {
    var onAttemptCallback = (function () {
      return function (builderDetails) {
        for (var option in builderDetails) {
          report[option] = builderDetails[option];
        }
        self.onAttempt(report);
      };
    })();

    // If this is the level builder, go to builderForm to get more info from
    // the level builder.
    if (options.builder) {
      this.builderForm_(onAttemptCallback);
    } else {
      onAttemptCallback();
    }
  }
};

/**
* Click the reset button.  Reset the application.
*/
StudioApp.prototype.resetButtonClick = function () {
  this.onResetPressed();
  this.toggleRunReset('run');
  this.clearHighlighting();
  if (this.isUsingBlockly()) {
    Blockly.mainBlockSpaceEditor.setEnableToolbox(true);
    Blockly.mainBlockSpace.traceOn(false);
  }
  this.reset(false);
};

/**
* Add count of blocks used.
*/
StudioApp.prototype.updateBlockCount = function () {
  // If the number of block used is bigger than the ideal number of blocks,
  // set it to be yellow, otherwise, keep it as black.
  var element = document.getElementById('blockUsed');
  if (this.IDEAL_BLOCK_NUM < this.feedback_.getNumCountableBlocks()) {
    element.className = "block-counter-overflow";
  } else {
    element.className = "block-counter-default";
  }

  // Update number of blocks used.
  if (element) {
    element.innerHTML = ''; // Remove existing children or text.
    element.appendChild(document.createTextNode(this.feedback_.getNumCountableBlocks()));
  }
};

/**
 * Set the ideal Number of blocks.
 */
StudioApp.prototype.setIdealBlockNumber_ = function () {
  var element = document.getElementById('idealBlockNumber');
  if (!element) {
    return;
  }

  var idealBlockNumberMsg = this.IDEAL_BLOCK_NUM === Infinity ? msg.infinity() : this.IDEAL_BLOCK_NUM;
  element.innerHTML = ''; // Remove existing children or text.
  element.appendChild(document.createTextNode(idealBlockNumberMsg));
};

/**
 *
 */
StudioApp.prototype.fixViewportForSmallScreens_ = function (viewport, config) {
  var deviceWidth;
  var desiredWidth;
  var minWidth;
  if (this.share && dom.isMobile()) {
    var mobileNoPaddingShareWidth = config.mobileNoPaddingShareWidth || DEFAULT_MOBILE_NO_PADDING_SHARE_WIDTH;
    // for mobile sharing, favor portrait mode, so width is the shorter of the two
    deviceWidth = desiredWidth = Math.min(screen.width, screen.height);
    if (this.noPadding && deviceWidth < MAX_PHONE_WIDTH) {
      desiredWidth = Math.min(desiredWidth, mobileNoPaddingShareWidth);
    }
    minWidth = mobileNoPaddingShareWidth;
  } else {
    // assume we are in landscape mode, so width is the longer of the two
    deviceWidth = desiredWidth = Math.max(screen.width, screen.height);
    minWidth = MIN_WIDTH;
  }
  var width = Math.max(minWidth, desiredWidth);
  var scale = deviceWidth / width;
  var content = ['width=' + width, 'minimal-ui', 'initial-scale=' + scale, 'maximum-scale=' + scale, 'minimum-scale=' + scale, 'target-densityDpi=device-dpi', 'user-scalable=no'];
  viewport.setAttribute('content', content.join(', '));
};

/**
 *
 */
StudioApp.prototype.setConfigValues_ = function (config) {
  this.share = config.share;
  this.centerEmbedded = utils.valueOr(config.centerEmbedded, this.centerEmbedded);
  this.wireframeShare = utils.valueOr(config.wireframeShare, this.wireframeShare);

  // if true, dont provide links to share on fb/twitter
  this.disableSocialShare = config.disableSocialShare;
  this.sendToPhone = config.sendToPhone;
  this.noPadding = config.noPadding;

  // contract editor requires more vertical space. set height to 1250 unless
  // explicitly specified
  if (config.level.useContractEditor) {
    config.level.minWorkspaceHeight = config.level.minWorkspaceHeight || 1250;
  }

  this.appMsg = config.appMsg;
  this.IDEAL_BLOCK_NUM = config.level.ideal || Infinity;
  this.MIN_WORKSPACE_HEIGHT = config.level.minWorkspaceHeight || 800;
  this.requiredBlocks_ = config.level.requiredBlocks || [];
  this.recommendedBlocks_ = config.level.recommendedBlocks || [];
  this.startBlocks_ = config.level.lastAttempt || config.level.startBlocks || '';
  this.vizAspectRatio = config.vizAspectRatio || 1.0;
  this.nativeVizWidth = config.nativeVizWidth || this.maxVisualizationWidth;

  // enableShowCode defaults to true if not defined
  this.enableShowCode = config.enableShowCode !== false;
  this.enableShowLinesCount = config.enableShowLinesCount !== false;

  // If the level has no ideal block count, don't show a block count. If it does
  // have an ideal, show block count unless explicitly configured not to.
  if (config.level && (config.level.ideal === undefined || config.level.ideal === Infinity)) {
    this.enableShowBlockCount = false;
  } else {
    this.enableShowBlockCount = config.enableShowBlockCount !== false;
  }

  // Store configuration.
  this.onAttempt = config.onAttempt || function () {};
  this.onContinue = config.onContinue || function () {};
  this.onInitialize = config.onInitialize ? config.onInitialize.bind(config) : function () {};
  this.onResetPressed = config.onResetPressed || function () {};
  this.backToPreviousLevel = config.backToPreviousLevel || function () {};
  this.skin = config.skin;
  this.showInstructions = this.showInstructions_.bind(this, config.level, false);
  this.polishCodeHook = config.polishCodeHook;
};

// Overwritten by applab.
StudioApp.prototype.runButtonClickWrapper = function (callback) {
  if (window.$) {
    $(window).trigger('run_button_pressed');
    $(window).trigger('appModeChanged');
  }
  callback();
};

/**
 * Begin modifying the DOM based on config.
 * Note: Has side effects on config
 */
StudioApp.prototype.configureDom = function (config) {
  var container = document.getElementById(config.containerId);
  if (!this.enableShowCode) {
    document.getElementById('show-code-header').style.display = 'none';
  }
  var codeWorkspace = container.querySelector('#codeWorkspace');

  var runButton = container.querySelector('#runButton');
  var resetButton = container.querySelector('#resetButton');
  var runClick = this.runButtonClick.bind(this);
  var throttledRunClick = _.debounce(this.runButtonClickWrapper.bind(this, runClick), 250, true);
  dom.addClickTouchEvent(runButton, _.bind(throttledRunClick, this));
  dom.addClickTouchEvent(resetButton, _.bind(this.resetButtonClick, this));

  // TODO (cpirich): make conditional for applab
  var belowViz = document.getElementById('belowVisualization');
  var referenceArea = document.getElementById('reference_area');
  if (referenceArea) {
    belowViz.appendChild(referenceArea);
  }

  var visualizationColumn = document.getElementById('visualizationColumn');
  var visualization = document.getElementById('visualization');

  if (!config.hideSource || config.embed) {
    var vizHeight = this.MIN_WORKSPACE_HEIGHT;
    if (this.isUsingBlockly() && config.level.edit_blocks) {
      // Set a class on the main blockly div so CSS can style blocks differently
      $(codeWorkspace).addClass('edit');
      // If in level builder editing blocks, make workspace extra tall
      vizHeight = 3000;
      // Modify the arrangement of toolbox blocks so categories align left
      if (config.level.edit_blocks == "toolbox_blocks") {
        this.blockYCoordinateInterval = 80;
        config.blockArrangement = { category: { x: 20 } };
      }
      // Enable param & var editing in levelbuilder, regardless of level setting
      config.level.disableParamEditing = false;
      config.level.disableVariableEditing = false;
    }

    if (config.pinWorkspaceToBottom) {
      var bodyElement = document.body;
      bodyElement.style.overflow = "hidden";
      bodyElement.className = bodyElement.className + " pin_bottom";
      container.className = container.className + " pin_bottom";
      visualizationColumn.className = visualizationColumn.className + " pin_bottom";
      codeWorkspace.className = codeWorkspace.className + " pin_bottom";
      if (this.editCode) {
        var codeTextbox = document.getElementById('codeTextbox');
        codeTextbox.className = codeTextbox.className + " pin_bottom";
      }
    } else {
      visualizationColumn.style.minHeight = vizHeight + 'px';
      container.style.minHeight = vizHeight + 'px';
    }
  }

  if (config.readonlyWorkspace) {
    $(codeWorkspace).addClass('readonly');
  }

  // NOTE: Can end up with embed true and hideSource false in level builder
  // scenarios. See https://github.com/code-dot-org/code-dot-org/pull/1744
  if (config.embed && config.hideSource && this.centerEmbedded) {
    container.className = container.className + " centered_embed";
    visualizationColumn.className = visualizationColumn.className + " centered_embed";
  }

  if (!config.embed && !config.hideSource) {
    // Make the visualization responsive to screen size, except on share page.
    visualization.className += " responsive";
    visualizationColumn.className += " responsive";
    var smallFooter = document.querySelector('#page-small-footer .small-footer-base');
    if (smallFooter) {
      smallFooter.className += " responsive";
    }
  }
};

/**
 *
 */
StudioApp.prototype.handleHideSource_ = function (options) {
  var container = document.getElementById(options.containerId);
  this.hideSource = true;
  var workspaceDiv = document.getElementById('codeWorkspace');
  if (!options.embed || options.level.skipInstructionsPopup) {
    container.className = 'hide-source';
  }
  workspaceDiv.style.display = 'none';
  document.getElementById('visualizationResizeBar').style.display = 'none';

  // Chrome-less share page.
  if (this.share) {
    if (options.isLegacyShare || this.wireframeShare) {
      document.body.style.backgroundColor = '#202B34';

      $('.header-wrapper').hide();
      var vizColumn = document.getElementById('visualizationColumn');
      if (dom.isMobile() && (options.isLegacyShare || !dom.isIPad())) {
        $(vizColumn).addClass('chromelessShare');
      } else {
        $(vizColumn).addClass('wireframeShare');

        var div = document.createElement('div');
        document.body.appendChild(div);
        ReactDOM.render(React.createElement(WireframeSendToPhone, {
          channelId: dashboard.project.getCurrentId(),
          appType: dashboard.project.getStandaloneApp()
        }), div);
      }

      if (!options.embed) {
        var runButton = document.getElementById('runButton');
        var buttonRow = runButton.parentElement;
        var openWorkspace = document.createElement('button');
        openWorkspace.setAttribute('id', 'open-workspace');
        openWorkspace.appendChild(document.createTextNode(msg.openWorkspace()));

        dom.addClickTouchEvent(openWorkspace, function () {
          // /c/ URLs go to /edit when we click open workspace.
          // /project/ URLs we want to go to /view (which doesnt require login)
          if (/^\/c\//.test(location.pathname)) {
            location.href += '/edit';
          } else {
            location.href += '/view';
          }
        });

        buttonRow.appendChild(openWorkspace);
      }
    }
  }
};

StudioApp.prototype.handleEditCode_ = function (config) {

  if (this.hideSource) {
    // In hide source mode, just call afterInject and exit immediately
    if (config.afterInject) {
      config.afterInject();
    }
    return;
  }

  var displayMessage, examplePrograms, messageElement, onChange, startingText;

  // Ensure global ace variable is the same as window.ace
  // (important because they can be different in our test environment)

  /* jshint ignore:start */
  ace = window.ace;
  /* jshint ignore:end */

  var fullDropletPalette = dropletUtils.generateDropletPalette(config.level.codeFunctions, config.dropletConfig);
  this.editor = new droplet.Editor(document.getElementById('codeTextbox'), {
    mode: 'javascript',
    modeOptions: dropletUtils.generateDropletModeOptions(config),
    palette: fullDropletPalette,
    showPaletteInTextMode: true,
    showDropdownInPalette: config.showDropdownInPalette,
    allowFloatingBlocks: false,
    dropIntoAceAtLineStart: config.dropIntoAceAtLineStart,
    enablePaletteAtStart: !config.readonlyWorkspace,
    textModeAtStart: config.level.textModeAtStart
  });

  this.editor.aceEditor.setShowPrintMargin(false);

  // Init and define our custom ace mode:
  aceMode.defineForAce(config.dropletConfig, config.unusedConfig, this.editor);
  // Now set the editor to that mode:
  var aceEditor = this.editor.aceEditor;
  aceEditor.session.setMode('ace/mode/javascript_codeorg');

  // Extend the command list on the ace Autocomplete object to include the period:
  var Autocomplete = window.ace.require("ace/autocomplete").Autocomplete;
  Autocomplete.prototype.commands['.'] = function (editor) {
    // First, insert the period and update the completions:
    editor.insert(".");
    editor.completer.updateCompletions(true);
    var filtered = editor.completer.completions && editor.completer.completions.filtered;
    for (var i = 0; i < (filtered && filtered.length); i++) {
      // If we have any exact maches in our filtered completions that include
      // this period, allow the completer to stay active:
      if (filtered[i].exactMatch) {
        return;
      }
    }
    // Otherwise, detach the completer:
    editor.completer.detach();
  };

  var langTools = window.ace.require("ace/ext/language_tools");

  // We don't want to include the textCompleter. langTools doesn't give us a way
  // to remove base completers (note: it does in newer versions of ace), so
  // we set aceEditor.completers manually
  aceEditor.completers = [langTools.snippetCompleter, langTools.keyWordCompleter];
  // make setCompleters fail so that attempts to use it result in clear failure
  // instead of just silently not working
  langTools.setCompleters = function () {
    throw new Error('setCompleters disabled. set aceEditor.completers directly');
  };

  // Add an ace completer for the API functions exposed for this level
  if (config.dropletConfig) {
    var functionsFilter = null;
    if (config.level.autocompletePaletteApisOnly) {
      functionsFilter = config.level.codeFunctions;
    }

    aceEditor.completers.push(dropletUtils.generateAceApiCompleter(functionsFilter, config.dropletConfig));
  }

  this.editor.aceEditor.setOptions({
    enableBasicAutocompletion: true,
    enableLiveAutocompletion: true
  });

  this.dropletTooltipManager = new DropletTooltipManager(this.appMsg, config.dropletConfig, config.level.codeFunctions, config.level.autocompletePaletteApisOnly);
  if (config.level.dropletTooltipsDisabled) {
    this.dropletTooltipManager.setTooltipsEnabled(false);
  }
  this.dropletTooltipManager.registerBlocks();

  // Bind listener to palette/toolbox 'Hide' and 'Show' links
  var hideToolboxHeader = document.getElementById('toolbox-header');
  var hideToolboxIcon = document.getElementById('hide-toolbox-icon');
  var showToolboxHeader = document.getElementById('show-toolbox-header');
  if (hideToolboxHeader && hideToolboxIcon && showToolboxHeader) {
    hideToolboxHeader.className += ' toggleable';
    hideToolboxIcon.style.display = 'inline-block';
    var handleTogglePalette = (function () {
      if (this.editor) {
        this.editor.enablePalette(!this.editor.paletteEnabled);
        showToolboxHeader.style.display = this.editor.paletteEnabled ? 'none' : 'inline-block';
        hideToolboxIcon.style.display = !this.editor.paletteEnabled ? 'none' : 'inline-block';
        this.resizeToolboxHeader();
      }
    }).bind(this);
    dom.addClickTouchEvent(hideToolboxHeader, handleTogglePalette);
    dom.addClickTouchEvent(showToolboxHeader, handleTogglePalette);
  }

  this.resizeToolboxHeader();

  var startBlocks = config.level.lastAttempt || config.level.startBlocks;
  if (startBlocks) {

    try {
      // Don't pass CRLF pairs to droplet until they fix CR handling:
      this.editor.setValue(startBlocks.replace(/\r\n/g, '\n'));
    } catch (err) {
      // catch errors without blowing up entirely. we may still not be in a
      // great state
      console.error(err.message);
    }
    // Reset droplet Undo stack:
    this.editor.clearUndoStack();
    // Reset ace Undo stack:
    var UndoManager = window.ace.require("ace/undomanager").UndoManager;
    this.editor.aceEditor.getSession().setUndoManager(new UndoManager());
  }

  if (config.readonlyWorkspace) {
    // When in readOnly mode, show source, but do not allow editing,
    // disable the palette, and hide the UI to show the palette:
    this.editor.setReadOnly(true);
    showToolboxHeader.style.display = 'none';
  }

  // droplet may now be in code mode if it couldn't parse the code into
  // blocks, so update the UI based on the current state (don't autofocus
  // if we have already created an instructionsDialog at this stage of init)
  this.onDropletToggle_(!this.instructionsDialog);

  this.dropletTooltipManager.registerDropletBlockModeHandlers(this.editor);

  this.editor.on('palettetoggledone', function (e) {
    // Reposition callouts after block/text toggle (in case they need to move)
    $('.cdo-qtips').qtip('reposition', null, false);
  });

  if (this.instructionsDialog) {
    // Initializing the droplet editor in text mode (ace) can steal the focus
    // from our visible instructions dialog. Restore focus where it belongs:
    this.instructionsDialog.focus();
  }

  if (config.afterEditorReady) {
    config.afterEditorReady();
  }

  if (config.afterInject) {
    config.afterInject();
  }
};

/**
 * Enable adding/removing breakpoints by clicking in the gutter of the editor.
 * Prerequisites: Droplet editor must be in use and initialized (e.g. you have
 * to call handleEditCode_ first).
 */
StudioApp.prototype.enableBreakpoints = function () {
  if (!this.editor) {
    throw new Error('Droplet editor must be in use to enable breakpoints.');
  }

  // Set up an event handler to create breakpoints when clicking in the gutter:
  this.editor.on('guttermousedown', (function (e) {
    var bps = this.editor.getBreakpoints();
    if (bps[e.line]) {
      this.editor.clearBreakpoint(e.line);
    } else {
      this.editor.setBreakpoint(e.line);
    }
  }).bind(this));
};

/**
 * Set whether to alert user to empty blocks, short-circuiting all other tests.
 * @param {boolean} checkBlocks Whether to check for empty blocks.
 */
StudioApp.prototype.setCheckForEmptyBlocks = function (checkBlocks) {
  this.checkForEmptyBlocks_ = checkBlocks;
};

/**
 * Add the starting block(s).  Don't load lastAttempt for Jigsaw levels or the
 * level will advance as soon as it's loaded.
 * @param loadLastAttempt If true, try to load config.lastAttempt.
 */
StudioApp.prototype.setStartBlocks_ = function (config, loadLastAttempt) {
  if (config.level.edit_blocks) {
    loadLastAttempt = false;
  }
  var startBlocks = config.level.startBlocks || '';
  if (loadLastAttempt && config.levelGameName !== 'Jigsaw') {
    startBlocks = config.level.lastAttempt || startBlocks;
  }
  if (config.forceInsertTopBlock) {
    startBlocks = blockUtils.forceInsertTopBlock(startBlocks, config.forceInsertTopBlock);
  }
  startBlocks = this.arrangeBlockPosition(startBlocks, config.blockArrangement);
  try {
    this.loadBlocks(startBlocks);
  } catch (e) {
    if (loadLastAttempt) {
      Blockly.mainBlockSpace.clear();
      // Try loading the default start blocks instead.
      this.setStartBlocks_(config, false);
    } else {
      throw e;
    }
  }
};

/**
 * Show the configured starting function definition.
 */
StudioApp.prototype.openFunctionDefinition_ = function (config) {
  if (Blockly.contractEditor) {
    Blockly.contractEditor.autoOpenWithLevelConfiguration({
      autoOpenFunction: config.level.openFunctionDefinition,
      contractCollapse: config.level.contractCollapse,
      contractHighlight: config.level.contractHighlight,
      examplesCollapse: config.level.examplesCollapse,
      examplesHighlight: config.level.examplesHighlight,
      definitionCollapse: config.level.definitionCollapse,
      definitionHighlight: config.level.definitionHighlight
    });
  } else {
    Blockly.functionEditor.autoOpenFunction(config.level.openFunctionDefinition);
  }
};

/**
 *
 */
StudioApp.prototype.handleUsingBlockly_ = function (config) {
  // Allow empty blocks if editing blocks.
  if (config.level.edit_blocks) {
    this.checkForEmptyBlocks_ = false;
    if (config.level.edit_blocks === 'required_blocks' || config.level.edit_blocks === 'toolbox_blocks' || config.level.edit_blocks === 'recommended_blocks') {
      // Don't show when run block for toolbox/required/recommended block editing
      config.forceInsertTopBlock = null;
    }
  }

  // If levelbuilder provides an empty toolbox, some apps (like artist)
  // replace it with a full toolbox. I think some levels may depend on this
  // behavior. We want a way to specify no toolbox, which is <xml></xml>
  if (config.level.toolbox) {
    var toolboxWithoutWhitespace = config.level.toolbox.replace(/\s/g, '');
    if (toolboxWithoutWhitespace === '<xml></xml>' || toolboxWithoutWhitespace === '<xml/>') {
      config.level.toolbox = undefined;
    }
  }

  var div = document.getElementById('codeWorkspace');
  var options = {
    toolbox: config.level.toolbox,
    disableParamEditing: utils.valueOr(config.level.disableParamEditing, true),
    disableVariableEditing: utils.valueOr(config.level.disableVariableEditing, false),
    useModalFunctionEditor: utils.valueOr(config.level.useModalFunctionEditor, false),
    useContractEditor: utils.valueOr(config.level.useContractEditor, false),
    disableExamples: utils.valueOr(config.level.disableExamples, false),
    defaultNumExampleBlocks: utils.valueOr(config.level.defaultNumExampleBlocks, 2),
    scrollbars: config.level.scrollbars,
    hasVerticalScrollbars: config.hasVerticalScrollbars,
    hasHorizontalScrollbars: config.hasHorizontalScrollbars,
    editBlocks: utils.valueOr(config.level.edit_blocks, false),
    readOnly: utils.valueOr(config.readonlyWorkspace, false),
    showExampleTestButtons: utils.valueOr(config.showExampleTestButtons, false)
  };
  ['trashcan', 'varsInGlobals', 'grayOutUndeletableBlocks', 'disableParamEditing'].forEach(function (prop) {
    if (config[prop] !== undefined) {
      options[prop] = config[prop];
    }
  });
  this.inject(div, options);
  this.onResize();

  if (config.afterInject) {
    config.afterInject();
  }
  this.setStartBlocks_(config, true);
};

/**
 * Modify the workspace header after a droplet blocks/code or palette toggle
 */
StudioApp.prototype.updateHeadersAfterDropletToggle_ = function (usingBlocks) {
  // Update header titles:
  var showCodeHeader = document.getElementById('show-code-header');
  var contentSpan = showCodeHeader.firstChild;
  var fontAwesomeGlyph = _.find(contentSpan.childNodes, function (node) {
    return (/\bfa\b/.test(node.className)
    );
  });
  var imgBlocksGlyph = _.find(contentSpan.childNodes, function (node) {
    return (/\bblocks-glyph\b/.test(node.className)
    );
  });

  // Change glyph
  if (usingBlocks) {
    if (fontAwesomeGlyph && imgBlocksGlyph) {
      fontAwesomeGlyph.style.display = 'inline-block';
      imgBlocksGlyph.style.display = 'none';
    }
    contentSpan.lastChild.textContent = msg.showTextHeader();
  } else {
    if (fontAwesomeGlyph && imgBlocksGlyph) {
      fontAwesomeGlyph.style.display = 'none';
      imgBlocksGlyph.style.display = 'inline-block';
    }
    contentSpan.lastChild.textContent = msg.showBlocksHeader();
  }

  var blockCount = document.getElementById('blockCounter');
  if (blockCount) {
    blockCount.style.display = usingBlocks && this.enableShowBlockCount ? 'inline-block' : 'none';
  }
};

/**
 * Handle updates after a droplet toggle between blocks/code has taken place
 */
StudioApp.prototype.onDropletToggle_ = function (autoFocus) {
  autoFocus = utils.valueOr(autoFocus, true);
  this.updateHeadersAfterDropletToggle_(this.editor.currentlyUsingBlocks);
  if (!this.editor.currentlyUsingBlocks) {
    if (autoFocus) {
      this.editor.aceEditor.focus();
    }
    this.dropletTooltipManager.registerDropletTextModeHandlers(this.editor);
  }
};

/**
 * Do we have any floating blocks not attached to an event block or function block?
 */
StudioApp.prototype.hasExtraTopBlocks = function () {
  return this.feedback_.hasExtraTopBlocks();
};

/**
 *
 */
StudioApp.prototype.hasQuestionMarksInNumberField = function () {
  return this.feedback_.hasQuestionMarksInNumberField();
};

/**
 * @returns true if any non-example block in the workspace has an unfilled input
 */
StudioApp.prototype.hasUnfilledFunctionalBlock = function () {
  return !!this.getUnfilledFunctionalBlock();
};

/**
 * @returns {Block} The first block that has an unfilled input, or undefined
 *   if there isn't one.
 */
StudioApp.prototype.getUnfilledFunctionalBlock = function () {
  return this.getFilteredUnfilledFunctionalBlock_(function (rootBlock) {
    return rootBlock.type !== 'functional_example';
  });
};

/**
 * @returns {Block} The first example block that has an unfilled input, or
 *   undefined if there isn't one. Ignores example blocks that don't have a
 *   call portion, as these are considered invalid.
 */
StudioApp.prototype.getUnfilledFunctionalExample = function () {
  return this.getFilteredUnfilledFunctionalBlock_(function (rootBlock) {
    if (rootBlock.type !== 'functional_example') {
      return false;
    }
    var actual = rootBlock.getInputTargetBlock('ACTUAL');
    return actual && actual.getTitleValue('NAME');
  });
};

/**
 * @param {function} filter Run against root block in chain. Returns true if
 *   this is a block we care about
 */
StudioApp.prototype.getFilteredUnfilledFunctionalBlock_ = function (filter) {
  var unfilledBlock;
  Blockly.mainBlockSpace.getAllBlocks().some(function (block) {
    // Get the root block in the chain
    var rootBlock = block.getRootBlock();
    if (!filter(rootBlock)) {
      return false;
    }

    if (block.hasUnfilledFunctionalInput()) {
      unfilledBlock = block;
      return true;
    }
  });

  return unfilledBlock;
};

/**
 * @returns {string} The name of a function that doesn't have any examples, or
 *   undefined if all have at least one.
 */
StudioApp.prototype.getFunctionWithoutTwoExamples = function () {
  var definitionNames = Blockly.mainBlockSpace.getTopBlocks().filter(function (block) {
    return block.type === 'functional_definition' && !block.isVariable();
  }).map(function (definitionBlock) {
    return definitionBlock.getProcedureInfo().name;
  });

  var exampleNames = Blockly.mainBlockSpace.getTopBlocks().filter(function (block) {
    if (block.type !== 'functional_example') {
      return false;
    }

    // Only care about functional_examples that have an ACTUAL input (i.e. it's
    // clear which function they're for
    var actual = block.getInputTargetBlock('ACTUAL');
    return actual && actual.getTitleValue('NAME');
  }).map(function (exampleBlock) {
    return exampleBlock.getInputTargetBlock('ACTUAL').getTitleValue('NAME');
  });

  var definitionWithLessThanTwoExamples;
  definitionNames.forEach(function (def) {
    var definitionExamples = exampleNames.filter(function (example) {
      return def === example;
    });

    if (definitionExamples.length < 2) {
      definitionWithLessThanTwoExamples = def;
    }
  });
  return definitionWithLessThanTwoExamples;
};

/**
 * Get the error message when we have an unfilled block
 * @param {string} topLevelType The block.type For our expected top level block
 */
StudioApp.prototype.getUnfilledFunctionalBlockError = function (topLevelType) {
  var unfilled = this.getUnfilledFunctionalBlock();

  if (!unfilled) {
    return null;
  }

  var topParent = unfilled;
  while (topParent.getParent()) {
    topParent = topParent.getParent();
  }

  if (unfilled.type === topLevelType) {
    return msg.emptyTopLevelBlock({ topLevelBlockName: unfilled.getTitleValue() });
  }

  if (topParent.type !== 'functional_definition') {
    return msg.emptyFunctionalBlock();
  }

  var procedureInfo = topParent.getProcedureInfo();
  if (topParent.isVariable()) {
    return msg.emptyBlockInVariable({ name: procedureInfo.name });
  } else {
    return msg.emptyBlockInFunction({ name: procedureInfo.name });
  }
};

/**
 * Looks for failing examples, and updates the result text for them if they're
 * open in the contract editor
 * @param {function} failureChecker Apps example tester that takes in an example
 *   block, and outputs a failure string (or null if success)
 * @returns {string} Name of block containing first failing example we found, or
 *   empty string if no failures.
 */
StudioApp.prototype.checkForFailingExamples = function (failureChecker) {
  var failingBlockName = '';
  Blockly.mainBlockSpace.findFunctionExamples().forEach(function (exampleBlock) {
    var failure = failureChecker(exampleBlock, false);

    // Update the example result. No-op if we're not currently editing this
    // function.
    Blockly.contractEditor.updateExampleResult(exampleBlock, failure);

    if (failure) {
      failingBlockName = exampleBlock.getInputTargetBlock('ACTUAL').getTitleValue('NAME');
    }
  });
  return failingBlockName;
};

/**
 * @returns {boolean} True if we have a function or variable named "" (empty string)
 */
StudioApp.prototype.hasEmptyFunctionOrVariableName = function () {
  return Blockly.mainBlockSpace.getTopBlocks().some(function (block) {
    if (block.type !== 'functional_definition') {
      return false;
    }

    return !block.getProcedureInfo().name;
  });
};

StudioApp.prototype.createCoordinateGridBackground = function (options) {
  var svgName = options.svg;
  var origin = options.origin;
  var firstLabel = options.firstLabel;
  var lastLabel = options.lastLabel;
  var increment = options.increment;

  var CANVAS_HEIGHT = 400;
  var CANVAS_WIDTH = 400;

  var svg = document.getElementById(svgName);

  var bbox, text, rect;
  for (var label = firstLabel; label <= lastLabel; label += increment) {
    // create x axis labels
    text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.appendChild(document.createTextNode(label));
    svg.appendChild(text);
    bbox = text.getBBox();
    text.setAttribute('x', label - origin - bbox.width / 2);
    text.setAttribute('y', CANVAS_HEIGHT);
    text.setAttribute('font-weight', 'bold');
    rect = rectFromElementBoundingBox(text);
    rect.setAttribute('fill', 'white');
    svg.insertBefore(rect, text);

    // create y axis labels
    text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.appendChild(document.createTextNode(label));
    svg.appendChild(text);
    bbox = text.getBBox();
    text.setAttribute('x', 0);
    text.setAttribute('y', CANVAS_HEIGHT - (label - origin));
    text.setAttribute('dominant-baseline', 'central');
    text.setAttribute('font-weight', 'bold');
    rect = rectFromElementBoundingBox(text);
    rect.setAttribute('fill', 'white');
    svg.insertBefore(rect, text);
  }
};

function rectFromElementBoundingBox(element) {
  var bbox = element.getBBox();
  var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  rect.setAttribute('x', bbox.x);
  rect.setAttribute('y', bbox.y);
  rect.setAttribute('width', bbox.width);
  rect.setAttribute('height', bbox.height);
  return rect;
}

/**
 * Displays a small alert box inside DOM element at parentSelector.
 * @param {string} parentSelector
 * @param {object} props A set of React properties passed to the AbuseError
 *   component
 */
StudioApp.prototype.displayAlert = function (parentSelector, props) {
  // Each parent is assumed to have at most a single alert. This assumption
  // could be changed, but we would then want to clean up our DOM element on
  // close
  var parent = $(parentSelector);
  var container = parent.children('.react-alert');
  if (container.length === 0) {
    container = $("<div class='react-alert'/>");
    parent.append(container);
  }

  var reactProps = $.extend({}, {
    className: 'alert-error',
    onClose: function onClose() {
      React.unmountComponentAtNode(container[0]);
    }
  }, props);

  var element = React.createElement(Alert, reactProps);
  ReactDOM.render(element, container[0]);
};

/**
 * If the current project is considered abusive, display a small alert box
 * @param {string} parentSelector The selector for the DOM element parent we
 *   should display the error in.
 */
StudioApp.prototype.alertIfAbusiveProject = function (parentSelector) {
  if (window.dashboard && dashboard.project.exceedsAbuseThreshold()) {
    this.displayAlert(parentSelector, {
      body: React.createElement(dashboard.AbuseError, {
        i18n: {
          tos: window.dashboard.i18n.t('project.abuse.tos'),
          contact_us: window.dashboard.i18n.t('project.abuse.contact_us')
        }
      }),
      style: {
        top: 45,
        left: 350,
        right: 50
      }
    });
  }
};

/**
 * Searches for cases where we have two (or more) nested for loops in which
 * both loops use the same variable. This can cause infinite loops.
 * @returns {boolean} True if we detect an instance of this.
 */
StudioApp.prototype.hasDuplicateVariablesInForLoops = function () {
  if (this.editCode) {
    return false;
  }
  return Blockly.mainBlockSpace.getAllBlocks().some(this.forLoopHasDuplicatedNestedVariables_);
};

/**
 * Looks to see if a particular block is (a) a for loop and (b) has a descendant
 * for loop using the same variable.
 * @returns {boolean} True if that is true of this block
 */
StudioApp.prototype.forLoopHasDuplicatedNestedVariables_ = function (block) {
  if (!block || block.type !== 'controls_for' && block.type !== 'controls_for_counter') {
    return;
  }

  var innerBlock = block.getInput('DO').connection.targetBlock();

  // Not the most efficient of algo's, but we shouldn't have enough blocks for
  // it to matter.
  return block.getVars().some(function (varName) {
    return innerBlock.getDescendants().some(function (descendant) {
      if (descendant.type !== 'controls_for' && descendant.type !== 'controls_for_counter') {
        return false;
      }
      return descendant.getVars().indexOf(varName) !== -1;
    });
  });
};

/**
 * Polishes the generated code string before displaying it to the user. If the
 * app provided a polishCodeHook function, it will be called.
 * @returns {string} code string that may/may not have been modified
 */
StudioApp.prototype.polishGeneratedCodeString = function (code) {
  if (this.polishCodeHook) {
    return this.polishCodeHook(code);
  } else {
    return code;
  }
};

},{"./ResizeSensor":"/home/ubuntu/staging/apps/build/js/ResizeSensor.js","./acemode/mode-javascript_codeorg":"/home/ubuntu/staging/apps/build/js/acemode/mode-javascript_codeorg.js","./assetManagement/assetListStore":"/home/ubuntu/staging/apps/build/js/assetManagement/assetListStore.js","./assetManagement/assetPrefix":"/home/ubuntu/staging/apps/build/js/assetManagement/assetPrefix.js","./authoredHints":"/home/ubuntu/staging/apps/build/js/authoredHints.js","./blockTooltips/DropletTooltipManager":"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletTooltipManager.js","./block_utils":"/home/ubuntu/staging/apps/build/js/block_utils.js","./clientApi":"/home/ubuntu/staging/apps/build/js/clientApi.js","./codegen":"/home/ubuntu/staging/apps/build/js/codegen.js","./constants.js":"/home/ubuntu/staging/apps/build/js/constants.js","./dom":"/home/ubuntu/staging/apps/build/js/dom.js","./dropletUtils":"/home/ubuntu/staging/apps/build/js/dropletUtils.js","./feedback":"/home/ubuntu/staging/apps/build/js/feedback.js","./locale":"/home/ubuntu/staging/apps/build/js/locale.js","./logToCloud":"/home/ubuntu/staging/apps/build/js/logToCloud.js","./puzzleRatingUtils":"/home/ubuntu/staging/apps/build/js/puzzleRatingUtils.js","./templates/Instructions.jsx":"/home/ubuntu/staging/apps/build/js/templates/Instructions.jsx","./templates/VersionHistory.jsx":"/home/ubuntu/staging/apps/build/js/templates/VersionHistory.jsx","./templates/WireframeSendToPhone.jsx":"/home/ubuntu/staging/apps/build/js/templates/WireframeSendToPhone.jsx","./templates/alert.jsx":"/home/ubuntu/staging/apps/build/js/templates/alert.jsx","./templates/builder.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/builder.html.ejs","./templates/buttons.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/buttons.html.ejs","./templates/learn.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/learn.html.ejs","./templates/makeYourOwn.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/makeYourOwn.html.ejs","./utils":"/home/ubuntu/staging/apps/build/js/utils.js","./xml":"/home/ubuntu/staging/apps/build/js/xml.js","url":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/url/url.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/url/url.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/punycode/punycode.js","querystring":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/querystring-es3/index.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/querystring-es3/index.js":[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/querystring-es3/decode.js","./encode":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/querystring-es3/encode.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/querystring-es3/encode.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/querystring-es3/decode.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/punycode/punycode.js":[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/home/ubuntu/staging/apps/build/js/templates/makeYourOwn.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1; var msg = require('../locale') ; buf.push('\n\n<div id="make-your-own">\n\n  <h1><a href=', escape((5,  data.makeUrl )), '>', escape((5,  data.makeString )), '</a></h1>\n  <a href=', escape((6,  data.makeUrl )), '><img src=', escape((6,  data.makeImage )), '></a>\n\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js","ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/learn.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1; var msg = require('../locale') ; buf.push('\n\n');3; var root = location.protocol + '//' + location.host.replace('learn\.', '').replace('studio\.', ''); 
; buf.push('\n\n<div id="learn">\n\n  <h1><a href="', escape((7,  root )), '">', escape((7,  msg.wantToLearn() )), '</a></h1>\n  <a href="', escape((8,  root )), '"><img id="learn-to-code" src="', escape((8,  assetUrl('media/promo.png') )), '"></a>\n  <a href="', escape((9,  root )), '">', escape((9,  msg.watchVideo() )), '</a>\n  <a href="', escape((10,  root )), '">', escape((10,  msg.tryHOC() )), '</a>\n  <a href="', escape((11,  location.protocol + '//' + location.host 
)), '">', escape((11,  msg.signup() )), '</a>\n\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js","ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/builder.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<div><span>Instructions: </span><textarea type="text" name="instructions"></textarea></div>\n<div><span>Level Name: </span><textarea type="text" name="level_name"></textarea></div>\n<button id="create-level-button" class="launch">\n  Create Level\n</button>\n<div id="builder-error"></div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/alert.jsx":[function(require,module,exports){
/* global $ */

/**
 * Simple boot-strapped style alert.
 */
'use strict';

module.exports = React.createClass({
  displayName: 'exports',

  propTypes: {
    body: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.element]).isRequired,
    className: React.PropTypes.string,
    style: React.PropTypes.object,
    onClose: React.PropTypes.func.isRequired
  },

  render: function render() {
    var style = $.extend({}, {
      position: 'absolute',
      zIndex: 1000
    }, this.props.style);

    return React.createElement(
      'div',
      { style: style },
      React.createElement(
        'div',
        { className: "alert fade in " + (this.props.className || '') },
        React.createElement(
          'button',
          { type: 'button',
            className: 'alert-button close',
            style: { margin: 0 } },
          React.createElement(
            'span',
            { onClick: this.props.onClose },
            '×'
          )
        ),
        this.props.body
      )
    );
  }
});

},{}],"/home/ubuntu/staging/apps/build/js/templates/WireframeSendToPhone.jsx":[function(require,module,exports){
/* globals $, dashboard */

'use strict';

var SendToPhone = window.dashboard ? window.dashboard.SendToPhone : undefined;

var styles = {
  main: {
    position: 'absolute',
    bottom: 10,
    right: 10,
    textAlign: 'right',
    textShadow: '#000 -1px -1px 0',
    font: '12pt "Gotham 5r", sans-serif',
    color: '#8F9499'
  },
  icon: {
    fontSize: '1.5em'
  },
  sendToPhone: {
    label: {
      font: '12pt "Gotham 5r", sans-serif',
      color: '#8F9499'
    },
    div: {
      margin: 0
    }
  }
};

/**
 * Shows a prompt for SendToPhone. On click, replaces prompt with our
 * SendToPhone component.
 */
module.exports = React.createClass({
  displayName: 'exports',

  propTypes: {
    channelId: React.PropTypes.string.isRequired,
    appType: React.PropTypes.string.isRequired
  },

  getInitialState: function getInitialState() {
    return {
      clicked: false
    };
  },

  handleClick: function handleClick() {
    this.setState({ clicked: !this.state.clicked });
    return false; // so the # link doesn't go anywhere.
  },

  render: function render() {
    return React.createElement(
      'div',
      { style: styles.main },
      this.renderSendToPhone(),
      React.createElement(
        'a',
        { className: 'WireframeSendToPhone_send-to-phone-link', href: '#', onClick: this.handleClick },
        React.createElement('i', { style: styles.icon, className: 'fa fa-mobile' }),
        ' See this app on your phone'
      )
    );
  },

  renderSendToPhone: function renderSendToPhone() {
    if (this.state.clicked) {
      return React.createElement(SendToPhone, {
        styles: styles.sendToPhone,
        channelId: this.props.channelId,
        appType: this.props.appType
      });
    }
  }
});

},{}],"/home/ubuntu/staging/apps/build/js/templates/VersionHistory.jsx":[function(require,module,exports){
/* global dashboard */
'use strict';

var VersionRow = require('./VersionRow.jsx');
var sourcesApi = require('../clientApi').sources;

/**
 * A component for viewing project version history.
 */
var VersionHistory = React.createClass({
  displayName: 'VersionHistory',

  propTypes: {
    handleClearPuzzle: React.PropTypes.func.isRequired
  },

  /**
   * @returns {{statusMessage: string, versions: (null|{
   *   lastModified: Date,
   *   isLatest: boolean,
   *   versionId: string
   * }[])}}
   */
  getInitialState: function getInitialState() {
    return {
      versions: null,
      statusMessage: '',
      showSpinner: true,
      confirmingClearPuzzle: false
    };
  },

  componentWillMount: function componentWillMount() {
    // TODO: Use Dave's client api when it's finished.
    sourcesApi.ajax('GET', 'main.json/versions', this.onVersionListReceived, this.onAjaxFailure);
  },

  /**
   * Called after the component mounts, when the server responds with the
   * current list of versions.
   * @param xhr
   */
  onVersionListReceived: function onVersionListReceived(xhr) {
    this.setState({ versions: JSON.parse(xhr.responseText), showSpinner: false });
  },

  /**
   * Called if the server responds with an error when loading an API request.
   */
  onAjaxFailure: function onAjaxFailure() {
    this.setState({ statusMessage: 'An error occurred.' });
  },

  /**
   * Called when the server responds to a request to restore a previous version.
   */
  onRestoreSuccess: function onRestoreSuccess() {
    location.reload();
  },

  /**
   * Called when the user chooses a previous version to restore.
   * @param versionId
   */
  onChooseVersion: function onChooseVersion(versionId) {
    // TODO: Use Dave's client api when it's finished.
    sourcesApi.ajax('PUT', 'main.json/restore?version=' + versionId, this.onRestoreSuccess, this.onAjaxFailure);

    // Show the spinner.
    this.setState({ showSpinner: true });
  },

  onConfirmClearPuzzle: function onConfirmClearPuzzle() {
    this.setState({ confirmingClearPuzzle: true });
  },

  onCancelClearPuzzle: function onCancelClearPuzzle() {
    this.setState({ confirmingClearPuzzle: false });
  },

  onClearPuzzle: function onClearPuzzle() {
    this.setState({ showSpinner: true });
    this.props.handleClearPuzzle();
    dashboard.project.save(function () {
      location.reload();
    }, true);
  },

  render: function render() {
    var body;
    if (this.state.showSpinner) {
      body = React.createElement(
        'div',
        { style: { margin: '1em 0', textAlign: 'center' } },
        React.createElement('i', { className: 'fa fa-spinner fa-spin', style: { fontSize: '32px' } })
      );
    } else if (this.state.confirmingClearPuzzle) {
      body = React.createElement(
        'div',
        null,
        React.createElement(
          'p',
          null,
          'Are you sure you want to clear all progress for this level?'
        ),
        React.createElement(
          'button',
          { id: 'confirm-button', style: { float: 'right' }, onClick: this.onClearPuzzle },
          'Start Over'
        ),
        React.createElement(
          'button',
          { id: 'again-button', onClick: this.onCancelClearPuzzle },
          'Cancel'
        )
      );
    } else {
      var rows = this.state.versions.map((function (version) {
        return React.createElement(VersionRow, {
          key: version.versionId,
          lastModified: new Date(version.lastModified),
          isLatest: version.isLatest,
          onChoose: this.onChooseVersion.bind(this, version.versionId) });
      }).bind(this));

      body = React.createElement(
        'div',
        null,
        React.createElement(
          'div',
          { style: { maxHeight: '330px', overflowX: 'scroll', margin: '1em 0' } },
          React.createElement(
            'table',
            { style: { width: '100%' } },
            React.createElement(
              'tbody',
              null,
              rows,
              React.createElement(
                'tr',
                null,
                React.createElement(
                  'td',
                  null,
                  React.createElement(
                    'p',
                    { style: { margin: 0 } },
                    'Initial version'
                  )
                ),
                React.createElement(
                  'td',
                  { width: '250', style: { textAlign: 'right' } },
                  React.createElement(
                    'button',
                    { className: 'btn-danger', onClick: this.onConfirmClearPuzzle, style: { float: 'right' } },
                    'Delete Progress'
                  )
                )
              )
            )
          )
        )
      );
    }

    return React.createElement(
      'div',
      { className: 'modal-content', style: { margin: 0 } },
      React.createElement(
        'p',
        { className: 'dialog-title' },
        'Version History'
      ),
      body,
      this.state.statusMessage
    );
  }
});
module.exports = VersionHistory;

},{"../clientApi":"/home/ubuntu/staging/apps/build/js/clientApi.js","./VersionRow.jsx":"/home/ubuntu/staging/apps/build/js/templates/VersionRow.jsx"}],"/home/ubuntu/staging/apps/build/js/templates/VersionRow.jsx":[function(require,module,exports){
/* globals $ */

/**
 * A single row in the VersionHistory dialog, describing one version of a project.
 */
"use strict";

var VersionRow = React.createClass({
  displayName: "VersionRow",

  propTypes: {
    lastModified: React.PropTypes.instanceOf(Date),
    isLatest: React.PropTypes.bool,
    onChoose: React.PropTypes.func
  },

  getLastModifiedTimestamp: function getLastModifiedTimestamp() {
    var timestamp = this.props.lastModified;
    if (timestamp.toLocaleString) {
      return timestamp.toLocaleString();
    }
    return timestamp.toString();
  },

  render: function render() {
    var button;
    if (this.props.isLatest) {
      button = React.createElement(
        "button",
        { className: "btn-default", disabled: "disabled", style: { cursor: "default" } },
        "Current Version"
      );
    } else {
      button = React.createElement(
        "button",
        { className: "btn-info", onClick: this.props.onChoose },
        "Restore this Version"
      );
    }

    return React.createElement(
      "tr",
      { className: "versionRow" },
      React.createElement(
        "td",
        null,
        React.createElement(
          "p",
          null,
          "Saved ",
          React.createElement(
            "time",
            { className: "versionTimestamp", dateTime: this.props.lastModified.toISOString() },
            this.getLastModifiedTimestamp()
          )
        ),
        this.getLastModifiedTimestamp()
      ),
      React.createElement(
        "td",
        { width: "250", style: { textAlign: 'right' } },
        button
      )
    );
  },

  componentDidMount: function componentDidMount() {
    $('.versionTimestamp').timeago();
  }
});
module.exports = VersionRow;

},{}],"/home/ubuntu/staging/apps/build/js/templates/Instructions.jsx":[function(require,module,exports){
'use strict';

var Instructions = React.createClass({
  displayName: 'Instructions',

  propTypes: {
    puzzleTitle: React.PropTypes.string,
    instructions: React.PropTypes.string,
    instructions2: React.PropTypes.string,
    renderedMarkdown: React.PropTypes.string,
    markdownClassicMargins: React.PropTypes.bool,
    aniGifURL: React.PropTypes.string,
    authoredHints: React.PropTypes.element
  },

  render: function render() {

    // Body logic is as follows:
    //
    // If we have been given rendered markdown, render a div containing
    // that, optionally with inline-styled margins. We don't need to
    // worry about the title in this case, as it is rendered by the
    // Dialog header
    //
    // Otherwise, render the title and up to two sets of instructions.
    // These instructions may contain spans and images as determined by
    // StudioApp.substituteInstructionImages
    var body;
    if (this.props.renderedMarkdown) {
      // Optionally give markdown dialog wide left margin so it looks more like a
      // non-markdown instructions dialog (useful if mixing markdown instructions
      // with non-markdown instructions in one tutorial).
      var bodyStyle = this.props.markdownClassicMargins ? {
        paddingTop: 0,
        marginLeft: '90px'
      } : {};

      body = React.createElement('div', {
        className: 'instructions-markdown',
        style: bodyStyle,
        dangerouslySetInnerHTML: { __html: this.props.renderedMarkdown }
      });
    } else {
      body = [React.createElement(
        'p',
        { key: 'dialog-title', className: 'dialog-title' },
        this.props.puzzleTitle
      )];

      if (this.props.instructions) {
        body.push(React.createElement('p', { key: 'instructions-1', dangerouslySetInnerHTML: { __html: this.props.instructions } }));
      }

      if (this.props.instructions2) {
        body.push(React.createElement('p', { key: 'instructions-2', className: 'instructions2', dangerouslySetInnerHTML: { __html: this.props.instructions2 } }));
      }
    }

    var aniGif;
    if (this.props.aniGifURL) {
      aniGif = React.createElement('img', { className: 'aniGif example-image', src: this.props.aniGifURL });
    }

    return React.createElement(
      'div',
      null,
      body,
      aniGif,
      this.props.authoredHints
    );
  }
});
module.exports = Instructions;

},{}],"/home/ubuntu/staging/apps/build/js/logToCloud.js":[function(require,module,exports){
'use strict';

var PageAction = {
  DropletTransitionError: 'DropletTransitionError',
  SanitizedLevelHtml: 'SanitizedLevelHtml',
  UserJavaScriptError: 'UserJavaScriptError'
};

var MAX_FIELD_LENGTH = 4095;

/**
 * Shims window.newrelic, which is only included in production. This causes us
 * to no-op in other environments.
 */
module.exports = {
  PageAction: PageAction,

  /**
   * @param {string} actionName - Must be one of the keys from PageAction
   * @param {object} value - Object literal representing columns we want to
   *   add for this action
   */
  addPageAction: function addPageAction(actionName, value) {
    if (!window.newrelic) {
      return;
    }

    if (!PageAction[actionName]) {
      console.log('Unknown actionName: ' + actionName);
      return;
    }

    if (typeof value !== "object") {
      console.log('Expected value to be an object');
      return;
    }

    for (var prop in value) {
      if (typeof value[prop] === 'string') {
        value[prop] = value[prop].substring(0, MAX_FIELD_LENGTH);
      }
    }

    window.newrelic.addPageAction(actionName, value);
  },

  /**
   * Sets an attribute that will be included on any subsequent generated events
   */
  setCustomAttribute: function setCustomAttribute(key, value) {
    if (!window.newrelic) {
      return;
    }

    window.newrelic.setCustomAttribute(key, value);
  }
};

},{}],"/home/ubuntu/staging/apps/build/js/feedback.js":[function(require,module,exports){
/* global trackEvent, appOptions */

// NOTE: These must be kept in sync with activity_hint.rb in dashboard.
'use strict';

var HINT_REQUEST_PLACEMENT = {
  NONE: 0, // This value must not be changed.
  LEFT: 1, // Hint request button is on left.
  RIGHT: 2 // Hint request button is on right.
};

/**
 * Bag of utility functions related to building and displaying feedback
 * to students.
 * @class
 * @param {StudioApp} studioApp A studioApp instance used to pull
 *   configuration and perform operations.
 */
var FeedbackUtils = function FeedbackUtils(studioApp) {
  this.studioApp_ = studioApp;
};
module.exports = FeedbackUtils;

// Globals used in this file:
//   Blockly

var trophy = require('./templates/trophy.html.ejs');
var utils = require('./utils');
var _ = utils.getLodash();
var codegen = require('./codegen');
var msg = require('./locale');
var dom = require('./dom');
var xml = require('./xml');
var FeedbackBlocks = require('./feedbackBlocks');
var constants = require('./constants');
var TestResults = constants.TestResults;
var KeyCodes = constants.KeyCodes;
var puzzleRatingUtils = require('./puzzleRatingUtils');

/**
 * @typedef {Object} TestableBlock
 * @property {string|function} test - A test whether the block is
 *           present, either:
 *           - A string, in which case the string is searched for in
 *             the generated code.
 *           - A single-argument function is called on each user-added
 *             block individually.  If any call returns true, the block
 *             is deemed present.  "User-added" blocks are ones that are
 *             neither disabled or undeletable.
 * @property {string} type - The type of block to be produced for
 *           display to the user if the test failed.
 * @property {Object} [titles] - A dictionary, where, for each
 *           KEY-VALUE pair, this is added to the block definition:
 *           <title name="KEY">VALUE</title>.
 * @property {Object} [value] - A dictionary, where, for each
 *           KEY-VALUE pair, this is added to the block definition:
 *           <value name="KEY">VALUE</value>
 * @property {string} [extra] - A string that should be blacked
 *           between the "block" start and end tags.
 */

/**
 * @param {Object} options
 * @param {!TestableBlock[]} requiredBlocks The blocks that are required to be used in
 *   the solution to this level.
 * @param {number} maxRequiredBlocksToFlag The number of required blocks to
 *   give hints about at any one time.  Set this to Infinity to show all.
 * @param {!TestableBlock[]} recommendedBlocks The blocks that are recommended to be used in
 *   the solution to this level.
 * @param {number} maxRecommendedBlocksToFlag The number of recommended blocks to
 *   give hints about at any one time.  Set this to Infinity to show all.
 */
FeedbackUtils.prototype.displayFeedback = function (options, requiredBlocks, maxRequiredBlocksToFlag, recommendedBlocks, maxRecommendedBlocksToFlag) {

  options.level = options.level || {};
  options.numTrophies = this.numTrophiesEarned_(options);

  // Tracking event for level newly completed
  if (options.response && options.response.new_level_completed) {
    trackEvent('Puzzle', 'Completed', options.response.level_path, options.response.level_attempts);
  }

  var hadShareFailure = options.response && options.response.share_failure;
  // options.response.level_source is the url that we are sharing; can't
  // share without it
  var canShare = options.response && options.response.level_source;
  var showingSharing = options.showingSharing && !hadShareFailure && canShare;

  var canContinue = this.canContinueToNextLevel(options.feedbackType);
  var displayShowCode = this.studioApp_.enableShowCode && this.studioApp_.enableShowLinesCount && canContinue && !showingSharing;
  var feedback = document.createElement('div');
  var sharingDiv = canContinue && showingSharing ? this.createSharingDiv(options) : null;
  var showCode = displayShowCode ? this.getShowCodeElement_(options) : null;
  var shareFailureDiv = hadShareFailure ? this.getShareFailure_(options) : null;
  if (hadShareFailure) {
    trackEvent('Share', 'Failure', options.response.share_failure.type);
  }
  var feedbackBlocks;
  if (this.studioApp_.isUsingBlockly()) {
    feedbackBlocks = new FeedbackBlocks(options, this.getMissingBlocks_(requiredBlocks, maxRequiredBlocksToFlag), this.getMissingBlocks_(recommendedBlocks, maxRecommendedBlocksToFlag), this.studioApp_);
  }
  // feedbackMessage must be initialized after feedbackBlocks
  // because FeedbackBlocks can mutate options.response.hint.
  var feedbackMessage = this.getFeedbackMessage_(options);

  if (feedbackMessage) {
    feedback.appendChild(feedbackMessage);
  }
  if (options.numTrophies) {
    // Tracking event for new trophy earned
    if (options.numTrophies > 0) {
      for (var i = 0; i < options.numTrophies; i++) {
        var concept_name = options.response.trophy_updates[i][0];
        var trophy_name = options.response.trophy_updates[i][1];
        trackEvent('Trophy', concept_name, trophy_name);
      }
    }
    var trophies = this.getTrophiesElement_(options);
    feedback.appendChild(trophies);
  }
  if (feedbackBlocks && feedbackBlocks.div) {
    if (feedbackMessage && this.useSpecialFeedbackDesign_(options)) {
      // put the blocks iframe inside the feedbackMessage for this special case:
      feedbackMessage.appendChild(feedbackBlocks.div);
    } else {
      feedback.appendChild(feedbackBlocks.div);
    }
  }
  if (sharingDiv) {
    feedback.appendChild(sharingDiv);
  }
  if (showingSharing) {
    var shareCodeSpacer = document.createElement('div');
    shareCodeSpacer.className = "share-code-spacer";
    feedback.appendChild(shareCodeSpacer);
  }
  if (shareFailureDiv) {
    feedback.appendChild(shareFailureDiv);
  }
  if (showCode) {
    feedback.appendChild(showCode);
  }
  if (options.level.isK1) {
    feedback.className += " k1";
  }
  if (options.appDiv) {
    feedback.appendChild(options.appDiv);
  }

  feedback.className += canContinue ? " win-feedback" : " failure-feedback";

  var finalLevel = options.response && options.response.message === "no more levels";

  feedback.appendChild(this.getFeedbackButtons_({
    feedbackType: options.feedbackType,
    tryAgainText: options.tryAgainText,
    keepPlayingText: options.keepPlayingText,
    continueText: options.continueText,
    showPreviousButton: options.level.showPreviousLevelButton,
    isK1: options.level.isK1,
    freePlay: options.level.freePlay,
    finalLevel: finalLevel
  }));

  var againButton = feedback.querySelector('#again-button');
  var hintRequestButton = feedback.querySelector('#hint-request-button');
  var previousLevelButton = feedback.querySelector('#back-button');
  var continueButton = feedback.querySelector('#continue-button');

  var onlyContinue = continueButton && !againButton && !previousLevelButton;

  // get the topmost missing recommended block, if it exists, to be
  // added to the queue of contextual hints. If the user views the block
  // in the dialog, mark it as seen and add it to the list as such.
  var missingRecommendedBlockHints = this.getMissingBlocks_(recommendedBlocks, 1).blocksToDisplay.map(function (block) {
    block.alreadySeen = false;
    return block;
  });
  var markContextualHintsAsSeen = function markContextualHintsAsSeen() {
    missingRecommendedBlockHints.filter(function (hint) {
      return feedbackBlocks && feedbackBlocks.xml && feedbackBlocks.xml.indexOf(hint.blockDisplayXML) > -1;
    }).forEach(function (hint) {
      hint.alreadySeen = true;
    });
  };

  var onHidden = onlyContinue ? options.onContinue : (function () {
    this.studioApp_.displayMissingBlockHints(missingRecommendedBlockHints);
  }).bind(this);

  var icon;
  if (!options.hideIcon) {
    icon = canContinue ? this.studioApp_.winIcon : this.studioApp_.failureIcon;
  }
  var defaultBtnSelector = onlyContinue ? '#continue-button' : '#again-button';

  var feedbackDialog = this.createModalDialog({
    Dialog: options.Dialog,
    contentDiv: feedback,
    icon: icon,
    defaultBtnSelector: defaultBtnSelector,
    onHidden: onHidden,
    id: 'feedback-dialog'
  });

  // Update the background color if it is set to be in special design.
  if (this.useSpecialFeedbackDesign_(options)) {
    if (options.response.design == "white_background") {
      document.getElementById('feedback-dialog').className += " white-background";
      document.getElementById('feedback-content').className += " light-yellow-background";
    }
  }

  if (againButton) {
    dom.addClickTouchEvent(againButton, function () {
      feedbackDialog.hide();
    });
  }

  if (previousLevelButton) {
    dom.addClickTouchEvent(previousLevelButton, function () {
      feedbackDialog.hide();
      options.backToPreviousLevel();
    });
  }

  // If there is a hint request button, hide the hint that would ordinarily
  // be shown (including any feedback blocks), and add code to restore the
  // hint if the button gets pressed.
  if (hintRequestButton) {

    var alreadySeen = options.response && options.response.hint_view_requests && options.response.hint_view_requests.some(function (request) {
      var requestMatchesFeedback = request.feedback_type === options.feedbackType;
      if (feedbackBlocks && feedbackBlocks.xml) {
        requestMatchesFeedback = requestMatchesFeedback && request.feedback_xml === feedbackBlocks.xml;
      }
      return requestMatchesFeedback;
    });

    if (alreadySeen) {
      // Remove "Show hint" button.  Making it invisible isn't enough,
      // because it will still take up space.
      hintRequestButton.parentNode.removeChild(hintRequestButton);

      // mark the corresponding block hint as seen
      markContextualHintsAsSeen();
    } else {

      // Generate a generic feedback message to display when we show the
      // feedback block
      var genericFeedback = this.getFeedbackMessage_({ message: msg.tryBlocksBelowFeedback() });

      // If there are feedback blocks, temporarily hide them.
      if (feedbackBlocks && feedbackBlocks.div) {
        feedbackBlocks.hide();
      }

      // If the user requests the hint...
      dom.addClickTouchEvent(hintRequestButton, function () {
        // mark the corresponding block hint as seen
        markContextualHintsAsSeen();

        // Swap out the specific feedback message with a generic one.
        var parentNode = feedbackMessage.parentNode;
        parentNode.replaceChild(genericFeedback, feedbackMessage);

        // Remove "Show hint" button.  Making it invisible isn't enough,
        // because it will still take up space.
        hintRequestButton.parentNode.removeChild(hintRequestButton);

        // Restore feedback blocks, if present.
        if (feedbackBlocks && feedbackBlocks.div) {
          feedbackBlocks.show();
        }

        // Report hint request to server.
        if (options.response.hint_view_request_url) {
          $.ajax({
            url: options.response.hint_view_request_url,
            type: 'POST',
            data: {
              script_id: options.response.script_id,
              level_id: options.response.level_id,
              feedback_type: options.feedbackType,
              feedback_xml: feedbackBlocks ? feedbackBlocks.xml : undefined
            }
          });
        }
      });
    }
  }

  if (continueButton) {

    if (options.response && options.response.puzzle_ratings_enabled) {
      feedback.appendChild(puzzleRatingUtils.buildPuzzleRatingButtons());
    }

    dom.addClickTouchEvent(continueButton, function () {
      feedbackDialog.hide();

      if (options.response && options.response.puzzle_ratings_enabled) {
        puzzleRatingUtils.cachePuzzleRating(feedback, {
          script_id: options.response.script_id,
          level_id: options.response.level_id
        });
      }

      // onContinue will fire already if there was only a continue button
      if (!onlyContinue) {
        options.onContinue();
      }
    });
  }

  // set up the Save To Gallery button if necessary
  var saveToGalleryButton = feedback.querySelector('#save-to-gallery-button');
  if (saveToGalleryButton && options.response && options.response.save_to_gallery_url) {
    dom.addClickTouchEvent(saveToGalleryButton, function () {
      $.post(options.response.save_to_gallery_url, function () {
        $('#save-to-gallery-button').prop('disabled', true).text("Saved!");
      });
    });
  }

  function createHiddenPrintWindow(src) {
    var iframe = $('<iframe id="print_frame" style="display: none"></iframe>'); // Created a hidden iframe with just the desired image as its contents
    iframe.appendTo("body");
    iframe[0].contentWindow.document.write("<img src='" + src + "'/>");
    iframe[0].contentWindow.document.write("<script>if (document.execCommand('print', false, null)) {  } else { window.print();  } </script>");
    $("#print_frame").remove(); // Remove the iframe when the print dialogue has been launched
  }

  var printButton = feedback.querySelector('#print-button');
  if (printButton) {
    dom.addClickTouchEvent(printButton, function () {
      createHiddenPrintWindow(options.feedbackImage);
    });
  }

  feedbackDialog.show({
    backdrop: options.app === 'flappy' ? 'static' : true
  });

  if (feedbackBlocks && feedbackBlocks.div) {
    feedbackBlocks.render();
  }
};

/**
 * Counts the number of blocks used.  Blocks are only counted if they are
 * not disabled, are deletable.
 * @return {number} Number of blocks used.
 */
FeedbackUtils.prototype.getNumBlocksUsed = function () {
  var i;
  if (this.studioApp_.editCode) {
    var codeLines = 0;
    // quick and dirty method to count non-blank lines that don't start with //
    var lines = this.getGeneratedCodeString_().split("\n");
    for (i = 0; i < lines.length; i++) {
      if (lines[i].length > 1 && (lines[i][0] != '/' || lines[i][1] != '/')) {
        codeLines++;
      }
    }
    return codeLines;
  }
  return this.getUserBlocks_().length;
};

/**
 * Counts the total number of blocks. Blocks are only counted if they are
 * not disabled.
 * @return {number} Total number of blocks.
 */
FeedbackUtils.prototype.getNumCountableBlocks = function () {
  var i;
  if (this.studioApp_.editCode) {
    var codeLines = 0;
    // quick and dirty method to count non-blank lines that don't start with //
    var lines = this.getGeneratedCodeString_().split("\n");
    for (i = 0; i < lines.length; i++) {
      if (lines[i].length > 1 && (lines[i][0] != '/' || lines[i][1] != '/')) {
        codeLines++;
      }
    }
    return codeLines;
  }
  return this.getCountableBlocks_().length;
};

/**
 *
 */
FeedbackUtils.prototype.getFeedbackButtons_ = function (options) {
  var buttons = document.createElement('div');
  buttons.id = 'feedbackButtons';

  var tryAgainText = '';
  if (options.feedbackType !== TestResults.ALL_PASS) {
    tryAgainText = utils.valueOr(options.tryAgainText, msg.tryAgain());
  }
  if (options.keepPlayingText) {
    tryAgainText = options.keepPlayingText;
  }

  buttons.innerHTML = require('./templates/buttons.html.ejs')({
    data: {
      previousLevel: !this.canContinueToNextLevel(options.feedbackType) && options.showPreviousButton,
      tryAgain: tryAgainText,
      continueText: options.continueText || (options.finalLevel ? msg.finish() : msg['continue']()),
      nextLevel: this.canContinueToNextLevel(options.feedbackType),
      shouldPromptForHint: this.shouldPromptForHint(options.feedbackType),
      isK1: options.isK1,
      assetUrl: this.studioApp_.assetUrl,
      freePlay: options.freePlay
    }
  });

  return buttons;
};

/**
 *
 */
FeedbackUtils.prototype.getShareFailure_ = function (options) {
  var shareFailure = options.response.share_failure;
  var shareFailureDiv = document.createElement('div');
  shareFailureDiv.innerHTML = require('./templates/shareFailure.html.ejs')({ shareFailure: shareFailure });
  return shareFailureDiv;
};

/**
 *
 */
FeedbackUtils.prototype.useSpecialFeedbackDesign_ = function (options) {
  return options.response && options.response.design && options.response.hint;
};

// This returns a document element with the appropriate feedback message.
// The message will be one of the following, from highest to lowest precedence:
// 0. Failure override message specified on level (options.level.failureMessageOverride)
// 1. Message passed in by caller (options.message).
// 2. Message from dashboard database (options.response.hint).
// 3. Header message due to dashboard text check fail (options.response.share_failure).
// 4. Level-specific message (e.g., options.level.emptyBlocksErrorMsg) for
//    specific result type (e.g., TestResults.EMPTY_BLOCK_FAIL).
// 5. System-wide message (e.g., msg.emptyBlocksErrorMsg()) for specific
//    result type (e.g., TestResults.EMPTY_BLOCK_FAIL).
FeedbackUtils.prototype.getFeedbackMessage_ = function (options) {
  var feedback = document.createElement('p');
  feedback.className = 'congrats';
  var message;

  // If a message was explicitly passed in, use that.
  if (options.feedbackType !== TestResults.ALL_PASS && options.level && options.level.failureMessageOverride) {
    message = options.level.failureMessageOverride;
  } else if (options.message) {
    message = options.message;
  } else if (options.response && options.response.share_failure) {
    message = msg.shareFailure();
  } else if (options.response && options.response.hint) {
    // Otherwise, if there's a dashboard database hint, use that.
    message = options.response.hint;
  } else {
    // Otherwise, the message will depend on the test result.
    switch (options.feedbackType) {
      case TestResults.RUNTIME_ERROR_FAIL:
        message = msg.runtimeErrorMsg({ lineNumber: options.executionError.lineNumber });
        break;
      case TestResults.SYNTAX_ERROR_FAIL:
        message = msg.syntaxErrorMsg({ lineNumber: options.executionError.lineNumber });
        break;
      case TestResults.EMPTY_BLOCK_FAIL:
        message = options.level.emptyBlocksErrorMsg || msg.emptyBlocksErrorMsg();
        break;
      case TestResults.EMPTY_FUNCTION_BLOCK_FAIL:
        if (options.level.emptyFunctionBlocksErrorMsg) {
          message = options.level.emptyFunctionBlocksErrorMsg;
        } else if (Blockly.useContractEditor || Blockly.useModalFunctionEditor) {
          message = msg.errorEmptyFunctionBlockModal();
        } else {
          message = msg.emptyFunctionBlocksErrorMsg();
        }
        break;
      case TestResults.TOO_FEW_BLOCKS_FAIL:
        message = options.level.tooFewBlocksMsg || msg.tooFewBlocksMsg();
        break;
      case TestResults.LEVEL_INCOMPLETE_FAIL:
        message = options.level.levelIncompleteError || msg.levelIncompleteError();
        break;
      case TestResults.EXTRA_TOP_BLOCKS_FAIL:
        var hasWhenRun = Blockly.mainBlockSpace.getTopBlocks().some(function (block) {
          return block.type === 'when_run' && block.isUserVisible();
        });

        var defaultMessage = hasWhenRun ? msg.extraTopBlocksWhenRun() : msg.extraTopBlocks();
        message = options.level.extraTopBlocks || defaultMessage;
        break;
      case TestResults.APP_SPECIFIC_FAIL:
        message = options.level.appSpecificFailError;
        break;
      case TestResults.UNUSED_PARAM:
        message = msg.errorUnusedParam();
        break;
      case TestResults.UNUSED_FUNCTION:
        message = msg.errorUnusedFunction();
        break;
      case TestResults.PARAM_INPUT_UNATTACHED:
        message = msg.errorParamInputUnattached();
        break;
      case TestResults.INCOMPLETE_BLOCK_IN_FUNCTION:
        message = msg.errorIncompleteBlockInFunction();
        break;
      case TestResults.QUESTION_MARKS_IN_NUMBER_FIELD:
        message = msg.errorQuestionMarksInNumberField();
        break;
      case TestResults.TOO_MANY_BLOCKS_FAIL:
        // Allow apps to override the "too many blocks" failure message
        // Passed as a msg function to allow the parameters to be passed in.
        var messageFunction = options.appStrings && options.appStrings.tooManyBlocksFailMsgFunction || msg.numBlocksNeeded;
        message = messageFunction({
          numBlocks: this.studioApp_.IDEAL_BLOCK_NUM,
          puzzleNumber: options.level.puzzle_number || 0
        });
        break;
      case TestResults.APP_SPECIFIC_ACCEPTABLE_FAIL:
        message = options.level.appSpecificAcceptableFailError;
        break;
      case TestResults.EDIT_BLOCKS:
        message = options.level.edit_blocks_success;
        break;
      case TestResults.MISSING_BLOCK_UNFINISHED:
      /* fallthrough */
      case TestResults.MISSING_BLOCK_FINISHED:
        message = options.level.missingRequiredBlocksErrorMsg || msg.missingRequiredBlocksErrorMsg();
        break;
      case TestResults.MISSING_RECOMMENDED_BLOCK_UNFINISHED:
        message = msg.missingRecommendedBlocksErrorMsg();
        break;
      case TestResults.MISSING_RECOMMENDED_BLOCK_FINISHED:
        var numEnabledBlocks = this.getNumCountableBlocks();
        if (this.studioApp_.IDEAL_BLOCK_NUM && numEnabledBlocks > this.studioApp_.IDEAL_BLOCK_NUM) {
          message = msg.numBlocksNeeded({
            numBlocks: this.studioApp_.IDEAL_BLOCK_NUM,
            puzzleNumber: options.level.puzzle_number || 0
          });
        } else {
          message = msg.completedWithoutRecommendedBlock({
            puzzleNumber: options.level.puzzle_number || 0
          });
        }
        break;
      case TestResults.NESTED_FOR_SAME_VARIABLE:
        message = msg.nestedForSameVariable();
        break;

      // Success.
      case TestResults.ALL_PASS:
      case TestResults.FREE_PLAY:
        var finalLevel = options.response && options.response.message === "no more levels";
        var stageCompleted = null;
        if (options.response && options.response.stage_changing) {
          stageCompleted = options.response.stage_changing.previous.name;
        }
        var msgParams = {
          numTrophies: options.numTrophies,
          stageNumber: 0, // TODO: remove once localized strings have been fixed
          stageName: stageCompleted,
          puzzleNumber: options.level.puzzle_number || 0
        };
        if (options.feedbackType === TestResults.FREE_PLAY && !options.level.disableSharing) {
          var reinfFeedbackMsg = options.appStrings && options.appStrings.reinfFeedbackMsg || '';

          if (options.level.disableFinalStageMessage) {
            message = reinfFeedbackMsg;
          } else {
            message = finalLevel ? msg.finalStage(msgParams) + ' ' : '';
            message = message + reinfFeedbackMsg;
          }
        } else if (options.numTrophies > 0) {
          message = finalLevel ? msg.finalStageTrophies(msgParams) : stageCompleted ? msg.nextStageTrophies(msgParams) : msg.nextLevelTrophies(msgParams);
        } else {
          var nextLevelMsg = options.appStrings && options.appStrings.nextLevelMsg || msg.nextLevel(msgParams);
          message = finalLevel ? msg.finalStage(msgParams) : stageCompleted ? msg.nextStage(msgParams) : nextLevelMsg;
        }
        break;
    }
  }

  $(feedback).text(message);

  // Update the feedback box design, if the hint message came from server.
  if (this.useSpecialFeedbackDesign_(options)) {
    // Setup a new div
    var feedbackDiv = document.createElement('div');
    feedbackDiv.className = 'feedback-callout';
    feedbackDiv.id = 'feedback-content';

    // Insert an image
    var imageDiv = document.createElement('img');
    imageDiv.className = "hint-image";
    imageDiv.src = this.studioApp_.assetUrl('media/lightbulb_for_' + options.response.design + '.png');
    feedbackDiv.appendChild(imageDiv);
    // Add new text
    var hintHeader = document.createElement('p');
    $(hintHeader).text(msg.hintHeader());
    feedbackDiv.appendChild(hintHeader);
    hintHeader.className = 'hint-header';
    // Append the original text
    feedbackDiv.appendChild(feedback);
    return feedbackDiv;
  }
  return feedback;
};

/**
 *
 */
FeedbackUtils.prototype.createSharingDiv = function (options) {
  // TODO: this bypasses the config encapsulation to ensure we have the most up-to-date value.
  if (this.studioApp_.disableSocialShare || window.appOptions.disableSocialShare) {
    // Clear out our urls so that we don't display any of our social share links
    options.twitterUrl = undefined;
    options.facebookUrl = undefined;
    options.sendToPhone = false;
  } else {

    // set up the twitter share url
    var twitterUrl = "https://twitter.com/intent/tweet?url=" + options.response.level_source;

    if (options.twitter && options.twitter.text !== undefined) {
      twitterUrl += "&text=" + encodeURI(options.twitter.text);
    } else {
      twitterUrl += "&text=" + encodeURI(msg.defaultTwitterText() + " @codeorg");
    }

    if (options.twitter && options.twitter.hashtag !== undefined) {
      twitterUrl += "&hashtags=" + options.twitter.hashtag;
    } else {
      twitterUrl += "&hashtags=" + 'HourOfCode';
    }

    if (options.twitter && options.twitter.related !== undefined) {
      twitterUrl += "&related=" + options.twitter.related;
    } else {
      twitterUrl += "&related=codeorg";
    }

    options.twitterUrl = twitterUrl;

    // set up the facebook share url
    var facebookUrl = "https://www.facebook.com/sharer/sharer.php?u=" + options.response.level_source;
    options.facebookUrl = facebookUrl;
  }

  options.assetUrl = this.studioApp_.assetUrl;

  var sharingDiv = document.createElement('div');
  sharingDiv.setAttribute('id', 'sharing');
  sharingDiv.innerHTML = require('./templates/sharing.html.ejs')({
    options: options
  });

  // Note: We have a dependency on dashboard here. This dependency has always
  // been here (we used to mysteriously just always bubble clicks on body to
  // a.popup-window if it existed), but it is now more explicit
  if (window.dashboard && window.dashboard.popupWindow) {
    $(sharingDiv).find('a.popup-window').click(window.dashboard.popupWindow);
  }

  var sharingInput = sharingDiv.querySelector('#sharing-input');
  if (sharingInput) {
    dom.addClickTouchEvent(sharingInput, function () {
      sharingInput.focus();
      sharingInput.select();
      sharingInput.setSelectionRange(0, 9999);
    });
  }

  //  SMS-to-phone feature
  var sharingPhone = sharingDiv.querySelector('#sharing-phone');
  if (sharingPhone && options.sendToPhone) {
    dom.addClickTouchEvent(sharingPhone, function () {
      var sendToPhone = sharingDiv.querySelector('#send-to-phone');
      if ($(sendToPhone).is(':hidden')) {
        $(sendToPhone).show();
        var phone = $(sharingDiv.querySelector("#phone"));
        var submitted = false;
        var submitButton = sharingDiv.querySelector('#phone-submit');
        submitButton.disabled = true;
        phone.mask('(000) 000-0000', {
          onComplete: function onComplete() {
            if (!submitted) {
              submitButton.disabled = false;
            }
          },
          onChange: function onChange() {
            submitButton.disabled = true;
          }
        });
        phone.focus();
        dom.addClickTouchEvent(submitButton, function () {
          var phone = $(sharingDiv.querySelector("#phone"));
          var params = jQuery.param({
            level_source: options.response.level_source_id,
            phone: phone.val()
          });
          $(submitButton).val("Sending..");
          phone.prop('readonly', true);
          submitButton.disabled = true;
          submitted = true;
          jQuery.post(options.response.phone_share_url, params).done(function (response) {
            $(submitButton).text("Sent!");
            trackEvent("SendToPhone", "success");
          }).fail(function (xhr) {
            $(submitButton).text("Error!");
            trackEvent("SendToPhone", "error");
          });
        });
      } else {
        // not hidden, hide
        $(sendToPhone).hide();
      }
    });
  }

  return sharingDiv;
};

/**
 *
 */
FeedbackUtils.prototype.numTrophiesEarned_ = function (options) {
  if (options.response && options.response.trophy_updates) {
    return options.response.trophy_updates.length;
  } else {
    return 0;
  }
};

/**
 *
 */
FeedbackUtils.prototype.getTrophiesElement_ = function (options) {
  var html = "";
  for (var i = 0; i < options.numTrophies; i++) {
    html += trophy({
      img_url: options.response.trophy_updates[i][2],
      concept_name: options.response.trophy_updates[i][0]
    });
  }
  var trophies = document.createElement('div');
  trophies.innerHTML = html;
  return trophies;
};

/**
 *
 */
FeedbackUtils.prototype.getShowCodeElement_ = function (options) {
  var showCodeDiv = document.createElement('div');
  showCodeDiv.setAttribute('id', 'show-code');

  var numLinesWritten = this.getNumBlocksUsed();
  var shouldShowTotalLines = options.response && options.response.total_lines && options.response.total_lines !== numLinesWritten;
  var totalNumLinesWritten = shouldShowTotalLines ? options.response.total_lines : 0;

  showCodeDiv.innerHTML = require('./templates/showCode.html.ejs')({
    numLinesWritten: numLinesWritten,
    totalNumLinesWritten: totalNumLinesWritten
  });

  var showCodeButton = showCodeDiv.querySelector('#show-code-button');
  showCodeButton.addEventListener('click', _.bind(function () {
    var generatedCodeElement = this.getGeneratedCodeElement_({
      generatedCodeDescription: options.appStrings && options.appStrings.generatedCodeDescription
    });
    showCodeDiv.appendChild(generatedCodeElement);
    showCodeButton.style.display = 'none';
  }, this));

  return showCodeDiv;
};

/**
 * Determines whether the user can proceed to the next level, based on the level feedback
 * @param {number} feedbackType A constant property of TestResults,
 *     typically produced by StudioApp.getTestResults().
 */
FeedbackUtils.prototype.canContinueToNextLevel = function (feedbackType) {
  return feedbackType === TestResults.ALL_PASS || feedbackType === TestResults.TOO_MANY_BLOCKS_FAIL || feedbackType === TestResults.APP_SPECIFIC_ACCEPTABLE_FAIL || feedbackType === TestResults.MISSING_RECOMMENDED_BLOCK_FINISHED || feedbackType === TestResults.FREE_PLAY;
};

/**
 * Determines whether we should prompt the user to show the given
 * feedback, rather than showing it to them automatically. Currently
 * only used for missing block feedback; may expand in the future
 * @param {number} feedbackType A constant property of TestResults,
 *     typically produced by StudioApp.getTestResults().
 */
FeedbackUtils.prototype.shouldPromptForHint = function (feedbackType) {
  return feedbackType === TestResults.MISSING_BLOCK_UNFINISHED || feedbackType === TestResults.MISSING_BLOCK_FINISHED || feedbackType === TestResults.MISSING_RECOMMENDED_BLOCK_FINISHED || feedbackType === TestResults.MISSING_RECOMMENDED_BLOCK_UNFINISHED;
};

/**
 * Retrieve a string containing the user's generated Javascript code.
 */
FeedbackUtils.prototype.getGeneratedCodeString_ = function () {
  if (this.studioApp_.editCode) {
    return this.studioApp_.editor ? this.studioApp_.editor.getValue() : '';
  } else {
    return codegen.workspaceCode(Blockly);
  }
};

/**
 * Generates a "show code" div with a description of what code is.
 * @param {Object} [options] - optional
 * @param {string} [options.generatedCodeDescription] - optional description
 *        of code to put in place instead of the default
 * @returns {Element}
 * @private
 */
FeedbackUtils.prototype.getGeneratedCodeElement_ = function (options) {
  options = options || {};

  var codeInfoMsgParams = {
    berkeleyLink: "<a href='http://bjc.berkeley.edu/' target='_blank'>Berkeley</a>",
    harvardLink: "<a href='https://cs50.harvard.edu/' target='_blank'>Harvard</a>"
  };

  var infoMessage = this.getGeneratedCodeDescription(codeInfoMsgParams, options.generatedCodeDescription);
  var code = this.studioApp_.polishGeneratedCodeString(this.getGeneratedCodeString_());

  var codeDiv = document.createElement('div');
  codeDiv.innerHTML = require('./templates/code.html.ejs')({
    message: infoMessage,
    code: code
  });

  return codeDiv;
};

/**
 * Generates explanation of what code is.
 * @param {Object} codeInfoMsgParams - params for generatedCodeInfo msg function
 * @param {String} [generatedCodeDescription] - optional description to use
 *        instead of the default
 * @returns {string}
 */
FeedbackUtils.prototype.getGeneratedCodeDescription = function (codeInfoMsgParams, generatedCodeDescription) {
  if (this.studioApp_.editCode) {
    return '';
  }

  if (generatedCodeDescription) {
    return generatedCodeDescription;
  }

  return msg.generatedCodeInfo(codeInfoMsgParams);
};

/**
 * Display the 'Show Code' modal dialog.
 * @param {Dialog} Dialog
 * @param {Object} [appStrings] - optional app strings to override
 * @param {string} [appStrings.generatedCodeDescription] - string
 *        to display instead of the usual show code description
 */
FeedbackUtils.prototype.showGeneratedCode = function (Dialog, appStrings) {
  var codeDiv = this.getGeneratedCodeElement_({
    generatedCodeDescription: appStrings && appStrings.generatedCodeDescription
  });

  var buttons = document.createElement('div');
  buttons.innerHTML = require('./templates/buttons.html.ejs')({
    data: {
      ok: true
    }
  });
  codeDiv.appendChild(buttons);

  var dialog = this.createModalDialog({
    Dialog: Dialog,
    contentDiv: codeDiv,
    icon: this.studioApp_.icon,
    defaultBtnSelector: '#ok-button'
  });

  var okayButton = buttons.querySelector('#ok-button');
  if (okayButton) {
    dom.addClickTouchEvent(okayButton, function () {
      dialog.hide();
    });
  }

  dialog.show();
};

/**
 * Display the "Clear Puzzle" confirmation dialog.  Takes a parameter to hide
 * the icon.  Calls `callback` if the user confirms they want to clear the puzzle.
 */
FeedbackUtils.prototype.showClearPuzzleConfirmation = function (Dialog, hideIcon, callback) {
  this.showSimpleDialog(Dialog, {
    headerText: msg.clearPuzzleConfirmHeader(),
    bodyText: msg.clearPuzzleConfirm(),
    confirmText: msg.clearPuzzle(),
    cancelText: msg.dialogCancel(),
    onConfirm: callback,
    onCancel: null,
    hideIcon: hideIcon
  });
};

/**
 * Shows a simple dialog that has a header, body, continue button, and cancel
 * button
 * @param {object} options Configurable options.
 * @param {string} headerText Text for header portion
 * @param {string} bodyText Text for body portion
 * @param {string} cancelText Text for cancel button
 * @param {string} confirmText Text for confirm button
 * @param {boolean} hideIcon Whether to hide the icon
 * @param {function} [onConfirm] Function to be called after clicking confirm
 * @param {function} [onCancel] Function to be called after clicking cancel
 */
FeedbackUtils.prototype.showSimpleDialog = function (Dialog, options) {
  var contentDiv = document.createElement('div');
  contentDiv.innerHTML = '';
  if (options.headerText) {
    contentDiv.innerHTML += '<p class="dialog-title">' + options.headerText + '</p>';
  }
  if (options.bodyText) {
    contentDiv.innerHTML += '<p>' + options.bodyText + '</p>';
  }

  var buttons = document.createElement('div');
  buttons.innerHTML = require('./templates/buttons.html.ejs')({
    data: {
      confirmText: options.confirmText,
      cancelText: options.cancelText,
      cancelButtonClass: options.cancelButtonClass
    }
  });
  contentDiv.appendChild(buttons);

  var dialog = this.createModalDialog({
    Dialog: Dialog,
    contentDiv: contentDiv,
    icon: options.hideIcon ? null : this.studioApp_.icon,
    defaultBtnSelector: '#again-button'
  });

  var cancelButton = buttons.querySelector('#again-button');
  if (cancelButton) {
    dom.addClickTouchEvent(cancelButton, function () {
      if (options.onCancel) {
        options.onCancel();
      }
      dialog.hide();
    });
  }

  var confirmButton = buttons.querySelector('#confirm-button');
  if (confirmButton) {
    dom.addClickTouchEvent(confirmButton, function () {
      if (options.onConfirm) {
        options.onConfirm();
      }
      dialog.hide();
    });
  }

  dialog.show();
};

/**
 *
 */
FeedbackUtils.prototype.showToggleBlocksError = function (Dialog) {
  var contentDiv = document.createElement('div');
  contentDiv.innerHTML = msg.toggleBlocksErrorMsg();

  var buttons = document.createElement('div');
  buttons.innerHTML = require('./templates/buttons.html.ejs')({
    data: {
      ok: true
    }
  });
  contentDiv.appendChild(buttons);

  var dialog = this.createModalDialog({
    Dialog: Dialog,
    contentDiv: contentDiv,
    icon: this.studioApp_.icon,
    defaultBtnSelector: '#ok-button'
  });

  var okayButton = buttons.querySelector('#ok-button');
  if (okayButton) {
    dom.addClickTouchEvent(okayButton, function () {
      dialog.hide();
    });
  }

  dialog.show();
};

/**
 * Get an empty container block, if any are present.
 * @return {Blockly.Block} an empty container block, or null if none exist.
 */
FeedbackUtils.prototype.getEmptyContainerBlock_ = function () {
  var blocks = Blockly.mainBlockSpace.getAllBlocks();
  return Blockly.findEmptyContainerBlock(blocks);
};

/**
 * Check for empty container blocks, and return an appropriate failure
 * code if any are found.
 * @return {TestResults} ALL_PASS if no empty blocks are present, or
 *   EMPTY_BLOCK_FAIL or EMPTY_FUNCTION_BLOCK_FAIL if empty blocks
 *   are found.
 */
FeedbackUtils.prototype.checkForEmptyContainerBlockFailure_ = function () {
  var emptyBlock = this.getEmptyContainerBlock_();
  if (!emptyBlock) {
    return TestResults.ALL_PASS;
  }

  var type = emptyBlock.type;
  if (type === 'procedures_defnoreturn' || type === 'procedures_defreturn') {
    return TestResults.EMPTY_FUNCTION_BLOCK_FAIL;
  }

  // Block is assumed to be "if" or "repeat" if we reach here.
  // This is where to add checks if you want a different TestResult
  // for "controls_for_counter" blocks, for example.
  return TestResults.EMPTY_BLOCK_FAIL;
};

/**
 * Throws errors with descriptive messages when example call or result blocks
 * don't exist or have unfilled functional inputs.
 * @param {Blockly.Block} callBlock
 * @param {Blockly.Block} resultBlock
 */
FeedbackUtils.prototype.throwOnInvalidExampleBlocks = function (callBlock, resultBlock) {
  if (!callBlock) {
    throw new Error('Invalid Call Block');
  }

  if (!resultBlock) {
    throw new Error('Invalid Result Block');
  }

  if (resultBlock.hasUnfilledFunctionalInput()) {
    throw new Error('Result has unfilled inputs');
  }

  if (callBlock.hasUnfilledFunctionalInput()) {
    throw new Error('Call has unfilled inputs');
  }
};

/**
 * Check whether the user code has all the given blocks
 * @param {!TestableBlock[]} blocks
 * @return {boolean} true if all blocks are present, false otherwise.
 */
FeedbackUtils.prototype.hasAllBlocks_ = function (blocks) {
  // It's okay (maybe faster) to pass 1 for maxBlocksToFlag, since in the end
  // we want to check that there are zero blocks missing.
  var maxBlocksToFlag = 1;
  return this.getMissingBlocks_(blocks, maxBlocksToFlag).blocksToDisplay.length === 0;
};

/**
 * Get blocks that the user intends in the program. These are the blocks
 * that are used when checking for required and recommended blocks and
 * when determining lines of code written.
 * @return {Array<Object>} The blocks.
 */
FeedbackUtils.prototype.getUserBlocks_ = function () {
  var allBlocks = Blockly.mainBlockSpace.getAllBlocks();
  var blocks = allBlocks.filter(function (block) {
    var blockValid = !block.disabled && block.type !== 'when_run';
    // If Blockly is in readOnly mode, then all blocks are uneditable
    // so this filter would be useless. Ignore uneditable blocks only if
    // Blockly is in edit mode.
    if (!Blockly.mainBlockSpace.isReadOnly()) {
      blockValid = blockValid && block.isEditable();
    }
    return blockValid;
  });
  return blocks;
};

/**
 * Get countable blocks in the program, namely any that are not disabled.
 * These are used when determined the number of blocks relative to the ideal
 * block count.
 * @return {Array<Object>} The blocks.
 */
FeedbackUtils.prototype.getCountableBlocks_ = function () {
  var allBlocks = Blockly.mainBlockSpace.getAllBlocks();
  var blocks = allBlocks.filter(function (block) {
    return !block.disabled;
  });
  return blocks;
};

/**
 * Check to see if the user's code contains the given blocks for a level.
 * @param {!TestableBlock[]} blocks
 * @param {number} maxBlocksToFlag The maximum number of blocks to
 *   return. We most often only care about a single block at a time
 * @return {{blocksToDisplay:!Array, message:?string}} 'missingBlocks' is an
 *   array of array of strings where each array of strings is a set of blocks
 *   that at least one of them should be used. Each block is represented as the
 *   prefix of an id in the corresponding template.soy. 'message' is an
 *   optional message to override the default error text.
 */
FeedbackUtils.prototype.getMissingBlocks_ = function (blocks, maxBlocksToFlag) {
  var missingBlocks = [];
  var customMessage = null;
  var code = null; // JavaScript code, which is initialized lazily.
  if (blocks && blocks.length) {
    var userBlocks = this.getUserBlocks_();
    // For each list of blocks
    // Keep track of the number of the missing block lists. It should not be
    // bigger than the maxBlocksToFlag param.
    var missingBlockNum = 0;
    for (var i = 0; i < blocks.length && missingBlockNum < maxBlocksToFlag; i++) {
      var block = blocks[i];
      // For each of the test
      // If at least one of the tests succeeded, we consider the block
      // is used
      var usedBlock = false;
      for (var testId = 0; testId < block.length; testId++) {
        var test = block[testId].test;
        if (typeof test === 'string') {
          code = code || Blockly.Generator.blockSpaceToCode('JavaScript');
          if (code.indexOf(test) !== -1) {
            // Succeeded, moving to the next list of tests
            usedBlock = true;
            break;
          }
        } else if (typeof test === 'function') {
          if (userBlocks.some(test)) {
            // Succeeded, moving to the next list of tests
            usedBlock = true;
            break;
          } else {
            customMessage = block[testId].message || customMessage;
          }
        } else {
          throw new Error('Bad test: ' + test);
        }
      }
      if (!usedBlock) {
        missingBlockNum++;
        missingBlocks = missingBlocks.concat(blocks[i][0]);
      }
    }
  }
  return {
    blocksToDisplay: missingBlocks,
    message: customMessage
  };
};

/**
 * Do we have any floating blocks not attached to an event block or function block?
 */
FeedbackUtils.prototype.hasExtraTopBlocks = function () {
  if (this.studioApp_.editCode) {
    return false;
  }
  var topBlocks = Blockly.mainBlockSpace.getTopBlocks();
  for (var i = 0; i < topBlocks.length; i++) {
    // ignore disabled top blocks. we have a level turtle:2_7 that depends on
    // having disabled top level blocks
    if (topBlocks[i].disabled) {
      continue;
    }
    // Ignore top blocks which are functional definitions.
    if (topBlocks[i].type === 'functional_definition') {
      continue;
    }
    // None of our top level blocks should have a previous or output connection
    // (they should only have a next)
    if (topBlocks[i].previousConnection || topBlocks[i].outputConnection) {
      return true;
    }
  }
  return false;
};

/**
 * Runs the tests and returns results.
 * @param {boolean} levelComplete Did the user successfully complete the level?
 * @param {!TestableBlock[]} requiredBlocks The blocks that are required
 *   to be used in the solution to this level.
 * @param {!TestableBlock[]} recommendedBlocks The blocks that are
 *   recommended to be used in the solution to this level.
 * @param {boolean} shouldCheckForEmptyBlocks Whether empty blocks should cause
 *   a test fail result.
 * @param {Object} options
 * @return {number} The appropriate property of TestResults.
 */
FeedbackUtils.prototype.getTestResults = function (levelComplete, requiredBlocks, recommendedBlocks, shouldCheckForEmptyBlocks, options) {
  options = options || {};
  if (this.studioApp_.editCode) {
    if (levelComplete) {
      return this.studioApp_.TestResults.ALL_PASS;
    } else if (options.executionError && options.executionError.err instanceof SyntaxError) {
      return this.studioApp_.TestResults.SYNTAX_ERROR_FAIL;
    } else if (options.executionError) {
      return this.studioApp_.TestResults.RUNTIME_ERROR_FAIL;
    } else {
      return this.studioApp_.TestResults.TOO_FEW_BLOCKS_FAIL;
    }
  }
  if (shouldCheckForEmptyBlocks) {
    var emptyBlockFailure = this.checkForEmptyContainerBlockFailure_();
    if (emptyBlockFailure !== TestResults.ALL_PASS) {
      return emptyBlockFailure;
    }
  }
  if (!options.allowTopBlocks && this.hasExtraTopBlocks()) {
    return TestResults.EXTRA_TOP_BLOCKS_FAIL;
  }
  if (this.studioApp_.hasDuplicateVariablesInForLoops()) {
    return TestResults.NESTED_FOR_SAME_VARIABLE;
  }
  if (Blockly.useContractEditor || Blockly.useModalFunctionEditor) {
    if (this.hasUnusedParam_()) {
      return TestResults.UNUSED_PARAM;
    }
    if (this.hasUnusedFunction_()) {
      return TestResults.UNUSED_FUNCTION;
    }
    if (this.hasParamInputUnattached_()) {
      return TestResults.PARAM_INPUT_UNATTACHED;
    }
    if (this.hasIncompleteBlockInFunction_()) {
      return TestResults.INCOMPLETE_BLOCK_IN_FUNCTION;
    }
  }
  if (this.hasQuestionMarksInNumberField()) {
    return TestResults.QUESTION_MARKS_IN_NUMBER_FIELD;
  }
  if (!this.hasAllBlocks_(requiredBlocks)) {
    return levelComplete ? TestResults.MISSING_BLOCK_FINISHED : TestResults.MISSING_BLOCK_UNFINISHED;
  }
  if (!this.hasAllBlocks_(recommendedBlocks)) {
    return levelComplete ? TestResults.MISSING_RECOMMENDED_BLOCK_FINISHED : TestResults.MISSING_RECOMMENDED_BLOCK_UNFINISHED;
  }
  var numEnabledBlocks = this.getNumCountableBlocks();
  if (!levelComplete) {
    if (this.studioApp_.IDEAL_BLOCK_NUM && this.studioApp_.IDEAL_BLOCK_NUM !== Infinity && numEnabledBlocks < this.studioApp_.IDEAL_BLOCK_NUM) {
      return TestResults.TOO_FEW_BLOCKS_FAIL;
    }
    return TestResults.LEVEL_INCOMPLETE_FAIL;
  }
  if (this.studioApp_.IDEAL_BLOCK_NUM && numEnabledBlocks > this.studioApp_.IDEAL_BLOCK_NUM) {
    return TestResults.TOO_MANY_BLOCKS_FAIL;
  } else {
    return TestResults.ALL_PASS;
  }
};

/**
 * Show a modal dialog without an icon.
 * @param {Object} options
 * @param {Dialog} options.Dialog
 * @param {string} options.icon
 * @param {HTMLElement} options.contentDiv
 * @param {string} options.defaultBtnSelector
 * @param {boolean} options.markdownMode
 * @param {boolean} options.scrollContent
 * @param {boolean} options.scrollableSelector
 * @param {function} options.onHidden
 * @param {string} options.id
 * @param {HTMLElement} options.header
 */
FeedbackUtils.prototype.createModalDialog = function (options) {
  var modalBody = document.createElement('div');
  if (options.icon) {
    var imageDiv;
    imageDiv = document.createElement('img');
    imageDiv.className = "modal-image";
    imageDiv.src = options.icon;
    modalBody.appendChild(imageDiv);
  } else {
    options.contentDiv.className += ' no-modal-icon';
  }

  if (options.markdownMode) {
    modalBody.className += ' markdown';
  }

  options.contentDiv.className += ' modal-content';
  modalBody.appendChild(options.contentDiv);

  var btn = options.contentDiv.querySelector(options.defaultBtnSelector);
  var keydownHandler = function keydownHandler(e) {
    if (e.keyCode == KeyCodes.ENTER || e.keyCode == KeyCodes.SPACE) {
      // Simulate a 'click':
      var event = new MouseEvent('click', {
        'view': window,
        'bubbles': true,
        'cancelable': true
      });
      btn.dispatchEvent(event);

      e.stopPropagation();
      e.preventDefault();
    }
  };

  var scrollableSelector = options.scrollableSelector || '.modal-content';
  var elementToScroll = options.scrollContent ? scrollableSelector : null;
  return new options.Dialog({
    body: modalBody,
    onHidden: options.onHidden,
    onKeydown: btn ? keydownHandler : undefined,
    autoResizeScrollableElement: elementToScroll,
    id: options.id,
    header: options.header
  });
};

/**
 * Check for '???' instead of a value in block fields.
 */
FeedbackUtils.prototype.hasQuestionMarksInNumberField = function () {
  return Blockly.mainBlockSpace.getAllBlocks().some(function (block) {
    return block.getTitles().some(function (title) {
      return title.value_ === '???' || title.text_ === '???';
    });
  });
};

/**
 * Ensure that all procedure definitions actually use the parameters they define
 * inside the procedure.
 */
FeedbackUtils.prototype.hasUnusedParam_ = function () {
  var self = this;
  return Blockly.mainBlockSpace.getAllBlocks().some(function (userBlock) {
    var params = userBlock.parameterNames_;
    // Only search procedure definitions
    return params && params.some(function (paramName) {
      // Unused param if there's no parameters_get descendant with the same name
      return !self.hasMatchingDescendant_(userBlock, function (block) {
        return (block.type === 'parameters_get' || block.type === 'functional_parameters_get' || block.type === 'variables_get') && block.getTitleValue('VAR') === paramName;
      });
    });
  });
};

/**
 * Ensure that all procedure calls have each parameter input connected.
 */
FeedbackUtils.prototype.hasParamInputUnattached_ = function () {
  return Blockly.mainBlockSpace.getAllBlocks().some(function (userBlock) {
    // Only check procedure_call* blocks
    if (!/^procedures_call/.test(userBlock.type)) {
      return false;
    }
    return userBlock.inputList.filter(function (input) {
      return (/^ARG/.test(input.name)
      );
    }).some(function (argInput) {
      // Unattached param input if any ARG* connection target is null
      return !argInput.connection.targetConnection;
    });
  });
};

/**
 * Ensure that all user-declared procedures have associated call blocks.
 */
FeedbackUtils.prototype.hasUnusedFunction_ = function () {
  var userDefs = [];
  var callBlocks = {};
  Blockly.mainBlockSpace.getAllBlocks().forEach(function (block) {
    var name = block.getTitleValue('NAME');
    if (/^procedures_def/.test(block.type) && block.userCreated) {
      userDefs.push(name);
    } else if (/^procedures_call/.test(block.type)) {
      callBlocks[name] = true;
    }
  });
  // Unused function if some user def doesn't have a matching call
  return userDefs.some(function (name) {
    return !callBlocks[name];
  });
};

/**
 * Ensure there are no incomplete blocks inside any function definitions.
 */
FeedbackUtils.prototype.hasIncompleteBlockInFunction_ = function () {
  var self = this;
  return Blockly.mainBlockSpace.getAllBlocks().some(function (userBlock) {
    // Only search procedure definitions
    if (!userBlock.parameterNames_) {
      return false;
    }
    return self.hasMatchingDescendant_(userBlock, function (block) {
      // Incomplete block if any input connection target is null
      return block.inputList.some(function (input) {
        return input.type === Blockly.INPUT_VALUE && !input.connection.targetConnection;
      });
    });
  });
};

/**
 * Returns true if any descendant (inclusive) of the given node matches the
 * given filter.
 */
FeedbackUtils.prototype.hasMatchingDescendant_ = function (node, filter) {
  if (filter(node)) {
    return true;
  }
  var self = this;
  return node.childBlocks_.some(function (child) {
    return self.hasMatchingDescendant_(child, filter);
  });
};

},{"./codegen":"/home/ubuntu/staging/apps/build/js/codegen.js","./constants":"/home/ubuntu/staging/apps/build/js/constants.js","./dom":"/home/ubuntu/staging/apps/build/js/dom.js","./feedbackBlocks":"/home/ubuntu/staging/apps/build/js/feedbackBlocks.js","./locale":"/home/ubuntu/staging/apps/build/js/locale.js","./puzzleRatingUtils":"/home/ubuntu/staging/apps/build/js/puzzleRatingUtils.js","./templates/buttons.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/buttons.html.ejs","./templates/code.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/code.html.ejs","./templates/shareFailure.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/shareFailure.html.ejs","./templates/sharing.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/sharing.html.ejs","./templates/showCode.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/showCode.html.ejs","./templates/trophy.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/trophy.html.ejs","./utils":"/home/ubuntu/staging/apps/build/js/utils.js","./xml":"/home/ubuntu/staging/apps/build/js/xml.js"}],"/home/ubuntu/staging/apps/build/js/templates/trophy.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<div class=\'trophy\'><img class=\'trophyimg\' src=\'', escape((1,  img_url )), '\'><br>', escape((1,  concept_name )), '</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/showCode.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1; var msg = require('../locale'); ; buf.push('\n\n<p id="num-lines-of-code" class="lines-of-code-message">\n  ', escape((4,  msg.numLinesOfCodeWritten({ numLines: numLinesWritten }) )), '\n  <button id="show-code-button" href="#">\n    ', escape((6,  msg.showGeneratedCode() )), '\n  </button>\n</p>\n\n');10; if (totalNumLinesWritten !== 0) { ; buf.push('\n  <p id="total-num-lines-of-code" class="lines-of-code-message">\n    ', escape((12,  msg.totalNumLinesOfCodeWritten({ numLines: totalNumLinesWritten }) )), '\n  </p>\n');14; } ; buf.push('\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js","ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/sharing.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1; var msg = require('../locale'); ; buf.push('\n');2; if (options.feedbackImage) { ; buf.push('\n  <img class="feedback-image" src="', escape((3,  options.feedbackImage )), '"/>\n  <div class="sharing-content">\n');5; } else { ; buf.push('\n  <div class="sharing-content no-image">\n');7; } ; buf.push('\n\n\n');10; if (options.response && options.response.level_source) { ; buf.push('\n  ');11; if (options.appStrings && options.appStrings.sharingText) { ; buf.push('\n    <div>', escape((12,  options.appStrings.sharingText )), '</div>\n  ');13; } ; buf.push('\n\n  <div>\n    <input type="text" id="sharing-input" value=', escape((16,  options.response.level_source )), ' readonly>\n  </div>\n  <div class=\'social-buttons\'>\n    ');19; if (options.facebookUrl) {; buf.push('      <a href=\'', escape((19,  options.facebookUrl )), '\' target="_blank" class="popup-window">\n        <button>\n          <i class="fa fa-facebook fa-lg"></i>\n        </button>\n      </a>\n    ');24; }; buf.push('    ');24; if (options.twitterUrl) {; buf.push('      <a href=\'', escape((24,  options.twitterUrl )), '\' target="_blank" class="popup-window">\n        <button>\n          <i class="fa fa-twitter fa-lg"></i>\n        </button>\n      </a>\n    ');29; }; buf.push('    ');29; if (!options.onMainPage && !options.disablePrinting) { ; buf.push('\n      <button id="print-button">\n        <i class="fa fa-print fa-lg"></i>\n      </button>\n    ');33; } ; buf.push('\n    ');34; if (options.alreadySaved) { ; buf.push('\n      <button class="saved-to-gallery" disabled>\n        ', escape((36,  msg.savedToGallery() )), '\n      </button>\n    ');38; } else if (options.saveToGalleryUrl && !options.disableSaveToGallery) { ; buf.push('\n      <button id="save-to-gallery-button" class="launch">\n        ', escape((40,  msg.saveToGallery() )), '\n      </button>\n    ');42; } ; buf.push('\n    ');43; if (options.sendToPhone) {; buf.push('      <button id="sharing-phone">\n        <i class="fa fa-mobile fa-lg"></i>\n        ', escape((45,  msg.sendToPhone() )), '\n      </button>\n    ');47; }; buf.push('\n  </div>\n  <div id="send-to-phone" style="display: none">\n    <label for="phone">Enter a US phone number:</label>\n    <input type="tel" id="phone" name="phone" />\n    <button id="phone-submit" onClick="return false;">Send</button>\n    <div id="phone-charges">A text message will be sent via <a href="http://twilio.com" target="_blank">Twilio</a>. Charges may apply to the recipient.</div>\n  </div>\n');55; } ; buf.push('\n\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js","ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/shareFailure.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<p id="share-fail-explanation">', escape((1,  shareFailure.message )), '</p>\n\n');3; if (shareFailure.contents) { ; buf.push('\n  <div class="share-fail-excerpt">\n    <pre class="generatedCode">', escape((5,  shareFailure.contents )), '</pre>\n  </div>\n');7; } ; buf.push('\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/code.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<div class="generated-code-container">\n  <p class="generatedCodeMessage">', (2,  message ), '</p>\n  <pre class="generatedCode">', escape((3,  code )), '</pre>\n</div>\n\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/buttons.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1; var msg = require('../locale'); ; buf.push('\n\n');3; if (data.ok) {; buf.push('  <div class="farSide" style="padding: 1ex 3ex 0">\n    <button id="ok-button" class="secondary">\n      ', escape((5,  msg.dialogOK() )), '\n    </button>\n  </div>\n');8; }; buf.push('\n');9; if (data.cancelText) {; buf.push('<button id="again-button" class="', escape((9,  data.cancelButtonClass || '' )), '">\n    ', escape((10,  data.cancelText )), '\n</button>\n');12; }; buf.push('\n');13; if (data.confirmText) {; buf.push('<button id="confirm-button" class="launch" style="float: right">\n    ', escape((14,  data.confirmText )), '\n</button>\n');16; }; buf.push('\n');17; if (data.previousLevel) {; buf.push('  <button id="back-button" class="launch">\n    ', escape((18,  msg.backToPreviousLevel() )), '\n  </button>\n');20; }; buf.push('\n');21; if (data.tryAgain) {; buf.push('  ');21; if (data.isK1 && !data.freePlay) {; buf.push('    <div id="again-button" class="launch arrow-container arrow-left">\n      <div class="arrow-head"><img src="', escape((22,  data.assetUrl('media/tryagain-arrow-head.png') )), '" alt="Arrowhead" width="67" height="130"/></div>\n      <div class="arrow-text">', escape((23,  data.tryAgain )), '</div>\n    </div>\n  ');25; } else {; buf.push('    ');25; if (data.shouldPromptForHint) {; buf.push('      <button id="hint-request-button" class="lightbulb-button">\n        <span>' + (function(){var buf = [];
 buf.push('<svg version="1.1"\n	 id="svg3013" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:svg="http://www.w3.org/2000/svg" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" sodipodi:docname="light_bulb_font_awesome.svg" inkscape:version="0.48.3.1 r9886"\n	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px"\n	 viewBox="0 0 612 792" enable-background="new 0 0 612 792" xml:space="preserve">\n<g id="bulb">\n  <path fill="#EFB834" d="M453.775,353.156c0,24.012-57.189,128.942-61.414,132.265c-12.384,9.741-48.514,15.318-82.869,16.518\n    c-8.362,0.292-16.619,0.325-24.403,0.096c-20.716-0.611-38.081-3.079-45.155-7.464c-6.896-4.274-74.477-119.24-74.477-141.415\n    c0-89.195,64.542-161.502,144.159-161.502S453.775,263.961,453.775,353.156z"/>\n  <g id="g3015" transform="matrix(1,0,0,-1,379.66102,1293.0169)">\n    <path id="path3017" inkscape:connector-curvature="0" fill="#5D5D5D" d="M7.357,980.857c0-2.96-1.081-5.521-3.244-7.684\n      s-4.724-3.244-7.684-3.244s-5.521,1.081-7.684,3.244s-3.244,4.724-3.244,7.684c0,10.473-6.147,18.556-18.442,24.248\n      c-12.295,5.692-24.362,8.538-36.201,8.538c-2.96,0-5.521,1.081-7.684,3.244s-3.244,4.724-3.244,7.684\n      c0,2.96,1.081,5.521,3.244,7.684s4.724,3.244,7.684,3.244c11.384,0,22.711-1.821,33.981-5.464s21.174-9.79,29.712-18.442\n      S7.357,992.696,7.357,980.857z M62,980.857c0,16.393-3.927,31.647-11.782,45.763s-18.1,25.671-30.737,34.664\n      s-26.638,16.051-42.007,21.174s-30.907,7.684-46.617,7.684s-31.249-2.561-46.617-7.684s-29.371-12.181-42.007-21.174\n      c-12.636-8.993-22.882-20.548-30.737-34.664c-7.855-14.116-11.782-29.371-11.782-45.763c0-22.996,7.741-43.487,23.223-61.473\n      c2.277-2.504,5.749-6.261,10.416-11.27c4.667-5.009,8.14-8.766,10.416-11.27c29.143-34.835,45.194-68.759,48.154-101.772h77.866\n      c2.96,33.013,19.011,66.938,48.154,101.772c2.277,2.504,5.749,6.261,10.416,11.27s8.14,8.766,10.416,11.27\n      C54.259,937.37,62,957.862,62,980.857z M105.714,980.857c0-35.29-11.725-65.799-35.176-91.527\n      c-10.246-11.156-18.727-21.06-25.443-29.712s-13.49-19.523-20.32-32.615c-6.83-13.092-10.701-25.329-11.612-36.713\n      c10.701-6.375,16.051-15.71,16.051-28.004c0-8.424-2.846-15.71-8.538-21.857c5.692-6.147,8.538-13.433,8.538-21.857\n      c0-11.839-5.123-21.06-15.368-27.663c2.96-5.237,4.44-10.587,4.44-16.051c0-10.473-3.586-18.556-10.758-24.248\n      s-15.994-8.538-26.468-8.538c-4.554-10.018-11.384-17.987-20.491-23.906c-9.107-5.92-19.011-8.879-29.712-8.879\n      c-10.701,0-20.605,2.96-29.712,8.879c-9.107,5.92-15.938,13.888-20.491,23.906c-10.473,0-19.296,2.846-26.468,8.538\n      s-10.758,13.775-10.758,24.248c0,5.464,1.48,10.815,4.44,16.051c-10.246,6.603-15.368,15.824-15.368,27.663\n      c0,8.424,2.846,15.71,8.538,21.857c-5.692,6.147-8.538,13.433-8.538,21.857c0,12.295,5.35,21.629,16.051,28.004\n      c-0.911,11.384-4.781,23.622-11.612,36.713c-6.83,13.091-13.604,23.963-20.32,32.615s-15.198,18.556-25.443,29.712\n      C-232.275,915.058-244,945.567-244,980.857c0,22.54,5.066,43.544,15.198,63.01c10.132,19.467,23.451,35.632,39.958,48.496\n      c16.507,12.864,35.176,22.995,56.009,30.395s42.064,11.099,63.693,11.099s42.86-3.7,63.693-11.099s39.502-17.531,56.009-30.395\n      c16.507-12.864,29.826-29.029,39.958-48.496C100.648,1024.401,105.714,1003.397,105.714,980.857z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="473.582" y1="208.1" x2="560.578" y2="159.16"/>\n    <path fill="#EFB834" d="M473.141,207.315c0,0,1.225-1.003,3.396-2.711c1.08-0.864,2.402-1.894,3.925-3.063\n      c1.525-1.167,3.227-2.514,5.117-3.927c1.887-1.418,3.931-2.954,6.092-4.578c2.158-1.632,4.462-3.3,6.831-5.055\n      c2.386-1.723,4.843-3.519,7.372-5.285c2.515-1.791,5.104-3.552,7.677-5.341c2.578-1.778,5.065-3.721,7.503-5.648\n      c1.228-0.948,2.436-1.907,3.665-2.792c1.231-0.881,2.478-1.695,3.736-2.442c2.527-1.472,5.12-2.629,7.656-3.587\n      c2.529-0.971,4.998-1.751,7.331-2.377c4.655-1.268,8.797-1.858,11.81-2.069c1.504-0.109,2.718-0.138,3.572-0.111\n      c0.843,0.007,1.313,0.047,1.313,0.047l0.883,1.569c0,0-0.21,0.422-0.641,1.146c-0.42,0.744-1.075,1.766-1.95,2.995\n      c-1.745,2.465-4.4,5.698-7.9,9.019c-1.746,1.669-3.694,3.374-5.838,5.031c-2.136,1.671-4.471,3.285-7.041,4.681\n      c-1.291,0.687-2.635,1.331-4.027,1.925c-1.394,0.591-2.841,1.126-4.289,1.683c-2.914,1.083-5.865,2.2-8.723,3.48\n      c-2.865,1.27-5.713,2.568-8.55,3.788c-2.823,1.245-5.633,2.412-8.345,3.556c-2.729,1.113-5.352,2.217-7.867,3.213\n      c-2.511,1.004-4.885,1.953-7.076,2.83c-2.189,0.881-4.224,1.637-6.013,2.334c-1.79,0.695-3.357,1.29-4.656,1.764\n      c-2.587,0.968-4.08,1.494-4.08,1.494L473.141,207.315z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="492.348" y1="410.008" x2="589.509" y2="432.883"/>\n    <path fill="#EFB834" d="M492.555,409.132c0,0,1.581,0.091,4.335,0.303c1.38,0.095,3.05,0.232,4.962,0.403\n      c1.912,0.173,4.077,0.334,6.424,0.574c2.348,0.234,4.892,0.487,7.583,0.755c2.693,0.259,5.519,0.592,8.45,0.904\n      c2.923,0.347,5.947,0.688,9.004,1.101c3.064,0.384,6.161,0.841,9.266,1.266c3.102,0.437,6.247,0.691,9.346,0.922\n      c1.546,0.133,3.084,0.246,4.588,0.426c1.502,0.185,2.972,0.43,4.403,0.732c2.857,0.628,5.548,1.531,8.064,2.543\n      c2.519,0.998,4.864,2.095,7.004,3.213c4.285,2.219,7.732,4.588,10.093,6.472c1.181,0.938,2.094,1.738,2.704,2.337\n      c0.615,0.576,0.934,0.923,0.934,0.923l-0.412,1.752c0,0-0.44,0.169-1.248,0.41c-0.813,0.263-1.987,0.572-3.463,0.885\n      c-2.953,0.633-7.096,1.216-11.92,1.29c-2.414,0.046-5.003-0.018-7.702-0.249c-2.703-0.216-5.515-0.609-8.351-1.322\n      c-1.415-0.368-2.84-0.804-4.267-1.309c-1.426-0.509-2.853-1.095-4.296-1.665c-2.878-1.176-5.805-2.351-8.776-3.344\n      c-2.968-1.004-5.944-1.977-8.857-3c-2.92-0.995-5.779-2.038-8.549-3.032c-2.762-1.029-5.44-1.992-7.965-2.961\n      c-2.528-0.961-4.918-1.869-7.124-2.708c-2.207-0.833-4.217-1.655-6.005-2.353c-1.788-0.7-3.344-1.323-4.621-1.854\n      c-2.559-1.039-4.015-1.663-4.015-1.663L492.555,409.132z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="502.559" y1="301.7" x2="602.37" y2="300.685"/>\n    <path fill="#EFB834" d="M502.55,300.8c0,0,1.557-0.289,4.282-0.742c1.362-0.237,3.017-0.504,4.915-0.795\n      c1.898-0.289,4.039-0.65,6.375-0.979c2.336-0.334,4.867-0.697,7.544-1.08c2.677-0.392,5.5-0.744,8.421-1.142\n      c2.921-0.362,5.939-0.753,9.006-1.084c3.067-0.359,6.183-0.656,9.3-0.985c3.116-0.317,6.23-0.823,9.296-1.339\n      c1.533-0.24,3.053-0.499,4.556-0.683c1.503-0.18,2.989-0.293,4.45-0.342c2.924-0.073,5.753,0.16,8.438,0.542\n      c2.685,0.366,5.224,0.871,7.57,1.446c4.691,1.13,8.605,2.607,11.347,3.872c1.371,0.629,2.449,1.187,3.185,1.622\n      c0.735,0.412,1.128,0.673,1.128,0.673l0.018,1.8c0,0-0.387,0.269-1.114,0.696c-0.727,0.45-1.793,1.031-3.151,1.687\n      c-2.716,1.321-6.6,2.877-11.266,4.102c-2.333,0.622-4.862,1.179-7.539,1.599c-2.676,0.436-5.5,0.727-8.425,0.713\n      c-1.462-0.019-2.95-0.102-4.456-0.251c-1.506-0.153-3.032-0.381-4.569-0.59c-3.075-0.454-6.199-0.895-9.321-1.149\n      c-3.122-0.266-6.244-0.499-9.318-0.796c-3.073-0.268-6.099-0.598-9.026-0.9c-2.928-0.338-5.758-0.634-8.442-0.971\n      c-2.684-0.329-5.222-0.639-7.564-0.926c-2.342-0.281-4.49-0.599-6.394-0.849c-1.903-0.253-3.563-0.486-4.93-0.695\n      c-2.734-0.397-4.296-0.655-4.296-0.655L502.55,300.8z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="135.661" y1="212.764" x2="48.665" y2="163.824"/>\n    <path fill="#EFB834" d="M135.22,213.548c0,0-1.493-0.526-4.08-1.494c-1.299-0.474-2.866-1.069-4.656-1.764\n      c-1.789-0.697-3.824-1.453-6.013-2.334c-2.191-0.876-4.565-1.826-7.076-2.83c-2.515-0.996-5.138-2.1-7.867-3.213\n      c-2.712-1.144-5.522-2.312-8.345-3.556c-2.837-1.22-5.686-2.518-8.55-3.788c-2.859-1.28-5.81-2.397-8.723-3.48\n      c-1.448-0.557-2.895-1.092-4.289-1.683c-1.392-0.594-2.736-1.238-4.027-1.925c-2.57-1.396-4.905-3.01-7.041-4.681\n      c-2.143-1.657-4.092-3.363-5.838-5.031c-3.5-3.32-6.155-6.554-7.9-9.019c-0.874-1.229-1.53-2.251-1.95-2.995\n      c-0.431-0.724-0.641-1.146-0.641-1.146l0.883-1.569c0,0,0.47-0.04,1.313-0.047c0.854-0.027,2.068,0.002,3.572,0.111\n      c3.013,0.211,7.155,0.801,11.81,2.069c2.332,0.625,4.801,1.406,7.331,2.377c2.537,0.958,5.129,2.115,7.656,3.587\n      c1.258,0.746,2.505,1.561,3.736,2.442c1.229,0.885,2.437,1.844,3.665,2.792c2.438,1.928,4.925,3.87,7.503,5.648\n      c2.573,1.789,5.161,3.549,7.677,5.341c2.529,1.766,4.986,3.562,7.372,5.285c2.368,1.755,4.673,3.423,6.831,5.055\n      c2.162,1.625,4.206,3.16,6.092,4.578c1.889,1.413,3.592,2.76,5.117,3.927c1.523,1.169,2.845,2.199,3.925,3.063\n      c2.17,1.708,3.396,2.711,3.396,2.711L135.22,213.548z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="120.895" y1="411.672" x2="23.734" y2="434.547"/>\n    <path fill="#EFB834" d="M121.101,412.548c0,0-1.456,0.623-4.015,1.663c-1.277,0.53-2.833,1.153-4.621,1.854\n      c-1.788,0.698-3.798,1.52-6.005,2.353c-2.206,0.838-4.596,1.747-7.124,2.708c-2.526,0.969-5.203,1.932-7.965,2.961\n      c-2.77,0.993-5.629,2.037-8.549,3.032c-2.914,1.023-5.889,1.996-8.857,3c-2.971,0.993-5.899,2.169-8.776,3.344\n      c-1.443,0.57-2.87,1.156-4.296,1.665c-1.427,0.505-2.852,0.941-4.267,1.309c-2.836,0.713-5.648,1.105-8.351,1.321\n      c-2.699,0.231-5.288,0.295-7.702,0.249c-4.824-0.074-8.967-0.657-11.92-1.29c-1.476-0.313-2.65-0.621-3.463-0.885\n      c-0.808-0.241-1.248-0.41-1.248-0.41l-0.413-1.752c0,0,0.319-0.347,0.934-0.923c0.61-0.598,1.523-1.399,2.704-2.337\n      c2.36-1.884,5.808-4.254,10.093-6.472c2.14-1.119,4.485-2.216,7.004-3.213c2.516-1.012,5.207-1.915,8.064-2.543\n      c1.431-0.302,2.9-0.547,4.403-0.732c1.503-0.181,3.042-0.293,4.588-0.426c3.1-0.232,6.245-0.486,9.346-0.922\n      c3.104-0.425,6.201-0.882,9.265-1.266c3.057-0.412,6.081-0.754,9.004-1.101c2.931-0.312,5.757-0.644,8.45-0.904\n      c2.691-0.268,5.235-0.521,7.583-0.755c2.347-0.239,4.512-0.4,6.424-0.574c1.913-0.171,3.583-0.308,4.962-0.403\n      c2.754-0.212,4.335-0.303,4.335-0.303L121.101,412.548z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="112.684" y1="306.364" x2="12.873" y2="305.349"/>\n    <path fill="#EFB834" d="M112.675,307.264c0,0-1.562,0.257-4.296,0.655c-1.367,0.21-3.026,0.443-4.93,0.695\n      c-1.904,0.25-4.051,0.568-6.394,0.849c-2.343,0.287-4.88,0.598-7.564,0.926c-2.684,0.337-5.514,0.633-8.442,0.971\n      c-2.928,0.302-5.953,0.632-9.026,0.9c-3.074,0.297-6.195,0.53-9.318,0.796c-3.122,0.254-6.246,0.696-9.321,1.149\n      c-1.537,0.209-3.063,0.437-4.569,0.59c-1.506,0.149-2.994,0.232-4.456,0.251c-2.925,0.014-5.749-0.277-8.425-0.713\n      c-2.676-0.421-5.205-0.977-7.539-1.599c-4.667-1.225-8.55-2.781-11.266-4.102c-1.358-0.656-2.424-1.237-3.151-1.687\n      c-0.727-0.427-1.114-0.696-1.114-0.696l0.018-1.8c0,0,0.393-0.261,1.128-0.673c0.736-0.435,1.814-0.994,3.185-1.622\n      c2.742-1.265,6.657-2.742,11.347-3.872c2.345-0.575,4.885-1.079,7.57-1.446c2.685-0.382,5.514-0.615,8.438-0.542\n      c1.462,0.049,2.947,0.162,4.45,0.342c1.503,0.184,3.024,0.443,4.556,0.683c3.065,0.516,6.18,1.021,9.296,1.339\n      c3.116,0.329,6.232,0.626,9.299,0.985c3.067,0.33,6.085,0.722,9.006,1.084c2.92,0.398,5.744,0.75,8.421,1.142\n      c2.677,0.383,5.208,0.745,7.544,1.08c2.336,0.329,4.477,0.69,6.375,0.979c1.898,0.291,3.552,0.558,4.915,0.795\n      c2.725,0.453,4.282,0.742,4.282,0.742L112.675,307.264z"/>\n  </g>\n</g>\n<g id="count">\n  <text x="400" y="700" id="hintCount"></text>\n</g>\n</svg>\n');
return buf.join('');})() + '</span>\n        ', escape((27,  msg.hintRequest() )), '\n      </button>\n    ');29; } ; buf.push('\n    <button id="again-button" class="launch">\n      ', escape((31,  data.tryAgain )), '\n    </button>\n  ');33; }; buf.push('');33; }; buf.push('\n');34; if (data.nextLevel) {; buf.push('  ');34; if (data.isK1 && !data.freePlay) {; buf.push('    <div id="continue-button" class="launch arrow-container arrow-right">\n      <div class="arrow-head"><img src="', escape((35,  data.assetUrl('media/next-arrow-head.png') )), '" alt="Arrowhead" width="66" height="130"/></div>\n      <div class="arrow-text">', escape((36,  data.continueText )), '</div>\n    </div>\n  ');38; } else {; buf.push('    <button id="continue-button" class="launch" style="float: right">\n      ', escape((39,  data.continueText )), '\n    </button>\n  ');41; }; buf.push('');41; }; buf.push('<div class="after-feedback-buttons"/>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js","ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/puzzleRatingUtils.js":[function(require,module,exports){
/**
 * @overview A helper class for all actions associated with Puzzle
 * Ratings, aka the Fun-O-Meter.
 */

'use strict';

var puzzleRatingUtils = {};

module.exports = puzzleRatingUtils;

var dom = require('./dom');

/**
 * Construct the puzzle rating buttons themselves
 *
 * @returns {Element} div containing puzzle ratng buttons with attached
 *          click handlers
 */
puzzleRatingUtils.buildPuzzleRatingButtons = function () {
  var buttonContainer = document.createElement('div');
  buttonContainer.id = 'puzzleRatingButtons';
  buttonContainer.innerHTML = require('./templates/puzzleRating.html.ejs')();

  var buttons = buttonContainer.querySelectorAll('.puzzle-rating-btn');
  var buttonClickHandler = function buttonClickHandler() {
    for (var i = 0, button; button = buttons[i]; i++) {
      if (button != this) {
        $(button).removeClass('enabled');
      }
    }
    $(this).toggleClass('enabled');
  };
  for (var i = 0, button; button = buttons[i]; i++) {
    dom.addClickTouchEvent(button, buttonClickHandler);
  }

  return buttonContainer;
};

/**
 * @typedef {Object} PuzzleRating
 *
 * @property {number} script_id
 * @property {number} level_id
 * @property {number|string} rating - can be a number or an
 *           integer-parseable string
 */

/**
 * Private getter/localStorage proxy
 * @returns {PuzzleRating[]} - ratings
 */
puzzleRatingUtils.getPuzzleRatings_ = function () {
  var ratings = localStorage.getItem('puzzleRatings');
  try {
    return ratings ? JSON.parse(ratings) : [];
  } catch (e) {
    return [];
  }
};

/**
 * Private setter/localStorage proxy
 * @param {PuzzleRating[]} ratings
 */
puzzleRatingUtils.setPuzzleRatings_ = function (ratings) {
  localStorage.setItem('puzzleRatings', JSON.stringify(ratings));
};

/**
 * Private deleter/localStorage proxy
 * @param {PuzzleRating} rating
 */
puzzleRatingUtils.removePuzzleRating_ = function (rating) {
  var ratings = puzzleRatingUtils.getPuzzleRatings_().filter(function (other) {
    var otherEqualsRating = rating.level_id === other.level_id && rating.script_id === other.script_id && rating.rating === other.rating;
    return !otherEqualsRating;
  });
  puzzleRatingUtils.setPuzzleRatings_(ratings);
};

/**
 * Cache the selected rating, to be submitted (possibly with other
 * cached ratings) at some later point
 *
 * @param {jQuery} container - some element that contains the buttons
 * @param {Object} options - other data to be submitted along with the
 *        rating. Usually script_id and level_id
 */
puzzleRatingUtils.cachePuzzleRating = function (container, options) {
  var selectedButton = container.querySelector('.puzzle-rating-btn.enabled');
  if (selectedButton) {
    var rating = $.extend({}, options, { rating: selectedButton.getAttribute('data-value') });
    var ratings = puzzleRatingUtils.getPuzzleRatings_();
    ratings.push(rating);
    puzzleRatingUtils.setPuzzleRatings_(ratings);
  }
};

/**
 * POST the cached ratings to the given URL and clear the cache
 * @param {string} url 
 */
puzzleRatingUtils.submitCachedPuzzleRatings = function (url) {
  var ratings = puzzleRatingUtils.getPuzzleRatings_();
  ratings.forEach(function (rating) {
    $.ajax({
      url: url,
      type: 'POST',
      data: rating,
      complete: function complete() {
        puzzleRatingUtils.removePuzzleRating_(rating);
      }
    });
  });
};

},{"./dom":"/home/ubuntu/staging/apps/build/js/dom.js","./templates/puzzleRating.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/puzzleRating.html.ejs"}],"/home/ubuntu/staging/apps/build/js/templates/puzzleRating.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<hr>\n<p>Did you like this puzzle?</p>\n\n<a class="puzzle-rating-btn" id="like" data-value="1">\n  <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n      width="27px" height="27px" viewBox="0 0 26.055 21.058" enable-background="new 0 0 26.055 21.058" xml:space="preserve" value="1">\n    <path d="M14.426,2.5c0.986-1.348,2.83-2.5,5.092-2.5c3.613,0,6.537,3.044,6.537,6.537\n        c0,2.357-1.076,3.709-1.894,4.525c-0.941,0.941-8.082,8.082-9.113,9.113c-1.244,1.243-3.019,1.137-4.246-0.09\n        c-1.314-1.314-7.158-7.158-9.131-9.131C0.408,9.693,0,8.113,0,6.537C0,2.926,3.197,0,6.537,0c2.451,0,4.438,1.508,5.188,2.535\n        C12.4,3.459,13.643,3.564,14.426,2.5z"/>\n  </svg>\n</a>\n\n<a class="puzzle-rating-btn" id="dislike" data-value="0">\n  <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n      width="27px" height="27px" viewBox="382.321 292.82 26.37 26.371" enable-background="new 382.321 292.82 26.37 26.371"\n      xml:space="preserve">\n    <path d="M395.506,292.82c-7.282,0.002-13.184,5.904-13.185,13.185c0.001,7.283,5.902,13.184,13.185,13.186\n        c7.281-0.002,13.183-5.902,13.185-13.186C408.689,298.725,402.787,292.822,395.506,292.82z M402.5,313\n        c-1.795,1.793-4.257,2.896-6.994,2.898c-2.737-0.002-5.199-1.105-6.994-2.898c-1.794-1.795-2.897-4.258-2.897-6.994\n        s1.103-5.199,2.897-6.994c1.795-1.793,4.257-2.897,6.994-2.897s5.199,1.104,6.994,2.897c1.792,1.795,2.896,4.258,2.896,6.994\n        S404.292,311.205,402.5,313z M391.317,304.951c1.054,0,1.907-0.854,1.907-1.906c0-1.053-0.854-1.906-1.907-1.906\n        c-1.054,0-1.907,0.854-1.907,1.906C389.41,304.098,390.264,304.951,391.317,304.951z M399.691,304.951\n        c1.053,0,1.906-0.854,1.906-1.906c0-1.053-0.853-1.906-1.906-1.906s-1.907,0.854-1.907,1.906\n        C397.784,304.098,398.639,304.951,399.691,304.951z M391.773,311.928c1.037-1.035,2.379-1.543,3.739-1.545\n        c1.352,0.002,2.689,0.512,3.724,1.545c0.642,0.643,1.685,0.643,2.328,0c0.645-0.643,0.645-1.686,0-2.33\n        c-1.665-1.666-3.864-2.51-6.052-2.508h-0.008c-2.185,0-4.39,0.838-6.06,2.51c-0.642,0.643-0.643,1.686,0,2.328\n        C390.088,312.571,391.131,312.571,391.773,311.928z"/>\n  </svg>\n</a>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/feedbackBlocks.js":[function(require,module,exports){
'use strict';

var constants = require('./constants');
var parseXmlElement = require('./xml').parseElement;

var TestResults = constants.TestResults;

// TODO (br-pair): can we not pass in the studioApp
var FeedbackBlocks = function FeedbackBlocks(options, missingRequiredBlocks, missingRecommendedBlocks, studioApp) {
  // Check whether blocks are embedded in the hint returned from dashboard.
  // See below comment for format.
  var embeddedBlocks = options.response && options.response.hint && options.response.hint.indexOf("[{") !== 0;
  if (!embeddedBlocks && options.feedbackType !== TestResults.MISSING_BLOCK_UNFINISHED && options.feedbackType !== TestResults.MISSING_BLOCK_FINISHED && options.feedbackType !== TestResults.MISSING_RECOMMENDED_BLOCK_UNFINISHED && options.feedbackType !== TestResults.MISSING_RECOMMENDED_BLOCK_FINISHED) {
    return;
  }

  var blocksToDisplay = [];
  if (embeddedBlocks) {
    // Hint should be of the form: SOME TEXT [{..}, {..}, ..] IGNORED.
    // Example: 'Try the following block: [{"type": "maze_moveForward"}]'
    // Note that double quotes are required by the JSON parser.
    var parts = options.response.hint.match(/(.*)(\[.*\])/);
    if (!parts) {
      return;
    }
    options.response.hint = parts[1].trim(); // Remove blocks from hint.
    try {
      blocksToDisplay = JSON.parse(parts[2]);
    } catch (err) {
      // The blocks could not be parsed.  Ignore them.
      return;
    }
  } else if (missingRequiredBlocks.blocksToDisplay.length) {
    handleMissingBlocks(missingRequiredBlocks);
  } else {
    handleMissingBlocks(missingRecommendedBlocks);
  }

  function handleMissingBlocks(blocks) {
    blocksToDisplay = blocks.blocksToDisplay;
    if (blocks.message) {
      options.message = blocks.message;
    }
  }

  if (blocksToDisplay.length === 0) {
    return;
  }

  this.xml = this.generateXMLForBlocks_(blocksToDisplay);

  this.div = document.createElement('div');
  this.div.setAttribute('id', 'feedbackBlocks');

  // Will be set by this.render()
  this.blockSpaceEditor = undefined;
};

module.exports = FeedbackBlocks;

FeedbackBlocks.prototype.render = function () {
  // Only render if this.div exists in the DOM
  if (!document.body.contains(this.div)) {
    return;
  }

  var parsedXml = parseXmlElement(this.xml);
  var blockSpace = Blockly.BlockSpace.createReadOnlyBlockSpace(this.div, parsedXml);
  this.blockSpaceEditor = blockSpace.blockSpaceEditor;
};

FeedbackBlocks.prototype.show = function () {
  this.div.style.visibility = '';
  this.div.style.height = '';
  if (this.blockSpaceEditor) {
    this.blockSpaceEditor.svgResize();
  }
};

FeedbackBlocks.prototype.hide = function () {
  this.div.style.visibility = 'hidden';
  this.div.style.height = '0px';
};

/**
 * Creates the XML for blocks to be displayed in a read-only frame.
 * @param {Array} blocks An array of blocks to display (with optional args).
 * @return {string} The generated string of XML.
 */
FeedbackBlocks.prototype.generateXMLForBlocks_ = function (blocks) {
  var blockXMLStrings = ['<xml>'];
  var blockX = 10; // Prevent left output plugs from being cut off.
  var blockY = 0;
  var blockXPadding = 200;
  var blockYPadding = 120;
  var blocksPerLine = 2;
  var k, name;
  for (var i = 0; i < blocks.length; i++) {
    var block = blocks[i];
    if (block.blockDisplayXML) {
      blockXMLStrings.push(block.blockDisplayXML);
      continue;
    }
    blockXMLStrings.push('<block', ' type="', block.type, '" x="', blockX.toString(), '" y="', blockY, '">');
    if (block.titles) {
      var titleNames = Object.keys(block.titles);
      for (k = 0; k < titleNames.length; k++) {
        name = titleNames[k];
        blockXMLStrings.push('<title name="', name, '">', block.titles[name], '</title>');
      }
    }
    if (block.values) {
      var valueNames = Object.keys(block.values);
      for (k = 0; k < valueNames.length; k++) {
        name = valueNames[k];
        blockXMLStrings.push('<value name="', name, '">', block.values[name], '</value>');
      }
    }
    if (block.extra) {
      blockXMLStrings.push(block.extra);
    }
    blockXMLStrings.push('</block>');
    if ((i + 1) % blocksPerLine === 0) {
      blockY += blockYPadding;
      blockX = 0;
    } else {
      blockX += blockXPadding;
    }
  }
  blockXMLStrings.push('</xml>');
  return blockXMLStrings.join('');
};

},{"./constants":"/home/ubuntu/staging/apps/build/js/constants.js","./xml":"/home/ubuntu/staging/apps/build/js/xml.js"}],"/home/ubuntu/staging/apps/build/js/clientApi.js":[function(require,module,exports){
/* global dashboard */
// TODO(dave): Merge with the client API in /shared.
// TODO: The client API should be instantiated with the channel ID, instead of grabbing it from the `dashboard.project` global.

'use strict';

module.exports = {
  assets: clientApi('assets'),
  sources: clientApi('sources')
};

function clientApi(endpoint) {
  return {
    basePath: function basePath(path) {
      return '/v3/' + endpoint + '/' + dashboard.project.getCurrentId() + (path ? '/' + path : '');
    },
    ajax: function ajax(method, file, success, error, data) {
      if (!window.dashboard) {
        error({ status: "No dashboard" });
        return;
      }
      var xhr = new XMLHttpRequest();
      xhr.addEventListener('load', function () {
        if (xhr.status >= 400) {
          error(xhr);
          return;
        }
        success(xhr);
      });
      xhr.addEventListener('error', function () {
        error(xhr);
      });

      xhr.open(method, this.basePath(file), true);
      xhr.send(data);
    }
  };
}

},{}],"/home/ubuntu/staging/apps/build/js/block_utils.js":[function(require,module,exports){
'use strict';

var xml = require('./xml');

/**
 * Create the xml for a level's toolbox
 * @param {string} blocks The xml of the blocks to go in the toolbox
 */
exports.createToolbox = function (blocks) {
  return '<xml id="toolbox" style="display: none;">' + blocks + '</xml>';
};

/**
 * Create the xml for a block of the given type
 * @param {string} type The type of the block
 * @param {Object.<string,string>} [titles] Dictionary of titles mapping name to value
 */
exports.blockOfType = function (type, titles) {
  var titleText = '';
  if (titles) {
    for (var key in titles) {
      titleText += '<title name="' + key + '">' + titles[key] + '</title>';
    }
  }
  return '<block type="' + type + '">' + titleText + '</block>';
};

/**
 * Create the xml for a block of the given type, with the provided child nested
 * in a next block
 * @param {string} type The type of the block
 * @param {Object.<string,string>} [titles] Dictionary of titles mapping name to value
 * @param {string} child Xml for the child block
 */
exports.blockWithNext = function (type, titles, child) {
  var titleText = '';
  if (titles) {
    for (var key in titles) {
      titleText += '<title name="' + key + '">' + titles[key] + '</title>';
    }
  }
  return '<block type="' + type + '">' + titleText + '<next>' + child + '</next></block>';
};

/**
 * Give a list of types, returns the xml assuming each block is a child of
 * the previous block.
 */
exports.blocksFromList = function (types) {
  if (types.length === 1) {
    return this.blockOfType(types[0]);
  }

  return this.blockWithNext(types[0], {}, this.blocksFromList(types.slice(1)));
};

/**
 * Create the xml for a category in a toolbox
 */
exports.createCategory = function (name, blocks, custom) {
  return '<category name="' + name + '"' + (custom ? ' custom="' + custom + '"' : '') + '>' + blocks + '</category>';
};

/**
 * Generate a simple block with a plain title and next/previous connectors.
 */
exports.generateSimpleBlock = function (blockly, generator, options) {
  ['name', 'title', 'tooltip', 'functionName'].forEach(function (param) {
    if (!options[param]) {
      throw new Error('generateSimpleBlock requires param "' + param + '"');
    }
  });

  var name = options.name;
  var helpUrl = options.helpUrl || ""; // optional param
  var title = options.title;
  var titleImage = options.titleImage;
  var tooltip = options.tooltip;
  var functionName = options.functionName;

  blockly.Blocks[name] = {
    helpUrl: helpUrl,
    init: function init() {
      // Note: has a fixed HSV.  Could make this customizable if need be
      this.setHSV(184, 1.00, 0.74);
      var input = this.appendDummyInput();
      if (title) {
        input.appendTitle(title);
      }
      if (titleImage) {
        input.appendTitle(new blockly.FieldImage(titleImage));
      }
      this.setPreviousStatement(true);
      this.setNextStatement(true);
      this.setTooltip(tooltip);
    }
  };

  generator[name] = function () {
    // Generate JavaScript for putting dirt on to a tile.
    return functionName + '(\'block_id_' + this.id + '\');\n';
  };
};

/**
 * Generates a single block from a <block/> DOM element, adding it to the main workspace
 * @param blockDOM {Element}
 * @returns {*}
 */
exports.domToBlock = function (blockDOM) {
  return Blockly.Xml.domToBlock(Blockly.mainBlockSpace, blockDOM);
};

/**
 * Generates a single block from a block XML string—e.g., <block type="testBlock"></block>,
 * and adds it to the main workspace
 * @param blockDOMString
 * @returns {*}
 */
exports.domStringToBlock = function (blockDOMString) {
  return exports.domToBlock(xml.parseElement(blockDOMString).firstChild);
};

/**
 * Takes a set of start blocks, and returns them with a particular top level
 * block inserted in front of the first non-function block.  If we already have
 * this block, does nothing.
 */
exports.forceInsertTopBlock = function (input, blockType) {
  input = input || '';

  if (blockType === null || input.indexOf(blockType) !== -1) {
    return input;
  }

  var root = xml.parseElement(input);

  // Extract the document from the root. The reason I do this instead of just
  // using document.createElement elsewhere is
  var doc = root.parentNode;

  var topBlock = doc.createElement('block');
  topBlock.setAttribute('type', blockType);
  topBlock.setAttribute('movable', 'false');
  topBlock.setAttribute('deletable', 'false');

  var numChildren = root.childNodes ? root.childNodes.length : 0;

  // find the first non-function definition block and extract it
  var firstBlock = null,
      i = 0;
  while (i < numChildren && firstBlock === null) {
    var child = root.childNodes[i];
    // only look at element nodes
    if (child.nodeType === 1) {
      var type = child.getAttribute('type');
      if (type !== 'procedures_defnoreturn' && type !== 'procedures_defreturn') {
        firstBlock = root.removeChild(child);
        numChildren--;
      }
    }
    i++;
  }

  if (firstBlock !== null) {
    // when run -> next -> firstBlock
    var next;
    if (/^functional/.test(blockType)) {
      next = doc.createElement('functional_input');
      next.setAttribute('name', 'ARG1');
    } else {
      next = doc.createElement('next');
    }
    next.appendChild(firstBlock);
    topBlock.appendChild(next);
  }

  if (numChildren > 0) {
    root.insertBefore(topBlock, root.childNodes[0]);
  } else {
    root.appendChild(topBlock);
  }
  return xml.serialize(root);
};

/**
 * Generate the xml for a block for the calc app.
 * @param {string} type Type for this block
 * @param {number[]|string[]} args List of args, where each arg is either the
 *   xml for a child block, a number, or the name of a variable.
 */
exports.calcBlockXml = function (type, args) {
  var str = '<block type="' + type + '" inline="false">';
  for (var i = 1; i <= args.length; i++) {
    str += '<functional_input name="ARG' + i + '">';
    var arg = args[i - 1];
    if (typeof arg === "number") {
      arg = '<block type="functional_math_number"><title name="NUM">' + arg + '</title></block>';
    } else if (/^<block/.test(arg)) {
      // we have xml, dont make any changes
      arg = arg;
    } else {
      // we think we have a variable
      arg = exports.calcBlockGetVar(arg);
    }
    str += arg;
    str += '</functional_input>';
  }
  str += '</block>';

  return str;
};

/**
 * @returns the xml for a functional_parameters_get block with the given
 *   variableName
 */
exports.calcBlockGetVar = function (variableName) {
  return '' + '<block type="functional_parameters_get" uservisible="false">' + '  <mutation>' + '    <outputtype>Number</outputtype>' + '  </mutation>' + '  <title name="VAR">' + variableName + '</title>' + '</block>';
};

/**
 * Generate the xml for a math block (either calc or eval apps).
 * @param {string} type Type for this block
 * @param {Object.<string,string} inputs Dictionary mapping input name to the
     xml for that input
 * @param {Object.<string.string>} [titles] Dictionary of titles mapping name to value
 */
exports.mathBlockXml = function (type, inputs, titles) {
  var str = '<block type="' + type + '" inline="false">';
  for (var title in titles) {
    str += '<title name="' + title + '">' + titles[title] + '</title>';
  }

  for (var input in inputs) {
    str += '<functional_input name="' + input + '">' + inputs[input] + '</functional_input>';
  }

  str += '</block>';

  return str;
};

/**
 * Generate xml for a functional defintion
 * @param {string} name The name of the function
 * @param {string} outputType Function's output type
 * @param {Object<string, string>[]} argList Name and type for each arg
 * @param {string} blockXml Xml for the blocks that actually define the function
 */
exports.functionalDefinitionXml = function (name, outputType, argList, blockXml) {
  var mutation = '<mutation>';
  argList.forEach(function (argInfo) {
    mutation += '<arg name="' + argInfo.name + '" type="' + argInfo.type + '"></arg>';
  });
  mutation += '<outputtype>' + outputType + '</outputtype></mutation>';

  return '<block type="functional_definition" inline="false">' + mutation + '<title name="NAME">' + name + '</title>' + '<functional_input name="STACK">' + blockXml + '</functional_input>' + '</block>';
};

/**
 * Generate xml for a calling a functional function
 * @param {string} name The name of the function
 * @param {Object<string, string>[]} argList Name and type for each arg
 */
exports.functionalCallXml = function (name, argList, inputContents) {
  if (argList.length !== inputContents.length) {
    throw new Error('must define contents for each arg');
  }

  var mutation = '<mutation name="' + name + '">';
  argList.forEach(function (argInfo) {
    mutation += '<arg name="' + argInfo.name + '" type="' + argInfo.type + '"></arg>';
  });
  mutation += '</mutation>';

  var contents = '';
  inputContents.forEach(function (blockXml, index) {
    contents += '<functional_input name="ARG' + index + '">' + blockXml + '</functional_input>';
  });

  return '<block type="functional_call">' + mutation + contents + '</block>';
};

},{"./xml":"/home/ubuntu/staging/apps/build/js/xml.js"}],"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletTooltipManager.js":[function(require,module,exports){
'use strict';

var DropletFunctionTooltip = require('./DropletFunctionTooltip');
var DropletBlockTooltipManager = require('./DropletBlockTooltipManager');
var DropletAutocompletePopupTooltipManager = require('./DropletAutocompletePopupTooltipManager');
var DropletAutocompleteParameterTooltipManager = require('./DropletAutocompleteParameterTooltipManager');
var dropletUtils = require('../dropletUtils');

/**
 * @fileoverview Manages a store of known blocks and tooltips
 */

/**
 * Store for finding tooltips for blocks
 * @constructor
 */
function DropletTooltipManager(appMsg, dropletConfig, codeFunctions, autocompletePaletteApisOnly) {
  /**
   * App-specific strings (to override common msg)
   * @type {Object.<String, Function>}
   */
  this.appMsg = appMsg || {};
  this.tooltipsEnabled = true;

  /**
   * Droplet config for this app
   */
  this.dropletConfig = dropletConfig || {};

  /**
   * Code functions
   * @type {Object.<String>} optional object with keys to modify the blocks
   */
  this.codeFunctions = codeFunctions;

  /**
   * Flag to limit the number of APIs that see autocomplete behavior
   */
  this.autocompletePaletteApisOnly = autocompletePaletteApisOnly;

  /**
   * Map of block types to tooltip objects
   * @type {Object.<String, DropletFunctionTooltip>}
   */
  this.blockTypeToTooltip_ = {};

  /**
   * Maps func from one block type to another, such that we use the target for
   * documentation instead of the source
   * @type {Object.<String, String>}
   */
  this.docFuncMapping_ = {};

  /**
   * @type {DropletBlockTooltipManager}
   * @private
   */
  this.dropletBlockTooltipManager_ = new DropletBlockTooltipManager(this);

  /**
   * @type {DropletAutocompletePopupTooltipManager}
   * @private
   */
  this.dropletAutocompletePopupTooltipManager_ = new DropletAutocompletePopupTooltipManager(this);

  /**
   * @type {DropletAutocompletePopupTooltipManager}
   * @private
   */
  this.dropletAutocompleteParameterTooltipManager_ = new DropletAutocompleteParameterTooltipManager(this);
}

/**
 * Registers handlers for droplet block tooltips.
 * @param dropletEditor
 */
DropletTooltipManager.prototype.registerDropletBlockModeHandlers = function (dropletEditor) {
  this.dropletBlockTooltipManager_.installTooltipsForEditor_(dropletEditor);
};

/**
 * Registers handlers for ACE mode tooltips
 * @param dropletEditor
 */
DropletTooltipManager.prototype.registerDropletTextModeHandlers = function (dropletEditor) {
  this.dropletAutocompletePopupTooltipManager_.installTooltipsForEditor_(dropletEditor);
  this.dropletAutocompleteParameterTooltipManager_.installTooltipsForEditor_(dropletEditor);
};

/**
 * Registers block tooltips for blocks based on the dropletBlocks and
 * codeFunctions passed to the constructor
 */
DropletTooltipManager.prototype.registerBlocks = function () {
  var blocks = dropletUtils.getAllAvailableDropletBlocks(this.dropletConfig, this.codeFunctions, this.autocompletePaletteApisOnly);
  blocks.forEach(function (dropletBlockDefinition) {
    var key = dropletBlockDefinition.modeOptionName || dropletBlockDefinition.func;
    if (dropletBlockDefinition.docFunc) {
      // If a docFunc was specified, update our mapping
      this.docFuncMapping_[key] = dropletBlockDefinition.docFunc;
    } else {
      this.blockTypeToTooltip_[key] = new DropletFunctionTooltip(this.appMsg, dropletBlockDefinition);
    }
  }, this);
};

DropletTooltipManager.prototype.getDocFor = function (functionName) {
  var docFuncName = this.docFuncMapping_[functionName] || functionName;
  return this.blockTypeToTooltip_[docFuncName];
};

DropletTooltipManager.prototype.showDocFor = function (functionName) {
  if (!this.tooltipsEnabled) {
    return;
  }
  $('.tooltipstered').tooltipster('hide');
  var dialog = new window.Dialog({
    body: $('<iframe>').addClass('markdown-instructions-container').width('100%').attr('src', this.getDropletTooltip(functionName).getFullDocumentationURL()),
    autoResizeScrollableElement: '.markdown-instructions-container',
    id: 'block-documentation-lightbox'
  });
  dialog.show();
};

/**
 * @param {String} functionName
 * @returns {DropletFunctionTooltip}
 */
DropletTooltipManager.prototype.getDropletTooltip = function (functionName) {
  var tooltip = this.getDocFor(functionName);
  if (!tooltip) {
    throw "Function name " + functionName + " not registered in documentation manager.";
  }

  return tooltip;
};

/**
 * @param {boolean} enabled if tooltips should be enabled.
 */
DropletTooltipManager.prototype.setTooltipsEnabled = function (enabled) {
  this.tooltipsEnabled = !!enabled;
  this.dropletAutocompletePopupTooltipManager_.setTooltipsEnabled(enabled);
  this.dropletAutocompleteParameterTooltipManager_.setTooltipsEnabled(enabled);
  this.dropletBlockTooltipManager_.setTooltipsEnabled(enabled);
};

module.exports = DropletTooltipManager;

},{"../dropletUtils":"/home/ubuntu/staging/apps/build/js/dropletUtils.js","./DropletAutocompleteParameterTooltipManager":"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletAutocompleteParameterTooltipManager.js","./DropletAutocompletePopupTooltipManager":"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletAutocompletePopupTooltipManager.js","./DropletBlockTooltipManager":"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletBlockTooltipManager.js","./DropletFunctionTooltip":"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletFunctionTooltip.js"}],"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletBlockTooltipManager.js":[function(require,module,exports){
'use strict';

var DropletFunctionTooltip = require('./DropletFunctionTooltip');
var DropletFunctionTooltipMarkup = require('./DropletFunctionTooltip.html.ejs');
var dom = require('../dom');

/**
 * @fileoverview Displays tooltips for Droplet blocks
 */

/**
 * Handles displaying tooltips on Droplet blocks
 * @param {DropletTooltipManager} dropletTooltipManager
 * @constructor
 */
var DropletBlockTooltipManager = function DropletBlockTooltipManager(dropletTooltipManager) {
  this.dropletTooltipManager = dropletTooltipManager;
  this.showExamplesLink = dropletTooltipManager.dropletConfig.showExamplesLink;
  this.tooltipsEnabled = true;
};

var DEFAULT_TOOLTIP_CONFIG = {
  interactive: true,
  speed: 150,
  maxWidth: 450,
  position: 'right',
  contentAsHTML: true,
  theme: 'droplet-block-tooltipster',
  offsetY: 2,
  delay: 400
};

/**
 * Simple helper function that will swallow exceptions, and log them as
 * console.error. This is done because the way that some of our callbacks are
 * called by droplet, exceptions would bubble down to the droplet code, and
 * prevent desired behavior (i.e. we fail to transition back to block mode).
 */
function swallowErrors(fn) {
  return function () {
    try {
      fn();
    } catch (err) {
      if (typeof console !== "undefined" && console.error) {
        console.error(err);
      }
    }
  };
}

/**
 * @param {Editor} dropletEditor
 */
DropletBlockTooltipManager.prototype.installTooltipsForEditor_ = function (dropletEditor) {
  this.installTooltipsForCurrentCategoryBlocks_();
  this.hideTooltipsOnBlockPick_(dropletEditor);

  dropletEditor.on('changepalette', swallowErrors(this.installTooltipsForCurrentCategoryBlocks_.bind(this)));
  dropletEditor.on('toggledone', swallowErrors(this.installTooltipsIfNotInstalled_.bind(this)));
};

DropletBlockTooltipManager.prototype.installTooltipsIfNotInstalled_ = function () {
  if (!$('.droplet-hover-div').hasClass('tooltipstered')) {
    this.installTooltipsForCurrentCategoryBlocks_();
  }
};

DropletBlockTooltipManager.prototype.installTooltipsForCurrentCategoryBlocks_ = function () {
  if (!this.tooltipsEnabled) {
    return;
  }

  $('.droplet-hover-div').each((function (_, blockHoverDiv) {
    if ($(blockHoverDiv).hasClass('tooltipstered')) {
      return;
    }

    var funcName = $(blockHoverDiv).attr('title');

    var hoverDivWidth = $(blockHoverDiv).width();
    var hoverDivLeftToToolboxRight = $('.droplet-palette-canvas').width() - parseInt(blockHoverDiv.style.left, 10);
    var desiredXPosition = Math.min(hoverDivWidth, hoverDivLeftToToolboxRight);
    var tooltipOffsetX = desiredXPosition - hoverDivWidth;

    var configuration = $.extend({}, DEFAULT_TOOLTIP_CONFIG, {
      content: this.getTooltipHTML(funcName),
      offsetX: tooltipOffsetX,
      functionReady: (function (_, contents) {
        if (!this.showExamplesLink) {
          return;
        }
        var seeExamplesLink = contents.find('.tooltip-example-link > a')[0];
        // Important this binds to mouseDown/touchDown rather than click, needs to
        // happen before `blur` which triggers the ace editor completer popup
        // hide which in turn would hide the link and not show the docs.
        dom.addClickTouchEvent(seeExamplesLink, (function (event) {
          this.dropletTooltipManager.showDocFor(funcName);
          event.stopPropagation();
        }).bind(this));
      }).bind(this)
    });

    // Store the title/funcName as a block id so we can attach callouts later:
    $(blockHoverDiv).attr('id', 'droplet_palette_block_' + funcName);
    $(blockHoverDiv).tooltipster(configuration);
  }).bind(this));
};

/**
 * Tooltipster's hideOnClick setting does not work with the droplet hover
 * overlay as-is. Hide the tooltip on block picking explicitly.
 */
DropletBlockTooltipManager.prototype.hideTooltipsOnBlockPick_ = function (dropletEditor) {
  dropletEditor.on('pickblock', function () {
    $('.tooltipstered').tooltipster('hide');
  });
};

/**
 * @returns {String} HTML for tooltip
 */
DropletBlockTooltipManager.prototype.getTooltipHTML = function (functionName) {
  var tooltipInfo = this.dropletTooltipManager.getDropletTooltip(functionName);
  return DropletFunctionTooltipMarkup({
    functionName: tooltipInfo.functionName,
    isProperty: tooltipInfo.isProperty,
    tipPrefix: tooltipInfo.tipPrefix,
    functionShortDescription: tooltipInfo.description,
    parameters: tooltipInfo.parameterInfos,
    signatureOverride: tooltipInfo.signatureOverride,
    showExamplesLink: this.showExamplesLink
  });
};

/**
 * @param {boolean} enabled if tooltips should be enabled
 */

DropletBlockTooltipManager.prototype.setTooltipsEnabled = function (enabled) {
  this.tooltipsEnabled = !!enabled;
};

module.exports = DropletBlockTooltipManager;

},{"../dom":"/home/ubuntu/staging/apps/build/js/dom.js","./DropletFunctionTooltip":"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletFunctionTooltip.js","./DropletFunctionTooltip.html.ejs":"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletFunctionTooltip.html.ejs"}],"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletFunctionTooltip.js":[function(require,module,exports){
'use strict';

var msg = require('../locale');
var utils = require('../utils');

/**
 * @fileoverview Representation of a droplet function/block's tooltip
 */

var DROPLET_BLOCK_I18N_PREFIX = "dropletBlock_";

/**
 * @typedef {Object} parameterInfo
 * @property {String} name
 * @property {?String} description
 */

/**
 * Stores a block's tooltip information and helps render it
 * Grabs much of the tooltip's information from either app-specific locale
 * file (passed in as appMsg) or, if not present, the 'common' locale file,
 * (apps/i18n/common/en_us.json), keyed by the function name.
 *
 * e.g.,
 *
 * "dropletBlock_readRecords_description": "Reads records [...].",
 * "dropletBlock_readRecords_param0": "table",
 * "dropletBlock_readRecords_param1": "searchParams",
 * "dropletBlock_readRecords_param2": "onSuccess",
 *
 * Will result in a tooltip with the contents:
 *
 *    readRecords(table, searchParams, onSuccess)
 *    Reads records [...].
 *    [Read More] (links to `readRecords` doc file)
 *
 * Blocks which have functionNames that should not be user-visible can define
 * their own signature override.
 *
 * e.g.,
 *
 * "dropletBlock_functionParams_n_description": "Define a function with a given parameter",
 * "dropletBlock_functionParams_n_signatureOverride": "Function with a Parameter",
 *
 * Will result in a tooltip with the contents:
 *
 *    Function with a Parameter <-- note, no ()s
 *    Define a function with a given parameter.
 *    [Read More] (links to `functionParams_n` doc file)
 *
 * @constructor
 */
var DropletFunctionTooltip = function DropletFunctionTooltip(appMsg, definition) {
  this.appMsg = appMsg;

  /** @type {string} */
  this.functionName = definition.func;

  /** @type {boolean} */
  this.isProperty = definition.type === 'property';

  /** @type {string} */
  this.tipPrefix = definition.tipPrefix;

  var description = this.getLocalization(this.descriptionKey());
  if (description) {
    this.description = description();
  }

  var signatureOverride = this.getLocalization(this.signatureOverrideKey());
  if (signatureOverride) {
    this.signatureOverride = signatureOverride();
  }

  /** @type {Array.<parameterInfo>} */
  this.parameterInfos = [];

  for (var paramId = 0;; paramId++) {
    var paramInfo = {};
    /*
     * Parameter names can be specified in the localization file if desired,
     * but will also be pulled from the block definition's paletteParams array.
     */
    var paramName = this.getLocalization(this.parameterNameKey(paramId));
    if (paramName) {
      paramInfo.name = paramName();
    } else {
      paramInfo.name = definition.paletteParams && definition.paletteParams[paramId];
    }
    if (!paramInfo.name) {
      break;
    }

    var paramDesc = this.getLocalization(this.parameterDescriptionKey(paramId));
    if (paramDesc) {
      paramInfo.description = paramDesc();
    }
    if (definition.assetTooltip) {
      paramInfo.assetTooltip = definition.assetTooltip[paramId];
    }
    this.parameterInfos.push(paramInfo);
  }
};

/**
 * @param {string} key
 * @returns {Function}
 */
DropletFunctionTooltip.prototype.getLocalization = function (key) {
  return this.appMsg[key] || msg[key];
};

/**
 * @returns {string}
 */
DropletFunctionTooltip.prototype.descriptionKey = function () {
  return this.i18nPrefix() + "_description";
};

/**
 * @returns {string}
 */
DropletFunctionTooltip.prototype.signatureOverrideKey = function () {
  return this.i18nPrefix() + "_signatureOverride";
};

/**
 * @param {Number} paramIndex
 * @returns {string}
 */
DropletFunctionTooltip.prototype.parameterNameKey = function (paramIndex) {
  return this.i18nPrefix() + "_param" + paramIndex;
};

/**
 * @param {Number} paramIndex
 * @returns {string}
 */
DropletFunctionTooltip.prototype.parameterDescriptionKey = function (paramIndex) {
  return this.i18nPrefix() + "_param" + paramIndex + '_description';
};

/**
 * @returns {string} i18n file prefix for this function
 */
DropletFunctionTooltip.prototype.i18nPrefix = function () {
  return DROPLET_BLOCK_I18N_PREFIX + this.functionName;
};

/**
 * @returns {string} URL for full doc about this function
 */
DropletFunctionTooltip.prototype.getFullDocumentationURL = function () {
  return '//' + utils.getPegasusHost() + '/applab/docs/' + this.functionName + '?embedded';
};

module.exports = DropletFunctionTooltip;

},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js","../utils":"/home/ubuntu/staging/apps/build/js/utils.js"}],"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletAutocompletePopupTooltipManager.js":[function(require,module,exports){
'use strict';

var DropletFunctionTooltipMarkup = require('./DropletFunctionTooltip.html.ejs');
var dom = require('../dom');

/**
 * @fileoverview Displays tooltips for Droplet blocks
 */

/**
 * Handles displaying tooltips on Droplet's ACE editor autocomplete dropdown
 * @param {DropletTooltipManager} dropletTooltipManager
 * @constructor
 */
var DropletAutocompletePopupTooltipManager = function DropletAutocompletePopupTooltipManager(dropletTooltipManager) {
  this.dropletTooltipManager = dropletTooltipManager;
  this.showExamplesLink = dropletTooltipManager.dropletConfig.showExamplesLink;
  this.tooltipsEnabled = true;
};

var DEFAULT_TOOLTIP_CONFIG = {
  interactive: true,
  autoClose: false,
  trigger: 'custom',
  speed: 100,
  maxWidth: 450,
  position: 'left',
  contentAsHTML: true,
  theme: 'droplet-block-tooltipster',
  offsetY: 2,
  restoration: 'none',
  updateAnimation: false
};

/**
 * @param {Editor} dropletEditor
 */
DropletAutocompletePopupTooltipManager.prototype.installTooltipsForEditor_ = function (dropletEditor) {
  var aceEditor = dropletEditor.aceEditor;

  this.editorChangedEventHandler_ = this.setupOnPopupShown_.bind(this, aceEditor);
  aceEditor.commands.on("afterExec", this.editorChangedEventHandler_);
};

/**
 * When an autocomplete popup has been shown the first time, register event
 * handlers to show and hide tooltips during autocomplete popup usage.
 * @param aceEditor - ace editor instance
 * @param changeEvent - event from aceEditor.commands.on("afterExec")
 * @private
 */
DropletAutocompletePopupTooltipManager.prototype.setupOnPopupShown_ = function (aceEditor, changeEvent) {
  if (changeEvent.command.name !== 'insertstring') {
    return;
  }

  var popupHasBeenShownOnce = aceEditor.completer && aceEditor.completer.popup;
  if (!popupHasBeenShownOnce) {
    return;
  }

  this.setupForEditorPopup_(aceEditor);

  aceEditor.commands.removeListener("afterExec", this.editorChangedEventHandler_);
  this.editorChangedEventHandler_ = null;
};

DropletAutocompletePopupTooltipManager.prototype.setupForEditorPopup_ = function (aceEditor) {
  aceEditor.completer.popup.setSelectOnHover(true);

  aceEditor.completer.popup.renderer.on("afterRender", (function () {
    this.updateAutocompletePopupTooltip(aceEditor);
  }).bind(this));

  aceEditor.completer.popup.on("hide", (function () {
    this.destroyAutocompleteTooltips_();
  }).bind(this));
};

DropletAutocompletePopupTooltipManager.prototype.updateAutocompletePopupTooltip = function (aceEditor) {
  if (!this.tooltipsEnabled || !aceEditor.completer.completions) {
    return;
  }

  var keyboardRow = aceEditor.completer.popup.getRow();

  if (keyboardRow < 0) {
    return;
  }

  var filteredCompletions = aceEditor.completer.completions.filtered;
  var funcName = filteredCompletions[keyboardRow].docFunc || filteredCompletions[keyboardRow].value;

  this.destroyAutocompleteTooltips_();

  if (!this.dropletTooltipManager.getDocFor(funcName)) {
    return;
  }

  this.attachTooltipForFunction(funcName);
};

DropletAutocompletePopupTooltipManager.prototype.attachTooltipForFunction = function (funcName) {
  var tooltipDOM = this.getTooltipHTML(funcName);
  var configuration = $.extend({}, DEFAULT_TOOLTIP_CONFIG, {
    content: tooltipDOM,
    functionReady: (function (_, contents) {
      if (!this.showExamplesLink) {
        return;
      }
      var seeExamplesLink = contents.find('.tooltip-example-link > a')[0];
      // Important this binds to mouseDown/touchDown rather than click, needs to
      // happen before `blur` which triggers the ace editor completer popup
      // hide which in turn would hide the link and not show the docs.
      dom.addClickTouchEvent(seeExamplesLink, (function (event) {
        this.dropletTooltipManager.showDocFor(funcName);
        event.stopPropagation();
      }).bind(this));
    }).bind(this)
  });

  var rowOverlayDiv = $('.ace_selected');
  rowOverlayDiv.tooltipster(configuration);
  rowOverlayDiv.tooltipster('show');
};

DropletAutocompletePopupTooltipManager.prototype.destroyAutocompleteTooltips_ = function () {
  $('.ace_autocomplete .tooltipstered').tooltipster('destroy');
};

/**
 * @returns {String} HTML for tooltip
 */
DropletAutocompletePopupTooltipManager.prototype.getTooltipHTML = function (functionName) {
  var tooltipInfo = this.dropletTooltipManager.getDropletTooltip(functionName);
  var dropletFunctionTooltipMarkup = DropletFunctionTooltipMarkup({
    functionName: tooltipInfo.functionName,
    isProperty: tooltipInfo.isProperty,
    tipPrefix: tooltipInfo.tipPrefix,
    functionShortDescription: tooltipInfo.description,
    parameters: tooltipInfo.parameterInfos,
    signatureOverride: tooltipInfo.signatureOverride,
    showExamplesLink: this.showExamplesLink
  });
  return dropletFunctionTooltipMarkup;
};

/**
 * @param {boolean} enabled if tooltips are enabled
 */

DropletAutocompletePopupTooltipManager.prototype.setTooltipsEnabled = function (enabled) {
  this.tooltipsEnabled = !!enabled;
};

module.exports = DropletAutocompletePopupTooltipManager;

},{"../dom":"/home/ubuntu/staging/apps/build/js/dom.js","./DropletFunctionTooltip.html.ejs":"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletFunctionTooltip.html.ejs"}],"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletFunctionTooltip.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1; function getPrefixedName () {
  return tipPrefix ? tipPrefix + functionName : functionName;
} ; buf.push('\n<div class="function-name">\n  ');5; if (signatureOverride) {; buf.push('    ', escape((5,  signatureOverride )), '\n  ');6; } else if (isProperty) {; buf.push('    ', escape((6,  getPrefixedName() )), '\n  ');7; } else {
    /**
     * TODO(bjordan): would be nice to split the following line up, can't figure
     * out how to do so without inserting extraneous spaces between parameters.
     */
   ; buf.push('    ', escape((12,  getPrefixedName() )), '(');12; for (var i = 0; i < parameters.length; i++) {; buf.push('', (12,  parameters[i].name), '');12; if (i < parameters.length - 1) {; buf.push(', ');12; }; buf.push('');12; }; buf.push(')  ');12; } ; buf.push('\n</div>\n');14; if (functionShortDescription) { ; buf.push('<div>', escape((14,  functionShortDescription )), '</div>');14; } ; buf.push('\n');15; if (showExamplesLink) { ; buf.push('\n  <div class="tooltip-example-link">\n    <a href="javascript:void(0);">See examples</a>\n  </div>\n');19; } ; buf.push('\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletAutocompleteParameterTooltipManager.js":[function(require,module,exports){
/* global ace */
'use strict';

var DropletFunctionTooltipMarkup = require('./DropletParameterTooltip.html.ejs');
var tooltipUtils = require('./tooltipUtils.js');
var dom = require('../dom');
var dropletUtils = require('../dropletUtils');

/**
 * @fileoverview Displays tooltips for Droplet blocks
 */

/**
 * Handles displaying tooltips on Droplet's ACE editor when filling in
 * an empty parameter.
 * Also will augment ACE editor's Live autocomplete by invoking scoped
 * autocomplete dropdowns for each parameter.
 * @param {DropletTooltipManager} dropletTooltipManager
 * @constructor
 */
var DropletAutocompleteParameterTooltipManager = function DropletAutocompleteParameterTooltipManager(dropletTooltipManager) {
  this.dropletTooltipManager = dropletTooltipManager;
  this.showExamplesLink = dropletTooltipManager.dropletConfig.showExamplesLink;
  this.showParamDropdowns = dropletTooltipManager.dropletConfig.showParamDropdowns;
  this.tooltipConfig = {
    interactive: true,
    autoClose: false,
    trigger: 'custom',
    speed: 100,
    maxWidth: 450,
    position: this.showParamDropdowns ? 'top' : 'bottom',
    contentAsHTML: true,
    theme: 'droplet-block-tooltipster',
    offsetY: 2,
    restoration: 'none',
    updateAnimation: false,
    positionTracker: true,
    tooltipsEnabled: true
  };
};

/**
 * @param {Editor} dropletEditor
 */
DropletAutocompleteParameterTooltipManager.prototype.installTooltipsForEditor_ = function (dropletEditor) {
  var aceEditor = dropletEditor.aceEditor;

  var cursorMovementHandler = this.onCursorMovement_.bind(this, aceEditor);
  aceEditor.commands.on('afterExec', cursorMovementHandler);
  aceEditor.on('mousedown', (function (e) {
    this.getCursorTooltip_().tooltipster('hide');
  }).bind(this));
};

/**
 * @param editor - ace editor instance
 * @param changeEvent - event from aceEditor.session.selection.on('changeCursor')
 * @private
 */
DropletAutocompleteParameterTooltipManager.prototype.onCursorMovement_ = function (editor, changeEvent) {
  this.getCursorTooltip_().tooltipster('hide');

  if (!editor.selection.isEmpty()) {
    return;
  }

  var cursorPosition = editor.selection.getCursor();

  var currentParameterInfo = tooltipUtils.findFunctionAndParamNumber(editor, cursorPosition);
  if (!currentParameterInfo) {
    return;
  }

  if (this.blockDropdownsAndTooltips || this.startingAutoComplete) {
    // Guard against re-entrancy that occurs inside the showParamDropdownIfNeeded_() and the click
    // handlers below
    return;
  }

  if (editor.completer && this.showParamDropdowns) {
    this.showParamDropdownIfNeeded_(editor, currentParameterInfo);
  }

  this.updateParameterTooltip_(editor, currentParameterInfo);
};

/**
 * @param editor - ace editor instance
 * @param paramInfo - parameter info already retrieved based on the cursor position
 * @private
 */
DropletAutocompleteParameterTooltipManager.prototype.showParamDropdownIfNeeded_ = function (editor, paramInfo) {
  // Check the dropletConfig to see if we can find dropdown info for this parameter
  var dropdownList;
  dropletUtils.getAllAvailableDropletBlocks(this.dropletTooltipManager.dropletConfig, this.dropletTooltipManager.codeFunctions, this.autocompletePaletteApisOnly).forEach(function (block) {
    if (!block.dropdown || block.func !== paramInfo.funcName && block.func !== paramInfo.fullFuncName) {
      // Not the right block or no dropdown specified
      return;
    }
    if (block.noAutocomplete) {
      // Block doesn't want autocomplete, so ignore
      return;
    }
    if (this.dropletTooltipManager.autocompletePaletteApisOnly && this.dropletTooltipManager.codeFunctions && typeof this.dropletTooltipManager.codeFunctions[block.func] === 'undefined') {
      // In autocompletePaletteApisOnly mode and block is not in the palette:
      return;
    }
    if (typeof block.dropdown[paramInfo.currentParameterIndex] === 'function') {
      dropdownList = block.dropdown[paramInfo.currentParameterIndex]();
    } else {
      dropdownList = block.dropdown[paramInfo.currentParameterIndex];
    }
  }, this);

  if (dropdownList && !editor.completer.activated) {
    // The cursor is positioned where a parameter with a dropdown should appear
    // and autocomplete is not already active, so let's pop up a special dropdown
    // autocomplete

    // First, install our hooks to modify the normal ace AutoComplete (these are
    // safe to leave in place, and we can call this multiple times):
    this.installAceCompleterHooks_(editor);

    // Create a new ace completer based on the dropdown info and mark it as the
    // "overrideCompleter" which will stay in place for the next popup from
    // autocomplete only:
    var dropdownCompletions = [];
    dropdownList.forEach(function (listValue) {
      var valString, valClick;
      if (typeof listValue === 'string') {
        valString = listValue;
      } else {
        // Support the { text: x, display: x } form, but ignore the display field
        valString = listValue.text;
        // Tack on the special click handler if present
        valClick = listValue.click;
      }
      dropdownCompletions.push({
        name: 'dropdown',
        value: valString,
        click: valClick
      });
    });
    editor.completer.overrideCompleter = {
      getCompletions: function getCompletions(editor, session, pos, prefix, callback) {
        callback(null, dropdownCompletions);
      }
    };
    // Mark the we are starting auto-complete so that we can guard against
    // re-entrancy when we see more cursor movement events:
    this.startingAutoComplete = true;
    editor.execCommand("startAutocomplete");
    this.startingAutoComplete = false;
  }
};

DropletAutocompleteParameterTooltipManager.prototype.updateParameterTooltip_ = function (aceEditor, paramInfo) {
  if (!this.tooltipConfig.tooltipsEnabled) {
    return;
  }

  var docFunc;
  if (this.dropletTooltipManager.getDocFor(paramInfo.funcName)) {
    docFunc = paramInfo.funcName;
  } else if (this.dropletTooltipManager.getDocFor(paramInfo.fullFuncName)) {
    docFunc = paramInfo.fullFuncName;
  } else {
    return;
  }
  var tooltipInfo = this.dropletTooltipManager.getDropletTooltip(docFunc);

  var hasTooltipParams = tooltipInfo.parameterInfos.length > 0;
  if (hasTooltipParams && paramInfo.currentParameterIndex >= tooltipInfo.parameterInfos.length) {
    return;
  }

  var cursorTooltip = this.getCursorTooltip_();

  cursorTooltip.tooltipster('content', this.getTooltipHTML(tooltipInfo, paramInfo.currentParameterIndex));
  cursorTooltip.tooltipster('show');

  if (this.showExamplesLink) {
    var seeExamplesLink = $(cursorTooltip.tooltipster('elementTooltip')).find('.tooltip-example-link > a')[0];
    dom.addClickTouchEvent(seeExamplesLink, (function (event) {
      this.dropletTooltipManager.showDocFor(docFunc);
      event.stopPropagation();
    }).bind(this));
  }

  if (!hasTooltipParams) {
    return;
  }

  var chooseAsset = tooltipInfo.parameterInfos[paramInfo.currentParameterIndex].assetTooltip;
  if (chooseAsset) {
    var chooseAssetLink = $(cursorTooltip.tooltipster('elementTooltip')).find('.tooltip-choose-link > a')[0];
    dom.addClickTouchEvent(chooseAssetLink, (function (event) {
      cursorTooltip.tooltipster('hide');
      chooseAsset(function (filename) {
        aceEditor.onTextInput('"' + filename + '"');
      });
      event.stopPropagation();
    }).bind(this));
  }
};

DropletAutocompleteParameterTooltipManager.prototype.getCursorTooltip_ = function () {
  if (!this.cursorTooltip_) {
    this.cursorTooltip_ = $('.droplet-ace .ace_cursor');
    this.cursorTooltip_.tooltipster(this.tooltipConfig);
  }
  return this.cursorTooltip_;
};

/**
 * @returns {String} HTML for tooltip
 */
DropletAutocompleteParameterTooltipManager.prototype.getTooltipHTML = function (tooltipInfo, currentParameterIndex) {
  return DropletFunctionTooltipMarkup({
    funcName: tooltipInfo.functionName,
    functionName: tooltipInfo.functionName,
    isProperty: tooltipInfo.isProperty,
    tipPrefix: tooltipInfo.tipPrefix,
    functionShortDescription: tooltipInfo.description,
    parameters: tooltipInfo.parameterInfos,
    signatureOverride: tooltipInfo.signatureOverride,
    showExamplesLink: this.showExamplesLink,
    currentParameterIndex: currentParameterIndex
  });
};

/**
 * @param editor - ace editor instance
 * @private
 */
DropletAutocompleteParameterTooltipManager.prototype.installAceCompleterHooks_ = function (editor) {
  if (editor.completer.showPopup !== DropletAutocompleteParameterTooltipManager.showPopup) {
    DropletAutocompleteParameterTooltipManager.originalShowPopup = editor.completer.showPopup;
    editor.completer.showPopup = DropletAutocompleteParameterTooltipManager.showPopup;
  }
  if (editor.completer.gatherCompletions !== DropletAutocompleteParameterTooltipManager.gatherCompletions) {
    DropletAutocompleteParameterTooltipManager.originalGatherCompletions = editor.completer.gatherCompletions;
    editor.completer.gatherCompletions = DropletAutocompleteParameterTooltipManager.gatherCompletions;
  }
  if (!editor.completer.insertMatchOverride) {
    editor.completer.insertMatchOverride = DropletAutocompleteParameterTooltipManager.insertMatch.bind(editor.completer, this);
  }
  if (editor.completer.insertMatch !== editor.completer.insertMatchOverride) {
    DropletAutocompleteParameterTooltipManager.originalInsertMatch = editor.completer.insertMatch;
    editor.completer.insertMatch = editor.completer.insertMatchOverride;
  }
};

/**
 * @param this completer instance
 * @param editor ace editor
 * @param callback we pass this through
 */
DropletAutocompleteParameterTooltipManager.gatherCompletions = function (editor, callback) {
  // Override normal ace AutoComplete behavior by using only overrideCompleter
  // instead of the normal set of completers when overrideCompleter is set
  if (this.overrideCompleter) {
    var allCompleters = editor.completers;
    editor.completers = [this.overrideCompleter];

    // Ensure that autoInsert is off so we don't insert immediately when there is only one option:
    editor.completer.autoInsert = false;

    DropletAutocompleteParameterTooltipManager.originalGatherCompletions.call(this, editor, callback);
    editor.completers = allCompleters;
  } else {
    DropletAutocompleteParameterTooltipManager.originalGatherCompletions.call(this, editor, callback);
  }
};

/**
 * @param this completer instance
 * @param editor ace editor
 */
DropletAutocompleteParameterTooltipManager.showPopup = function (editor) {
  // Override normal ace AutoComplete behavior by guaranteeing that overrideCompleter is reset
  // after each call to showPopup()
  DropletAutocompleteParameterTooltipManager.originalShowPopup.call(this, editor);
  this.overrideCompleter = null;
};

/**
 * @param this completer instance
 * @param self DropletAutocompleteParameterTooltipManager instance
 * @param data info passed to ace's insertMatch
 */
DropletAutocompleteParameterTooltipManager.insertMatch = function (self, data) {
  // Modify normal ace AutoComplete behavior by calling our special 'click' handler when supplied
  // and passing it the default implementation of insertMatch() to be called within
  if (!data) {
    data = this.popup.getData(this.popup.getRow());
  }
  if (!data) {
    return false;
  }

  if (data.click) {
    // Execute detach() method here to ensure that the popup goes
    // away before we call the click() method
    this.detach();

    // And hide our cursor tooltip as well:
    self.getCursorTooltip_().tooltipster('hide');

    // Note: stop dropdowns and tooltips until the callback is complete...
    self.blockDropdownsAndTooltips = true;

    var lang = ace.require("./lib/lang");

    // Use delayedCall so the popup and tooltip disappear in the case where the
    // Enter key was pressed before we choose this autocomplete item
    var clickFunc = lang.delayedCall((function () {
      // We create a callback function which the click function will call, passing a
      // string which will be inserted.
      data.click((function (data) {
        this.editor.execCommand("insertstring", data);
        self.blockDropdownsAndTooltips = false;
      }).bind(this));
    }).bind(this));

    clickFunc.schedule();
  } else {
    DropletAutocompleteParameterTooltipManager.originalInsertMatch.call(this, data);
  }
};

/**
 * @param {boolean} enabled if tooltips should be enabled
 */
DropletAutocompleteParameterTooltipManager.prototype.setTooltipsEnabled = function (enabled) {
  this.tooltipConfig.tooltipsEnabled = !!enabled;
};

module.exports = DropletAutocompleteParameterTooltipManager;

},{"../dom":"/home/ubuntu/staging/apps/build/js/dom.js","../dropletUtils":"/home/ubuntu/staging/apps/build/js/dropletUtils.js","./DropletParameterTooltip.html.ejs":"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletParameterTooltip.html.ejs","./tooltipUtils.js":"/home/ubuntu/staging/apps/build/js/blockTooltips/tooltipUtils.js"}],"/home/ubuntu/staging/apps/build/js/blockTooltips/tooltipUtils.js":[function(require,module,exports){
/* global ace */
'use strict';

var utils = require('../utils');
var _ = utils.getLodash();

/**
 * @typedef {Object} parameterSlotInfo
 * @property {string} funcName
 * @property {number} currentParameterIndex
 */

var ONLY_WHITESPACE_REGEXP = /^\s*$/;
var ENDING_OF_BLOCK_COMMENT = /\*\/$/;
var START_OF_BLOCK_COMMENT = /^\/\*/;

/**
 * Returns the number of instances of character within string
 * @param {string} string
 * @param {string} character
 * @returns {number}
 */
function countNumberOfCharacter(string, character) {
  return string.split(character).length - 1;
}

function openerMatchesCloser(opener, closer) {
  var closersToOpeners = {
    '}': '{',
    ')': '(',
    ']': '['
  };
  return closersToOpeners[closer] === opener;
}

/**
 * Given an ace editor and row/column position, returns the function
 * name and index of the currently edited parameter.
 * If a parameter is not currently being filled in, returns null.
 * TODO(bjordan): Unit test once ace.require available in utility tests
 * @param editor
 * @param position
 * @returns {parameterSlotInfo|null}
 */
exports.findFunctionAndParamNumber = function (editor, position) {
  var seenCloserStack = [];
  var sameDepthPrecedingCommaCount = 0;

  var TokenIterator = ace.require("./token_iterator").TokenIterator;
  var iterator = new TokenIterator(editor.session, position.row, position.column);

  var token = iterator.getCurrentToken();

  // Special cases for first token

  if (position.column === 0) {
    // At beginning of a line. Step back one for first token.
    token = iterator.stepBackward();
  } else if (token && token.type.match(/^comment/)) {
    var isBlockComment = token.type === "comment.doc" || token.value.match(START_OF_BLOCK_COMMENT);
    if (isBlockComment) {
      var tokenIsEndOfDocComment = token.value.match(ENDING_OF_BLOCK_COMMENT);
      var cursorIsEndOfToken = token.start + token.value.length === position.column;
      var cursorIsEndOfBlockComment = tokenIsEndOfDocComment && cursorIsEndOfToken;
      if (!cursorIsEndOfBlockComment) {
        // Starting within a block comment
        return null;
      }
    } else {
      // Starting within a comment
      return null;
    }
  }

  while (token) {
    switch (token.type) {
      case "paren.rparen":
        var closers = token.value.split();
        for (var i = closers.length - 1; i >= 0; i--) {
          var currentCloser = closers[i];
          seenCloserStack.push(currentCloser);
        }
        break;
      case "paren.lparen":
        var openers = token.value.split();
        for (var j = openers.length - 1; j >= 0; j--) {
          var currentOpener = openers[j];

          var isBeginningOfFunctionCall = seenCloserStack.length === 0 && currentOpener === '(';
          if (isBeginningOfFunctionCall) {
            var funcName = iterator.stepBackward().value;
            // if we have text "foo.bar(", store "foo.bar" as fullFuncName and
            // "*.bar" as funcName:
            var fullFuncName;
            var previousToken = iterator.stepBackward();
            if (previousToken && previousToken.value === '.') {
              fullFuncName = iterator.stepBackward().value + '.' + funcName;
              funcName = '*.' + funcName;
            }

            return {
              funcName: funcName,
              fullFuncName: fullFuncName,
              currentParameterIndex: sameDepthPrecedingCommaCount
            };
          }

          var lastCloser = seenCloserStack.pop();
          if (!lastCloser || !openerMatchesCloser(currentOpener, lastCloser)) {
            return null;
          }
        }
        break;
      case "punctuation.operator":
        if (seenCloserStack.length === 0) {
          if (_.contains(token.value, ';')) {
            return null;
          }
          if (_.contains(token.value, ',')) {
            sameDepthPrecedingCommaCount += countNumberOfCharacter(token.value, ',');
          }
        }
        break;
      case "comment":
      case "comment.doc":
        break;
      case "text":
        // Whitespace or random non-identifier characters
        if (seenCloserStack.length !== 0 || token.value.match(ONLY_WHITESPACE_REGEXP)) {
          break;
        }
        return null;
      case "string":
      case "storage.type":
      case "identifier":
      /* falls through */
      default:
        if (seenCloserStack.length === 0 && sameDepthPrecedingCommaCount === 0) {
          // Something substantial between cursor and start of parameter slot
          return null;
        }
        break;
    }

    token = iterator.stepBackward();
  }

  return null;
};

},{"../utils":"/home/ubuntu/staging/apps/build/js/utils.js"}],"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletParameterTooltip.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<div class="function-name">\n  ');2; if (signatureOverride) {; buf.push('    ', escape((2,  signatureOverride )), '\n  ');3; } else {
    /**
     * TODO(bjordan): would be nice to split the following line up, can't figure
     * out how to do so without inserting extraneous spaces between parameters.
     */
   ; buf.push('    ', escape((8,  functionName )), '(');8; for (var i = 0; i < parameters.length; i++) {; buf.push('<span class="tooltip-parameter-name ');8; if (i === currentParameterIndex) { ; buf.push(' current-tooltip-parameter-name');8; } ; buf.push('">', (8,  parameters[i].name), '</span>');8; if (i < parameters.length - 1) {; buf.push(', ');8; }; buf.push('');8; }; buf.push(')  ');8; } ; buf.push('\n</div>\n');10; if (parameters[currentParameterIndex] && parameters[currentParameterIndex].description) { ; buf.push('<div>', escape((10,  parameters[currentParameterIndex].description )), '</div>');10; } ; buf.push('\n');11; if (parameters[currentParameterIndex] && parameters[currentParameterIndex].assetTooltip) { ; buf.push('\n  <div class="tooltip-choose-link">\n    <a href="javascript:void(0);">Choose...</a>\n  </div>\n');15; } ; buf.push('\n');16; if (showExamplesLink) { ; buf.push('\n  <div class="tooltip-example-link">\n    <a href="javascript:void(0);">See examples</a>\n  </div>\n');20; } ; buf.push('\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/authoredHints.js":[function(require,module,exports){
/**
 * @overview helper class to manage the state of the Authored Hint UI.
 * Used exclusively by StudioApp.
 */

'use strict';

var dom = require('./dom');
var msg = require('./locale');
var HintSelect = require('./templates/HintSelect.jsx');
var HintsDisplay = require('./templates/HintsDisplay.jsx');
var authoredHintUtils = require('./authoredHintUtils');
var lightbulbSVG = require('./templates/lightbulb.svg.ejs')();
var lightbulbDimSVG = require('./templates/lightbulb_dim.svg.ejs')();

var AuthoredHints = function AuthoredHints(studioApp) {
  this.studioApp_ = studioApp;

  /**
   * @typedef {Object} AuthoredHint
   * @property {string} content
   * @property {string} hintId
   * @property {string} hintClass
   * @property {string} hintType
   * @property {boolean} alreadySeen
   */
  /**
   * @type {!AuthoredHint[]}
   */
  this.hints_ = [];
  this.contextualHints_ = [];

  /**
   * @type {number}
   */
  this.scrptId_ = undefined;

  /**
   * @type {number}
   */
  this.levelId_ = undefined;

  /**
   * @type {Element}
   */
  this.lightbulb = document.createElement('div');
  this.lightbulb.id = "lightbulb";
};

module.exports = AuthoredHints;

/**
 * @return {AuthoredHints[]}
 */
AuthoredHints.prototype.getUnseenHints = function () {
  var hints = this.contextualHints_.concat(this.hints_ || []);
  return hints.filter(function (hint) {
    return hint.alreadySeen === false;
  });
};

/**
 * @return {AuthoredHints[]}
 */
AuthoredHints.prototype.getSeenHints = function () {
  var hints = this.contextualHints_.concat(this.hints_ || []);
  return hints.filter(function (hint) {
    return hint.alreadySeen === true;
  });
};

/**
 * Creates contextual hints for the specified blocks and adds them to
 * the queue of hints to display. Triggers an animation on the hint
 * lightbulb if the queue has changed.
 * @param {Object[]} blocks @see authoredHintUtils.createContextualHintsFromBlocks
 */
AuthoredHints.prototype.displayMissingBlockHints = function (blocks) {
  var newContextualHints = authoredHintUtils.createContextualHintsFromBlocks(blocks);

  // if the set of contextual hints currently being shown has changed,
  // animate the hint display lightbulb when we update it.
  var oldContextualHints = this.contextualHints_.filter(function (hint) {
    return hint.alreadySeen === false;
  });
  var animateLightbulb = oldContextualHints.length !== newContextualHints.length;

  this.contextualHints_ = newContextualHints;
  this.updateLightbulbDisplay_(animateLightbulb);
};

/**
 * @param {Object} response
 */
AuthoredHints.prototype.finishHints = function (response) {
  authoredHintUtils.finishHints({
    time: new Date().getTime() - this.studioApp_.initTime,
    attempt: this.studioApp_.attempts,
    testResult: this.studioApp_.lastTestResult,
    activityId: response && response.activity_id,
    levelSourceId: response && response.level_source_id
  });
};

/**
 * @param {string} url
 */
AuthoredHints.prototype.submitHints = function (url) {
  authoredHintUtils.submitHints(url);
};

/**
 * @param {AuthoredHint[]} hints
 * @param {number} scriptId
 * @param {number} levelId
 */
AuthoredHints.prototype.init = function (hints, scriptId, levelId) {
  this.hints_ = hints;
  this.scriptId_ = scriptId;
  this.levelId_ = levelId;
};

/**
 * Sets up the Authored Hints UI; decorates the specified element with a
 * lightbulb image and hint counter, and adds a click handler to show
 * a qtip for the next unseen hint.
 *
 * @param {Element} promptIcon - the page element to "decorate" with the
 *        lightbulb
 * @param {Element} clickTarget
 * @param {function} callback - a StudioApp function to be treated as
 *        the "default" action when there are no unseen hints. 
 */
AuthoredHints.prototype.display = function (promptIcon, clickTarget, callback) {
  this.promptIcon = promptIcon;
  this.updateLightbulbDisplay_();
  clickTarget.addEventListener('click', (function () {
    var hintsToShow = this.getUnseenHints();
    if (hintsToShow.length > 0) {
      this.showHint_(hintsToShow[0], callback);
    } else {
      callback();
    }
  }).bind(this));
};

/**
 * Mostly a passthrough to authoredHintUtils.recordUnfinishedHint. Also
 * marks the given hint as seen.
 * @param {AuthoredHint} hint
 */
AuthoredHints.prototype.recordUserViewedHint_ = function (hint) {
  hint.alreadySeen = true;
  this.updateLightbulbDisplay_();

  authoredHintUtils.recordUnfinishedHint({
    // level info
    scriptId: this.scriptId_,
    levelId: this.levelId_,

    // hint info
    hintId: hint.hintId,
    hintClass: hint.hintClass,
    hintType: hint.hintType
  });
};

/**
 * Adjusts the displayed number of unseen hints. Dims the lightbulb
 * image if there are no hints. Optionally plays a simple CSS animation
 * to highlight the update.
 * @param {boolean} animate defaults to false
 */
AuthoredHints.prototype.updateLightbulbDisplay_ = function (animate) {
  animate = animate || false;

  var hintCount = this.getUnseenHints().length;

  // If we have hints to show, but are not in the DOM, insert ourselves
  // into the DOM. This can happen when contextual hints appear in a
  // level that was initialized with no hints. Note that we can be in
  // the DOM and have zero hints to show, and that's just fine.
  if (hintCount > 0 && !document.body.contains(this.lightbulb)) {
    this.promptIcon.parentNode.className += ' authored_hints';
    this.promptIcon.parentNode.insertBefore(this.lightbulb, this.promptIcon);
  }

  // If there are more than nine hints, simply display "9+"
  var hintText = hintCount > 9 ? "9+" : hintCount;
  if (hintCount === 0) {
    this.lightbulb.innerHTML = lightbulbDimSVG;
  } else {
    this.lightbulb.innerHTML = lightbulbSVG;
    this.lightbulb.querySelector('#hintCount').textContent = hintText;
  }

  var bulb = document.getElementById("bulb");
  if (animate && bulb) {
    bulb.setAttribute('class', 'animate-hint');
  }
};

AuthoredHints.prototype.getHintsDisplay = function () {
  var hintsDisplay = React.createElement(HintsDisplay, {
    hintReviewTitle: msg.hintReviewTitle(),
    seenHints: this.getSeenHints(),
    unseenHints: this.getUnseenHints(),
    lightbulbSVG: lightbulbSVG,
    onUserViewedHint: (function () {
      var nextHint = this.getUnseenHints()[0];
      this.recordUserViewedHint_(nextHint);
    }).bind(this)
  });

  return hintsDisplay;
};

/**
 * Render a qtip popup containing an interface which gives the user the
 * option of viewing the instructions for the level (along with all
 * previously-viewed hints) or viewing a new hint.
 * @param {AuthoredHint} hint
 * @param {function} callback
 */
AuthoredHints.prototype.showHint_ = function (hint, callback) {
  $('#prompt-icon').qtip({
    content: {
      text: (function (html, api) {
        var container = document.createElement('div');

        var element = React.createElement(HintSelect, {
          showInstructions: (function () {
            api.destroy();
            callback();
          }).bind(this),
          showHint: (function () {
            if (hint.block) {
              var content = document.createElement('div');
              content.innerHTML = hint.content;
              var blockContainer = document.createElement('div');
              blockContainer.style.height = '100px';
              content.appendChild(blockContainer);
              api.set('content.text', content);

              Blockly.BlockSpace.createReadOnlyBlockSpace(blockContainer, hint.block);
            } else {
              api.set('content.text', hint.content);
            }
            $(api.elements.content).find('img').on('load', function (e) {
              api.reposition(e);
            });
            this.recordUserViewedHint_(hint);
          }).bind(this)
        });

        ReactDOM.render(element, container);

        return container;
      }).bind(this),
      title: {
        button: $('<div class="tooltip-x-close"/>')
      }
    },
    style: {
      classes: "cdo-qtips",
      tip: {
        width: 20,
        height: 20
      }
    },
    position: {
      my: "bottom left",
      at: "top right"
    },
    hide: {
      event: 'unfocus'
    },
    show: false // don't show on mouseover
  }).qtip('show');
};

},{"./authoredHintUtils":"/home/ubuntu/staging/apps/build/js/authoredHintUtils.js","./dom":"/home/ubuntu/staging/apps/build/js/dom.js","./locale":"/home/ubuntu/staging/apps/build/js/locale.js","./templates/HintSelect.jsx":"/home/ubuntu/staging/apps/build/js/templates/HintSelect.jsx","./templates/HintsDisplay.jsx":"/home/ubuntu/staging/apps/build/js/templates/HintsDisplay.jsx","./templates/lightbulb.svg.ejs":"/home/ubuntu/staging/apps/build/js/templates/lightbulb.svg.ejs","./templates/lightbulb_dim.svg.ejs":"/home/ubuntu/staging/apps/build/js/templates/lightbulb_dim.svg.ejs"}],"/home/ubuntu/staging/apps/build/js/templates/lightbulb_dim.svg.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<svg version="1.1"\n	 id="svg3013" inkscape:version="0.48.3.1 r9886" sodipodi:docname="light_bulb_font_awesome.svg" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:cc="http://creativecommons.org/ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns:dc="http://purl.org/dc/elements/1.1/"\n	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px"\n	 viewBox="0 0 612 792" enable-background="new 0 0 612 792" xml:space="preserve">\n<sodipodi:namedview  inkscape:pageopacity="0" inkscape:window-width="640" inkscape:pageshadow="2" inkscape:window-height="480" inkscape:window-x="0" inkscape:window-y="25" inkscape:window-maximized="0" inkscape:current-layer="svg3013" guidetolerance="10" pagecolor="#ffffff" objecttolerance="10" gridtolerance="10" showgrid="false" inkscape:cx="896" inkscape:cy="896" borderopacity="1" bordercolor="#666666" inkscape:zoom="0.13169643" id="namedview3019">\n	</sodipodi:namedview>\n<path fill="#C9C9C9" d="M453.775,353.156c0,24.012-57.189,128.942-61.414,132.265c-12.384,9.741-48.514,15.318-82.869,16.518\n	c-8.362,0.292-16.619,0.325-24.403,0.096c-20.716-0.611-38.081-3.079-45.155-7.464c-6.896-4.274-74.477-119.24-74.477-141.415\n	c0-89.195,64.542-161.502,144.159-161.502S453.775,263.961,453.775,353.156z"/>\n<g id="g3015" transform="matrix(1,0,0,-1,379.66102,1293.0169)">\n	<path id="path3017" inkscape:connector-curvature="0" fill="#5D5D5D" d="M7.357,980.857c0-2.96-1.081-5.521-3.244-7.684\n		s-4.724-3.244-7.684-3.244s-5.521,1.081-7.684,3.244s-3.244,4.724-3.244,7.684c0,10.473-6.147,18.556-18.442,24.248\n		c-12.295,5.692-24.362,8.538-36.201,8.538c-2.96,0-5.521,1.081-7.684,3.244s-3.244,4.724-3.244,7.684\n		c0,2.96,1.081,5.521,3.244,7.684s4.724,3.244,7.684,3.244c11.384,0,22.711-1.821,33.981-5.464s21.174-9.79,29.712-18.442\n		S7.357,992.696,7.357,980.857z M62,980.857c0,16.393-3.927,31.647-11.782,45.763s-18.1,25.671-30.737,34.664\n		s-26.638,16.051-42.007,21.174s-30.907,7.684-46.617,7.684s-31.249-2.561-46.617-7.684s-29.371-12.181-42.007-21.174\n		c-12.636-8.993-22.882-20.548-30.737-34.664c-7.855-14.116-11.782-29.371-11.782-45.763c0-22.996,7.741-43.487,23.223-61.473\n		c2.277-2.504,5.749-6.261,10.416-11.27c4.667-5.009,8.14-8.766,10.416-11.27c29.143-34.835,45.194-68.759,48.154-101.772h77.866\n		c2.96,33.013,19.011,66.938,48.154,101.772c2.277,2.504,5.749,6.261,10.416,11.27s8.14,8.766,10.416,11.27\n		C54.259,937.37,62,957.862,62,980.857z M105.714,980.857c0-35.29-11.725-65.799-35.176-91.527\n		c-10.246-11.156-18.727-21.06-25.443-29.712s-13.49-19.523-20.32-32.615c-6.83-13.092-10.701-25.329-11.612-36.713\n		c10.701-6.375,16.051-15.71,16.051-28.004c0-8.424-2.846-15.71-8.538-21.857c5.692-6.147,8.538-13.433,8.538-21.857\n		c0-11.839-5.123-21.06-15.368-27.663c2.96-5.237,4.44-10.587,4.44-16.051c0-10.473-3.586-18.556-10.758-24.248\n		s-15.994-8.538-26.468-8.538c-4.554-10.018-11.384-17.987-20.491-23.906c-9.107-5.92-19.011-8.879-29.712-8.879\n		c-10.701,0-20.605,2.96-29.712,8.879c-9.107,5.92-15.938,13.888-20.491,23.906c-10.473,0-19.296,2.846-26.468,8.538\n		s-10.758,13.775-10.758,24.248c0,5.464,1.48,10.815,4.44,16.051c-10.246,6.603-15.368,15.824-15.368,27.663\n		c0,8.424,2.846,15.71,8.538,21.857c-5.692,6.147-8.538,13.433-8.538,21.857c0,12.295,5.35,21.629,16.051,28.004\n		c-0.911,11.384-4.781,23.622-11.612,36.713c-6.83,13.091-13.604,23.963-20.32,32.615s-15.198,18.556-25.443,29.712\n		C-232.275,915.058-244,945.567-244,980.857c0,22.54,5.066,43.544,15.198,63.01c10.132,19.467,23.451,35.632,39.958,48.496\n		c16.507,12.864,35.176,22.995,56.009,30.395s42.064,11.099,63.693,11.099s42.86-3.7,63.693-11.099s39.502-17.531,56.009-30.395\n		c16.507-12.864,29.826-29.029,39.958-48.496C100.648,1024.401,105.714,1003.397,105.714,980.857z"/>\n</g>\n<path fill="#EFB834" d="M1538.775-187.844c0,24.012-57.189,128.942-61.414,132.265c-12.384,9.741-48.514,15.318-82.869,16.518\n	c-8.362,0.292-16.619,0.325-24.403,0.096c-20.716-0.611-38.081-3.079-45.155-7.464c-6.896-4.274-74.477-119.24-74.477-141.415\n	c0-89.195,64.542-161.502,144.159-161.502S1538.775-277.039,1538.775-187.844z"/>\n<g id="g3015_1_" transform="matrix(1,0,0,-1,379.66102,1293.0169)">\n	<path id="path3017_1_" inkscape:connector-curvature="0" fill="#5D5D5D" d="M1092.357,1521.857c0-2.96-1.082-5.521-3.244-7.684\n		c-2.163-2.163-4.724-3.245-7.684-3.245s-5.521,1.082-7.684,3.245c-2.163,2.163-3.244,4.724-3.244,7.684\n		c0,10.473-6.147,18.556-18.442,24.248c-12.295,5.692-24.362,8.538-36.201,8.538c-2.96,0-5.521,1.081-7.684,3.244\n		c-2.163,2.163-3.244,4.724-3.244,7.684c0,2.96,1.081,5.521,3.244,7.684c2.163,2.163,4.724,3.244,7.684,3.244\n		c11.384,0,22.711-1.821,33.981-5.464c11.27-3.643,21.174-9.79,29.712-18.442\n		C1088.088,1543.942,1092.357,1533.696,1092.357,1521.857z M1147,1521.857c0,16.393-3.927,31.647-11.782,45.763\n		s-18.1,25.671-30.737,34.664c-12.636,8.993-26.638,16.051-42.007,21.174s-30.907,7.684-46.617,7.684s-31.249-2.561-46.617-7.684\n		c-15.368-5.123-29.371-12.181-42.007-21.174s-22.882-20.548-30.737-34.664s-11.782-29.371-11.782-45.763\n		c0-22.995,7.741-43.487,23.223-61.473c2.277-2.505,5.749-6.261,10.416-11.27s8.139-8.766,10.416-11.27\n		c29.143-34.835,45.194-68.759,48.154-101.772h77.866c2.96,33.013,19.011,66.938,48.154,101.772\n		c2.277,2.505,5.749,6.261,10.416,11.27c4.667,5.009,8.14,8.766,10.416,11.27C1139.259,1478.37,1147,1498.862,1147,1521.857z\n		 M1190.714,1521.857c0-35.29-11.725-65.799-35.176-91.527c-10.245-11.156-18.727-21.06-25.443-29.712\n		c-6.717-8.652-13.49-19.524-20.32-32.615c-6.83-13.092-10.701-25.329-11.612-36.713c10.701-6.375,16.051-15.71,16.051-28.005\n		c0-8.424-2.846-15.71-8.538-21.857c5.692-6.147,8.538-13.433,8.538-21.857c0-11.839-5.123-21.06-15.368-27.663\n		c2.96-5.237,4.44-10.587,4.44-16.051c0-10.473-3.586-18.556-10.758-24.248c-7.172-5.692-15.995-8.538-26.468-8.538\n		c-4.554-10.018-11.384-17.987-20.491-23.906c-9.107-5.92-19.011-8.879-29.712-8.879c-10.701,0-20.605,2.96-29.712,8.879\n		c-9.107,5.92-15.938,13.888-20.491,23.906c-10.473,0-19.296,2.846-26.468,8.538c-7.172,5.692-10.758,13.775-10.758,24.248\n		c0,5.464,1.48,10.815,4.44,16.051c-10.245,6.603-15.368,15.824-15.368,27.663c0,8.424,2.846,15.71,8.538,21.857\n		c-5.692,6.147-8.538,13.433-8.538,21.857c0,12.295,5.35,21.63,16.051,28.005c-0.911,11.384-4.781,23.622-11.612,36.713\n		c-6.83,13.091-13.604,23.963-20.32,32.615c-6.717,8.652-15.198,18.556-25.443,29.712c-23.451,25.728-35.176,56.237-35.176,91.527\n		c0,22.54,5.066,43.544,15.198,63.01c10.132,19.467,23.451,35.632,39.958,48.496c16.507,12.864,35.176,22.995,56.009,30.395\n		s42.064,11.099,63.693,11.099c21.629,0,42.86-3.7,63.693-11.099c20.833-7.4,39.502-17.531,56.009-30.395\n		c16.507-12.864,29.826-29.029,39.958-48.496C1185.648,1565.401,1190.714,1544.397,1190.714,1521.857z"/>\n</g>\n<g>\n	<line fill="#EFB834" x1="1558.582" y1="-332.9" x2="1645.578" y2="-381.84"/>\n	<path fill="#EFB834" d="M1558.141-333.685c0,0,1.225-1.003,3.396-2.711c1.08-0.864,2.402-1.894,3.925-3.063\n		c1.525-1.167,3.227-2.514,5.117-3.927c1.887-1.418,3.931-2.954,6.092-4.578c2.158-1.632,4.463-3.3,6.831-5.055\n		c2.386-1.723,4.843-3.519,7.372-5.285c2.515-1.791,5.104-3.552,7.677-5.341c2.578-1.778,5.065-3.721,7.503-5.648\n		c1.228-0.948,2.436-1.907,3.665-2.792c1.231-0.881,2.478-1.695,3.736-2.442c2.527-1.472,5.12-2.629,7.656-3.587\n		c2.529-0.971,4.998-1.751,7.331-2.377c4.656-1.268,8.797-1.858,11.81-2.069c1.504-0.109,2.718-0.138,3.572-0.111\n		c0.843,0.007,1.313,0.047,1.313,0.047l0.882,1.569c0,0-0.21,0.422-0.641,1.146c-0.42,0.744-1.075,1.766-1.95,2.995\n		c-1.745,2.465-4.4,5.698-7.9,9.019c-1.746,1.669-3.694,3.374-5.838,5.031c-2.136,1.671-4.471,3.285-7.041,4.681\n		c-1.291,0.687-2.635,1.331-4.027,1.925c-1.394,0.591-2.841,1.126-4.289,1.683c-2.914,1.083-5.865,2.2-8.723,3.48\n		c-2.865,1.27-5.713,2.568-8.55,3.788c-2.823,1.245-5.633,2.412-8.345,3.556c-2.729,1.113-5.352,2.217-7.867,3.213\n		c-2.511,1.004-4.885,1.953-7.076,2.83c-2.188,0.881-4.224,1.637-6.013,2.334c-1.79,0.695-3.357,1.29-4.656,1.764\n		c-2.587,0.968-4.08,1.494-4.08,1.494L1558.141-333.685z"/>\n</g>\n<g>\n	<line fill="#EFB834" x1="1577.348" y1="-130.992" x2="1674.509" y2="-108.117"/>\n	<path fill="#EFB834" d="M1577.555-131.868c0,0,1.581,0.091,4.335,0.303c1.38,0.095,3.05,0.232,4.962,0.403\n		c1.912,0.173,4.077,0.334,6.424,0.574c2.348,0.234,4.892,0.487,7.583,0.755c2.693,0.259,5.519,0.592,8.45,0.904\n		c2.923,0.347,5.947,0.688,9.004,1.101c3.064,0.384,6.161,0.841,9.266,1.266c3.102,0.437,6.246,0.691,9.346,0.922\n		c1.546,0.133,3.084,0.246,4.588,0.426c1.502,0.185,2.972,0.43,4.403,0.732c2.856,0.628,5.548,1.531,8.064,2.543\n		c2.519,0.998,4.864,2.095,7.004,3.213c4.285,2.219,7.732,4.588,10.093,6.472c1.181,0.938,2.094,1.738,2.704,2.337\n		c0.615,0.576,0.934,0.923,0.934,0.923l-0.412,1.752c0,0-0.44,0.169-1.248,0.41c-0.813,0.263-1.987,0.572-3.463,0.885\n		c-2.953,0.633-7.096,1.216-11.92,1.29c-2.414,0.046-5.003-0.018-7.702-0.249c-2.703-0.216-5.515-0.609-8.351-1.322\n		c-1.416-0.368-2.84-0.804-4.267-1.309c-1.426-0.509-2.853-1.095-4.296-1.665c-2.878-1.176-5.805-2.351-8.776-3.344\n		c-2.968-1.004-5.943-1.977-8.857-3c-2.92-0.995-5.779-2.038-8.549-3.032c-2.762-1.029-5.44-1.992-7.965-2.961\n		c-2.528-0.961-4.918-1.869-7.124-2.708c-2.207-0.833-4.217-1.655-6.005-2.353c-1.788-0.7-3.344-1.323-4.621-1.854\n		c-2.559-1.039-4.015-1.663-4.015-1.663L1577.555-131.868z"/>\n</g>\n<g>\n	<line fill="#EFB834" x1="1587.559" y1="-239.3" x2="1687.37" y2="-240.315"/>\n	<path fill="#EFB834" d="M1587.55-240.2c0,0,1.557-0.289,4.282-0.742c1.362-0.237,3.017-0.504,4.915-0.795\n		c1.898-0.289,4.039-0.65,6.375-0.979c2.336-0.334,4.867-0.697,7.544-1.08c2.677-0.392,5.5-0.744,8.421-1.142\n		c2.921-0.362,5.939-0.753,9.006-1.084c3.067-0.359,6.183-0.656,9.299-0.985c3.116-0.317,6.23-0.823,9.296-1.339\n		c1.533-0.24,3.053-0.499,4.556-0.683c1.503-0.18,2.989-0.293,4.45-0.342c2.924-0.073,5.753,0.16,8.438,0.542\n		c2.684,0.366,5.224,0.871,7.569,1.446c4.691,1.13,8.605,2.607,11.347,3.872c1.371,0.629,2.449,1.187,3.185,1.622\n		c0.735,0.412,1.128,0.673,1.128,0.673l0.018,1.8c0,0-0.387,0.269-1.114,0.696c-0.726,0.45-1.793,1.031-3.151,1.687\n		c-2.716,1.321-6.6,2.877-11.266,4.102c-2.333,0.622-4.862,1.179-7.539,1.599c-2.676,0.436-5.5,0.727-8.425,0.713\n		c-1.462-0.019-2.95-0.102-4.456-0.251c-1.506-0.153-3.032-0.381-4.569-0.59c-3.075-0.454-6.199-0.895-9.321-1.149\n		c-3.122-0.266-6.244-0.499-9.318-0.796c-3.073-0.268-6.099-0.598-9.026-0.9c-2.928-0.338-5.758-0.634-8.442-0.971\n		c-2.684-0.329-5.222-0.639-7.564-0.926c-2.343-0.281-4.49-0.599-6.394-0.849c-1.903-0.253-3.563-0.486-4.93-0.695\n		c-2.734-0.397-4.296-0.655-4.296-0.655L1587.55-240.2z"/>\n</g>\n<g>\n	<line fill="#EFB834" x1="1220.661" y1="-328.236" x2="1133.665" y2="-377.176"/>\n	<path fill="#EFB834" d="M1220.22-327.452c0,0-1.493-0.526-4.08-1.494c-1.299-0.474-2.866-1.069-4.656-1.764\n		c-1.789-0.697-3.824-1.453-6.013-2.334c-2.191-0.876-4.565-1.826-7.076-2.83c-2.515-0.996-5.138-2.1-7.867-3.213\n		c-2.712-1.144-5.522-2.312-8.345-3.556c-2.837-1.22-5.686-2.518-8.55-3.788c-2.859-1.28-5.81-2.397-8.723-3.48\n		c-1.448-0.557-2.895-1.092-4.289-1.683c-1.392-0.594-2.736-1.238-4.027-1.925c-2.57-1.396-4.905-3.01-7.041-4.681\n		c-2.143-1.657-4.092-3.363-5.838-5.031c-3.5-3.32-6.155-6.554-7.9-9.019c-0.875-1.229-1.53-2.251-1.95-2.995\n		c-0.431-0.724-0.641-1.146-0.641-1.146l0.883-1.569c0,0,0.47-0.04,1.313-0.047c0.854-0.027,2.068,0.002,3.573,0.111\n		c3.013,0.211,7.155,0.801,11.81,2.069c2.332,0.625,4.802,1.406,7.331,2.377c2.537,0.958,5.129,2.115,7.656,3.587\n		c1.258,0.746,2.505,1.561,3.736,2.442c1.229,0.885,2.437,1.844,3.665,2.792c2.438,1.928,4.925,3.87,7.503,5.648\n		c2.573,1.789,5.161,3.549,7.677,5.341c2.53,1.766,4.986,3.562,7.372,5.285c2.368,1.755,4.673,3.423,6.831,5.055\n		c2.162,1.625,4.206,3.16,6.092,4.578c1.889,1.413,3.592,2.76,5.116,3.927c1.523,1.169,2.845,2.199,3.925,3.063\n		c2.171,1.708,3.396,2.711,3.396,2.711L1220.22-327.452z"/>\n</g>\n<g>\n	<line fill="#EFB834" x1="1205.895" y1="-129.328" x2="1108.734" y2="-106.453"/>\n	<path fill="#EFB834" d="M1206.101-128.452c0,0-1.455,0.623-4.015,1.663c-1.277,0.53-2.833,1.153-4.621,1.854\n		c-1.788,0.698-3.798,1.52-6.005,2.353c-2.206,0.838-4.596,1.747-7.124,2.708c-2.526,0.969-5.203,1.932-7.965,2.961\n		c-2.77,0.993-5.629,2.037-8.549,3.032c-2.914,1.023-5.889,1.996-8.857,3c-2.971,0.993-5.899,2.169-8.776,3.344\n		c-1.443,0.57-2.87,1.156-4.296,1.665c-1.427,0.505-2.852,0.941-4.267,1.309c-2.836,0.713-5.648,1.105-8.351,1.321\n		c-2.7,0.231-5.288,0.295-7.703,0.249c-4.824-0.074-8.967-0.657-11.92-1.29c-1.476-0.313-2.65-0.621-3.463-0.885\n		c-0.808-0.241-1.248-0.41-1.248-0.41l-0.412-1.752c0,0,0.319-0.347,0.934-0.923c0.61-0.598,1.523-1.399,2.704-2.337\n		c2.36-1.884,5.808-4.254,10.093-6.472c2.14-1.119,4.485-2.216,7.004-3.213c2.516-1.012,5.207-1.915,8.064-2.543\n		c1.431-0.302,2.901-0.547,4.403-0.732c1.503-0.181,3.042-0.293,4.588-0.426c3.1-0.232,6.245-0.486,9.346-0.922\n		c3.104-0.425,6.202-0.882,9.266-1.266c3.057-0.412,6.081-0.754,9.004-1.101c2.931-0.312,5.757-0.644,8.45-0.904\n		c2.691-0.268,5.235-0.521,7.583-0.755c2.347-0.239,4.512-0.4,6.424-0.574c1.913-0.171,3.583-0.308,4.962-0.403\n		c2.754-0.212,4.335-0.303,4.335-0.303L1206.101-128.452z"/>\n</g>\n<g>\n	<line fill="#EFB834" x1="1197.684" y1="-234.636" x2="1097.873" y2="-235.651"/>\n	<path fill="#EFB834" d="M1197.675-233.736c0,0-1.562,0.257-4.296,0.655c-1.367,0.21-3.026,0.443-4.93,0.695\n		c-1.904,0.25-4.051,0.568-6.394,0.849c-2.342,0.287-4.88,0.598-7.564,0.926c-2.684,0.337-5.514,0.633-8.442,0.971\n		c-2.928,0.302-5.953,0.632-9.026,0.9c-3.074,0.297-6.195,0.53-9.318,0.796c-3.122,0.254-6.246,0.696-9.321,1.149\n		c-1.538,0.209-3.063,0.437-4.569,0.59c-1.506,0.149-2.994,0.232-4.456,0.251c-2.925,0.014-5.749-0.277-8.425-0.713\n		c-2.677-0.421-5.205-0.977-7.539-1.599c-4.667-1.225-8.55-2.781-11.266-4.102c-1.358-0.656-2.424-1.237-3.151-1.687\n		c-0.727-0.427-1.114-0.696-1.114-0.696l0.018-1.8c0,0,0.393-0.261,1.128-0.673c0.736-0.435,1.813-0.994,3.185-1.622\n		c2.742-1.265,6.657-2.742,11.347-3.872c2.345-0.575,4.885-1.079,7.57-1.446c2.685-0.382,5.514-0.615,8.438-0.542\n		c1.462,0.049,2.947,0.162,4.45,0.342c1.503,0.184,3.024,0.443,4.556,0.683c3.065,0.516,6.18,1.021,9.296,1.339\n		c3.116,0.329,6.233,0.626,9.3,0.985c3.067,0.33,6.085,0.722,9.006,1.084c2.921,0.398,5.744,0.75,8.421,1.142\n		c2.677,0.383,5.208,0.745,7.544,1.08c2.336,0.329,4.477,0.69,6.375,0.979c1.898,0.291,3.552,0.558,4.915,0.795\n		c2.725,0.453,4.282,0.742,4.282,0.742L1197.675-233.736z"/>\n</g>\n<path fill="#C9C9C9" d="M2633.883-46.319c0,24.012-57.189,128.942-61.414,132.265c-12.384,9.741-48.514,15.318-82.869,16.518\n	c-8.362,0.292-16.619,0.325-24.403,0.096c-20.716-0.611-38.081-3.079-45.155-7.464c-6.896-4.274-74.477-119.24-74.477-141.415\n	c0-89.195,64.542-161.502,144.159-161.502C2569.341-207.82,2633.883-135.514,2633.883-46.319z"/>\n<g id="g3015_2_" transform="matrix(1,0,0,-1,379.66102,1293.0169)">\n	<path id="path3017_2_" inkscape:connector-curvature="0" fill="#5D5D5D" d="M2187.466,1380.332c0-2.96-1.082-5.521-3.244-7.684\n		c-2.163-2.163-4.724-3.244-7.684-3.244c-2.96,0-5.521,1.081-7.684,3.244s-3.244,4.724-3.244,7.684\n		c0,10.473-6.147,18.556-18.442,24.248c-12.295,5.692-24.362,8.538-36.201,8.538c-2.96,0-5.521,1.081-7.684,3.244\n		c-2.163,2.163-3.244,4.724-3.244,7.684s1.082,5.521,3.244,7.684c2.163,2.163,4.724,3.244,7.684,3.244\n		c11.384,0,22.711-1.821,33.981-5.464c11.27-3.643,21.174-9.79,29.712-18.442\n		C2183.197,1402.416,2187.466,1392.171,2187.466,1380.332z M2242.108,1380.332c0,16.393-3.927,31.647-11.782,45.763\n		c-7.855,14.116-18.1,25.671-30.737,34.664s-26.638,16.051-42.007,21.174c-15.368,5.123-30.907,7.684-46.617,7.684\n		c-15.71,0-31.249-2.561-46.617-7.684c-15.368-5.123-29.371-12.181-42.007-21.174c-12.636-8.993-22.882-20.548-30.737-34.664\n		c-7.855-14.116-11.782-29.37-11.782-45.763c0-22.996,7.741-43.487,23.223-61.473c2.277-2.505,5.749-6.261,10.416-11.27\n		c4.667-5.009,8.14-8.766,10.416-11.27c29.143-34.835,45.194-68.759,48.154-101.772h77.866\n		c2.96,33.013,19.011,66.938,48.154,101.772c2.277,2.504,5.749,6.261,10.416,11.27c4.667,5.009,8.14,8.766,10.417,11.27\n		C2234.367,1336.845,2242.108,1357.336,2242.108,1380.332z M2285.823,1380.332c0-35.29-11.726-65.799-35.177-91.527\n		c-10.245-11.156-18.727-21.06-25.443-29.712s-13.49-19.523-20.32-32.615c-6.83-13.092-10.701-25.329-11.612-36.713\n		c10.701-6.375,16.052-15.71,16.052-28.005c0-8.424-2.846-15.71-8.538-21.857c5.692-6.147,8.538-13.433,8.538-21.857\n		c0-11.839-5.123-21.06-15.368-27.663c2.96-5.237,4.44-10.587,4.44-16.051c0-10.473-3.586-18.556-10.758-24.248\n		c-7.172-5.692-15.994-8.538-26.468-8.538c-4.554-10.018-11.384-17.987-20.491-23.906c-9.107-5.92-19.011-8.879-29.712-8.879\n		c-10.701,0-20.605,2.96-29.712,8.879c-9.107,5.92-15.938,13.888-20.491,23.906c-10.473,0-19.296,2.846-26.468,8.538\n		c-7.172,5.692-10.758,13.775-10.758,24.248c0,5.464,1.48,10.815,4.44,16.051c-10.246,6.603-15.368,15.824-15.368,27.663\n		c0,8.424,2.846,15.71,8.538,21.857c-5.692,6.147-8.538,13.433-8.538,21.857c0,12.295,5.35,21.63,16.051,28.005\n		c-0.911,11.384-4.781,23.622-11.612,36.713s-13.604,23.963-20.32,32.615s-15.198,18.556-25.443,29.712\n		c-23.451,25.728-35.176,56.237-35.176,91.527c0,22.54,5.066,43.543,15.198,63.01s23.451,35.632,39.958,48.495\n		c16.507,12.864,35.176,22.996,56.009,30.395c20.833,7.4,42.063,11.099,63.693,11.099c21.629,0,42.86-3.7,63.693-11.099\n		c20.833-7.4,39.502-17.531,56.009-30.395c16.507-12.864,29.826-29.029,39.958-48.495\n		C2280.757,1423.875,2285.823,1402.872,2285.823,1380.332z"/>\n</g>\n</svg>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/lightbulb.svg.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<svg version="1.1"\n	 id="svg3013" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:svg="http://www.w3.org/2000/svg" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" sodipodi:docname="light_bulb_font_awesome.svg" inkscape:version="0.48.3.1 r9886"\n	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px"\n	 viewBox="0 0 612 792" enable-background="new 0 0 612 792" xml:space="preserve">\n<g id="bulb">\n  <path fill="#EFB834" d="M453.775,353.156c0,24.012-57.189,128.942-61.414,132.265c-12.384,9.741-48.514,15.318-82.869,16.518\n    c-8.362,0.292-16.619,0.325-24.403,0.096c-20.716-0.611-38.081-3.079-45.155-7.464c-6.896-4.274-74.477-119.24-74.477-141.415\n    c0-89.195,64.542-161.502,144.159-161.502S453.775,263.961,453.775,353.156z"/>\n  <g id="g3015" transform="matrix(1,0,0,-1,379.66102,1293.0169)">\n    <path id="path3017" inkscape:connector-curvature="0" fill="#5D5D5D" d="M7.357,980.857c0-2.96-1.081-5.521-3.244-7.684\n      s-4.724-3.244-7.684-3.244s-5.521,1.081-7.684,3.244s-3.244,4.724-3.244,7.684c0,10.473-6.147,18.556-18.442,24.248\n      c-12.295,5.692-24.362,8.538-36.201,8.538c-2.96,0-5.521,1.081-7.684,3.244s-3.244,4.724-3.244,7.684\n      c0,2.96,1.081,5.521,3.244,7.684s4.724,3.244,7.684,3.244c11.384,0,22.711-1.821,33.981-5.464s21.174-9.79,29.712-18.442\n      S7.357,992.696,7.357,980.857z M62,980.857c0,16.393-3.927,31.647-11.782,45.763s-18.1,25.671-30.737,34.664\n      s-26.638,16.051-42.007,21.174s-30.907,7.684-46.617,7.684s-31.249-2.561-46.617-7.684s-29.371-12.181-42.007-21.174\n      c-12.636-8.993-22.882-20.548-30.737-34.664c-7.855-14.116-11.782-29.371-11.782-45.763c0-22.996,7.741-43.487,23.223-61.473\n      c2.277-2.504,5.749-6.261,10.416-11.27c4.667-5.009,8.14-8.766,10.416-11.27c29.143-34.835,45.194-68.759,48.154-101.772h77.866\n      c2.96,33.013,19.011,66.938,48.154,101.772c2.277,2.504,5.749,6.261,10.416,11.27s8.14,8.766,10.416,11.27\n      C54.259,937.37,62,957.862,62,980.857z M105.714,980.857c0-35.29-11.725-65.799-35.176-91.527\n      c-10.246-11.156-18.727-21.06-25.443-29.712s-13.49-19.523-20.32-32.615c-6.83-13.092-10.701-25.329-11.612-36.713\n      c10.701-6.375,16.051-15.71,16.051-28.004c0-8.424-2.846-15.71-8.538-21.857c5.692-6.147,8.538-13.433,8.538-21.857\n      c0-11.839-5.123-21.06-15.368-27.663c2.96-5.237,4.44-10.587,4.44-16.051c0-10.473-3.586-18.556-10.758-24.248\n      s-15.994-8.538-26.468-8.538c-4.554-10.018-11.384-17.987-20.491-23.906c-9.107-5.92-19.011-8.879-29.712-8.879\n      c-10.701,0-20.605,2.96-29.712,8.879c-9.107,5.92-15.938,13.888-20.491,23.906c-10.473,0-19.296,2.846-26.468,8.538\n      s-10.758,13.775-10.758,24.248c0,5.464,1.48,10.815,4.44,16.051c-10.246,6.603-15.368,15.824-15.368,27.663\n      c0,8.424,2.846,15.71,8.538,21.857c-5.692,6.147-8.538,13.433-8.538,21.857c0,12.295,5.35,21.629,16.051,28.004\n      c-0.911,11.384-4.781,23.622-11.612,36.713c-6.83,13.091-13.604,23.963-20.32,32.615s-15.198,18.556-25.443,29.712\n      C-232.275,915.058-244,945.567-244,980.857c0,22.54,5.066,43.544,15.198,63.01c10.132,19.467,23.451,35.632,39.958,48.496\n      c16.507,12.864,35.176,22.995,56.009,30.395s42.064,11.099,63.693,11.099s42.86-3.7,63.693-11.099s39.502-17.531,56.009-30.395\n      c16.507-12.864,29.826-29.029,39.958-48.496C100.648,1024.401,105.714,1003.397,105.714,980.857z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="473.582" y1="208.1" x2="560.578" y2="159.16"/>\n    <path fill="#EFB834" d="M473.141,207.315c0,0,1.225-1.003,3.396-2.711c1.08-0.864,2.402-1.894,3.925-3.063\n      c1.525-1.167,3.227-2.514,5.117-3.927c1.887-1.418,3.931-2.954,6.092-4.578c2.158-1.632,4.462-3.3,6.831-5.055\n      c2.386-1.723,4.843-3.519,7.372-5.285c2.515-1.791,5.104-3.552,7.677-5.341c2.578-1.778,5.065-3.721,7.503-5.648\n      c1.228-0.948,2.436-1.907,3.665-2.792c1.231-0.881,2.478-1.695,3.736-2.442c2.527-1.472,5.12-2.629,7.656-3.587\n      c2.529-0.971,4.998-1.751,7.331-2.377c4.655-1.268,8.797-1.858,11.81-2.069c1.504-0.109,2.718-0.138,3.572-0.111\n      c0.843,0.007,1.313,0.047,1.313,0.047l0.883,1.569c0,0-0.21,0.422-0.641,1.146c-0.42,0.744-1.075,1.766-1.95,2.995\n      c-1.745,2.465-4.4,5.698-7.9,9.019c-1.746,1.669-3.694,3.374-5.838,5.031c-2.136,1.671-4.471,3.285-7.041,4.681\n      c-1.291,0.687-2.635,1.331-4.027,1.925c-1.394,0.591-2.841,1.126-4.289,1.683c-2.914,1.083-5.865,2.2-8.723,3.48\n      c-2.865,1.27-5.713,2.568-8.55,3.788c-2.823,1.245-5.633,2.412-8.345,3.556c-2.729,1.113-5.352,2.217-7.867,3.213\n      c-2.511,1.004-4.885,1.953-7.076,2.83c-2.189,0.881-4.224,1.637-6.013,2.334c-1.79,0.695-3.357,1.29-4.656,1.764\n      c-2.587,0.968-4.08,1.494-4.08,1.494L473.141,207.315z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="492.348" y1="410.008" x2="589.509" y2="432.883"/>\n    <path fill="#EFB834" d="M492.555,409.132c0,0,1.581,0.091,4.335,0.303c1.38,0.095,3.05,0.232,4.962,0.403\n      c1.912,0.173,4.077,0.334,6.424,0.574c2.348,0.234,4.892,0.487,7.583,0.755c2.693,0.259,5.519,0.592,8.45,0.904\n      c2.923,0.347,5.947,0.688,9.004,1.101c3.064,0.384,6.161,0.841,9.266,1.266c3.102,0.437,6.247,0.691,9.346,0.922\n      c1.546,0.133,3.084,0.246,4.588,0.426c1.502,0.185,2.972,0.43,4.403,0.732c2.857,0.628,5.548,1.531,8.064,2.543\n      c2.519,0.998,4.864,2.095,7.004,3.213c4.285,2.219,7.732,4.588,10.093,6.472c1.181,0.938,2.094,1.738,2.704,2.337\n      c0.615,0.576,0.934,0.923,0.934,0.923l-0.412,1.752c0,0-0.44,0.169-1.248,0.41c-0.813,0.263-1.987,0.572-3.463,0.885\n      c-2.953,0.633-7.096,1.216-11.92,1.29c-2.414,0.046-5.003-0.018-7.702-0.249c-2.703-0.216-5.515-0.609-8.351-1.322\n      c-1.415-0.368-2.84-0.804-4.267-1.309c-1.426-0.509-2.853-1.095-4.296-1.665c-2.878-1.176-5.805-2.351-8.776-3.344\n      c-2.968-1.004-5.944-1.977-8.857-3c-2.92-0.995-5.779-2.038-8.549-3.032c-2.762-1.029-5.44-1.992-7.965-2.961\n      c-2.528-0.961-4.918-1.869-7.124-2.708c-2.207-0.833-4.217-1.655-6.005-2.353c-1.788-0.7-3.344-1.323-4.621-1.854\n      c-2.559-1.039-4.015-1.663-4.015-1.663L492.555,409.132z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="502.559" y1="301.7" x2="602.37" y2="300.685"/>\n    <path fill="#EFB834" d="M502.55,300.8c0,0,1.557-0.289,4.282-0.742c1.362-0.237,3.017-0.504,4.915-0.795\n      c1.898-0.289,4.039-0.65,6.375-0.979c2.336-0.334,4.867-0.697,7.544-1.08c2.677-0.392,5.5-0.744,8.421-1.142\n      c2.921-0.362,5.939-0.753,9.006-1.084c3.067-0.359,6.183-0.656,9.3-0.985c3.116-0.317,6.23-0.823,9.296-1.339\n      c1.533-0.24,3.053-0.499,4.556-0.683c1.503-0.18,2.989-0.293,4.45-0.342c2.924-0.073,5.753,0.16,8.438,0.542\n      c2.685,0.366,5.224,0.871,7.57,1.446c4.691,1.13,8.605,2.607,11.347,3.872c1.371,0.629,2.449,1.187,3.185,1.622\n      c0.735,0.412,1.128,0.673,1.128,0.673l0.018,1.8c0,0-0.387,0.269-1.114,0.696c-0.727,0.45-1.793,1.031-3.151,1.687\n      c-2.716,1.321-6.6,2.877-11.266,4.102c-2.333,0.622-4.862,1.179-7.539,1.599c-2.676,0.436-5.5,0.727-8.425,0.713\n      c-1.462-0.019-2.95-0.102-4.456-0.251c-1.506-0.153-3.032-0.381-4.569-0.59c-3.075-0.454-6.199-0.895-9.321-1.149\n      c-3.122-0.266-6.244-0.499-9.318-0.796c-3.073-0.268-6.099-0.598-9.026-0.9c-2.928-0.338-5.758-0.634-8.442-0.971\n      c-2.684-0.329-5.222-0.639-7.564-0.926c-2.342-0.281-4.49-0.599-6.394-0.849c-1.903-0.253-3.563-0.486-4.93-0.695\n      c-2.734-0.397-4.296-0.655-4.296-0.655L502.55,300.8z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="135.661" y1="212.764" x2="48.665" y2="163.824"/>\n    <path fill="#EFB834" d="M135.22,213.548c0,0-1.493-0.526-4.08-1.494c-1.299-0.474-2.866-1.069-4.656-1.764\n      c-1.789-0.697-3.824-1.453-6.013-2.334c-2.191-0.876-4.565-1.826-7.076-2.83c-2.515-0.996-5.138-2.1-7.867-3.213\n      c-2.712-1.144-5.522-2.312-8.345-3.556c-2.837-1.22-5.686-2.518-8.55-3.788c-2.859-1.28-5.81-2.397-8.723-3.48\n      c-1.448-0.557-2.895-1.092-4.289-1.683c-1.392-0.594-2.736-1.238-4.027-1.925c-2.57-1.396-4.905-3.01-7.041-4.681\n      c-2.143-1.657-4.092-3.363-5.838-5.031c-3.5-3.32-6.155-6.554-7.9-9.019c-0.874-1.229-1.53-2.251-1.95-2.995\n      c-0.431-0.724-0.641-1.146-0.641-1.146l0.883-1.569c0,0,0.47-0.04,1.313-0.047c0.854-0.027,2.068,0.002,3.572,0.111\n      c3.013,0.211,7.155,0.801,11.81,2.069c2.332,0.625,4.801,1.406,7.331,2.377c2.537,0.958,5.129,2.115,7.656,3.587\n      c1.258,0.746,2.505,1.561,3.736,2.442c1.229,0.885,2.437,1.844,3.665,2.792c2.438,1.928,4.925,3.87,7.503,5.648\n      c2.573,1.789,5.161,3.549,7.677,5.341c2.529,1.766,4.986,3.562,7.372,5.285c2.368,1.755,4.673,3.423,6.831,5.055\n      c2.162,1.625,4.206,3.16,6.092,4.578c1.889,1.413,3.592,2.76,5.117,3.927c1.523,1.169,2.845,2.199,3.925,3.063\n      c2.17,1.708,3.396,2.711,3.396,2.711L135.22,213.548z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="120.895" y1="411.672" x2="23.734" y2="434.547"/>\n    <path fill="#EFB834" d="M121.101,412.548c0,0-1.456,0.623-4.015,1.663c-1.277,0.53-2.833,1.153-4.621,1.854\n      c-1.788,0.698-3.798,1.52-6.005,2.353c-2.206,0.838-4.596,1.747-7.124,2.708c-2.526,0.969-5.203,1.932-7.965,2.961\n      c-2.77,0.993-5.629,2.037-8.549,3.032c-2.914,1.023-5.889,1.996-8.857,3c-2.971,0.993-5.899,2.169-8.776,3.344\n      c-1.443,0.57-2.87,1.156-4.296,1.665c-1.427,0.505-2.852,0.941-4.267,1.309c-2.836,0.713-5.648,1.105-8.351,1.321\n      c-2.699,0.231-5.288,0.295-7.702,0.249c-4.824-0.074-8.967-0.657-11.92-1.29c-1.476-0.313-2.65-0.621-3.463-0.885\n      c-0.808-0.241-1.248-0.41-1.248-0.41l-0.413-1.752c0,0,0.319-0.347,0.934-0.923c0.61-0.598,1.523-1.399,2.704-2.337\n      c2.36-1.884,5.808-4.254,10.093-6.472c2.14-1.119,4.485-2.216,7.004-3.213c2.516-1.012,5.207-1.915,8.064-2.543\n      c1.431-0.302,2.9-0.547,4.403-0.732c1.503-0.181,3.042-0.293,4.588-0.426c3.1-0.232,6.245-0.486,9.346-0.922\n      c3.104-0.425,6.201-0.882,9.265-1.266c3.057-0.412,6.081-0.754,9.004-1.101c2.931-0.312,5.757-0.644,8.45-0.904\n      c2.691-0.268,5.235-0.521,7.583-0.755c2.347-0.239,4.512-0.4,6.424-0.574c1.913-0.171,3.583-0.308,4.962-0.403\n      c2.754-0.212,4.335-0.303,4.335-0.303L121.101,412.548z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="112.684" y1="306.364" x2="12.873" y2="305.349"/>\n    <path fill="#EFB834" d="M112.675,307.264c0,0-1.562,0.257-4.296,0.655c-1.367,0.21-3.026,0.443-4.93,0.695\n      c-1.904,0.25-4.051,0.568-6.394,0.849c-2.343,0.287-4.88,0.598-7.564,0.926c-2.684,0.337-5.514,0.633-8.442,0.971\n      c-2.928,0.302-5.953,0.632-9.026,0.9c-3.074,0.297-6.195,0.53-9.318,0.796c-3.122,0.254-6.246,0.696-9.321,1.149\n      c-1.537,0.209-3.063,0.437-4.569,0.59c-1.506,0.149-2.994,0.232-4.456,0.251c-2.925,0.014-5.749-0.277-8.425-0.713\n      c-2.676-0.421-5.205-0.977-7.539-1.599c-4.667-1.225-8.55-2.781-11.266-4.102c-1.358-0.656-2.424-1.237-3.151-1.687\n      c-0.727-0.427-1.114-0.696-1.114-0.696l0.018-1.8c0,0,0.393-0.261,1.128-0.673c0.736-0.435,1.814-0.994,3.185-1.622\n      c2.742-1.265,6.657-2.742,11.347-3.872c2.345-0.575,4.885-1.079,7.57-1.446c2.685-0.382,5.514-0.615,8.438-0.542\n      c1.462,0.049,2.947,0.162,4.45,0.342c1.503,0.184,3.024,0.443,4.556,0.683c3.065,0.516,6.18,1.021,9.296,1.339\n      c3.116,0.329,6.232,0.626,9.299,0.985c3.067,0.33,6.085,0.722,9.006,1.084c2.92,0.398,5.744,0.75,8.421,1.142\n      c2.677,0.383,5.208,0.745,7.544,1.08c2.336,0.329,4.477,0.69,6.375,0.979c1.898,0.291,3.552,0.558,4.915,0.795\n      c2.725,0.453,4.282,0.742,4.282,0.742L112.675,307.264z"/>\n  </g>\n</g>\n<g id="count">\n  <text x="400" y="700" id="hintCount"></text>\n</g>\n</svg>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/HintsDisplay.jsx":[function(require,module,exports){
'use strict';

var msg = require('../locale');
var Hint = require('./Hint.jsx');

/**
 * @overview React Component for displaying Authored Hints in the
 * Instructions dialog. Any hints the user has already requested to see
 * are listed, along with a button to see the next hint.
 * Pressing the button adds the next hint (or the first hint if none
 * have previously been viewed) to the list of hints and removes the
 * button.
 * Closing the instructions and re-opening them will reset this
 * Component, allowing the button to be pressed once more.
 */
var HintsDisplay = React.createClass({
  displayName: 'HintsDisplay',

  propTypes: {
    hintReviewTitle: React.PropTypes.string.isRequired,
    seenHints: React.PropTypes.arrayOf(React.PropTypes.object).isRequired,
    unseenHints: React.PropTypes.arrayOf(React.PropTypes.object).isRequired,
    onUserViewedHint: React.PropTypes.func.isRequired,
    lightbulbSVG: React.PropTypes.node.isRequired
  },

  getInitialState: function getInitialState() {
    return {
      showNextUnseenHint: false
    };
  },

  viewHint: function viewHint() {
    this.props.onUserViewedHint();
    this.setState({
      showNextUnseenHint: true
    });
  },

  /**
   * Many of our hints include Blockly blocks. Unfortunately, Blockly
   * BlockSpaces have a real problem with being created before they are
   * in the DOM, so we need to inject this BlockSpace outside of our
   * React render method once we're confident that this component is in
   * the DOM.
   */
  injectBlocklyHint: function injectBlocklyHint(hint) {
    var ref = this.refs[hint.hintId];
    ref.injectBlocklyHint();
  },

  componentDidMount: function componentDidMount() {
    // now that we're in the DOM, we can render our Blockly blocks for
    // those hints that have them
    this.props.seenHints.filter(function (hint) {
      return hint.block;
    }).forEach(this.injectBlocklyHint);
  },

  componentDidUpdate: function componentDidUpdate() {
    // if our update has us showing a new hint, make sure to render the
    // block if it has one
    if (this.state.showNextUnseenHint && this.props.unseenHints[0].block) {
      this.injectBlocklyHint(this.props.unseenHints[0]);
    }
  },

  render: function render() {
    var hintsToShow = this.props.seenHints;
    if (this.state.showNextUnseenHint) {
      hintsToShow = hintsToShow.concat(this.props.unseenHints[0]);
    }

    var seenHints;
    if (hintsToShow && hintsToShow.length) {
      seenHints = [React.createElement(
        'h1',
        { key: 'hint-review-title' },
        this.props.hintReviewTitle
      ), React.createElement(
        'ul',
        { key: 'hints-to-show' },
        hintsToShow.map(function (hint) {
          return React.createElement(Hint, { hint: hint, key: hint.hintId, ref: hint.hintId });
        })
      )];
    }

    var viewHintButton;
    if (!this.state.showNextUnseenHint && this.props.unseenHints && this.props.unseenHints.length) {
      viewHintButton = React.createElement(
        'button',
        { id: 'hint-button', onClick: this.viewHint, className: 'lightbulb-button' },
        React.createElement('span', { dangerouslySetInnerHTML: { __html: this.props.lightbulbSVG } }),
        msg.hintSelectNewHint()
      );
    }

    return React.createElement(
      'div',
      { className: 'authored-hints' },
      seenHints,
      viewHintButton
    );
  }
});
module.exports = HintsDisplay;

},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js","./Hint.jsx":"/home/ubuntu/staging/apps/build/js/templates/Hint.jsx"}],"/home/ubuntu/staging/apps/build/js/templates/Hint.jsx":[function(require,module,exports){
"use strict";

module.exports = React.createClass({
  displayName: "exports",

  propTypes: {
    hint: React.PropTypes.object.isRequired
  },

  /**
   * @see HintsDisplay.injectBlocklyHint
   */
  injectBlocklyHint: function injectBlocklyHint() {
    var node = this.refs.hintBlock;
    // Only render if the node exists in the DOM
    if (node && document.body.contains(node)) {
      Blockly.BlockSpace.createReadOnlyBlockSpace(node, this.props.hint.block);
    }
  },

  render: function render() {
    var hintBlock;
    if (this.props.hint.block) {
      hintBlock = React.createElement("div", { className: "block-hint", ref: "hintBlock", id: this.props.hint.hintId, style: { maxHeight: '100px' } });
    }
    return React.createElement(
      "li",
      { style: { marginBottom: '12px' } },
      React.createElement("div", { dangerouslySetInnerHTML: { __html: this.props.hint.content } }),
      hintBlock
    );
  }
});

},{}],"/home/ubuntu/staging/apps/build/js/templates/HintSelect.jsx":[function(require,module,exports){
'use strict';

var msg = require('../locale');

var HintSelect = React.createClass({
  displayName: 'HintSelect',

  propTypes: {
    showInstructions: React.PropTypes.func.isRequired,
    showHint: React.PropTypes.func.isRequired
  },
  render: function render() {
    return React.createElement(
      'div',
      null,
      React.createElement(
        'h4',
        null,
        msg.hintPrompt()
      ),
      React.createElement(
        'a',
        { className: 'btn btn-link show-instructions', onClick: this.props.showInstructions },
        msg.hintSelectInstructions()
      ),
      React.createElement(
        'a',
        { className: 'btn btn-link show-hint', onClick: this.props.showHint },
        msg.hintSelectNewHint()
      )
    );
  }
});
module.exports = HintSelect;

},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js"}],"/home/ubuntu/staging/apps/build/js/authoredHintUtils.js":[function(require,module,exports){
/* global marked */
'use strict';

var parseXmlElement = require('./xml').parseElement;
var msg = require('./locale');

/**
 * @overview A helper class for all actions associated with the Authored
 * Hint viewing and logging system.
 *
 * The general pattern for usage is straightforward:
 *
 * Every time a user requests to view a new hint, we log information
 * about that hint as well as the most recent attempt.
 *
 * Every time a user makes an "attempt" at the level and send an attempt
 * report, we save some information about that most recent attempt, and
 * add that information to all hint views from the previous attempt.
 *
 * Finally, when the user navigates to a new page (either by completing
 * the level and moving on or by leaving the level and coming back
 * later), we record for all hints the "final" attempt in that session
 * and post the results to the server.
 *
 * Thus, each hint has three attempt records by the end of the
 * lifecycle:
 *  1) a "previous" attempt (can be empty)
 *  2) a "next" attempt
 *  3) a "final" attempt
 */

/**
 * @typedef {Object} HintData
 * @property {number} scriptId
 * @property {number} levelId
 * @property {string} hintId
 * @property {string} hintClass
 * @property {string} hintType
 *
 * @typedef {Object} UnfinishedHint
 * @augments HintData
 * @property {number} [prevTime]
 * @property {number} [prevAttempt]
 * @property {number} [prevTestResult]
 * @property {number} [prevActivityId]
 * @property {number} [prevLevelSourceId]
 *
 * @typedef {Object} FinishedHint
 * @augments UnfinishedHint
 * @property {number} nextTime
 * @property {number} nextAttempt
 * @property {number} nextTestResult
 * @property {number} nextActivityId
 * @property {number} nextLevelSourceId
 *
 * @typedef {Object} FinalizedHint
 * @augments FinishedHint
 * @property {number} finalTime
 * @property {number} finalAttempt
 * @property {number} finalTestResult
 * @property {number} finalActivityId
 * @property {number} finalLevelSourceId
 *
 * @typedef {Object} AttemptRecord
 * @property {number} time
 * @property {number} attempt
 * @property {number} testResult
 * @property {number} activityId
 * @property {number} levelSourceId
 */

var authoredHintUtils = {};

module.exports = authoredHintUtils;

authoredHintUtils.getFromLocalStorage_ = function (key, defaultValue) {
  var result = localStorage.getItem(key);
  try {
    result = result ? JSON.parse(result) : defaultValue;
  } catch (e) {
    result = defaultValue;
  }
  return result;
};

/**
 * @return {UnfinishedHint[]}
 */
authoredHintUtils.getUnfinishedHints_ = function () {
  return authoredHintUtils.getFromLocalStorage_('unfinished_authored_hint_views', []);
};

/**
 * @return {FinishedHint[]}
 */
authoredHintUtils.getFinishedHints_ = function () {
  return authoredHintUtils.getFromLocalStorage_('finished_authored_hint_views', []);
};

/**
 * @return {AttemptRecord}
 */
authoredHintUtils.getLastAttemptRecord_ = function () {
  return authoredHintUtils.getFromLocalStorage_('last_attempt_record', undefined);
};

/**
 * Appends the given hints to the array of existing FinishedHints
 * @param {FinishedHint[]} hints
 */
authoredHintUtils.recordFinishedHints_ = function (hints) {
  var finishedHintViews = authoredHintUtils.getFinishedHints_();
  finishedHintViews = finishedHintViews.concat(hints);
  localStorage.setItem('finished_authored_hint_views', JSON.stringify(finishedHintViews));
};

authoredHintUtils.clearUnfinishedHints = function () {
  localStorage.setItem('unfinished_authored_hint_views', JSON.stringify([]));
};

authoredHintUtils.clearFinishedHints_ = function () {
  localStorage.setItem('finished_authored_hint_views', JSON.stringify([]));
};

/**
 * @return {FinalizedHints[]}
 */
authoredHintUtils.finalizeHints_ = function () {
  var finalAttemptRecord = authoredHintUtils.getLastAttemptRecord_();
  localStorage.removeItem('last_attempt_record');
  var hints = authoredHintUtils.getFinishedHints_();
  if (finalAttemptRecord) {
    hints = hints.map(function (hint) {
      hint = $.extend({
        finalTime: finalAttemptRecord.time,
        finalAttempt: finalAttemptRecord.attempt,
        finalTestResult: finalAttemptRecord.testResult,
        finalActivityId: finalAttemptRecord.activityId,
        finalLevelSourceId: finalAttemptRecord.levelSourceId
      }, hint);
      return hint;
    });
  }
  return hints;
};

/**
 * Adds a hint to the list of "unfinished" hints for the attempt
 * currently in progress. If this is not the first attempt of the
 * session, save along with the hint a record of the most recent
 * attempt.
 *
 * @param {HintData} hint
 */
authoredHintUtils.recordUnfinishedHint = function (hint) {
  var lastAttemptRecord = authoredHintUtils.getLastAttemptRecord_();
  if (lastAttemptRecord) {
    hint = $.extend({
      prevTime: lastAttemptRecord.time,
      prevAttempt: lastAttemptRecord.attempt,
      prevTestResult: lastAttemptRecord.testResult,
      prevActivityId: lastAttemptRecord.activityId,
      prevLevelSourceId: lastAttemptRecord.levelSourceId
    }, hint);
  }
  var unfinishedHintViews = authoredHintUtils.getUnfinishedHints_();
  unfinishedHintViews.push(hint);
  localStorage.setItem('unfinished_authored_hint_views', JSON.stringify(unfinishedHintViews));
};

/**
 * @param {AttemptRecord} nextAttemptRecord
 */
authoredHintUtils.finishHints = function (nextAttemptRecord) {
  if (!nextAttemptRecord) {
    return;
  }
  localStorage.setItem('last_attempt_record', JSON.stringify(nextAttemptRecord));
  var unfinishedHintViews = authoredHintUtils.getUnfinishedHints_();
  authoredHintUtils.clearUnfinishedHints();
  var finishedHintViews = unfinishedHintViews.map(function (hint) {
    hint = $.extend({
      nextTime: nextAttemptRecord.time,
      nextAttempt: nextAttemptRecord.attempt,
      nextTestResult: nextAttemptRecord.testResult,
      nextActivityId: nextAttemptRecord.activityId,
      nextLevelSourceId: nextAttemptRecord.levelSourceId
    }, hint);
    return hint;
  });
  authoredHintUtils.recordFinishedHints_(finishedHintViews);
};

/**
 * @param {string} url
 */
authoredHintUtils.submitHints = function (url) {
  // first, finish all unfinished hints
  var unfinishedHints = authoredHintUtils.getUnfinishedHints_();
  if (unfinishedHints && unfinishedHints.length) {
    var finalHint = unfinishedHints[unfinishedHints.length - 1];
    authoredHintUtils.finishHints({
      time: finalHint.prevTime,
      attempt: finalHint.prevAttempt,
      testResult: finalHint.prevTestResult,
      activityId: finalHint.prevActivityId,
      levelSourceId: finalHint.prevLevelSourceId
    });
  }

  // then, finalize all hints
  var hints = authoredHintUtils.finalizeHints_();

  // now, all hints should be finished and finalized. So submit them all
  if (hints && hints.length) {
    $.ajax({
      url: url,
      method: 'POST',
      contentType: 'application/json',
      data: JSON.stringify({ hints: hints }),
      complete: function complete() {
        authoredHintUtils.clearFinishedHints_();
      }
    });
  }
};

/**
 * Generates contextual hints as used by StudioApp from Blockly XML
 * @param {Object[]} blocks An array of objects representing the
 *        missing recommended Blockly Blocks for which we want to
 *        create hints.
 * @param {string} blocks[].blockDisplayXML
 * @param {boolean} blocks[].alreadySeen
 * @return {AuthoredHint[]}
 */
authoredHintUtils.createContextualHintsFromBlocks = function (blocks) {
  var hints = blocks.map(function (block) {
    var xmlBlock = parseXmlElement(block.blockDisplayXML);
    var blockType = xmlBlock.firstChild.getAttribute("type");
    return {
      content: marked(msg.recommendedBlockContextualHintTitle()),
      block: xmlBlock,
      hintId: "recommended_block_" + blockType,
      hintClass: 'recommended',
      hintType: 'contextual',
      alreadySeen: block.alreadySeen
    };
  });
  return hints;
};

/**
 * Generates authored hints as used by StudioApp from levelbuilder JSON.
 * @param {string} - JSON representing an array of hints
 * @return {AuthoredHint[]}
 */
authoredHintUtils.generateAuthoredHints = function (levelBuilderAuthoredHints) {
  if (!marked) {
    return [];
  }
  var hints;
  try {
    hints = JSON.parse(levelBuilderAuthoredHints);
  } catch (e) {
    hints = [];
  }
  return hints.map(function (hint) {
    return {
      content: marked(hint.hint_markdown),
      hintId: hint.hint_id,
      hintClass: hint.hint_class,
      hintType: hint.hint_type,
      alreadySeen: false
    };
  });
};

},{"./locale":"/home/ubuntu/staging/apps/build/js/locale.js","./xml":"/home/ubuntu/staging/apps/build/js/xml.js"}],"/home/ubuntu/staging/apps/build/js/xml.js":[function(require,module,exports){
// Serializes an XML DOM node to a string.
'use strict';

exports.serialize = function (node) {
  var serializer = new XMLSerializer();
  return serializer.serializeToString(node);
};

// Parses a single root element string, wrapping it in an <xml/> element
exports.parseElement = function (text) {
  var parser = new DOMParser();
  text = text.trim();
  var dom = text.indexOf('<xml') === 0 ? parser.parseFromString(text, 'text/xml') : parser.parseFromString('<xml>' + text + '</xml>', 'text/xml');
  var errors = dom.getElementsByTagName("parsererror");
  var element = dom.firstChild;
  if (!element) {
    throw new Error('Nothing parsed');
  }
  if (errors.length > 0) {
    throw new Error(exports.serialize(errors[0]));
  }
  if (element !== dom.lastChild) {
    throw new Error('Parsed multiple elements');
  }
  return element;
};

},{}],"/home/ubuntu/staging/apps/build/js/assetManagement/assetPrefix.js":[function(require,module,exports){
// For proxying non-https assets
'use strict';

var MEDIA_PROXY = '//' + location.host + '/media?u=';

// starts with http or https
var ABSOLUTE_REGEXP = new RegExp('^https?://', 'i');

var assetPathPrefix = "/v3/assets/";
var channelId;

module.exports.init = function (config) {
  if (config.assetPathPrefix) {
    assetPathPrefix = config.assetPathPrefix;
  }
  if (config.channel) {
    channelId = config.channel;
  }
};

/**
 * If the filename is relative (contains no slashes), then prepend
 * the path to the assets directory for this project to the filename.
 *
 * If the filename URL is absolute, route it through the MEDIA_PROXY.
 * @param {string} filename
 * @returns {string}
 */
module.exports.fixPath = function (filename) {

  if (ABSOLUTE_REGEXP.test(filename)) {
    // We want to be able to handle the case where our filename contains a
    // space, i.e. "www.example.com/images/foo bar.png", even though this is a
    // technically invalid URL. encodeURIComponent will replace space with %20
    // for us, but as soon as it's decoded, we again have an invalid URL. For
    // this reason we first replace space with %20 ourselves, such that we now
    // have a valid URL, and then call encodeURIComponent on the result.
    return MEDIA_PROXY + encodeURIComponent(filename.replace(/ /g, '%20'));
  }

  filename = filename || '';
  if (filename.length === 0) {
    return '/blockly/media/1x1.gif';
  }

  if (filename.indexOf('/') !== -1 || !channelId) {
    return filename;
  }

  return assetPathPrefix + channelId + '/' + filename;
};

},{}],"/home/ubuntu/staging/apps/build/js/assetManagement/assetListStore.js":[function(require,module,exports){
"use strict";

var assets = [];

module.exports = {
  reset: function reset(list) {
    assets = list.slice();
  },

  add: function add(asset) {
    assets.push(asset);
    return assets.slice();
  },

  remove: function remove(filename) {
    assets = assets.filter(function (asset) {
      return asset.filename !== filename;
    });
    return assets.slice();
  },

  list: function list(typeFilter) {
    return typeFilter ? assets.filter(function (asset) {
      return asset.category === typeFilter;
    }) : assets.slice();
  }
};

},{}],"/home/ubuntu/staging/apps/build/js/acemode/mode-javascript_codeorg.js":[function(require,module,exports){
/* global ace */
'use strict';

var dropletUtils = require('../dropletUtils');
var annotationList = require('./annotationList');

exports.defineForAce = function (dropletConfig, unusedConfig, dropletEditor) {
  // define ourselves for ace, so that it knows where to get us
  ace.define("ace/mode/javascript_codeorg", ["require", "exports", "module", "ace/lib/oop", "ace/mode/javascript", "ace/mode/javascript_highlight_rules", "ace/worker/worker_client", "ace/mode/matching_brace_outdent", "ace/mode/behaviour/cstyle", "ace/mode/folding/cstyle", "ace/config", "ace/lib/net", "ace/ext/searchbox"], function (acerequire, exports, module) {

    var oop = acerequire("ace/lib/oop");
    var JavaScriptMode = acerequire("ace/mode/javascript").Mode;
    var JavaScriptHighlightRules = acerequire("ace/mode/javascript_highlight_rules").JavaScriptHighlightRules;
    var WorkerModule = acerequire("ace/worker/worker_client");
    var WorkerClient = WorkerModule.WorkerClient;
    if (!window.Worker) {
      // If we don't support web workers, do everything on the UI thread
      WorkerClient = WorkerModule.UIWorkerClient;
      window.Worker = WorkerClient;
    }

    var MatchingBraceOutdent = acerequire("./matching_brace_outdent").MatchingBraceOutdent;
    var CstyleBehaviour = acerequire("./behaviour/cstyle").CstyleBehaviour;
    var CStyleFoldMode = acerequire("./folding/cstyle").FoldMode;

    var Mode = function Mode() {
      this.HighlightRules = JavaScriptHighlightRules;
      this.$outdent = new MatchingBraceOutdent();
      this.$behaviour = new CstyleBehaviour();
      this.foldingRules = new CStyleFoldMode();
    };
    oop.inherits(Mode, JavaScriptMode);

    (function () {
      // Manually create our highlight rules so that we can modify it
      this.$highlightRules = new JavaScriptHighlightRules();

      // We never want to show any of the builtin keywords in autocomplete
      this.$highlightRules.$keywordList = [];

      this.createWorker = function (session) {
        var worker = new WorkerClient(["ace"], "ace/mode/javascript_worker", "JavaScriptWorker");
        worker.attachToDocument(session.getDocument());
        var newOptions = {
          unused: true,
          undef: true,
          maxerr: 1000,
          predef: {},
          exported: {}
        };
        // Mark all of our blocks as predefined so that linter doesnt complain about
        // using undefined variables
        dropletUtils.getAllAvailableDropletBlocks(dropletConfig).forEach(function (block) {
          newOptions.predef[block.func] = false;
        });

        if (dropletConfig.additionalPredefValues) {
          dropletConfig.additionalPredefValues.forEach(function (val) {
            newOptions.predef[val] = false;
          });
        }

        // Do the same with unusedConfig if available
        if (unusedConfig) {
          unusedConfig.forEach(function (unusedVar) {
            newOptions.exported[unusedVar] = false;
          });
        }

        annotationList.attachToSession(session, dropletEditor);

        worker.send("changeOptions", [newOptions]);

        worker.on("jslint", annotationList.setJSLintAnnotations);

        worker.on("terminate", function () {
          session.clearAnnotations();
        });

        return worker;
      };

      this.cleanup = function () {
        annotationList.detachFromSession();
      };
    }).call(Mode.prototype);

    exports.Mode = Mode;
  });
};

},{"../dropletUtils":"/home/ubuntu/staging/apps/build/js/dropletUtils.js","./annotationList":"/home/ubuntu/staging/apps/build/js/acemode/annotationList.js"}],"/home/ubuntu/staging/apps/build/js/acemode/annotationList.js":[function(require,module,exports){
'use strict';

var errorMapper = require('./errorMapper');

var lintAnnotations = [];
var runtimeAnnotations = [];
var aceSession;
var dropletEditor;

/**
 * Update gutter with our annotation list
 * @private
 */
function updateGutter() {
  if (!aceSession) {
    return;
  }

  if (dropletEditor) {
    // Droplet will call aceSession.setAnnotations() under the hood
    // for us
    dropletEditor.setAnnotations(lintAnnotations.concat(runtimeAnnotations));
  } else {
    aceSession.setAnnotations(lintAnnotations.concat(runtimeAnnotations));
  }
}

/**
 * Object for tracking annotations placed in gutter. General design is as
 * follows:
 * When jslint runs (i.e. code changes) display just jslint errors
 * When code runs, display jslint errors and runtime errors. Runtime errors will
 * go away the next time jstlint gets run (when code changes)
 */
module.exports = {
  detachFromSession: function detachFromSession() {
    aceSession = null;
    dropletEditor = null;
  },

  attachToSession: function attachToSession(session, editor) {
    if (aceSession && session !== aceSession) {
      throw new Error('Already attached to ace session');
    }
    aceSession = session;
    dropletEditor = editor;
  },

  setJSLintAnnotations: function setJSLintAnnotations(jslintResults) {
    errorMapper.processResults(jslintResults);
    // clone annotations in case anyone else has a reference to data
    lintAnnotations = jslintResults.data.slice();
    updateGutter();
  },

  /**
   * @param {string} level
   * @param {number} lineNumber One index line number
   * @param {string} text Error string
   */
  addRuntimeAnnotation: function addRuntimeAnnotation(level, lineNumber, text) {
    var annotation = {
      row: lineNumber - 1,
      col: 0,
      raw: text,
      text: text,
      type: level.toLowerCase()
    };
    runtimeAnnotations.push(annotation);
    updateGutter();
  },

  clearRuntimeAnnotations: function clearRuntimeAnnotations() {
    if (runtimeAnnotations.length === 0) {
      return;
    }
    runtimeAnnotations = [];
    updateGutter();
  }
};

},{"./errorMapper":"/home/ubuntu/staging/apps/build/js/acemode/errorMapper.js"}],"/home/ubuntu/staging/apps/build/js/acemode/errorMapper.js":[function(require,module,exports){
"use strict";

var errorMap = [{
  original: /Assignment in conditional expression/,
  replacement: "For conditionals, use the comparison operator (===) to check if two things are equal."
}, {
  original: /(.*)\sis defined but never used./,
  replacement: "$1 is defined, but it's not called in your program."
}, {
  original: /(.*)\sis not defined./,
  replacement: "$1 hasn't been declared yet."
}];

/**
 * Takes the results of a JSLint pass, and modifies the error text according to
 * our mapping. Note this makes changes in place to the passed in results
 * object.
 */
module.exports.processResults = function (results) {
  results.data.forEach(function (item) {
    if (item.type === 'info') {
      item.type = 'warning';
    }

    errorMap.forEach(function (errorMapping) {
      if (!errorMapping.original.test(item.text)) {
        return;
      }

      item.text = item.text.replace(errorMapping.original, errorMapping.replacement);
    });
  });
};

},{}],"/home/ubuntu/staging/apps/build/js/ResizeSensor.js":[function(require,module,exports){
/**
 * Copyright Marc J. Schmidt. See the LICENSE file at the top-level
 * directory of this distribution and at
 * https://github.com/marcj/css-element-queries/blob/master/LICENSE.
 */

/**
 * Class for dimension change detection.
 *
 * @param {Element|Element[]|Elements|jQuery} element
 * @param {Function} callback
 *
 * @constructor
 */
'use strict';

module.exports = function (element, callback) {
    /**
     *
     * @constructor
     */
    function EventQueue() {
        this.q = [];
        this.add = function (ev) {
            this.q.push(ev);
        };

        var i, j;
        this.call = function () {
            for (i = 0, j = this.q.length; i < j; i++) {
                this.q[i].call();
            }
        };
    }

    /**
     * @param {HTMLElement} element
     * @param {String}      prop
     * @returns {String|Number}
     */
    function getComputedStyle(element, prop) {
        if (element.currentStyle) {
            return element.currentStyle[prop];
        } else if (window.getComputedStyle) {
            return window.getComputedStyle(element, null).getPropertyValue(prop);
        } else {
            return element.style[prop];
        }
    }

    /**
     *
     * @param {HTMLElement} element
     * @param {Function}    resized
     */
    function attachResizeEvent(element, resized) {
        if (!element.resizedAttached) {
            element.resizedAttached = new EventQueue();
            element.resizedAttached.add(resized);
        } else if (element.resizedAttached) {
            element.resizedAttached.add(resized);
            return;
        }

        element.resizeSensor = document.createElement('div');
        element.resizeSensor.className = 'resize-sensor';
        var style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: scroll; z-index: -1; visibility: hidden;';
        var styleChild = 'position: absolute; left: 0; top: 0;';

        element.resizeSensor.style.cssText = style;
        element.resizeSensor.innerHTML = '<div class="resize-sensor-expand" style="' + style + '">' + '<div style="' + styleChild + '"></div>' + '</div>' + '<div class="resize-sensor-shrink" style="' + style + '">' + '<div style="' + styleChild + ' width: 200%; height: 200%"></div>' + '</div>';
        element.appendChild(element.resizeSensor);

        if ('absolute' !== getComputedStyle(element, 'position')) {
            element.style.position = 'relative';
        }

        var expand = element.resizeSensor.childNodes[0];
        var expandChild = expand.childNodes[0];
        var shrink = element.resizeSensor.childNodes[1];
        var shrinkChild = shrink.childNodes[0];

        var lastWidth, lastHeight;

        var reset = function reset() {
            expandChild.style.width = expand.offsetWidth + 10 + 'px';
            expandChild.style.height = expand.offsetHeight + 10 + 'px';
            expand.scrollLeft = expand.scrollWidth;
            expand.scrollTop = expand.scrollHeight;
            shrink.scrollLeft = shrink.scrollWidth;
            shrink.scrollTop = shrink.scrollHeight;
            lastWidth = element.offsetWidth;
            lastHeight = element.offsetHeight;
        };

        reset();

        var changed = function changed() {
            element.resizedAttached.call();
        };

        var addEvent = function addEvent(el, name, cb) {
            if (el.attachEvent) {
                el.attachEvent('on' + name, cb);
            } else {
                el.addEventListener(name, cb);
            }
        };

        addEvent(expand, 'scroll', function () {
            if (element.offsetWidth > lastWidth || element.offsetHeight > lastHeight) {
                changed();
            }
            reset();
        });

        addEvent(shrink, 'scroll', function () {
            if (element.offsetWidth < lastWidth || element.offsetHeight < lastHeight) {
                changed();
            }
            reset();
        });
    }

    if (element && element.constructor === Array || 'undefined' !== typeof jQuery && element instanceof jQuery || //jquery
    'undefined' !== typeof Elements && element instanceof Elements //mootools
    ) {
            var i = 0,
                j = element.length;
            for (; i < j; i++) {
                attachResizeEvent(element[i], callback);
            }
        } else {
        attachResizeEvent(element, callback);
    }
};

},{}],"/home/ubuntu/staging/apps/build/js/MusicController.js":[function(require,module,exports){
/** @file The maestro! Helper that knows which music tracks can be played, and
 *        which one is playing now, and selects and plays them appropriately. */
// Strict linting: Absorb into global config when possible
/* jshint
 unused: true,
 eqeqeq: true,
 maxlen: 120
 */
'use strict';

var utils = require('./utils');
var _ = utils.getLodash();

var debugLogging = false;
function debug(msg) {
  if (debugLogging && console && console.info) {
    console.info(new Date().getTime() + ': MusicController: ' + msg);
  }
}

/**
 * @typedef {Object} MusicTrackDefinition
 * External track representation, used to define track info in skins.js.
 *
 * @property {string} name - corresponds to music filenames
 * @property {number} volume - on a 0..1 scale
 * @property {boolean} hasOgg - whether a .ogg version of the file should also
 *           available in addition to the .mp3
 */

/**
 * @typedef {Object} MusicTrack
 * Internal track representation, includes track metadata and references to
 * loaded sound object.
 *
 * @property {string} name
 * @property {string[]} assetUrls
 * @property {number} volume
 * @property {Sound} sound
 * @property {boolean} isLoaded
 */

/**
 * A helper class that handles loading, choosing, playing and stopping
 * background music for certain studio apps (e.g. playlab, craft).
 *
 * @param {AudioPlayer} audioPlayer - Reference to the Sounds object.
 * @param {function} assetUrl - Function for generating paths to static assets
 *        for the current skin.
 * @param {MusicTrackDefinition[]} [trackDefinitions] - List of music assets and
 *        general info about how they should be played. Can be omitted or empty
 *        if no music should be played.
 * @param {Number} [loopRandomWithDelay] - if specified, after a song is
 *        completed, will play a random track after given duration (in ms).
 * @constructor
 */
var MusicController = function MusicController(audioPlayer, assetUrl, trackDefinitions, loopRandomWithDelay) {
  /** @private {AudioPlayer} */
  this.audioPlayer_ = audioPlayer;

  /** @private {function} */
  this.assetUrl_ = assetUrl;

  /** @private {MusicTrack[]} */
  this.trackList_ = buildTrackData(trackDefinitions, assetUrl);

  /** @private {string} */
  this.nowPlaying_ = null;

  /** @private {string} Name of track to play on load */
  this.playOnLoad_ = null;

  /** @private {number} */
  this.loopRandomWithDelay_ = loopRandomWithDelay;

  /**
   * @private {boolean} whether we stopped playing music due to video being
   *          shown
   */
  this.wasPlayingWhenVideoShown_ = false;

  /** @private {number} setTimeout callback identifier for un-binding repeat */
  this.betweenTrackTimeout_ = null;

  // If the video player gets pulled up, make sure we stop the music.
  document.addEventListener('videoShown', (function () {
    debug("video shown");
    if (this.nowPlaying_ || this.betweenTrackTimeout_) {
      this.wasPlayingWhenVideoShown_ = true;

      if (this.betweenTrackTimeout_) {
        window.clearTimeout(this.betweenTrackTimeout_);
        this.betweenTrackTimeout_ = null;
      }
      this.fadeOut();
    }
  }).bind(this));

  // If the video player gets closed, make sure we re-start the music.
  document.addEventListener('videoHidden', (function () {
    if (this.wasPlayingWhenVideoShown_ && this.loopRandomWithDelay_ && !this.nowPlaying_) {
      this.play();
    }
    this.wasPlayingWhenVideoShown_ = false;
  }).bind(this));

  debug('constructed');
};
module.exports = MusicController;

/**
 * Build up initial internal track metadata.
 * @param {MusicTrackDefinition[]} trackDefinitions
 * @param {function} assetUrl
 * @return {MusicTrack[]}
 */
function buildTrackData(trackDefinitions, assetUrl) {
  trackDefinitions = utils.valueOr(trackDefinitions, []);
  return trackDefinitions.map(function (trackDef) {

    var assetUrls = [];
    assetUrls.push(assetUrl(trackDef.name + '.mp3'));
    if (trackDef.hasOgg) {
      assetUrls.push(assetUrl(trackDef.name + '.ogg'));
    }

    return {
      name: trackDef.name,
      assetUrls: assetUrls,
      volume: utils.valueOr(trackDef.volume, 1),
      sound: null,
      isLoaded: false
    };
  });
}

/**
 * Preload all music assets
 */
MusicController.prototype.preload = function () {
  if (!this.audioPlayer_) {
    return;
  }

  this.trackList_.forEach(function (track) {
    track.sound = this.audioPlayer_.registerByFilenamesAndID(track.assetUrls, track.name);
    track.sound.onLoad = (function () {
      debug('done loading ' + track.name);
      track.isLoaded = true;
      if (this.playOnLoad_ === track.name) {
        this.play(track.name);
      }
    }).bind(this);
  }, this);
};

/**
 * Begins playing a particular piece of music immediately.
 * @param {string} trackName
 */
MusicController.prototype.play = function (trackName) {
  debug('play ' + trackName);
  if (!this.audioPlayer_) {
    return;
  }

  var track;
  if (trackName) {
    track = this.getTrackByName_(trackName);
  } else {
    track = this.getRandomTrack_();
  }

  if (!track) {
    // No track to play - throw an exception?
    return;
  }

  if (track.sound && track.isLoaded) {
    debug('playing now');
    var callback = this.whenMusicStopped_.bind(this, track.name);
    track.sound.play({ volume: track.volume, onEnded: callback });
    this.nowPlaying_ = track.name;
  } else {
    debug('not done loading, playing after load');
    this.playOnLoad_ = track.name;
  }
};

/**
 * Stops playing whatever music is currently playing, immediately.
 */
MusicController.prototype.stop = function () {
  if (!this.nowPlaying_) {
    return;
  }

  var sound = this.audioPlayer_.get(this.nowPlaying_);
  if (sound) {
    sound.stop();
  }
};

/**
 * Fades music to nothing, then stops it.
 * @param {number} [durationSeconds] in seconds.  Default 3.
 */
MusicController.prototype.fadeOut = function (durationSeconds) {
  if (!this.nowPlaying_) {
    return;
  }

  durationSeconds = utils.valueOr(durationSeconds, 3);

  // Trigger a fade
  var sound = this.audioPlayer_.get(this.nowPlaying_);
  if (sound) {
    sound.fadeToGain(0, durationSeconds);
  }

  // Stop the audio after the fade.
  // Add a small margin due to poor fade granularity on fallback player.
  window.setTimeout((function () {
    this.stop();
  }).bind(this), 1000 * durationSeconds + 100);
};

/**
 * Callback for when music stops, to update internal state.
 * @param {string} musicName that was playing.  Should be bound when music
 *        is started.
 * @private
 */
MusicController.prototype.whenMusicStopped_ = function (musicName) {
  if (this.nowPlaying_ === musicName) {
    this.nowPlaying_ = null;
  }
  if (this.loopRandomWithDelay_ && !this.wasPlayingWhenVideoShown_) {
    this.betweenTrackTimeout_ = window.setTimeout((function () {
      this.betweenTrackTimeout_ = null;
      if (!this.nowPlaying_ && !this.wasPlayingWhenVideoShown_) {
        this.play();
      }
    }).bind(this), this.loopRandomWithDelay_);
  }
};

/**
 * @param {string} name
 * @returns {MusicTrack|undefined}
 * @private
 */
MusicController.prototype.getTrackByName_ = function (name) {
  return _.find(this.trackList_, function (track) {
    return track.name === name;
  });
};

/**
 * @returns {MusicTrack|undefined}
 * @private
 */
MusicController.prototype.getRandomTrack_ = function () {
  var trackIndex = Math.floor(Math.random() * this.trackList_.length);
  return this.trackList_[trackIndex];
};

},{"./utils":"/home/ubuntu/staging/apps/build/js/utils.js"}],"/home/ubuntu/staging/apps/build/js/JsInterpreterLogger.js":[function(require,module,exports){
/** @file Observes a JSInterpreter and logs to the designated browser console. */
// Strict linting: Absorb into global config when possible
/* jshint
 unused: true,
 eqeqeq: true,
 maxlen: 120
 */
'use strict';

var Observer = require('./Observer');

/**
 * Observer responsible for logging to the provided browser console when
 * the interpreter it is observing raises log-worthy events.
 * @constructor
 * @param {Console} window console API
 */
var JsInterpreterLogger = module.exports = function (outputConsole) {
  /** @private {Console} */
  this.outputConsole_ = outputConsole;

  /** @private {Observer} */
  this.observer_ = new Observer();
};

/**
 * Attach the logger to a particular JSInterpreter instance.
 * @param {JSInterpreter} jsInterpreter
 */
JsInterpreterLogger.prototype.attachTo = function (jsInterpreter) {
  this.observer_.observe(jsInterpreter.onExecutionWarning, this.log.bind(this));
};

/**
 * Detach the logger from whatever interpreter instance it is currently
 * attached to, unregistering handlers.
 * Safe to call when the logger is already detached.
 */
JsInterpreterLogger.prototype.detach = function () {
  this.observer_.unobserveAll();
};

/**
 * Log to the console object we were constructed with.
 * @param {*} arguments...
 * @see Console.log
 */
JsInterpreterLogger.prototype.log = function () {
  if (this.outputConsole_ && this.outputConsole_.log) {
    this.outputConsole_.log.apply(this.outputConsole_, arguments);
  }
};

},{"./Observer":"/home/ubuntu/staging/apps/build/js/Observer.js"}],"/home/ubuntu/staging/apps/build/js/JsDebuggerUi.js":[function(require,module,exports){
/** @file Debugger controls and debug console used in our rich JavaScript IDEs */
// Strict linting: Absorb into global config when possible
/* jshint
 unused: true,
 eqeqeq: true,
 maxlen: 120
 */
'use strict';

var CommandHistory = require('./CommandHistory');
var constants = require('./constants');
var DebugArea = require('./DebugArea');
var dom = require('./dom');
var JSInterpreter = require('./JSInterpreter');
var Observer = require('./Observer');
var Slider = require('./slider');
var utils = require('./utils');

var KeyCodes = constants.KeyCodes;
var StepType = JSInterpreter.StepType;

/** @const {number} */
var MIN_DEBUG_AREA_HEIGHT = 120;
/** @const {number} */
var MAX_DEBUG_AREA_HEIGHT = 400;

/**
 * Debugger controls and debug console used in our rich JavaScript IDEs, like
 * App Lab, Game Lab, etc.
 * @param {!function} runApp - callback for "launching" the app, which is used
 *        by the "Step In" button when the app isn't running.
 * @constructor
 */
var JsDebuggerUi = module.exports = function (runApp) {
  /**
   * Reference to currently attached JSInterpreter, null if unattached.
   * @private {JSInterpreter}
   */
  this.jsInterpreter_ = null;

  /** @private {Observer} */
  this.observer_ = new Observer();

  /**
   * Callback for "launching" the app, used by the "Step In" button when the app
   * isn't currently running.
   * @private {function}
   */
  this.runApp_ = runApp;

  /**
   * Browseable history of commands entered into the debug console.
   * @private {CommandHistory}
   */
  this.history_ = new CommandHistory();

  /**
   * Helper that handles open/shut actions for debugger UI
   * @private {DebugArea}
   */
  this.debugOpenShutController_ = null;

  /**
   * Root element for debug UI: div#debug-area
   * @private {HTMLDivElement}
   */
  this.rootDiv_ = null;
};

/**
 * Generate DOM element markup from an ejs file for the debug area.
 * @param {!function} assetUrl - Helper for getting asset URLs.
 * @param {!Object} options
 * @param {!boolean} options.showButtons - Whether to show the debug buttons
 * @param {!boolean} options.showConsole - Whether to show the debug console
 * @returns {string} of HTML markup to be embedded in codeWorkspace.html.ejs
 */
JsDebuggerUi.prototype.getMarkup = function (assetUrl, options) {
  return require('./JsDebuggerUi.html.ejs')({
    assetUrl: assetUrl,
    debugButtons: options.showButtons,
    debugConsole: options.showConsole
  });
};

/**
 * Attach the debugger to a particular JSInterpreter instance.  Reinitializes
 * the UI state and begins listening for interpreter events.
 * @param {JSInterpreter} jsInterpreter
 */
JsDebuggerUi.prototype.attachTo = function (jsInterpreter) {
  this.jsInterpreter_ = jsInterpreter;
  this.observer_.observe(jsInterpreter.onNextStepChanged, this.updatePauseUiState.bind(this));
  this.observer_.observe(jsInterpreter.onPause, this.onPauseContinueButton.bind(this));
  this.observer_.observe(jsInterpreter.onExecutionWarning, this.log.bind(this));

  this.updatePauseUiState();
  this.clearDebugOutput();
  this.clearDebugInput();
};

/**
 * Detach the debugger from whatever interpreter instance it is currently
 * attached to, unregistering handlers and resetting the controls to a
 * 'detached' state.
 * Safe to call when the debugger is already detached.
 */
JsDebuggerUi.prototype.detach = function () {
  this.observer_.unobserveAll();
  this.jsInterpreter_ = null;

  this.resetDebugControls_();
};

/**
 * Element getter for elements within the debugger UI.
 * @type {Function}
 * @private
 * @param {string} selector
 * @returns {HTMLElement}
 */
JsDebuggerUi.prototype.getElement_ = function (selector) {
  var rootDiv = document.getElementById('debug-area');
  if (rootDiv) {
    return rootDiv.querySelector(selector);
  }
  return undefined;
};

/**
 * Post-DOM initialization, which allows this controller to grab all the DOM
 * references it needs, bind handlers, and create any subordinate controllers.
 * @param {!Object} options
 * @param {number} [options.defaultStepSpeed] in range 0..1
 */
JsDebuggerUi.prototype.initializeAfterDomCreated = function (options) {
  // Get references to important elements of the DOM
  this.rootDiv_ = document.getElementById('debug-area');

  // Create controller for open/shut behavior of debug area
  this.debugOpenShutController_ = new DebugArea(this.rootDiv_, document.getElementById('codeTextbox'));

  // Initialize debug speed slider
  var slider = this.rootDiv_.querySelector('#speed-slider');
  if (slider) {
    var sliderXOffset = 10,
        sliderYOffset = 22,
        sliderWidth = 130;
    this.speedSlider_ = new Slider(sliderXOffset, sliderYOffset, sliderWidth, slider);

    // Change default speed (eg Speed up levels that have lots of steps).
    if (options.defaultStepSpeed) {
      this.setStepSpeed(options.defaultStepSpeed);
    }
  }

  // Attach keydown handler for debug console input area
  var debugInput = this.rootDiv_.querySelector('#debug-input');
  if (debugInput) {
    debugInput.addEventListener('keydown', this.onDebugInputKeyDown.bind(this));
  }

  // Attach click handler for focusing on console input when clicking output
  var debugOutput = this.rootDiv_.querySelector('#debug-output');
  if (debugOutput) {
    debugOutput.addEventListener('mouseup', this.onDebugOutputMouseUp.bind(this));
  }

  // Attach handlers for the debug area resize control
  var resizeBar = this.getElement_('#debugResizeBar');
  if (resizeBar) {
    dom.addMouseDownTouchEvent(resizeBar, this.onMouseDownDebugResizeBar.bind(this));

    // Can't use dom.addMouseUpTouchEvent() because it will preventDefault on
    // all touchend events on the page, breaking click events...
    document.body.addEventListener('mouseup', this.onMouseUpDebugResizeBar.bind(this));
    var mouseUpTouchEventName = dom.getTouchEventName('mouseup');
    if (mouseUpTouchEventName) {
      document.body.addEventListener(mouseUpTouchEventName, this.onMouseUpDebugResizeBar.bind(this));
    }
  }

  // Attach handler for console clear button
  var clearButton = this.rootDiv_.querySelector('#clear-console-header');
  if (clearButton) {
    dom.addClickTouchEvent(clearButton, this.clearDebugOutput.bind(this));
  }

  // Attach handlers for debugger controls
  var pauseButton = this.getElement_('#pauseButton');
  var continueButton = this.getElement_('#continueButton');
  var stepInButton = this.getElement_('#stepInButton');
  var stepOverButton = this.getElement_('#stepOverButton');
  var stepOutButton = this.getElement_('#stepOutButton');
  if (pauseButton && continueButton && stepInButton && stepOverButton && stepOutButton) {
    dom.addClickTouchEvent(pauseButton, this.onPauseContinueButton.bind(this));
    dom.addClickTouchEvent(continueButton, this.onPauseContinueButton.bind(this));
    dom.addClickTouchEvent(stepInButton, this.onStepInButton.bind(this));
    dom.addClickTouchEvent(stepOverButton, this.onStepOverButton.bind(this));
    dom.addClickTouchEvent(stepOutButton, this.onStepOutButton.bind(this));
  }
};

/**
 * Get the step delay in milliseconds from the speed slider in the debugger UI.
 * If no speed slider is present, returns undefined.
 * @return {number|undefined}
 */
JsDebuggerUi.prototype.getStepDelay = function () {
  if (this.speedSlider_) {
    return JsDebuggerUi.stepDelayFromStepSpeed(this.speedSlider_.getValue());
  }
  return undefined;
};

/**
 * Set the speed slider position.
 * @param {!number} speed - in range 0..1
 */
JsDebuggerUi.prototype.setStepSpeed = function (speed) {
  if (this.speedSlider_) {
    this.speedSlider_.setValue(speed);
  }
};

/**
 * Exponential conversion from step speed (as slider position, range 0..1) to
 * a step delay in milliseconds.
 * @param {!number} stepSpeed in range 0..1
 * @returns {number} step delay in milliseconds
 */
JsDebuggerUi.stepDelayFromStepSpeed = function (stepSpeed) {
  return 300 * Math.pow(1 - stepSpeed, 2);
};

/**
 * Given some object or message, attempt to log it both to the browser console
 * and to the user-facing debug console.
 * @param {*} output
 */
JsDebuggerUi.prototype.log = function (output) {
  var debugOutputDiv = this.getElement_('#debug-output');
  if (debugOutputDiv) {
    if (debugOutputDiv.textContent.length > 0) {
      debugOutputDiv.textContent += '\n';
    }
    debugOutputDiv.textContent += stringifyNonStrings(output);

    debugOutputDiv.scrollTop = debugOutputDiv.scrollHeight;
  }
};

/**
 * @param {*} object
 * @returns {string}
 */
function stringifyNonStrings(object) {
  if (typeof object === 'string' || object instanceof String) {
    return object;
  } else {
    return JSON.stringify(object);
  }
}

/**
 * Handler for key events in the debug console input box.
 * @param {KeyboardEvent} e
 */
JsDebuggerUi.prototype.onDebugInputKeyDown = function (e) {
  var input = e.target.textContent;
  if (e.keyCode === KeyCodes.ENTER) {
    e.preventDefault();
    this.history_.push(input);
    e.target.textContent = '';
    this.log('> ' + input);
    var jsInterpreter = this.jsInterpreter_;
    if (jsInterpreter) {
      try {
        var result = jsInterpreter.evalInCurrentScope(input);
        this.log('< ' + String(result));
      } catch (err) {
        this.log('< ' + String(err));
      }
    } else {
      this.log('< (not running)');
    }
  } else if (e.keyCode === KeyCodes.UP) {
    e.target.textContent = this.history_.goBack(input);
    moveCaretToEndOfDiv(e.target);
    e.preventDefault(); // Block default Home/End-like behavior in Chrome
  } else if (e.keyCode === KeyCodes.DOWN) {
      e.target.textContent = this.history_.goForward(input);
      moveCaretToEndOfDiv(e.target);
      e.preventDefault(); // Block default Home/End-like behavior in Chrome
    }
};

/**
 * Set the cursor position to the end of the text content in a div element.
 * @see http://stackoverflow.com/a/6249440/5000129
 * @param {!HTMLDivElement} element
 */
function moveCaretToEndOfDiv(element) {
  var range = document.createRange();
  if (element.childNodes.length === 0) {
    return;
  }

  range.setStart(element.lastChild, element.lastChild.nodeValue.length);
  range.collapse(true);

  // Change window selection to new range to set cursor position
  var selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);
}

/**
 * On mouseup over the console output, if the user hasn't just selected some
 * text, place the focus in the console input box.
 * @param {MouseEvent} e
 */
JsDebuggerUi.prototype.onDebugOutputMouseUp = function (e) {
  var debugInput = this.getElement_('#debug-input');
  if (debugInput && e.target.tagName === "DIV" && window.getSelection().toString().length === 0) {
    debugInput.focus();
  }
};

/** @type {boolean} */
var draggingDebugResizeBar = false;

/** @type {function} */
var boundMouseMoveHandler;

/** @type {string} */
var mouseMoveTouchEventName;

JsDebuggerUi.prototype.onMouseDownDebugResizeBar = function (event) {
  // When we see a mouse down in the resize bar, start tracking mouse moves:
  var eventSourceElm = event.srcElement || event.target;
  if (eventSourceElm.id === 'debugResizeBar') {
    draggingDebugResizeBar = true;
    boundMouseMoveHandler = this.onMouseMoveDebugResizeBar.bind(this);
    document.body.addEventListener('mousemove', boundMouseMoveHandler);
    mouseMoveTouchEventName = dom.getTouchEventName('mousemove');
    if (mouseMoveTouchEventName) {
      document.body.addEventListener(mouseMoveTouchEventName, boundMouseMoveHandler);
    }

    event.preventDefault();
  }
};

/**
 *  Handle mouse moves while dragging the debug resize bar.
 */
JsDebuggerUi.prototype.onMouseMoveDebugResizeBar = function (event) {
  var codeApp = document.getElementById('codeApp');
  var codeTextbox = document.getElementById('codeTextbox');

  var resizeBar = this.getElement_('#debugResizeBar');
  var rect = resizeBar.getBoundingClientRect();
  var offset = (parseInt(window.getComputedStyle(codeApp).bottom, 10) || 0) - rect.height / 2;
  var newDbgHeight = Math.max(MIN_DEBUG_AREA_HEIGHT, Math.min(MAX_DEBUG_AREA_HEIGHT, window.innerHeight - event.pageY - offset));

  if (this.debugOpenShutController_.isShut()) {
    this.debugOpenShutController_.snapOpen();
  }

  codeTextbox.style.bottom = newDbgHeight + 'px';
  this.rootDiv_.style.height = newDbgHeight + 'px';

  // Fire resize so blockly and droplet handle this type of resize properly:
  utils.fireResizeEvent();
};

JsDebuggerUi.prototype.onMouseUpDebugResizeBar = function () {
  // If we have been tracking mouse moves, remove the handler now:
  if (draggingDebugResizeBar) {
    document.body.removeEventListener('mousemove', boundMouseMoveHandler);
    if (mouseMoveTouchEventName) {
      document.body.removeEventListener(mouseMoveTouchEventName, boundMouseMoveHandler);
    }
    draggingDebugResizeBar = false;
  }
};

/**
 * Empty the contents of the debug console scrollback area.
 */
JsDebuggerUi.prototype.clearDebugOutput = function () {
  var debugOutputDiv = this.getElement_('#debug-output');
  if (debugOutputDiv) {
    debugOutputDiv.textContent = '';
  }
};

/**
 * Empty the debug console input area.
 */
JsDebuggerUi.prototype.clearDebugInput = function () {
  var debugInput = this.getElement_('#debug-input');
  if (debugInput) {
    debugInput.textContent = '';
  }
};

JsDebuggerUi.prototype.onPauseContinueButton = function () {
  var jsInterpreter = this.jsInterpreter_;
  if (jsInterpreter) {
    // We have code and are either running or paused
    if (jsInterpreter.paused && jsInterpreter.nextStep === StepType.RUN) {
      jsInterpreter.paused = false;
    } else {
      jsInterpreter.paused = true;
      jsInterpreter.nextStep = StepType.RUN;
    }

    this.updatePauseUiState();
  }
};

JsDebuggerUi.prototype.updatePauseUiState = function () {
  var jsInterpreter = this.jsInterpreter_;
  if (!jsInterpreter) {
    return;
  }

  var pauseButton = this.getElement_('#pauseButton');
  var continueButton = this.getElement_('#continueButton');
  var spinner = this.getElement_('#running-spinner');
  var pausedIcon = this.getElement_('#paused-icon');
  if (pauseButton && continueButton && spinner && pausedIcon) {
    if (jsInterpreter.paused && jsInterpreter.nextStep === StepType.RUN) {
      pauseButton.style.display = "none";
      continueButton.style.display = "inline-block";
      continueButton.disabled = false;
      spinner.style.display = 'none';
      pausedIcon.style.display = 'inline-block';
    } else {
      pauseButton.style.display = "inline-block";
      pauseButton.disabled = false;
      continueButton.style.display = "none";
      spinner.style.display = 'inline-block';
      pausedIcon.style.display = 'none';
    }
  }

  var stepInButton = this.getElement_('#stepInButton');
  var stepOverButton = this.getElement_('#stepOverButton');
  var stepOutButton = this.getElement_('#stepOutButton');
  if (stepInButton && stepOverButton && stepOutButton) {
    stepInButton.disabled = !jsInterpreter.paused;
    stepOverButton.disabled = !jsInterpreter.paused;
    stepOutButton.disabled = !jsInterpreter.paused;
  }
};

/**
 * Put the debug controls back into a detached state.
 * @private
 */
JsDebuggerUi.prototype.resetDebugControls_ = function () {
  var spinner = this.getElement_('#running-spinner');
  if (spinner) {
    spinner.style.display = 'none';
  }

  var pausedIcon = this.getElement_('#paused-icon');
  if (pausedIcon) {
    pausedIcon.style.display = 'none';
  }

  var pauseButton = this.getElement_('#pauseButton');
  var continueButton = this.getElement_('#continueButton');
  var stepInButton = this.getElement_('#stepInButton');
  var stepOverButton = this.getElement_('#stepOverButton');
  var stepOutButton = this.getElement_('#stepOutButton');
  if (pauseButton && continueButton && stepInButton && stepOverButton && stepOutButton) {
    pauseButton.style.display = "inline-block";
    pauseButton.disabled = true;
    continueButton.style.display = "none";
    stepInButton.disabled = false;
    stepOverButton.disabled = true;
    stepOutButton.disabled = true;
  }
};

JsDebuggerUi.prototype.onStepOverButton = function () {
  var jsInterpreter = this.jsInterpreter_;
  if (jsInterpreter) {
    jsInterpreter.paused = true;
    jsInterpreter.nextStep = StepType.OVER;
    this.updatePauseUiState();
  }
};

JsDebuggerUi.prototype.onStepInButton = function () {
  var jsInterpreter = this.jsInterpreter_;
  if (!jsInterpreter) {
    this.runApp_();
    this.onPauseContinueButton();
    jsInterpreter = this.jsInterpreter_;
  }
  jsInterpreter.paused = true;
  jsInterpreter.nextStep = StepType.IN;
  this.updatePauseUiState();
};

JsDebuggerUi.prototype.onStepOutButton = function () {
  var jsInterpreter = this.jsInterpreter_;
  if (jsInterpreter) {
    jsInterpreter.paused = true;
    jsInterpreter.nextStep = StepType.OUT;
    this.updatePauseUiState();
  }
};

},{"./CommandHistory":"/home/ubuntu/staging/apps/build/js/CommandHistory.js","./DebugArea":"/home/ubuntu/staging/apps/build/js/DebugArea.js","./JSInterpreter":"/home/ubuntu/staging/apps/build/js/JSInterpreter.js","./JsDebuggerUi.html.ejs":"/home/ubuntu/staging/apps/build/js/JsDebuggerUi.html.ejs","./Observer":"/home/ubuntu/staging/apps/build/js/Observer.js","./constants":"/home/ubuntu/staging/apps/build/js/constants.js","./dom":"/home/ubuntu/staging/apps/build/js/dom.js","./slider":"/home/ubuntu/staging/apps/build/js/slider.js","./utils":"/home/ubuntu/staging/apps/build/js/utils.js"}],"/home/ubuntu/staging/apps/build/js/slider.js":[function(require,module,exports){
/**
 * Blockly Apps: SVG Slider
 *
 * Copyright 2012 Google Inc.
 * http://blockly.googlecode.com/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview A slider control in SVG.
 * @author fraser@google.com (Neil Fraser)
 */
'use strict';
var SVG_NS = require('./constants').SVG_NS;
var dom = require('./dom');

/**
 * Object representing a horizontal slider widget.
 * @param {number} x The horizontal offset of the slider.
 * @param {number} y The vertical offset of the slider.
 * @param {number} width The total width of the slider.
 * @param {!Element} svgParent The SVG element to append the slider to.
 * @param {Function} opt_changeFunc Optional callback function that will be
 *     called when the slider is moved.  The current value is passed.
 * @constructor
 */
var Slider = function Slider(x, y, width, svgParent, opt_changeFunc) {
  this.KNOB_Y_ = y - 12;
  this.KNOB_MIN_X_ = x + 8;
  this.KNOB_MAX_X_ = x + width - 8;
  this.value_ = 0.5;
  this.changeFunc_ = opt_changeFunc;
  this.isAndroid_ = dom.isAndroid();
  this.isIOS_ = dom.isIOS();
  this.isWindowsTouch_ = dom.isWindowsTouch();

  // Draw the slider.
  /*
  <line class="sliderTrack" x1="10" y1="35" x2="140" y2="35" />
  <path id="knob"
      transform="translate(67, 23)"
      d="m 8,0 l -8,8 v 12 h 16 v -12 z" />
  */
  var track = document.createElementNS(SVG_NS, 'line');
  track.setAttribute('class', 'sliderTrack');
  track.setAttribute('x1', x);
  track.setAttribute('y1', y);
  track.setAttribute('x2', x + width);
  track.setAttribute('y2', y);
  svgParent.appendChild(track);
  this.track_ = track;
  var knob = document.createElementNS(SVG_NS, 'path');
  knob.setAttribute('class', 'sliderKnob');
  knob.setAttribute('d', 'm 0,0 l -8,8 v 12 h 16 v -12 z');
  svgParent.appendChild(knob);
  this.knob_ = knob;
  this.setValue(0.5);

  // Find the root SVG object.
  while (svgParent && svgParent.nodeName.toLowerCase() != 'svg') {
    svgParent = svgParent.parentNode;
  }
  this.SVG_ = svgParent;

  // Bind the events to this slider.
  var thisSlider = this;
  dom.addMouseDownTouchEvent(this.knob_, function (e) {
    return thisSlider.knobMouseDown_(e);
  });
  dom.addMouseDownTouchEvent(this.track_, function (e) {
    return thisSlider.trackMouseDown_(e);
  });
  dom.addMouseUpTouchEvent(this.SVG_, Slider.knobMouseUp_);
  dom.addMouseMoveTouchEvent(this.SVG_, Slider.knobMouseMove_);
  // Don't add touch events for mouseover. The UX is better on Android
  // and iOS if the drag action is allowed to continue when the
  // touchmove target moves above or below the SVG element.
  Slider.bindEvent_(document, 'mouseover', Slider.mouseOver_);
};

Slider.activeSlider_ = null;
Slider.startMouseX_ = 0;
Slider.startKnobX_ = 0;

/**
 * Start a drag when clicking down on the knob.
 * @param {!Event} e Mouse-down event.
 * @private
 */
Slider.prototype.knobMouseDown_ = function (e) {
  this.beginDrag_(this.mouseToSvg_(e));

  // Stop browser from attempting to drag the knob.
  e.preventDefault();
  return false;
};

/**
 * Snap the knob to the mouse location and start a drag
 * when clicking on the track (but not on the knob).
 * @param {!Event} e Mouse-down event.
 * @private
 */
Slider.prototype.trackMouseDown_ = function (e) {
  var mouseSVGPosition = this.mouseToSvg_(e);
  this.snapToPosition_(mouseSVGPosition.x);
  this.beginDrag_(mouseSVGPosition);

  // Stop browser from attempting to drag the track.
  e.preventDefault();
  return false;
};

/**
 * Start dragging the slider knob.
 * @param {!Object} mouseStartSVG Mouse start position in SVG space
 * @private
 */
Slider.prototype.beginDrag_ = function (startMouseSVG) {
  Slider.activeSlider_ = this;
  Slider.startMouseX_ = startMouseSVG.x;
  Slider.startKnobX_ = 0;
  var transform = this.knob_.getAttribute('transform');
  if (transform) {
    var r = transform.match(/translate\(\s*([-\d.]+)/);
    if (r) {
      Slider.startKnobX_ = Number(r[1]);
    }
  }
};

/**
 * Snap the slider knob to the clicked position.
 * @param {number} xPosition SVG x-coordinate
 * @private
 */
Slider.prototype.snapToPosition_ = function (xPosition) {
  var x = Math.min(Math.max(xPosition, this.KNOB_MIN_X_), this.KNOB_MAX_X_);
  this.knob_.setAttribute('transform', 'translate(' + x + ',' + this.KNOB_Y_ + ')');

  this.value_ = (x - this.KNOB_MIN_X_) / (this.KNOB_MAX_X_ - this.KNOB_MIN_X_);
  if (this.changeFunc_) {
    this.changeFunc_(this.value_);
  }
};

/**
 * Stop a drag when clicking up anywhere.
 * @param {Event} e Mouse-up event.
 * @private
 */
Slider.knobMouseUp_ = function (e) {
  Slider.activeSlider_ = null;
};

/**
 * Stop a drag when the mouse enters a node not part of the SVG.
 * @param {Event} e Mouse-up event.
 * @private
 */
Slider.mouseOver_ = function (e) {
  if (!Slider.activeSlider_) {
    return;
  }
  // Find the root SVG object.
  for (var node = e.target; node; node = node.parentNode) {
    if (node == Slider.activeSlider_.SVG_) {
      return;
    }
  }
  Slider.knobMouseUp_(e);
};

/**
 * Drag the knob to follow the mouse.
 * @param {!Event} e Mouse-move event.
 * @private
 */
Slider.knobMouseMove_ = function (e) {
  var thisSlider = Slider.activeSlider_;
  if (!thisSlider) {
    return;
  }
  var x = thisSlider.mouseToSvg_(e).x - Slider.startMouseX_ + Slider.startKnobX_;
  thisSlider.snapToPosition_(x);
};

/**
 * Returns the slider's value (0.0 - 1.0).
 * @return {number} Current value.
 */
Slider.prototype.getValue = function () {
  return this.value_;
};

/**
 * Sets the slider's value (0.0 - 1.0).
 * @param {number} value New value.
 */
Slider.prototype.setValue = function (value) {
  this.value_ = Math.min(Math.max(value, 0), 1);
  var x = this.KNOB_MIN_X_ + (this.KNOB_MAX_X_ - this.KNOB_MIN_X_) * this.value_;
  this.knob_.setAttribute('transform', 'translate(' + x + ',' + this.KNOB_Y_ + ')');
};

/**
 * Convert the mouse coordinates into SVG coordinates.
 * @param {!Object} e Object with x and y mouse coordinates.
 * @return {!Object} Object with x and y properties in SVG coordinates.
 * @private
 */
Slider.prototype.mouseToSvg_ = function (e) {
  var svgPoint = this.SVG_.createSVGPoint();
  // Most browsers provide clientX/Y. iOS only provides pageX/Y.
  // Android Chrome only provides coordinates within e.changedTouches.
  if (this.isWindowsTouch_) {
    // Only screenX/Y properly accounts for zooming in on windows touch.
    svgPoint.x = e.screenX;
    svgPoint.y = e.screenY;
  } else if (this.isAndroid_) {
    svgPoint.x = e.changedTouches[0].pageX;
    svgPoint.y = e.changedTouches[0].pageY;
  } else if (this.isIOS_) {
    svgPoint.x = e.pageX;
    svgPoint.y = e.pageY;
  } else {
    svgPoint.x = e.clientX;
    svgPoint.y = e.clientY;
  }
  var matrix = this.SVG_.getScreenCTM().inverse();
  return svgPoint.matrixTransform(matrix);
};

/**
 * Bind an event to a function call.
 * @param {!Element} element Element upon which to listen.
 * @param {string} name Event name to listen to (e.g. 'mousedown').
 * @param {!Function} func Function to call when event is triggered.
 * @private
 */
Slider.bindEvent_ = function (element, name, func) {
  element.addEventListener(name, func, false);
};

module.exports = Slider;

},{"./constants":"/home/ubuntu/staging/apps/build/js/constants.js","./dom":"/home/ubuntu/staging/apps/build/js/dom.js"}],"/home/ubuntu/staging/apps/build/js/constants.js":[function(require,module,exports){
/**
 * @fileoverview Constants used in production code and tests.
 */

/**
 * Enumeration of user program execution outcomes.
 * These are determined by each app.
 */
'use strict';

exports.ResultType = {
  UNSET: 0, // The result has not yet been computed.
  SUCCESS: 1, // The program completed successfully, achieving the goal.
  FAILURE: -1, // The program ran without error but did not achieve goal.
  TIMEOUT: 2, // The program did not complete (likely infinite loop).
  ERROR: -2 // The program generated an error.
};

/**
 * Enumeration of test results.
 * EMPTY_BLOCK_FAIL and EMPTY_FUNCTION_BLOCK_FAIL can only occur if
 * StudioApp.checkForEmptyBlocks_ is true.
 * NOTE: We store the results for user attempts in our db, so changing these
 * values would necessitate a migration
 */
exports.TestResults = {
  // Default value before any tests are run.
  NO_TESTS_RUN: -1,

  // The level was not solved.
  EMPTY_BLOCK_FAIL: 1, // An "if" or "repeat" block was empty.
  TOO_FEW_BLOCKS_FAIL: 2, // Fewer than the ideal number of blocks used.
  LEVEL_INCOMPLETE_FAIL: 3, // Default failure to complete a level.
  MISSING_BLOCK_UNFINISHED: 4, // A required block was not used.
  EXTRA_TOP_BLOCKS_FAIL: 5, // There was more than one top-level block.
  RUNTIME_ERROR_FAIL: 6, // There was a runtime error in the program.
  SYNTAX_ERROR_FAIL: 7, // There was a syntax error in the program.
  MISSING_BLOCK_FINISHED: 10, // The level was solved without required block.
  APP_SPECIFIC_FAIL: 11, // Application-specific failure.
  EMPTY_FUNCTION_BLOCK_FAIL: 12, // A "function" block was empty
  UNUSED_PARAM: 13, // Param declared but not used in function.
  UNUSED_FUNCTION: 14, // Function declared but not used in workspace.
  PARAM_INPUT_UNATTACHED: 15, // Function not called with enough params.
  INCOMPLETE_BLOCK_IN_FUNCTION: 16, // Incomplete block inside a function.
  QUESTION_MARKS_IN_NUMBER_FIELD: 17, // Block has ??? instead of a value.
  EMPTY_FUNCTIONAL_BLOCK: 18, // There's a functional block with an open input
  EXAMPLE_FAILED: 19, // One of our examples didn't match the definition

  // start using negative values, since we consider >= 20 to be "solved"
  NESTED_FOR_SAME_VARIABLE: -2, // We have nested for loops each using the same counter variable
  // NOTE: for smoe period of time, this was -1 and conflicted with NO_TESTS_RUN
  EMPTY_FUNCTION_NAME: -3, // We have a variable or function with the name ""
  MISSING_RECOMMENDED_BLOCK_UNFINISHED: -4, // The level was attempted but not solved without a recommended block
  EXTRA_FUNCTION_FAIL: -5, // The program contains a JavaScript function when it should not
  LOCAL_FUNCTION_FAIL: -6, // The program contains an unexpected JavaScript local function

  // The level was solved in a non-optimal way.  User may advance or retry.
  TOO_MANY_BLOCKS_FAIL: 20, // More than the ideal number of blocks were used.
  APP_SPECIFIC_ACCEPTABLE_FAIL: 21, // Application-specific acceptable failure.
  MISSING_RECOMMENDED_BLOCK_FINISHED: 22, // The level was solved without a recommended block

  // Other.
  FREE_PLAY: 30, // The user is in free-play mode.
  EDIT_BLOCKS: 70, // The user is creating/editing a new level.

  // The level was solved in the ideal manner.
  ALL_PASS: 100
};

exports.BeeTerminationValue = {
  FAILURE: false,
  SUCCESS: true,
  INFINITE_LOOP: Infinity,
  NOT_AT_FLOWER: 1, // Tried to get nectar when not at flower.
  FLOWER_EMPTY: 2, // Tried to get nectar when flower empty.
  NOT_AT_HONEYCOMB: 3, // Tried to make honey when not at honeycomb.
  HONEYCOMB_FULL: 4, // Tried to make honey, but no room at honeycomb.
  UNCHECKED_CLOUD: 5, // Finished puzzle, but didn't check every clouded item
  UNCHECKED_PURPLE: 6, // Finished puzzle, but didn't check every purple flower
  INSUFFICIENT_NECTAR: 7, // Didn't collect all nectar by finish
  INSUFFICIENT_HONEY: 8, // Didn't make all honey by finish
  DID_NOT_COLLECT_EVERYTHING: 9 // For quantum levels, didn't try to collect all available honey/nectar
};

exports.KeyCodes = {
  BACKSPACE: 8,
  ENTER: 13,
  SPACE: 32,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  DELETE: 127
};

/** @const {string} SVG element namespace */
exports.SVG_NS = 'http://www.w3.org/2000/svg';

},{}],"/home/ubuntu/staging/apps/build/js/Observer.js":[function(require,module,exports){
/** @file Helper for consuming ObservableEvents. */
// Strict linting: Absorb into global config when possible
/* jshint
 unused: true,
 eqeqeq: true,
 maxlen: 120
 */
'use strict';

/**
 * Helper object for consuming ObservableEvents, designed for composition into
 * other classes.  Remembers what it's observing and provides safer ways to
 * stop observing those things.
 * @constructor
 */
var Observer = module.exports = function () {
  /**
   * @private {Array.<Object>} event-key pairs of observed events, for easy
   *          unregistering later.
   */
  this.observed_ = [];
};

/**
 * Begin observing the given event, forwarding it to the provided callback
 * whenever the event occurs.
 * @param {!ObservableEvent} event
 * @param {!function} callback
 */
Observer.prototype.observe = function (event, callback) {
  var key = event.register(callback);
  this.observed_.push({
    event: event,
    key: key
  });
};

/**
 * Unregister all callbacks from all observed events.
 */
Observer.prototype.unobserveAll = function () {
  this.observed_.forEach(function (observable) {
    observable.event.unregister(observable.key);
  });
  this.observed_.length = 0;
};

},{}],"/home/ubuntu/staging/apps/build/js/JsDebuggerUi.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1; var i18n = require('./locale'); ; buf.push('\n\n<div id="debug-area">\n  <div id="debugResizeBar" class="fa fa-ellipsis-h"></div>\n  <div id="debug-area-header">\n    <span class="header-text">', escape((6,  i18n.debugConsoleHeader() )), '</span>\n    <i id="show-hide-debug-icon" class="fa fa-chevron-circle-down"></i>\n    ');8; if (debugButtons) { ; buf.push('\n    <div id="debug-commands-header" class="workspace-header">\n      <i id="running-spinner" style="display: none;" class="fa fa-spinner fa-spin"></i>\n      <i id="paused-icon" style="display: none;" class="fa fa-pause"></i>\n      <span class="header-text">', escape((12,  i18n.debugCommandsHeaderWhenOpen() )), '</span>\n    </div>\n    <div id="clear-console-header" class="workspace-header workspace-header-button"><span><i class="fa fa-eraser"></i>Clear</span></div>\n    ');15; } ; buf.push('\n    <div id="slider-cell" style="margin-left: ', escape((16,  debugButtons ? 0 : 40 )), 'px">\n      <svg id="speed-slider"\n           xmlns="http://www.w3.org/2000/svg"\n           xmlns:svg="http://www.w3.org/2000/svg"\n           xmlns:xlink="http://www.w3.org/1999/xlink"\n           version="1.1"\n           width="150"\n           height="28">\n          <!-- Slow icon. -->\n          <clipPath id="slowClipPath">\n            <rect width=26 height=12 x=5 y=6 />\n          </clipPath>\n          <image xlink:href="', escape((28,  assetUrl('media/turtle_icons.png') )), '" height=42 width=84 x=-21 y=-18\n              clip-path="url(#slowClipPath)" />\n          <!-- Fast icon. -->\n          <clipPath id="fastClipPath">\n            <rect width=26 height=16 x=120 y=2 />\n          </clipPath>\n          <image xlink:href="', escape((34,  assetUrl('media/turtle_icons.png') )), '" height=42 width=84 x=120 y=-19\n              clip-path="url(#fastClipPath)" />\n      </svg>\n    </div>\n  </div>\n\n  ');40; if (debugButtons) { ; buf.push('\n  <div id="debug-commands" class="debug-commands">\n    <div id="debug-buttons">\n      <button id="pauseButton" class="debugger_button">\n        <img src="', escape((44,  assetUrl('media/1x1.gif') )), '" class="pause-btn icon21">\n        ', escape((45,  i18n.pause() )), '\n      </button>\n      <button id="continueButton" class="debugger_button">\n        <img src="', escape((48,  assetUrl('media/1x1.gif') )), '" class="continue-btn icon21">\n        ', escape((49,  i18n.continue() )), '\n      </button>\n      <button id="stepOverButton" class="debugger_button">\n        <img src="', escape((52,  assetUrl('media/1x1.gif') )), '" class="step-over-btn icon21">\n        ', escape((53,  i18n.stepOver() )), '\n      </button>\n      <button id="stepOutButton" class="debugger_button">\n        <img src="', escape((56,  assetUrl('media/1x1.gif') )), '" class="step-out-btn icon21">\n        ', escape((57,  i18n.stepOut() )), '\n      </button>\n      <button id="stepInButton" class="debugger_button">\n        <img src="', escape((60,  assetUrl('media/1x1.gif') )), '" class="step-in-btn icon21">\n        ', escape((61,  i18n.stepIn() )), '\n      </button>\n    </div>\n  </div>\n  ');65; } ; buf.push('\n  ');66; if (debugConsole) { ; buf.push('\n  <div id="debug-console" class="debug-console ', escape((67,  debugButtons ? '' : 'full' )), '">\n    <div id="debug-output" class="debug-output"></div>\n    <span class="debug-input-prompt">\n      &gt;\n    </span>\n    <div contenteditable spellcheck="false" id="debug-input" class="debug-input"></div>\n  </div>\n  ');74; } ; buf.push('\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"./locale":"/home/ubuntu/staging/apps/build/js/locale.js","ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js":[function(require,module,exports){

/*!
 * EJS
 * Copyright(c) 2012 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var utils = require('./utils')
  , path = require('path')
  , basename = path.basename
  , dirname = path.dirname
  , extname = path.extname
  , join = path.join
  , fs = require('fs')
  , read = fs.readFileSync;

/**
 * Filters.
 *
 * @type Object
 */

var filters = exports.filters = require('./filters');

/**
 * Intermediate js cache.
 *
 * @type Object
 */

var cache = {};

/**
 * Clear intermediate js cache.
 *
 * @api public
 */

exports.clearCache = function(){
  cache = {};
};

/**
 * Translate filtered code into function calls.
 *
 * @param {String} js
 * @return {String}
 * @api private
 */

function filtered(js) {
  return js.substr(1).split('|').reduce(function(js, filter){
    var parts = filter.split(':')
      , name = parts.shift()
      , args = parts.join(':') || '';
    if (args) args = ', ' + args;
    return 'filters.' + name + '(' + js + args + ')';
  });
};

/**
 * Re-throw the given `err` in context to the
 * `str` of ejs, `filename`, and `lineno`.
 *
 * @param {Error} err
 * @param {String} str
 * @param {String} filename
 * @param {String} lineno
 * @api private
 */

function rethrow(err, str, filename, lineno){
  var lines = str.split('\n')
    , start = Math.max(lineno - 3, 0)
    , end = Math.min(lines.length, lineno + 3);

  // Error context
  var context = lines.slice(start, end).map(function(line, i){
    var curr = i + start + 1;
    return (curr == lineno ? ' >> ' : '    ')
      + curr
      + '| '
      + line;
  }).join('\n');

  // Alter exception message
  err.path = filename;
  err.message = (filename || 'ejs') + ':'
    + lineno + '\n'
    + context + '\n\n'
    + err.message;
  
  throw err;
}

/**
 * Parse the given `str` of ejs, returning the function body.
 *
 * @param {String} str
 * @return {String}
 * @api public
 */

var parse = exports.parse = function(str, options){
  var options = options || {}
    , open = options.open || exports.open || '<%'
    , close = options.close || exports.close || '%>'
    , filename = options.filename
    , compileDebug = options.compileDebug !== false
    , buf = [];

  buf.push('var buf = [];');
  if (false !== options._with) buf.push('\nwith (locals || {}) { (function(){ ');
  buf.push('\n buf.push(\'');

  var lineno = 1;

  var consumeEOL = false;
  for (var i = 0, len = str.length; i < len; ++i) {
    if (str.slice(i, open.length + i) == open) {
      i += open.length
  
      var prefix, postfix, line = (compileDebug ? '__stack.lineno=' : '') + lineno;
      switch (str.substr(i, 1)) {
        case '=':
          prefix = "', escape((" + line + ', ';
          postfix = ")), '";
          ++i;
          break;
        case '-':
          prefix = "', (" + line + ', ';
          postfix = "), '";
          ++i;
          break;
        default:
          prefix = "');" + line + ';';
          postfix = "; buf.push('";
      }

      var end = str.indexOf(close, i)
        , js = str.substring(i, end)
        , start = i
        , include = null
        , n = 0;

      if ('-' == js[js.length-1]){
        js = js.substring(0, js.length - 2);
        consumeEOL = true;
      }

      if (0 == js.trim().indexOf('include')) {
        var name = js.trim().slice(7).trim();
        if (!filename) throw new Error('filename option is required for includes');
        var path = resolveInclude(name, filename);
        include = read(path, 'utf8');
        include = exports.parse(include, { filename: path, _with: false, open: open, close: close, compileDebug: compileDebug });
        buf.push("' + (function(){" + include + "})() + '");
        js = '';
      }

      while (~(n = js.indexOf("\n", n))) n++, lineno++;
      if (js.substr(0, 1) == ':') js = filtered(js);
      if (js) {
        if (js.lastIndexOf('//') > js.lastIndexOf('\n')) js += '\n';
        buf.push(prefix, js, postfix);
      }
      i += end - start + close.length - 1;

    } else if (str.substr(i, 1) == "\\") {
      buf.push("\\\\");
    } else if (str.substr(i, 1) == "'") {
      buf.push("\\'");
    } else if (str.substr(i, 1) == "\r") {
      // ignore
    } else if (str.substr(i, 1) == "\n") {
      if (consumeEOL) {
        consumeEOL = false;
      } else {
        buf.push("\\n");
        lineno++;
      }
    } else {
      buf.push(str.substr(i, 1));
    }
  }

  if (false !== options._with) buf.push("'); })();\n} \nreturn buf.join('');")
  else buf.push("');\nreturn buf.join('');");

  return buf.join('');
};

/**
 * Compile the given `str` of ejs into a `Function`.
 *
 * @param {String} str
 * @param {Object} options
 * @return {Function}
 * @api public
 */

var compile = exports.compile = function(str, options){
  options = options || {};
  var escape = options.escape || utils.escape;
  
  var input = JSON.stringify(str)
    , compileDebug = options.compileDebug !== false
    , client = options.client
    , filename = options.filename
        ? JSON.stringify(options.filename)
        : 'undefined';
  
  if (compileDebug) {
    // Adds the fancy stack trace meta info
    str = [
      'var __stack = { lineno: 1, input: ' + input + ', filename: ' + filename + ' };',
      rethrow.toString(),
      'try {',
      exports.parse(str, options),
      '} catch (err) {',
      '  rethrow(err, __stack.input, __stack.filename, __stack.lineno);',
      '}'
    ].join("\n");
  } else {
    str = exports.parse(str, options);
  }
  
  if (options.debug) console.log(str);
  if (client) str = 'escape = escape || ' + escape.toString() + ';\n' + str;

  try {
    var fn = new Function('locals, filters, escape', str);
  } catch (err) {
    if ('SyntaxError' == err.name) {
      err.message += options.filename
        ? ' in ' + filename
        : ' while compiling ejs';
    }
    throw err;
  }

  if (client) return fn;

  return function(locals){
    return fn.call(this, locals, filters, escape);
  }
};

/**
 * Render the given `str` of ejs.
 *
 * Options:
 *
 *   - `locals`          Local variables object
 *   - `cache`           Compiled functions are cached, requires `filename`
 *   - `filename`        Used by `cache` to key caches
 *   - `scope`           Function execution context
 *   - `debug`           Output generated function body
 *   - `open`            Open tag, defaulting to "<%"
 *   - `close`           Closing tag, defaulting to "%>"
 *
 * @param {String} str
 * @param {Object} options
 * @return {String}
 * @api public
 */

exports.render = function(str, options){
  var fn
    , options = options || {};

  if (options.cache) {
    if (options.filename) {
      fn = cache[options.filename] || (cache[options.filename] = compile(str, options));
    } else {
      throw new Error('"cache" option requires "filename".');
    }
  } else {
    fn = compile(str, options);
  }

  options.__proto__ = options.locals;
  return fn.call(options.scope, options);
};

/**
 * Render an EJS file at the given `path` and callback `fn(err, str)`.
 *
 * @param {String} path
 * @param {Object|Function} options or callback
 * @param {Function} fn
 * @api public
 */

exports.renderFile = function(path, options, fn){
  var key = path + ':string';

  if ('function' == typeof options) {
    fn = options, options = {};
  }

  options.filename = path;

  var str;
  try {
    str = options.cache
      ? cache[key] || (cache[key] = read(path, 'utf8'))
      : read(path, 'utf8');
  } catch (err) {
    fn(err);
    return;
  }
  fn(null, exports.render(str, options));
};

/**
 * Resolve include `name` relative to `filename`.
 *
 * @param {String} name
 * @param {String} filename
 * @return {String}
 * @api private
 */

function resolveInclude(name, filename) {
  var path = join(dirname(filename), name);
  var ext = extname(name);
  if (!ext) path += '.ejs';
  return path;
}

// express support

exports.__express = exports.renderFile;

/**
 * Expose to require().
 */

if (require.extensions) {
  require.extensions['.ejs'] = function(module, filename) {
    source = require('fs').readFileSync(filename, 'utf-8');
    module._compile(compile(source, {}), filename);
  };
} else if (require.registerExtension) {
  require.registerExtension('.ejs', function(src) {
    return compile(src, {});
  });
}

},{"./filters":"/home/ubuntu/staging/apps/node_modules/ejs/lib/filters.js","./utils":"/home/ubuntu/staging/apps/node_modules/ejs/lib/utils.js","fs":"/home/ubuntu/staging/apps/node_modules/browserify/lib/_empty.js","path":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/path-browserify/index.js"}],"/home/ubuntu/staging/apps/node_modules/ejs/lib/utils.js":[function(require,module,exports){

/*!
 * EJS
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Escape the given string of `html`.
 *
 * @param {String} html
 * @return {String}
 * @api private
 */

exports.escape = function(html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
 
},{}],"/home/ubuntu/staging/apps/node_modules/ejs/lib/filters.js":[function(require,module,exports){

/*!
 * EJS - Filters
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * First element of the target `obj`.
 */

exports.first = function(obj) {
  return obj[0];
};

/**
 * Last element of the target `obj`.
 */

exports.last = function(obj) {
  return obj[obj.length - 1];
};

/**
 * Capitalize the first letter of the target `str`.
 */

exports.capitalize = function(str){
  str = String(str);
  return str[0].toUpperCase() + str.substr(1, str.length);
};

/**
 * Downcase the target `str`.
 */

exports.downcase = function(str){
  return String(str).toLowerCase();
};

/**
 * Uppercase the target `str`.
 */

exports.upcase = function(str){
  return String(str).toUpperCase();
};

/**
 * Sort the target `obj`.
 */

exports.sort = function(obj){
  return Object.create(obj).sort();
};

/**
 * Sort the target `obj` by the given `prop` ascending.
 */

exports.sort_by = function(obj, prop){
  return Object.create(obj).sort(function(a, b){
    a = a[prop], b = b[prop];
    if (a > b) return 1;
    if (a < b) return -1;
    return 0;
  });
};

/**
 * Size or length of the target `obj`.
 */

exports.size = exports.length = function(obj) {
  return obj.length;
};

/**
 * Add `a` and `b`.
 */

exports.plus = function(a, b){
  return Number(a) + Number(b);
};

/**
 * Subtract `b` from `a`.
 */

exports.minus = function(a, b){
  return Number(a) - Number(b);
};

/**
 * Multiply `a` by `b`.
 */

exports.times = function(a, b){
  return Number(a) * Number(b);
};

/**
 * Divide `a` by `b`.
 */

exports.divided_by = function(a, b){
  return Number(a) / Number(b);
};

/**
 * Join `obj` with the given `str`.
 */

exports.join = function(obj, str){
  return obj.join(str || ', ');
};

/**
 * Truncate `str` to `len`.
 */

exports.truncate = function(str, len){
  str = String(str);
  return str.substr(0, len);
};

/**
 * Truncate `str` to `n` words.
 */

exports.truncate_words = function(str, n){
  var str = String(str)
    , words = str.split(/ +/);
  return words.slice(0, n).join(' ');
};

/**
 * Replace `pattern` with `substitution` in `str`.
 */

exports.replace = function(str, pattern, substitution){
  return String(str).replace(pattern, substitution || '');
};

/**
 * Prepend `val` to `obj`.
 */

exports.prepend = function(obj, val){
  return Array.isArray(obj)
    ? [val].concat(obj)
    : val + obj;
};

/**
 * Append `val` to `obj`.
 */

exports.append = function(obj, val){
  return Array.isArray(obj)
    ? obj.concat(val)
    : obj + val;
};

/**
 * Map the given `prop`.
 */

exports.map = function(arr, prop){
  return arr.map(function(obj){
    return obj[prop];
  });
};

/**
 * Reverse the given `obj`.
 */

exports.reverse = function(obj){
  return Array.isArray(obj)
    ? obj.reverse()
    : String(obj).split('').reverse().join('');
};

/**
 * Get `prop` of the given `obj`.
 */

exports.get = function(obj, prop){
  return obj[prop];
};

/**
 * Packs the given `obj` into json string
 */
exports.json = function(obj){
  return JSON.stringify(obj);
};
},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/path-browserify/index.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/process/browser.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/home/ubuntu/staging/apps/node_modules/browserify/lib/_empty.js":[function(require,module,exports){

},{}],"/home/ubuntu/staging/apps/build/js/JSInterpreter.js":[function(require,module,exports){
// Strict linting: Absorb into global config when possible
/* jshint
 unused: true,
 eqeqeq: true,
 maxlen: 120
 */

'use strict';

var codegen = require('./codegen');
var ObservableEvent = require('./ObservableEvent');
var utils = require('./utils');

/**
 * Create a JSInterpreter object. This object wraps an Interpreter object and
 * adds stepping, batching of steps, code highlighting, error handling,
 * breakpoints, general debug capabilities (step in, step out, step over), and
 * an optional event queue.
 * @constructor
 * @param {!Object} options
 * @param {!StudioApp} options.studioApp
 * @param {function} [options.shouldRunAtMaxSpeed]
 * @param {number} [options.maxInterpreterStepsPerTick]
 * @param {Object} [options.customMarshalGlobalProperties]
 */
var JSInterpreter = module.exports = function (options) {
  this.studioApp = options.studioApp;
  this.shouldRunAtMaxSpeed = options.shouldRunAtMaxSpeed || function () {
    return true;
  };
  this.maxInterpreterStepsPerTick = options.maxInterpreterStepsPerTick || 10000;
  this.customMarshalGlobalProperties = options.customMarshalGlobalProperties || {};

  // Publicly-exposed events that anyone with access to the JSInterpreter can
  // observe and respond to.

  /** @type {ObservableEvent} */
  this.onNextStepChanged = new ObservableEvent();

  /** @type {ObservableEvent} */
  this.onPause = new ObservableEvent();

  /** @type {ObservableEvent} */
  this.onExecutionError = new ObservableEvent();

  /** @type {ObservableEvent} */
  this.onExecutionWarning = new ObservableEvent();

  this.paused = false;
  this.yieldExecution = false;
  this.startedHandlingEvents = false;
  this.executionError = null;
  this.nextStep = StepType.RUN;
  this.maxValidCallExpressionDepth = 0;
  this.executeLoopDepth = 0;
  this.callExpressionSeenAtDepth = [];
  this.stoppedAtBreakpointRows = [];
};

/**
 * Initialize the JSInterpreter, parsing the provided code and preparing to
 * execute it one step at a time.
 *
 * @param {!Object} options - for now, same options passed to the constructor
 * @param {!string} options.code - Code to be executed by the interpreter.
 * @param {Array} [options.blocks] - in dropletConfig.blocks format.  If a block
 *        has a parent property, we will populate that function into the
 *        interpreter global scope.
 * @param {Object} [options.blockFilter] - an object with block-name keys that
 *        should be used to filter which blocks are populated.
 * @param {Array} [options.globalFunctions] - objects containing functions to
 *        place in the interpreter global scope.
 * @param {boolean} [options.enableEvents] - allow the interpreter to define
 *        event handlers that can be invoked by native code. (default false)
 */
JSInterpreter.prototype.parse = function (options) {
  if (!this.studioApp.hideSource) {
    this.calculateCodeInfo(options.code);

    var session = this.studioApp.editor.aceEditor.getSession();
    this.isBreakpointRow = codegen.isAceBreakpointRow.bind(null, session);
  } else {
    this.isBreakpointRow = function () {
      return false;
    };
  }

  var self = this;
  if (options.enableEvents) {
    this.eventQueue = [];
    // Append our mini-runtime after the user's code. This will spin and process
    // callback functions:
    options.code += '\nwhile (true) { var obj = getCallback(); ' + 'if (obj) { var ret = obj.fn.apply(null, obj.arguments ? obj.arguments : null);' + 'setCallbackRetVal(ret); }}';

    codegen.createNativeFunctionFromInterpreterFunction = function (intFunc) {
      return function () {
        if (self.initialized()) {
          self.queueEvent(intFunc, arguments);

          if (self.executeLoopDepth === 0) {
            // Execute the interpreter and if a return value is sent back from the
            // interpreter's event handler, pass that back in the native world

            // NOTE: the interpreter will not execute forever, if the event handler
            // takes too long, executeInterpreter() will return and the native side
            // will just see 'undefined' as the return value. The rest of the interpreter
            // event handler will run in the next onTick(), but the return value will
            // no longer have any effect.
            self.executeInterpreter(false, true);
            return self.lastCallbackRetVal;
          }
        }
      };
    };
  }

  var initFunc = function initFunc(interpreter, scope) {
    // Store Interpreter on JSInterpreter
    self.interpreter = interpreter;
    // Store globalScope on JSInterpreter
    self.globalScope = scope;
    // Override Interpreter's get/set Property functions with JSInterpreter
    interpreter.getProperty = self.getProperty.bind(self, interpreter, interpreter.getProperty);
    // Store this for later because we need to bypass our overriden function
    // in createGlobalProperty()
    self.baseSetProperty = interpreter.setProperty;
    interpreter.setProperty = self.setProperty.bind(self, interpreter, interpreter.setProperty);
    codegen.initJSInterpreter(interpreter, options.blocks, options.blockFilter, scope, options.globalFunctions);

    // Only allow five levels of depth when marshalling the return value
    // since we will occasionally return DOM Event objects which contain
    // properties that recurse over and over...
    var wrapper = codegen.makeNativeMemberFunction({
      interpreter: interpreter,
      nativeFunc: self.nativeGetCallback.bind(self),
      maxDepth: 5
    });
    interpreter.setProperty(scope, 'getCallback', interpreter.createNativeFunction(wrapper));

    wrapper = codegen.makeNativeMemberFunction({
      interpreter: interpreter,
      nativeFunc: self.nativeSetCallbackRetVal.bind(self)
    });
    interpreter.setProperty(scope, 'setCallbackRetVal', interpreter.createNativeFunction(wrapper));
  };

  try {
    // Return value will be stored as this.interpreter inside the supplied
    // initFunc() (other code in initFunc() depends on this.interpreter, so
    // we can't wait until the constructor returns)
    /* jshint nonew:false */
    new window.Interpreter(options.code, initFunc);
    /* jshint nonew:true */
  } catch (err) {
    this.executionError = err;
    this.handleError();
  }
};

/**
 * Init `this.codeInfo` with cumulative length info (used to locate breakpoints).
 * @param code
 */
JSInterpreter.prototype.calculateCodeInfo = function (code) {
  this.codeInfo = {};
  this.codeInfo.userCodeStartOffset = 0;
  this.codeInfo.userCodeLength = code.length;
  this.codeInfo.cumulativeLength = codegen.calculateCumulativeLength(code);
};

/**
 * Returns true if the JSInterpreter instance initialized successfully. This
 * would typically fail when the program contains a syntax error.
 */
JSInterpreter.prototype.initialized = function () {
  return !!this.interpreter;
};

/**
 * Detech the Interpreter instance. Call before releasing references to
 * JSInterpreter so any async callbacks will not execute.
 */
JSInterpreter.prototype.deinitialize = function () {
  this.interpreter = null;
};

JSInterpreter.StepType = {
  RUN: 0,
  IN: 1,
  OVER: 2,
  OUT: 3
};

/**
 * A miniature runtime in the interpreted world calls this function repeatedly
 * to check to see if it should invoke any callbacks from within the
 * interpreted world. If the eventQueue is not empty, we will return an object
 * that contains an interpreted callback function (stored in "fn") and,
 * optionally, callback arguments (stored in "arguments")
 */
JSInterpreter.prototype.nativeGetCallback = function () {
  this.startedHandlingEvents = true;
  var retVal = this.eventQueue.shift();
  if (typeof retVal === "undefined") {
    this['yield']();
  }
  return retVal;
};

JSInterpreter.prototype.nativeSetCallbackRetVal = function (retVal) {
  if (this.eventQueue.length === 0) {
    // If nothing else is in the event queue, then store this return value
    // away so it can be returned in the native event handler
    this.seenReturnFromCallbackDuringExecution = true;
    this.lastCallbackRetVal = retVal;
  }
  // Provide warnings to the user if this function has been called with a
  // meaningful return value while we are no longer in the native event handler

  // TODO (cpirich): Check to see if the DOM event object was modified
  // (preventDefault(), stopPropagation(), returnValue) and provide a similar
  // warning since these won't work as expected unless running atMaxSpeed
  if (!this.runUntilCallbackReturn && typeof this.lastCallbackRetVal !== 'undefined') {
    this.onExecutionWarning.notifyObservers("Function passed to onEvent() " + "has taken too long - the return value was ignored.");
    if (!this.shouldRunAtMaxSpeed()) {
      this.onExecutionWarning.notifyObservers("  (try moving the speed " + "slider to its maximum value)");
    }
  }
};

/**
 * Queue an event to be fired in the interpreter. The nativeArgs are optional.
 * The function must be an interpreter function object (not native).
 */
JSInterpreter.prototype.queueEvent = function (interpreterFunc, nativeArgs) {
  this.eventQueue.push({
    'fn': interpreterFunc,
    'arguments': nativeArgs ? Array.prototype.slice.call(nativeArgs) : []
  });
};

/**
 * Yield execution (causes executeInterpreter loop to break out if this is
 * called by APIs called by interpreted code)
 */
JSInterpreter.prototype['yield'] = function () {
  this.yieldExecution = true;
};

var StepType = JSInterpreter.StepType;

/**
 * Small helper to step the interpreter so that exception handler can exist outside
 * of the core executeInterpeter() function (improves browser JS engine performance)
 */
function safeStepInterpreter(jsi) {
  try {
    jsi.interpreter.step();
  } catch (err) {
    return err;
  }
}

/**
 * Find a bpRow from the "stopped at breakpoint" array by matching the scope
 *
 * @param {!Object} scope to match from the list
 * @param {number} [row] to match from the list - in addition to scope
 */
JSInterpreter.prototype.findStoppedAtBreakpointRow = function (scope, row) {
  for (var i = 0; i < this.stoppedAtBreakpointRows.length; i++) {
    var bpRow = this.stoppedAtBreakpointRows[i];
    if (bpRow.scope === scope) {
      if (typeof row === 'undefined' || row === bpRow.row) {
        return bpRow;
      }
    }
  }
};

/**
 * Replace a bpRow from the "stopped at breakpoint" array by matching
 * the scope.
 *
 * If no rows are found matching the given scope, a new one is introduced.
 *
 * @param {!Object} scope to match from the list
 * @param {!number} row to replace in the list.
 * @throws {TypeError} when given an invalid row.
 */
JSInterpreter.prototype.replaceStoppedAtBreakpointRowForScope = function (scope, row) {
  if (typeof row !== 'number' || row < 0) {
    throw new TypeError('Row ' + row + ' is not a valid row in user code.');
  }

  for (var i = 0; i < this.stoppedAtBreakpointRows.length; i++) {
    var bpRow = this.stoppedAtBreakpointRows[i];
    if (bpRow.scope === scope) {
      // Update row number
      bpRow.row = row;
      return;
    }
  }
  // Scope not found, insert new object in array:
  this.stoppedAtBreakpointRows.unshift({
    row: row,
    scope: scope
  });
};

/**
 * Remove a bpRow from the "stopped at breakpoint" array by matching
 * the scope.
 *
 * Does nothing if no rows are found matching the given scope.
 *
 * @param {!Object} scope to match from the list
 */
JSInterpreter.prototype.removeStoppedAtBreakpointRowForScope = function (scope) {
  for (var i = 0; i < this.stoppedAtBreakpointRows.length; i++) {
    var bpRow = this.stoppedAtBreakpointRows[i];
    if (bpRow.scope === scope) {
      // Remove from array
      this.stoppedAtBreakpointRows.splice(i, 1);
      return;
    }
  }
};

/**
 * Determines if the program is done executing.
 *
 * @return {boolean} true if program is complete (or an error has occurred).
 */
JSInterpreter.prototype.isProgramDone = function () {
  return this.executionError || !this.interpreter || !this.interpreter.stateStack.length;
};

/**
 * Nodes that are visited between expressions, signifying the previous
 * expression is done.
 */
var INTERSTITIAL_NODES = {
  Program: true,
  BlockStatement: true,
  SwitchStatement: true
};

/**
 * Execute the interpreter
 */
JSInterpreter.prototype.executeInterpreter = function (firstStep, runUntilCallbackReturn) {
  this.executeLoopDepth++;
  this.runUntilCallbackReturn = runUntilCallbackReturn;
  if (runUntilCallbackReturn) {
    delete this.lastCallbackRetVal;
  }
  this.yieldExecution = false;
  this.seenReturnFromCallbackDuringExecution = false;

  var atInitialBreakpoint = this.paused && this.nextStep === StepType.IN && firstStep;
  var atMaxSpeed = false;

  if (this.paused) {
    switch (this.nextStep) {
      case StepType.RUN:
        // Bail out here if in a break state (paused), but make sure that we still
        // have the next tick queued first, so we can resume after un-pausing):
        return;
      case StepType.OUT:
        // If we haven't yet set stepOutToStackDepth, work backwards through the
        // history of callExpressionSeenAtDepth until we find the one we want to
        // step out to - and store that in stepOutToStackDepth:
        if (this.interpreter && typeof this.stepOutToStackDepth === 'undefined') {
          this.stepOutToStackDepth = 0;
          for (var i = this.maxValidCallExpressionDepth; i > 0; i--) {
            if (this.callExpressionSeenAtDepth[i]) {
              this.stepOutToStackDepth = i;
              break;
            }
          }
        }
        break;
    }
  }

  var doneUserLine = false;
  var reachedBreak = false;
  var unwindingAfterStep = false;
  var inUserCode;
  var userCodeRow;

  // In each tick, we will step the interpreter multiple times in a tight
  // loop as long as we are interpreting code that the user can't see
  // (function aliases at the beginning, getCallback event loop at the end)
  for (var stepsThisTick = 0; stepsThisTick < this.maxInterpreterStepsPerTick || unwindingAfterStep; stepsThisTick++) {
    // Check this every time because the speed is allowed to change...
    atMaxSpeed = this.shouldRunAtMaxSpeed();
    // NOTE:
    // (1) When running with no source visible AND at max speed, always set
    //   `userCodeRow` to -1. We'll never hit a breakpoint or need to add delay.
    // (2) When running with no source visible OR at max speed, call a simple
    //   function to just get the line number. Need to check `inUserCode` to
    //   maybe stop at a breakpoint, or add a `speed(n)` delay.
    // (3) Otherwise call a function that also highlights the code.
    var selectCodeFunc;
    if (this.studioApp.hideSource && atMaxSpeed) {
      selectCodeFunc = function () {
        return -1;
      };
    } else if (this.studioApp.hideSource || atMaxSpeed) {
      selectCodeFunc = this.getUserCodeLine;
    } else {
      selectCodeFunc = this.selectCurrentCode;
    }
    var currentScope = this.interpreter.getScope();

    if (reachedBreak && !unwindingAfterStep || doneUserLine && !unwindingAfterStep && !atMaxSpeed || this.yieldExecution || this.interpreter.paused_ || runUntilCallbackReturn && this.seenReturnFromCallbackDuringExecution) {
      // stop stepping the interpreter and wait until the next tick once we:
      // (1) reached a breakpoint and are done unwinding OR
      // (2) completed a line of user code and are are done unwinding
      //     (while not running atMaxSpeed) OR
      // (3) we've been asked to yield our executeInterpeter() loop OR
      // (4) the interpreter is paused (handling a native async func that is
      //     going to block to return a value synchronously in the interpreter) OR
      // (5) have seen an empty event queue in nativeGetCallback (no events) OR
      // (6) have seen a nativeSetCallbackRetVal call in runUntilCallbackReturn mode
      break;
    }
    userCodeRow = selectCodeFunc.call(this);
    inUserCode = -1 !== userCodeRow;
    // Check to see if we've arrived at a new breakpoint:
    //  (1) should be in user code
    //  (2) should never happen while unwinding
    //  (3) should never happen when revisiting an interstitial node
    //  (4) requires either
    //   (a) atInitialBreakpoint OR
    //   (b) isAceBreakpointRow() AND not still at the same line number where
    //       we have already stopped from the last step/breakpoint
    if (inUserCode && !unwindingAfterStep && !this.atInterstitialNode && (atInitialBreakpoint || this.isBreakpointRow(userCodeRow) && !this.findStoppedAtBreakpointRow(currentScope, userCodeRow))) {
      // Yes, arrived at a new breakpoint:
      if (this.paused) {
        // Overwrite the nextStep value. (If we hit a breakpoint during a step
        // out or step over, this will cancel that step operation early)
        this.nextStep = StepType.RUN;
        this.onNextStepChanged.notifyObservers();
      } else {
        this.onPause.notifyObservers();
      }
      // Store some properties about where we stopped:
      this.replaceStoppedAtBreakpointRowForScope(currentScope, userCodeRow);

      // Mark reachedBreak to stop stepping, and start unwinding if needed:
      reachedBreak = true;
      unwindingAfterStep = codegen.isNextStepSafeWhileUnwinding(this.interpreter);
      continue;
    }
    // If we've moved past the place of the last breakpoint hit without being
    // deeper in the stack, we will discard the stoppedAtBreakpoint properties:
    if (inUserCode && !this.findStoppedAtBreakpointRow(currentScope, userCodeRow)) {
      this.removeStoppedAtBreakpointRowForScope(currentScope);
    }
    // If we're unwinding, continue to update the stoppedAtBreakpoint properties
    // to ensure that we have the right properties stored when the unwind completes:
    if (inUserCode && unwindingAfterStep) {
      this.replaceStoppedAtBreakpointRowForScope(currentScope, userCodeRow);
    }
    this.executionError = safeStepInterpreter(this);
    if (!this.executionError && this.interpreter.stateStack.length) {
      var state = this.interpreter.stateStack[0],
          nodeType = state.node.type;
      this.atInterstitialNode = INTERSTITIAL_NODES.hasOwnProperty(nodeType);
      if (inUserCode) {
        doneUserLine = doneUserLine || state.done || this.atInterstitialNode;
      }

      var stackDepth = this.interpreter.stateStack.length;
      // Remember the stack depths of call expressions (so we can implement 'step out')

      // Truncate any history of call expressions seen deeper than our current stack position:
      for (var depth = stackDepth + 1; depth <= this.maxValidCallExpressionDepth; depth++) {
        this.callExpressionSeenAtDepth[depth] = false;
      }
      this.maxValidCallExpressionDepth = stackDepth;

      if (inUserCode && this.interpreter.stateStack[0].node.type === "CallExpression") {
        // Store that we've seen a call expression at this depth in callExpressionSeenAtDepth:
        this.callExpressionSeenAtDepth[stackDepth] = true;
      }

      if (this.paused) {
        // Store the first call expression stack depth seen while in this step operation:
        if (inUserCode && this.interpreter.stateStack[0].node.type === "CallExpression") {
          if (typeof this.firstCallStackDepthThisStep === 'undefined') {
            this.firstCallStackDepthThisStep = stackDepth;
          }
        }

        // For the step in case, we want to stop the interpreter as soon as we enter the callee:
        if (!doneUserLine && inUserCode && this.nextStep === StepType.IN && stackDepth > this.firstCallStackDepthThisStep) {
          reachedBreak = true;
        }
        // After the interpreter says a node is "done" (meaning it is time to stop), we will
        // advance a little further to the start of the next statement. We achieve this by
        // continuing to set unwindingAfterStep to true to keep the loop going:
        if (doneUserLine || reachedBreak) {
          var wasUnwinding = unwindingAfterStep;
          // step() additional times if we know it to be safe to get us to the next statement:
          unwindingAfterStep = codegen.isNextStepSafeWhileUnwinding(this.interpreter);
          if (wasUnwinding && !unwindingAfterStep) {
            // done unwinding.. select code that is next to execute:
            userCodeRow = selectCodeFunc.call(this);
            inUserCode = -1 !== userCodeRow;
            if (!inUserCode) {
              // not in user code, so keep unwinding after all...
              unwindingAfterStep = true;
            }
          }
        }

        if ((reachedBreak || doneUserLine) && !unwindingAfterStep) {
          if (this.nextStep === StepType.OUT && stackDepth > this.stepOutToStackDepth) {
            // trying to step out, but we didn't get out yet... continue on.
          } else if (this.nextStep === StepType.OVER && typeof this.firstCallStackDepthThisStep !== 'undefined' && stackDepth > this.firstCallStackDepthThisStep) {
              // trying to step over, and we're in deeper inside a function call... continue next onTick
            } else {
                // Our step operation is complete, reset nextStep to StepType.RUN to
                // return to a normal 'break' state:
                this.nextStep = StepType.RUN;
                this.onNextStepChanged.notifyObservers();
                if (inUserCode) {
                  // Store some properties about where we stopped:
                  this.replaceStoppedAtBreakpointRowForScope(this.interpreter.getScope(), userCodeRow);
                }
                delete this.stepOutToStackDepth;
                delete this.firstCallStackDepthThisStep;
                break;
              }
        }
      }
    } else {
      if (this.executionError) {
        this.handleError(inUserCode ? userCodeRow + 1 : undefined);
      }
      this.executeLoopDepth--;
      return;
    }
  }
  if (reachedBreak && atMaxSpeed) {
    // If we were running atMaxSpeed and just reached a breakpoint, the
    // code may not be selected in the editor, so do it now:
    this.selectCurrentCode();
  }
  this.executeLoopDepth--;
};

/**
 * Helper that wraps some error preprocessing before we notify observers that
 * an execution error has occurred. Operates on the current error that is
 * already saved as this.executionError
 *
 * @param {number} [lineNumber]
 */
JSInterpreter.prototype.handleError = function (lineNumber) {
  if (!lineNumber && this.executionError instanceof SyntaxError) {
    // syntax errors came before execution (during parsing), so we need
    // to determine the proper line number by looking at the exception
    lineNumber = this.executionError.loc.line;
    // Now select this location in the editor, since we know we didn't hit
    // this while executing (in which case, it would already have been selected)
    codegen.selectEditorRowColError(this.studioApp.editor, lineNumber - 1, this.executionError.loc.column);
  }

  // Select code that just executed:
  this.selectCurrentCode("ace_error");
  // Grab line number if we don't have one already:
  if (!lineNumber) {
    lineNumber = 1 + this.getNearestUserCodeLine();
  }

  this.onExecutionError.notifyObservers(this.executionError, lineNumber);
};

/**
 * Helper to create an interpeter primitive value. Useful when extending the
 * interpreter without relying on codegen marshalling helpers.
 */
JSInterpreter.prototype.createPrimitive = function (data) {
  if (this.interpreter) {
    return this.interpreter.createPrimitive(data);
  }
};

/**
 * Wrapper to Interpreter's getProperty (extended for custom marshaling)
 *
 * Fetch a property value from a data object.
 * @param {!Object} interpeter Interpreter instance.
 * @param {!Function} baseGetProperty Original getProperty() implementation.
 * @param {!Object} obj Data object.
 * @param {*} name Name of property.
 * @return {!Object} Property value (may be UNDEFINED).
 */
JSInterpreter.prototype.getProperty = function (interpreter, baseGetProperty, obj, name) {
  name = name.toString();
  var nativeParent;
  if (obj.isCustomMarshal || obj === this.globalScope && !!(nativeParent = this.customMarshalGlobalProperties[name])) {
    var value;
    if (obj.isCustomMarshal) {
      value = obj.data[name];
    } else {
      value = nativeParent[name];
    }
    var type = typeof value;
    if (type === 'number' || type === 'boolean' || type === 'string' || type === 'undefined' || value === null) {
      return interpreter.createPrimitive(value);
    } else {
      return codegen.marshalNativeToInterpreter(interpreter, value, obj.data);
    }
  } else {
    return baseGetProperty.call(interpreter, obj, name);
  }
};

/**
 * Wrapper to Interpreter's setProperty (extended for custom marshaling)
 *
 * Set a property value on a data object.
 * @param {!Object} interpeter Interpreter instance.
 * @param {!Function} baseSetProperty Original setProperty() implementation.
 * @param {!Object} obj Data object.
 * @param {*} name Name of property.
 * @param {*} value New property value.
 * @param {boolean} opt_fixed Unchangeable property if true.
 * @param {boolean} opt_nonenum Non-enumerable property if true.
 */
JSInterpreter.prototype.setProperty = function (interpreter, baseSetProperty, obj, name, value, opt_fixed, opt_nonenum) {
  name = name.toString();
  var nativeParent;
  if (obj.isCustomMarshal) {
    obj.data[name] = codegen.marshalInterpreterToNative(interpreter, value);
  } else if (obj === this.globalScope && !!(nativeParent = this.customMarshalGlobalProperties[name])) {
    nativeParent[name] = codegen.marshalInterpreterToNative(interpreter, value);
  } else {
    return baseSetProperty.call(interpreter, obj, name, value, opt_fixed, opt_nonenum);
  }
};

/**
 * Selects code in droplet/ace editor.
 *
 * Returns the row (line) of code highlighted. If nothing is highlighted
 * because it is outside of the userCode area, the return value is -1
 */
JSInterpreter.prototype.selectCurrentCode = function (highlightClass) {
  if (this.studioApp.hideSource) {
    return -1;
  }
  return codegen.selectCurrentCode(this.interpreter, this.codeInfo.cumulativeLength, this.codeInfo.userCodeStartOffset, this.codeInfo.userCodeLength, this.studioApp.editor, highlightClass);
};

/**
 * Finds the current line of code in droplet/ace editor.
 *
 * Returns the line of code where the interpreter is at. If it is outside
 * of the userCode area, the return value is -1
 */
JSInterpreter.prototype.getUserCodeLine = function () {
  var userCodeRow = -1;
  if (this.interpreter.stateStack[0]) {
    var node = this.interpreter.stateStack[0].node;
    // Adjust start/end by userCodeStartOffset since the code running
    // has been expanded vs. what the user sees in the editor window:
    var start = node.start - this.codeInfo.userCodeStartOffset;

    // Only return a valid userCodeRow if the node being executed is inside the
    // user's code (not inside code we inserted before or after their code that
    // is not visible in the editor):
    if (start >= 0 && start < this.codeInfo.userCodeLength) {
      userCodeRow = codegen.aceFindRow(this.codeInfo.cumulativeLength, 0, this.codeInfo.cumulativeLength.length, start);
    }
  }
  return userCodeRow;
};

/**
 * Finds the current line of code in droplet/ace editor. Walks up the stack if
 * not currently in the user code area.
 */
JSInterpreter.prototype.getNearestUserCodeLine = function () {
  if (this.studioApp.hideSource) {
    return -1;
  }
  var userCodeRow = -1;
  for (var i = 0; i < this.interpreter.stateStack.length; i++) {
    var node = this.interpreter.stateStack[i].node;
    // Adjust start/end by userCodeStartOffset since the code running
    // has been expanded vs. what the user sees in the editor window:
    var start = node.start - this.codeInfo.userCodeStartOffset;

    // Only return a valid userCodeRow if the node being executed is inside the
    // user's code (not inside code we inserted before or after their code that
    // is not visible in the editor):
    if (start >= 0 && start < this.codeInfo.userCodeLength) {
      userCodeRow = codegen.aceFindRow(this.codeInfo.cumulativeLength, 0, this.codeInfo.cumulativeLength.length, start);
      break;
    }
  }
  return userCodeRow;
};

/**
 * Creates a property in the interpreter's global scope. When a parent is
 * supplied and that parent object is in codegen's customMarshalObjectList,
 * property gets/sets in the interpreter will be reflected on the native parent
 * object. Functions can also be inserted into the global namespace using this
 * method. If a parent is supplied, they will be invoked natively with that
 * parent as the this parameter.
 *
 * @param {String} name Name for the property in the global scope.
 * @param {*} value Native value that will be marshalled to the interpreter.
 * @param {Object} parent (Optional) parent for the native value.
 */
JSInterpreter.prototype.createGlobalProperty = function (name, value, parent) {

  var interpreterVal;
  if (typeof value === 'function') {
    var wrapper = codegen.makeNativeMemberFunction({
      interpreter: this.interpreter,
      nativeFunc: value,
      nativeParentObj: parent
    });
    interpreterVal = this.interpreter.createNativeFunction(wrapper);
  } else {
    interpreterVal = codegen.marshalNativeToInterpreter(this.interpreter, value, utils.valueOr(parent, window));
  }

  // Bypass setProperty since we've hooked it and it will not create the
  // property if it is in customMarshalGlobalProperties
  this.baseSetProperty.call(this.interpreter, this.globalScope, name, interpreterVal);
};

/**
 * Returns the interpreter function object corresponding to 'funcName' if a
 * function with that name is found in the interpreter's global scope.
 */
JSInterpreter.prototype.findGlobalFunction = function (funcName) {
  var funcObj = this.interpreter.getProperty(this.globalScope, funcName);
  if (funcObj.type === 'function') {
    return funcObj;
  }
};

/**
 * Returns an array containing the names of all of the global functions
 * in the interpreter's global scope. Built-in global functions are excluded.
 */
JSInterpreter.prototype.getGlobalFunctionNames = function () {
  var builtInExclusionList = ["eval", "getCallback", "setCallbackRetVal"];

  var names = [];
  for (var objName in this.globalScope.properties) {
    var object = this.globalScope.properties[objName];
    if (object.type === 'function' && !object.nativeFunc && builtInExclusionList.indexOf(objName) === -1) {
      names.push(objName);
    }
  }
  return names;
};

/**
 * Returns an array containing the names of all of the functions defined
 * inside other functions.
 */
JSInterpreter.prototype.getLocalFunctionNames = function (scope) {
  if (!scope) {
    scope = this.globalScope;
  }
  var names = [];
  for (var objName in scope.properties) {
    var object = scope.properties[objName];
    if (object.type === 'function' && !object.nativeFunc && object.node) {
      if (scope !== this.globalScope) {
        names.push(objName);
      }
      var localScope = this.interpreter.createScope(object.node.body, object.parentScope);
      var localNames = this.getLocalFunctionNames(localScope);
      names = names.concat(localNames);
    }
  }
  return names;
};

/**
 * Returns the current interpreter state object.
 */
JSInterpreter.prototype.getCurrentState = function () {
  return this.interpreter && this.interpreter.stateStack[0];
};

/**
 * Evaluate an expression in the interpreter's current scope, and return the
 * value of the evaluated expression.
 * @param {!string} expression
 * @returns {?} value of the expression
 * @throws if there's a problem evaluating the expression
 */
JSInterpreter.prototype.evalInCurrentScope = function (expression) {
  var currentScope = this.interpreter.getScope();
  var evalInterpreter = new window.Interpreter(expression);
  // Set scope to the current scope of the running program
  // NOTE: we are being a little tricky here (we are re-running
  // part of the Interpreter constructor with a different interpreter's
  // scope)
  evalInterpreter.populateScope_(evalInterpreter.ast, currentScope);
  evalInterpreter.stateStack = [{
    node: evalInterpreter.ast,
    scope: currentScope,
    thisExpression: currentScope
  }];
  // Copy these properties directly into the evalInterpreter so the .isa()
  // method behaves as expected
  ['ARRAY', 'BOOLEAN', 'DATE', 'FUNCTION', 'NUMBER', 'OBJECT', 'STRING', 'UNDEFINED'].forEach(function (prop) {
    evalInterpreter[prop] = this.interpreter[prop];
  }, this);

  // Patch getProperty and setProperty to enable custom marshalling
  evalInterpreter.getProperty = this.getProperty.bind(this, evalInterpreter, evalInterpreter.getProperty);
  evalInterpreter.setProperty = this.setProperty.bind(this, evalInterpreter, evalInterpreter.setProperty);

  // run() may throw if there's a problem in the expression
  evalInterpreter.run();
  return evalInterpreter.value;
};

},{"./ObservableEvent":"/home/ubuntu/staging/apps/build/js/ObservableEvent.js","./codegen":"/home/ubuntu/staging/apps/build/js/codegen.js","./utils":"/home/ubuntu/staging/apps/build/js/utils.js"}],"/home/ubuntu/staging/apps/build/js/codegen.js":[function(require,module,exports){
/* global Interpreter, CanvasPixelArray, ace */

'use strict';

var dropletUtils = require('./dropletUtils');
var utils = require('./utils');

/**
 * Evaluates a string of code parameterized with a dictionary.
 */
exports.evalWith = function (code, options) {
  if (options.StudioApp && options.StudioApp.editCode) {
    // Use JS interpreter on editCode levels
    var initFunc = function initFunc(interpreter, scope) {
      exports.initJSInterpreter(interpreter, null, null, scope, options);
    };
    var myInterpreter = new Interpreter(code, initFunc);
    // interpret the JS program all at once:
    myInterpreter.run();
  } else {
    // execute JS code "natively"
    var params = [];
    var args = [];
    for (var k in options) {
      params.push(k);
      args.push(options[k]);
    }
    params.push(code);
    var ctor = function ctor() {
      return Function.apply(this, params);
    };
    ctor.prototype = Function.prototype;
    return new ctor().apply(null, args);
  }
};

/**
 * Returns a function based on a string of code parameterized with a dictionary.
 */
exports.functionFromCode = function (code, options) {
  if (options.StudioApp && options.StudioApp.editCode) {
    // Since this returns a new native function, it doesn't make sense in the
    // editCode case (we assume that the app will be using JSInterpreter)
    throw "Unexpected";
  } else {
    var params = [];
    var args = [];
    for (var k in options) {
      params.push(k);
      args.push(options[k]);
    }
    params.push(code);
    var ctor = function ctor() {
      return Function.apply(this, params);
    };
    ctor.prototype = Function.prototype;
    return new ctor();
  }
};

//
// Blockly specific codegen functions:
//

var INFINITE_LOOP_TRAP = '  executionInfo.checkTimeout(); if (executionInfo.isTerminated()){return;}\n';

var LOOP_HIGHLIGHT = 'loopHighlight();\n';
var LOOP_HIGHLIGHT_RE = new RegExp(LOOP_HIGHLIGHT.replace(/\(.*\)/, '\\(.*\\)'), 'g');

/**
 * Returns javascript code to call a timeout check
 */
exports.loopTrap = function () {
  return INFINITE_LOOP_TRAP;
};

exports.loopHighlight = function (apiName, blockId) {
  var args = "'block_id_" + blockId + "'";
  if (blockId === undefined) {
    args = "%1";
  }
  return apiName + '.' + LOOP_HIGHLIGHT.replace('()', '(' + args + ')');
};

/**
 * Extract the user's code as raw JavaScript.
 * @param {string} code Generated code.
 * @return {string} The code without serial numbers and timeout checks.
 */
exports.strip = function (code) {
  return code
  // Strip out serial numbers.
  .replace(/(,\s*)?'block_id_\d+'\)/g, ')')
  // Remove timeouts.
  .replace(INFINITE_LOOP_TRAP, '')
  // Strip out loop highlight
  .replace(LOOP_HIGHLIGHT_RE, '')
  // Strip out class namespaces.
  .replace(/(StudioApp|Maze|Turtle)\./g, '')
  // Strip out particular helper functions.
  .replace(/^function (colour_random)[\s\S]*?^}/gm, '')
  // Collapse consecutive blank lines.
  .replace(/\n\n+/gm, '\n\n')
  // Trim.
  .replace(/^\s+|\s+$/g, '');
};

/**
 * Extract the user's code as raw JavaScript.
 */
exports.workspaceCode = function (blockly) {
  var code = blockly.Generator.blockSpaceToCode('JavaScript', null, false);
  return exports.strip(code);
};

//
// Property access wrapped in try/catch. This is in an indepedendent function
// so the JIT compiler can optimize the calling function.
//

function safeReadProperty(object, property) {
  try {
    return object[property];
  } catch (e) {}
}

//
// Marshal a single native object from native to interpreter. This is in an
// indepedendent function so the JIT compiler can optimize the calling function.
// (Chrome V8 says ForInStatement is not fast case)
//

/**
 * Marshal a native object to an interpreter object.
 *
 * @param {Interpreter} interpreter Interpreter instance
 * @param {Object} nativeObject Object to marshal
 * @param {Number} maxDepth Optional maximum depth to traverse in properties
 * @param {Object} interpreterObject Optional existing interpreter object
 * @return {!Object} The interpreter object, which was created if needed.
 */
function marshalNativeToInterpreterObject(interpreter, nativeObject, maxDepth, interpreterObject) {
  var retVal = interpreterObject || interpreter.createObject(interpreter.OBJECT);
  var isFunc = interpreter.isa(retVal, interpreter.FUNCTION);
  for (var prop in nativeObject) {
    var value = safeReadProperty(nativeObject, prop);
    if (isFunc && (value === Function.prototype.trigger || value === Function.prototype.inherits)) {
      // Don't marshal these that were added by jquery or else we will recurse
      continue;
    }
    interpreter.setProperty(retVal, prop, exports.marshalNativeToInterpreter(interpreter, value, nativeObject, maxDepth));
  }
  return retVal;
}

function isCanvasImageData(nativeVar) {
  // IE 9/10 don't know about Uint8ClampedArray and call it CanvasPixelArray instead
  if (typeof Uint8ClampedArray !== "undefined") {
    return nativeVar instanceof Uint8ClampedArray;
  }
  return nativeVar instanceof CanvasPixelArray;
}

/**
 * Create a new "custom marshal" interpreter object that corresponds to a native
 * object.
 * @param {Interpreter} interpreter Interpreter instance
 * @param {Object} nativeObj Object to wrap
 * @param {Object} nativeParentObj Parent of object to wrap
 * @return {!Object} New interpreter object.
 */
var createCustomMarshalObject = function createCustomMarshalObject(interpreter, nativeObj, nativeParentObj) {
  if (nativeObj === undefined && interpreter.UNDEFINED) {
    return interpreter.UNDEFINED; // Reuse the same object.
  }
  var type = typeof nativeObj;
  var obj = {
    data: nativeObj,
    isPrimitive: false,
    isCustomMarshal: true,
    type: typeof nativeObj,
    parent: nativeParentObj, // TODO (cpirich): replace with interpreter object?
    toBoolean: function toBoolean() {
      return Boolean(this.data);
    },
    toNumber: function toNumber() {
      return Number(this.data);
    },
    toString: function toString() {
      return String(this.data);
    },
    valueOf: function valueOf() {
      return this.data;
    }
  };
  return obj;
};

exports.customMarshalObjectList = [];
exports.asyncFunctionList = [];
exports.nativeCallsInterpreterFunctionList = [];

// If this is on our list of "custom marshal" objects - or if it a property
// on one of those objects (other than a function), return true

var shouldCustomMarshalObject = function shouldCustomMarshalObject(nativeVar, nativeParentObj) {
  for (var i = 0; i < exports.customMarshalObjectList.length; i++) {
    var marshalObj = exports.customMarshalObjectList[i];
    if (nativeVar instanceof marshalObj.instance && (typeof marshalObj.requiredMethod === 'undefined' || nativeVar[marshalObj.requiredMethod] !== undefined) || typeof nativeVar !== 'function' && nativeParentObj instanceof marshalObj.instance) {
      return true;
    }
  }
  return false;
};

// When marshaling methods on "custom marshal" objects, we may need to augment
// the marshaling options. This returns those options.

var getCustomMarshalMethodOptions = function getCustomMarshalMethodOptions(nativeParentObj) {
  for (var i = 0; i < exports.customMarshalObjectList.length; i++) {
    var marshalObj = exports.customMarshalObjectList[i];
    if (nativeParentObj instanceof marshalObj.instance) {
      if (typeof marshalObj.requiredMethod === 'undefined' || nativeParentObj[marshalObj.requiredMethod] !== undefined) {
        return marshalObj.methodOpts || {};
      } else {
        return {};
      }
    }
  }
  return {};
};

//
// Droplet/JavaScript/Interpreter codegen functions:
//
exports.marshalNativeToInterpreter = function (interpreter, nativeVar, nativeParentObj, maxDepth) {
  if (maxDepth === 0 || typeof nativeVar === 'undefined') {
    return interpreter.UNDEFINED;
  }
  var i, retVal;
  if (typeof maxDepth === "undefined") {
    maxDepth = Infinity; // default to infinite levels of depth
  }
  if (shouldCustomMarshalObject(nativeVar, nativeParentObj)) {
    return createCustomMarshalObject(interpreter, nativeVar, nativeParentObj);
  }
  if (nativeVar instanceof Array) {
    retVal = interpreter.createObject(interpreter.ARRAY);
    for (i = 0; i < nativeVar.length; i++) {
      retVal.properties[i] = exports.marshalNativeToInterpreter(interpreter, nativeVar[i], null, maxDepth - 1);
    }
    retVal.length = nativeVar.length;
  } else if (isCanvasImageData(nativeVar)) {
    // Special case for canvas image data - could expand to support TypedArray
    retVal = interpreter.createObject(interpreter.ARRAY);
    for (i = 0; i < nativeVar.length; i++) {
      retVal.properties[i] = interpreter.createPrimitive(nativeVar[i]);
    }
    retVal.length = nativeVar.length;
  } else if (nativeVar instanceof Function) {
    var makeNativeOpts = {
      interpreter: interpreter,
      nativeFunc: nativeVar,
      nativeParentObj: nativeParentObj
    };
    if (exports.asyncFunctionList.indexOf(nativeVar) !== -1) {
      // Mark if this should be nativeIsAsync:
      makeNativeOpts.nativeIsAsync = true;
    }
    if (exports.nativeCallsInterpreterFunctionList.indexOf(nativeVar) !== -1) {
      // Mark if this should be nativeCallsBackInterpreter:
      makeNativeOpts.nativeCallsBackInterpreter = true;
    }
    var extraOpts = getCustomMarshalMethodOptions(nativeParentObj);
    // Add extra options if the parent of this function is in our custom marshal
    // modified object list:
    for (var prop in extraOpts) {
      makeNativeOpts[prop] = extraOpts[prop];
    }
    var wrapper = exports.makeNativeMemberFunction(makeNativeOpts);
    if (makeNativeOpts.nativeIsAsync) {
      retVal = interpreter.createAsyncFunction(wrapper);
    } else {
      retVal = interpreter.createNativeFunction(wrapper);
    }
    // Also marshal properties on the native function object:
    marshalNativeToInterpreterObject(interpreter, nativeVar, maxDepth - 1, retVal);
  } else if (nativeVar instanceof Object) {
    // note Object must be checked after Function and Array (since they are also Objects)
    if (interpreter.isa(nativeVar, interpreter.FUNCTION)) {
      // Special case to see if we are trying to marshal an interpreter object
      // (this currently happens when we store interpreter function objects in native
      //  and return them back in nativeGetCallback)

      // NOTE: this check could be expanded to check for other interpreter object types
      // if we have reason to believe that we may be passing those back

      retVal = nativeVar;
    } else {
      retVal = marshalNativeToInterpreterObject(interpreter, nativeVar, maxDepth - 1);
    }
  } else {
    retVal = interpreter.createPrimitive(nativeVar);
  }
  return retVal;
};

exports.createNativeFunctionFromInterpreterFunction = null;

exports.marshalInterpreterToNative = function (interpreter, interpreterVar) {
  if (interpreterVar.isPrimitive || interpreterVar.isCustomMarshal) {
    return interpreterVar.data;
  } else if (interpreter.isa(interpreterVar, interpreter.ARRAY)) {
    var nativeArray = [];
    nativeArray.length = interpreterVar.length;
    for (var i = 0; i < nativeArray.length; i++) {
      nativeArray[i] = exports.marshalInterpreterToNative(interpreter, interpreterVar.properties[i]);
    }
    return nativeArray;
  } else if (interpreter.isa(interpreterVar, interpreter.OBJECT) || interpreterVar.type === 'object') {
    var nativeObject = {};
    for (var prop in interpreterVar.properties) {
      nativeObject[prop] = exports.marshalInterpreterToNative(interpreter, interpreterVar.properties[prop]);
    }
    return nativeObject;
  } else if (interpreter.isa(interpreterVar, interpreter.FUNCTION)) {
    if (exports.createNativeFunctionFromInterpreterFunction) {
      return exports.createNativeFunctionFromInterpreterFunction(interpreterVar);
    } else {
      // Just return the interpreter object if we can't convert it. This is needed
      // for passing interpreter callback functions into native.

      return interpreterVar;
    }
  } else {
    throw "Can't marshal type " + typeof interpreterVar;
  }
};

/**
 * Generate a function wrapper for an interpreter async function callback.
 * The interpreter async function callback takes a single parameter, which
 * becomes the return value of the synchronous function in the interpreter
 * world. Here, we wrap the supplied callback to marshal the single parameter
 * from native to interpreter before calling the supplied callback.
 *
 * @param {Object} opts Options block with interpreter and maxDepth provided
 * @param {function} callback The interpreter supplied callback function
 */
var createNativeCallbackForAsyncFunction = function createNativeCallbackForAsyncFunction(opts, callback) {
  return function (nativeValue) {
    callback(exports.marshalNativeToInterpreter(opts.interpreter, nativeValue, null, opts.maxDepth));
  };
};

/**
 * Generate a function wrapper for an interpreter callback that will be
 * invoked by a special native function that can execute these callbacks inline
 * on the interpreter stack.
 *
 * @param {Object} opts Options block with interpreter and maxDepth provided
 * @param {function} intFunc The interpreter supplied callback function
 */
var createNativeInterpreterCallback = function createNativeInterpreterCallback(opts, intFunc) {
  return function (nativeValue) {
    var args = Array.prototype.slice.call(arguments);
    var intArgs = [];
    for (var i = 0; i < args.length; i++) {
      intArgs[i] = exports.marshalNativeToInterpreter(opts.interpreter, args[i], null, opts.maxDepth);
    }
    // Shift a CallExpression node on the stack that already has its func_,
    // arguments, and other state populated:
    var state = {
      node: {
        type: 'CallExpression',
        arguments: intArgs /* this just needs to be array of the same size */
      },
      doneCallee_: true,
      func_: intFunc,
      arguments: intArgs,
      n_: intArgs.length
    };
    opts.interpreter.stateStack.unshift(state);
  };
};

/**
 * Generate a native function wrapper for use with the JS interpreter.
 */
exports.makeNativeMemberFunction = function (opts) {
  if (opts.dontMarshal) {
    return function () {
      // Just call the native function and marshal the return value:
      var nativeRetVal = opts.nativeFunc.apply(opts.nativeParentObj, arguments);
      return exports.marshalNativeToInterpreter(opts.interpreter, nativeRetVal, null, opts.maxDepth);
    };
  } else {
    return function () {
      // Call the native function after marshalling parameters:
      var nativeArgs = [];
      for (var i = 0; i < arguments.length; i++) {
        if (opts.nativeIsAsync && i === arguments.length - 1) {
          // Async functions receive a native callback method as their last
          // parameter, and we want to wrap that callback to ease marshalling:
          nativeArgs[i] = createNativeCallbackForAsyncFunction(opts, arguments[i]);
        } else if (opts.nativeCallsBackInterpreter && typeof arguments[i] === 'object' && opts.interpreter.isa(arguments[i], opts.interpreter.FUNCTION)) {
          // A select class of native functions is aware of the interpreter and
          // capable of calling the interpreter on the stack immediately. We
          // marshal these differently:
          nativeArgs[i] = createNativeInterpreterCallback(opts, arguments[i]);
        } else {
          nativeArgs[i] = exports.marshalInterpreterToNative(opts.interpreter, arguments[i]);
        }
      }
      var nativeRetVal = opts.nativeFunc.apply(opts.nativeParentObj, nativeArgs);
      return exports.marshalNativeToInterpreter(opts.interpreter, nativeRetVal, null, opts.maxDepth);
    };
  }
};

function populateFunctionsIntoScope(interpreter, scope, funcsObj, parentObj, options) {
  for (var prop in funcsObj) {
    var func = funcsObj[prop];
    if (func instanceof Function) {
      // Populate the scope with native functions
      // NOTE: other properties are not currently passed to the interpreter
      var parent = parentObj ? parentObj : funcsObj;
      var wrapper = exports.makeNativeMemberFunction(utils.extend(options, {
        interpreter: interpreter,
        nativeFunc: func,
        nativeParentObj: parent
      }));
      interpreter.setProperty(scope, prop, interpreter.createNativeFunction(wrapper));
    }
  }
}

function populateGlobalFunctions(interpreter, blocks, blockFilter, scope) {
  for (var i = 0; i < blocks.length; i++) {
    var block = blocks[i];
    if (block.parent && (!blockFilter || typeof blockFilter[block.func] !== 'undefined')) {
      var funcScope = scope;
      var funcName = block.func;
      var funcComponents = funcName.split('.');
      if (funcComponents.length === 2) {
        // Special accommodation for Object.function syntax (2 components only):
        var objName = funcComponents[0];
        // Find or create global object named 'objName' and make it the scope:
        funcScope = interpreter.getProperty(scope, objName);
        if (interpreter.UNDEFINED === funcScope) {
          funcScope = interpreter.createObject(interpreter.OBJECT);
          interpreter.setProperty(scope, objName, funcScope);
        }
        funcName = funcComponents[1];
      }
      var func = block.parent[funcName];
      var wrapper = exports.makeNativeMemberFunction({
        interpreter: interpreter,
        nativeFunc: func,
        nativeParentObj: block.parent,
        dontMarshal: block.dontMarshal,
        nativeIsAsync: block.nativeIsAsync
      });
      var intFunc;
      if (block.nativeIsAsync) {
        intFunc = interpreter.createAsyncFunction(wrapper);
      } else {
        intFunc = interpreter.createNativeFunction(wrapper);
      }
      interpreter.setProperty(funcScope, funcName, intFunc);
    }
  }
}

function populateJSFunctions(interpreter) {
  // The interpreter is missing some basic JS functions. Add them as needed:
  var wrapper;

  // Add static methods from String:
  var functions = ['fromCharCode'];
  for (var i = 0; i < functions.length; i++) {
    wrapper = exports.makeNativeMemberFunction({
      interpreter: interpreter,
      nativeFunc: String[functions[i]],
      nativeParentObj: String
    });
    interpreter.setProperty(interpreter.STRING, functions[i], interpreter.createNativeFunction(wrapper), false, true);
  }

  // Add String.prototype.includes
  wrapper = function (searchStr) {
    // Polyfill based off of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
    return interpreter.createPrimitive(String.prototype.indexOf.apply(this, arguments) !== -1);
  };
  interpreter.setProperty(interpreter.STRING.properties.prototype, 'includes', interpreter.createNativeFunction(wrapper), false, true);
}

/**
 * Initialize a JS interpreter.
 *
 * interpreter (required): JS interpreter instance.
 * blocks (optional): blocks in dropletConfig.blocks format. If a block has
 *  a parent property, we will populate that function into the specified scope.
 * blockFilter (optional): an object with block-name keys that should be used
 *  to filter which blocks are populated.
 * scope (required): interpreter's global scope.
 * globalObjects (optional): objects containing functions to placed in a new scope
 *  created beneath the supplied scope.
 */
exports.initJSInterpreter = function (interpreter, blocks, blockFilter, scope, globalObjects) {
  for (var globalObj in globalObjects) {
    // The globalObjects object contains objects that will be referenced
    // by the code we plan to execute. Since these objects exist in the native
    // world, we need to create associated objects in the interpreter's world
    // so the interpreted code can call out to these native objects

    // Create global objects in the interpreter for everything in options
    var obj = interpreter.createObject(interpreter.OBJECT);
    interpreter.setProperty(scope, globalObj.toString(), obj);
    // Marshal return values with a maxDepth of 2 (just an object and its child
    // methods and properties only)
    populateFunctionsIntoScope(interpreter, obj, globalObjects[globalObj], null, { maxDepth: 2 });
  }
  populateGlobalFunctions(interpreter, dropletUtils.dropletGlobalConfigBlocks, blockFilter, scope);
  if (blocks) {
    populateGlobalFunctions(interpreter, blocks, blockFilter, scope);
  }
  populateJSFunctions(interpreter);
};

/**
 * Check to see if it is safe to step the interpreter while we are unwinding.
 * (Called repeatedly after completing a step where the node was marked 'done')
 */
exports.isNextStepSafeWhileUnwinding = function (interpreter) {
  var state = interpreter.stateStack[0];
  var type = state.node.type;
  if (state.done) {
    return true;
  }
  if (type === "SwitchStatement") {
    // Safe to skip over SwitchStatement's except the very start (before a
    // switchValue has been set):
    return typeof state.switchValue !== 'undefined';
  }
  if (type === "VariableDeclaration") {
    // Only stop the first time this VariableDeclaration is processed (the
    // interpreter will stop on this node multiple times, but with different
    // `state.n` representing which VariableDeclarator is being executed).
    return state.n > 0;
  }
  switch (type) {
    // Declarations:
    case "VariableDeclarator":
    // Statements:
    case "BlockStatement":
    case "BreakStatement":
    // All Expressions:
    case "ThisExpression":
    case "ArrayExpression":
    case "ObjectExpression":
    case "ArrowExpression":
    case "SequenceExpression":
    case "UnaryExpression":
    case "BinaryExpression":
    case "UpdateExpression":
    case "LogicalExpression":
    case "ConditionalExpression":
    case "NewExpression":
    case "CallExpression":
    case "MemberExpression":
    case "FunctionExpression":
    case "AssignmentExpression":
    // Other:
    case "Identifier":
    case "Literal":
    case "Program":
      return true;
  }
  return false;
};

// session is an instance of Ace editSession
// Usage
// var lengthArray = calculateCumulativeLength(editor.getSession());
// Need to call this only if the document is updated after the last call.
exports.calculateCumulativeLength = function (code) {
  var regex = /\n/g,
      result = [];
  do {
    result.push(regex.lastIndex);
    regex.exec(code);
  } while (regex.lastIndex !== 0);

  result.push(code.length + 1);
  return result;
};

// Fast binary search implementation
// Pass the cumulative length array here.
// Usage
// var row = aceFindRow(lengthArray, 0, lengthArray.length, 2512);
// tries to find 2512th character lies in which row.
exports.aceFindRow = function (cumulativeLength, rows, rowe, pos) {
  if (rows > rowe) {
    return null;
  }
  if (rows + 1 === rowe) {
    return rows;
  }

  var mid = Math.floor((rows + rowe) / 2);

  if (pos < cumulativeLength[mid]) {
    return exports.aceFindRow(cumulativeLength, rows, mid, pos);
  } else if (pos > cumulativeLength[mid]) {
    return exports.aceFindRow(cumulativeLength, mid, rowe, pos);
  }
  return mid;
};

exports.isAceBreakpointRow = function (session, userCodeRow) {
  if (!session) {
    return false;
  }
  var bps = session.getBreakpoints();
  return Boolean(bps[userCodeRow]);
};

var lastHighlightMarkerIds = {};

/**
 * Clears all highlights that we have added in the ace editor.
 */
function clearAllHighlightedAceLines(aceEditor) {
  var session = aceEditor.getSession();
  for (var hlClass in lastHighlightMarkerIds) {
    session.removeMarker(lastHighlightMarkerIds[hlClass]);
  }
  lastHighlightMarkerIds = {};
}

/**
 * Highlights lines in the ace editor. Always moves the previous highlight with
 * the same class to the new location.
 *
 * If the row parameters are not supplied, just clear the last highlight.
 */
function highlightAceLines(aceEditor, className, startRow, startColumn, endRow, endColumn) {
  var session = aceEditor.getSession();
  className = className || 'ace_step';
  if (lastHighlightMarkerIds[className]) {
    session.removeMarker(lastHighlightMarkerIds[className]);
    lastHighlightMarkerIds[className] = null;
  }
  if (typeof startRow !== 'undefined') {
    lastHighlightMarkerIds[className] = session.addMarker(new (window.ace.require('ace/range').Range)(startRow, startColumn, endRow, endColumn), className, 'text');
    if (!aceEditor.isRowFullyVisible(startRow)) {
      aceEditor.scrollToLine(startRow, true);
    }
  }
}

/**
 * Selects and highlights code in droplet/ace editor to indicate an error.
 *
 * This function simply highlights one spot, not a range. It is typically used
 * to highlight where an error has occurred.
 */
exports.selectEditorRowColError = function (editor, row, col) {
  if (!editor) {
    return;
  }
  if (editor.currentlyUsingBlocks) {
    var style = { color: '#FFFF22' };
    editor.clearLineMarks();
    editor.markLine(row, style);
  } else {
    var selection = editor.aceEditor.getSelection();
    var range = selection.getRange();

    range.start.row = row;
    range.start.column = col;
    range.end.row = row;
    range.end.column = col + 1;

    // setting with the backwards parameter set to true - this prevents horizontal
    // scrolling to the right
    selection.setSelectionRange(range, true);
  }
  lastHighlightMarkerIds.ace_error = editor.aceEditor.getSession().highlightLines(row, row, 'ace_error').id;
};

/**
 * Removes highlights (for the default ace_step class) and selection in
 * droplet and ace editors.
 *
 * @param {boolean} allClasses When set to true, remove all classes of
 * highlights (including ace_step, ace_error, and anything else)
 */
exports.clearDropletAceHighlighting = function (editor, allClasses) {
  if (editor.currentlyUsingBlocks) {
    editor.clearLineMarks();
  } else {
    editor.aceEditor.getSelection().clearSelection();
  }
  if (allClasses) {
    clearAllHighlightedAceLines(editor.aceEditor);
  } else {
    // when calling without a class or rows, highlightAceLines() will clear
    // everything highlighted with the default highlight class
    highlightAceLines(editor.aceEditor);
  }
};

function selectAndHighlightCode(aceEditor, cumulativeLength, start, end, highlightClass) {
  var selection = aceEditor.getSelection();
  var range = selection.getRange();

  range.start.row = exports.aceFindRow(cumulativeLength, 0, cumulativeLength.length, start);
  range.start.column = start - cumulativeLength[range.start.row];
  range.end.row = exports.aceFindRow(cumulativeLength, 0, cumulativeLength.length, end);
  range.end.column = end - cumulativeLength[range.end.row];

  highlightAceLines(aceEditor, highlightClass || "ace_step", range.start.row, range.start.column, range.end.row, range.end.column);
}

/**
 * Selects code in droplet/ace editor.
 *
 * Returns the row (line) of code highlighted. If nothing is highlighted
 * because it is outside of the userCode area, the return value is -1
 *
 * @param {string} highlightClass CSS class to use when highlighting in ACE
 */
exports.selectCurrentCode = function (interpreter, cumulativeLength, userCodeStartOffset, userCodeLength, editor, highlightClass) {
  var userCodeRow = -1;
  if (interpreter && interpreter.stateStack[0]) {
    var node = interpreter.stateStack[0].node;

    if (node.type === 'ForStatement') {
      var mode = interpreter.stateStack[0].mode || 0,
          subNode;
      if (mode === 0) {
        subNode = node.init;
      } else if (mode === 1) {
        subNode = node.test;
      } else if (mode === 2) {
        subNode = node.body;
      } else if (mode === 3) {
        subNode = node.update;
      }
      node = subNode || node;
    }

    // Adjust start/end by userCodeStartOffset since the code running
    // has been expanded vs. what the user sees in the editor window:
    var start = node.start - userCodeStartOffset;
    var end = node.end - userCodeStartOffset;

    // Only show selection if the node being executed is inside the user's
    // code (not inside code we inserted before or after their code that is
    // not visible in the editor):
    if (start >= 0 && start < userCodeLength && end <= userCodeLength) {
      userCodeRow = exports.aceFindRow(cumulativeLength, 0, cumulativeLength.length, start);
      // Highlight the code being executed in each step:
      if (editor.currentlyUsingBlocks) {
        var style = { color: '#FFFF22' };
        editor.clearLineMarks();
        editor.mark({ row: userCodeRow, col: start - cumulativeLength[userCodeRow] }, style);
      } else {
        selectAndHighlightCode(editor.aceEditor, cumulativeLength, start, end, highlightClass);
      }
    } else {
      exports.clearDropletAceHighlighting(editor);
    }
  } else {
    exports.clearDropletAceHighlighting(editor);
  }
  return userCodeRow;
};

},{"./dropletUtils":"/home/ubuntu/staging/apps/build/js/dropletUtils.js","./utils":"/home/ubuntu/staging/apps/build/js/utils.js"}],"/home/ubuntu/staging/apps/build/js/dropletUtils.js":[function(require,module,exports){
'use strict';

var utils = require('./utils');
var _ = utils.getLodash();

/**
 * @name DropletBlock
 * @description Definition of a block to be used in Droplet
 * @property {string} func identifying the function this block runs
 * @property {string} blockPrefix Prepend this string before the normal block name in the palette
 * @property {Object} parent object within which this function is defined as a property, keyed by the func name
 * @property {String} category category within which to place the block
 * @property {String} type type of the block (e.g. value, either, property)
 * @property {string[]} paletteParams
 * @property {string[]} params
 * @property {Object.<number, function>} dropdown
 * @property {Object.<number, function>} assetTooltip
 * @property {bool} dontMarshal API expects params in interpreter form and will return an interpreter value
 * @property {bool} noAutocomplete Do not include this function in our ace completer
 * @property {bool} nativeIsAsync The native function is internally async and will call a callback function to resume the interpreter
 * @property {string} tipPrefix Prepend this string before the tooltip formed from the function name and (optionally) parameters
 * @property {string} docFunc Use the provided func as the key for our documentation.
 * @property {string} modeOptionName Alternate name to be used when generating droplet mode options
 */

/**
 * @name DropletConfig
 * @description Configuration information for Droplet
 * @property {DropletBlock[]} blocks list of blocks
 * @property {Object} categories configuration of categories within which to place blocks
 */

var COLOR_PINK = '#F57AC6';
var COLOR_PURPLE = '#BB77C7';
var COLOR_GREEN = '#68D995';
var COLOR_LIGHT_GREEN = '#D3E965';
var COLOR_WHITE = '#FFFFFF';
var COLOR_BLUE = '#64B5F6';
var COLOR_ORANGE = '#FFB74D';

exports.randomNumber = function (min, max) {
  if (typeof max === 'undefined') {
    // If only one parameter is specified, use it as the max with zero as min:
    max = min;
    min = 0;
  }
  // Use double-tilde to ensure we are dealing with integers:
  return Math.floor(Math.random() * (~ ~max - ~ ~min + 1)) + ~ ~min;
};

exports.getTime = function () {
  return new Date().getTime();
};

/**
 * Use native window.prompt to ask for a value, but continue prompting until we
 * get a numerical value.
 * @returns {number} User value, converted to a number
 */
exports.promptNum = function (text) {
  var val;
  do {
    val = parseInt(window.prompt(text), 10);
  } while (isNaN(val));
  return val;
};

/**
 * @type {DropletBlock[]}
 */
exports.dropletGlobalConfigBlocks = [{ func: 'getTime', parent: exports, category: 'Control', type: 'value' }, { func: 'randomNumber', parent: exports, category: 'Math', type: 'value' }, { func: 'prompt', parent: window, category: 'Variables', type: 'value' }, { func: 'promptNum', parent: exports, category: 'Variables', type: 'value' }];

/**
 * @type {DropletBlock[]}
 */
exports.dropletBuiltinConfigBlocks = [{ func: 'Math.round', category: 'Math', type: 'value', docFunc: 'mathRound' }, { func: 'Math.abs', category: 'Math', type: 'value', docFunc: 'mathAbs' }, { func: 'Math.max', category: 'Math', type: 'value', docFunc: 'mathMax' }, { func: 'Math.min', category: 'Math', type: 'value', docFunc: 'mathMin' }, { func: 'Math.random', category: 'Math', type: 'value', docFunc: 'mathRandom' }];

/**
 * @type {DropletConfig|*}}
 */
var standardConfig = {};

standardConfig.blocks = [
// Control
{ func: 'forLoop_i_0_4', block: 'for (var i = 0; i < 4; i++) {\n  __;\n}', category: 'Control' }, { func: 'whileBlock', block: 'while (__) {\n  __;\n}', category: 'Control' }, { func: 'ifBlock', block: 'if (__) {\n  __;\n}', category: 'Control' }, { func: 'ifElseBlock', block: 'if (__) {\n  __;\n} else {\n  __;\n}', category: 'Control' }, { func: 'getTime', block: 'getTime()', category: 'Control', type: 'value' },

// Math
{ func: 'addOperator', block: '__ + __', category: 'Math' }, { func: 'subtractOperator', block: '__ - __', category: 'Math' }, { func: 'multiplyOperator', block: '__ * __', category: 'Math' }, { func: 'divideOperator', block: '__ / __', category: 'Math' }, { func: 'equalityOperator', block: '__ == __', category: 'Math' }, { func: 'inequalityOperator', block: '__ != __', category: 'Math' }, { func: 'greaterThanOperator', block: '__ > __', category: 'Math' }, { func: 'greaterThanOrEqualOperator', block: '__ >= __', category: 'Math' }, { func: 'lessThanOperator', block: '__ < __', category: 'Math' }, { func: 'lessThanOrEqualOperator', block: '__ <= __', category: 'Math' }, { func: 'andOperator', block: '__ && __', category: 'Math' }, { func: 'orOperator', block: '__ || __', category: 'Math' }, { func: 'notOperator', block: '!__', category: 'Math' },
// randomNumber_max has been deprecated
// {func: 'randomNumber_max', block: 'randomNumber(__)', category: 'Math' },
// Note: We use randomNumber as our base docFunc here so that we get the benefits of param descriptions
{ func: 'randomNumber_min_max', block: 'randomNumber(__, __)', category: 'Math', docFunc: 'randomNumber' }, { func: 'mathRound', block: 'Math.round(__)', category: 'Math' }, { func: 'mathAbs', block: 'Math.abs(__)', category: 'Math' }, { func: 'mathMax', block: 'Math.max(__)', category: 'Math' }, { func: 'mathMin', block: 'Math.min(__)', category: 'Math' }, { func: 'mathRandom', block: 'Math.random()', category: 'Math' },

// Variables
{ func: 'declareAssign_x', block: 'var x = __;', category: 'Variables' }, { func: 'declareNoAssign_x', block: 'var x;', category: 'Variables' }, { func: 'assign_x', block: 'x = __;', category: 'Variables' }, { func: 'declareAssign_x_array_1_4', block: 'var x = [1, 2, 3, 4];', category: 'Variables' }, { func: 'declareAssign_x_prompt', block: 'var x = prompt("Enter a value");', category: 'Variables' }, { func: 'declareAssign_x_promptNum', block: 'var x = promptNum("Enter a value");', category: 'Variables' },

// Functions
{ func: 'functionParams_none', block: 'function myFunction() {\n  __;\n}', category: 'Functions' }, { func: 'functionParams_n', block: 'function myFunction(n) {\n  __;\n}', category: 'Functions' }, { func: 'callMyFunction', block: 'myFunction()', category: 'Functions' }, { func: 'callMyFunction_n', block: 'myFunction(n)', category: 'Functions' }, { func: 'return', block: 'return __;', category: 'Functions' }, { func: 'comment', block: '// Comment', category: 'Functions' }];

standardConfig.categories = {
  Control: {
    color: 'blue',
    rgb: COLOR_BLUE,
    blocks: []
  },
  Math: {
    color: 'orange',
    rgb: COLOR_ORANGE,
    blocks: []
  },
  Variables: {
    color: 'purple',
    rgb: COLOR_PURPLE,
    blocks: []
  },
  Functions: {
    color: 'green',
    rgb: COLOR_GREEN,
    blocks: []
  },
  // create blank category in case level builders want to move all blocks here
  // (which will cause the palette header to disappear)
  '': { 'blocks': [] }
};

/**
 * Given a collection of code functions and a set of dropletteConfig, returns a
 * a list of blocks.
 * @param codeFunctions {object} A collection of named key/value pairs
 *   key is a block name from dropletBlocks or standardBlocks
 *   value is an object that can be used to override block defaults
 * @param {DropletConfig} dropletConfig
 * @param {DropletConfig} otherConfig optionally used to supply a standardConfig
 *  object which is not app specific. It will be used first, then overriden
 *  by the primary dropletConfig if there is overlap between the two.
 * @param {Object} options
 * @param {boolean} options.paletteOnly ignore blocks not in codeFunctions palette
 * @param {boolean} options.ignoreDocFunc don't include based on block.docFunc
 * @returns {Array<DropletBlock>}
 */
function filteredBlocksFromConfig(codeFunctions, dropletConfig, otherConfig, options) {
  if (!codeFunctions || !dropletConfig || !dropletConfig.blocks) {
    return [];
  }

  options = options || {};

  var blocks = [];
  if (otherConfig) {
    blocks = blocks.concat(otherConfig.blocks);
  }
  blocks = blocks.concat(dropletConfig.blocks);

  var docFunctions = {};
  blocks.forEach(function (block) {
    if (!(block.func in codeFunctions)) {
      return;
    }

    if (!options.ignoreDocFunc) {
      // For cases where we use a different block for our tooltips, make sure that
      // the target block ends up in the list of blocks we want
      var docFunc = block.docFunc;
      if (docFunc && !(docFunc in codeFunctions)) {
        docFunctions[docFunc] = null;
      }
    }
  });

  return blocks.filter(function (block) {
    return !options.paletteOnly || block.func in codeFunctions || block.func in docFunctions;
  }).map(function (block) {
    // We found this particular block, now override the defaults with extend
    return $.extend({}, block, codeFunctions[block.func]);
  });
}

/**
 * Return a new categories object with the categories from dropletConfig (app
 * specific configuration) merged with the ones in standardConfig (global
 * configuration). App configuration takes precendence
 */
function mergeCategoriesWithConfig(dropletConfig) {
  // Clone our merged categories so that as we mutate it, we're not mutating
  // our original config
  var dropletCategories = dropletConfig && dropletConfig.categories;
  // We include dropletCategories twice so that (a) it's ordering of categories
  // gets preference and (b) it's value override anything in standardConfig
  return _.cloneDeep($.extend({}, dropletCategories, standardConfig.categories, dropletCategories));
}

/**
 * Generate code aliases in Javascript based on some level data.
 * @param {DropletConfig} dropletConfig
 * @param {String} parentObjName string reference to object upon which func is
 *  a property
 * @returns {String} code
 */
exports.generateCodeAliases = function (dropletConfig, parentObjName) {
  var code = '';
  var aliasFunctions = dropletConfig.blocks;

  // Insert aliases from aliasFunctions into code
  for (var i = 0; i < aliasFunctions.length; i++) {
    var cf = aliasFunctions[i];
    code += "var " + cf.func + " = function() { ";
    if (cf.idArgNone) {
      code += "return " + parentObjName + "." + cf.func + ".apply(" + parentObjName + ", arguments); };\n";
    } else {
      code += "var newArgs = " + (cf.idArgLast ? "arguments.concat(['']);" : "[''].concat(arguments);") + " return " + parentObjName + "." + cf.func + ".apply(" + parentObjName + ", newArgs); };\n";
    }
  }
  return code;
};

function buildFunctionPrototype(prefix, params) {
  var proto = prefix + "(";
  if (params) {
    for (var i = 0; i < params.length; i++) {
      if (i !== 0) {
        proto += ", ";
      }
      proto += params[i];
    }
  }
  return proto + ")";
}

/**
 * Generate a palette for the droplet editor based on some level data.
 * @param {object} codeFunctions The set of functions we want to use for this level
 * @param {object} dropletConfig
 * @param {function} dropletConfig.getBlocks
 * @param {object} dropletConfig.categories
 */
exports.generateDropletPalette = function (codeFunctions, dropletConfig) {
  var mergedCategories = mergeCategoriesWithConfig(dropletConfig);
  var mergedFunctions = filteredBlocksFromConfig(codeFunctions, dropletConfig, standardConfig, { paletteOnly: true, ignoreDocFunc: true });

  for (var i = 0; i < mergedFunctions.length; i++) {
    var funcInfo = mergedFunctions[i];
    var block = funcInfo.block;
    var expansion = funcInfo.expansion;
    if (!block) {
      var nameWithPrefix = funcInfo.func;
      if (funcInfo.blockPrefix) {
        nameWithPrefix = funcInfo.blockPrefix + nameWithPrefix;
      }
      if (funcInfo.type === 'property') {
        block = nameWithPrefix;
      } else {
        var paletteParams = funcInfo.paletteParams || funcInfo.params;
        block = buildFunctionPrototype(nameWithPrefix, paletteParams);
        if (funcInfo.paletteParams) {
          // If paletteParams were specified and used for the 'block', then use
          // the regular params for the 'expansion' which appears when the block
          // is dragged out of the palette:
          expansion = buildFunctionPrototype(nameWithPrefix, funcInfo.params);
        }
      }
    }

    /**
     * Here we set the title attribute to the function shortname,
     * this is later used as a key for function documentation and tooltips
     */
    var blockPair = {
      block: block,
      expansion: expansion,
      title: funcInfo.modeOptionName || funcInfo.func
    };
    mergedCategories[funcInfo.category].blocks.push(blockPair);
  }

  // Convert to droplet's expected palette format:
  var addedPalette = [];
  for (var category in mergedCategories) {
    if (mergedCategories[category].blocks.length > 0) {
      mergedCategories[category].name = category;
      addedPalette.push(mergedCategories[category]);
    }
  }

  return addedPalette;
};

function populateCompleterApisFromConfigBlocks(opts, apis, methodsAndProperties, configBlocks) {
  for (var i = 0; i < configBlocks.length; i++) {
    var block = configBlocks[i];
    if (!block.noAutocomplete) {
      // Use score value of 100 to ensure that our APIs are not replaced by
      // other completers that are suggesting the same name
      var newApi = {
        name: 'api',
        value: block.modeOptionName || block.func,
        score: 100,
        meta: block.category
      };
      if (opts.autocompleteFunctionsWithParens) {
        newApi.completer = {
          insertMatch: (function (value, editor) {
            // Remove the filterText that was already typed (ace's built-in
            // insertMatch would normally do this automatically)
            if (editor.completer.completions.filterText) {
              var ranges = editor.selection.getAllRanges();
              for (var i = 0, range; !!(range = ranges[i]); i++) {
                range.start.column -= editor.completer.completions.filterText.length;
                editor.session.remove(range);
              }
            }
            // Insert the function name plus parentheses and semicolon:
            editor.execCommand("insertstring", value + '();');
            if (this.params) {
              // Move the selection back so parameters can be entered:
              var curRange = editor.selection.getRange();
              curRange.start.column -= 2;
              curRange.end.column -= 2;
              editor.selection.setSelectionRange(curRange);
            }
          }).bind(block, newApi.value)
        };
      }
      if (newApi.value.indexOf('*.') === 0 || newApi.value.indexOf('?.') === 0) {
        // Populate this in a special methodsAndProperties collection:

        // Store the original name in a docFunc property for the
        // benefit of our DropletAutocompletePopupTooltipManager:
        newApi.docFunc = newApi.value;
        // Update the value to skip over the '*.' or '?.' at the beginning:
        newApi.value = newApi.value.substring(2);
        methodsAndProperties.push(newApi);
      } else {
        // Populate this in the "normal" apis collection:
        apis.push(newApi);
      }
    }
  }
}

function populateCompleterFromPredefValues(apis, predefValues) {
  if (predefValues) {
    predefValues.forEach(function (val) {
      // Use score value of 100 to ensure that our APIs are not replaced by
      // other completers that are suggesting the same name
      apis.push({
        name: 'api',
        value: val,
        score: 100,
        meta: 'constants'
      });
    });
  }
}

/**
 * Determines if the ace editor cursor position is at the beginning of a method
 * or property (after a dot).
 * @param {Object} session Ace editor session
 * @param {Object} pos Ace editor position
 * @return {boolean} true if position is at the start of a method or property
 */
function isPositionAfterDot(session, pos) {
  var acUtil = window.ace.require("ace/autocomplete/util");
  var line = session.getLine(pos.row);
  var identifier = acUtil.retrievePrecedingIdentifier(line, pos.column);
  // If we're typing a valid identifier, inspect the preceeding
  // character to see if it is a period and ensure there's at least one
  // character before
  if (identifier.length > 0 && identifier.length < pos.column) {
    // We have an identifier and it is shorter than our column position in
    // this line, which means it is safe to check the line[] before the
    // identifier
    var posBeforeIdentifier = pos.column - identifier.length - 1;
    return line[posBeforeIdentifier] === '.';
  }
  return false;
}

/**
 * Generate an Ace editor completer for a set of APIs based on some level data.
 *
 * If functionFilter is non-null, use it to filter the dropletConfig
 * APIs to be set in autocomplete and create no other autocomplete entries
 */
exports.generateAceApiCompleter = function (functionFilter, dropletConfig) {
  var apis = [];
  var methodsAndProperties = [];
  var opts = {};

  // If autocompleteFunctionsWithParens is set, we will append "();" after functions
  opts.autocompleteFunctionsWithParens = dropletConfig.autocompleteFunctionsWithParens;

  if (functionFilter) {
    var mergedBlocks = filteredBlocksFromConfig(functionFilter, dropletConfig, null, { paletteOnly: true });
    populateCompleterApisFromConfigBlocks(opts, apis, methodsAndProperties, mergedBlocks);
  } else {
    populateCompleterApisFromConfigBlocks(opts, apis, methodsAndProperties, exports.dropletGlobalConfigBlocks);
    populateCompleterApisFromConfigBlocks(opts, apis, methodsAndProperties, exports.dropletBuiltinConfigBlocks);
    populateCompleterApisFromConfigBlocks(opts, apis, methodsAndProperties, dropletConfig.blocks);
    populateCompleterFromPredefValues(apis, dropletConfig.additionalPredefValues);
  }

  return {
    getCompletions: function getCompletions(editor, session, pos, prefix, callback) {
      if (prefix.length === 0) {
        callback(null, []);
        return;
      }
      if (isPositionAfterDot(session, pos)) {
        // Following a dot, we autocomplete from methodsAndProperties:
        callback(null, methodsAndProperties);
      } else {
        callback(null, apis);
      }
    }
  };
};

/**
 * Given a droplet config, create a mode option functions object
 * @param {object} config
 * @param {object[]} config.blocks
 * @param {object[]} config.categories
 */
function getModeOptionFunctionsFromConfig(config) {
  var mergedCategories = mergeCategoriesWithConfig(config);

  var modeOptionFunctions = {};

  for (var i = 0; i < config.blocks.length; i++) {
    var newFunc = {};

    if (config.blocks[i].type === 'value') {
      newFunc.value = true;
    } else if (config.blocks[i].type === 'either') {
      newFunc.value = true;
      newFunc.command = true;
    } else if (config.blocks[i].type === 'property') {
      newFunc.property = true;
      newFunc.value = true;
    }

    var category = mergedCategories[config.blocks[i].category];
    if (category) {
      newFunc.color = category.rgb || category.color;
    }

    newFunc.dropdown = config.blocks[i].dropdown;

    var modeOptionName = config.blocks[i].modeOptionName || config.blocks[i].func;
    newFunc.title = modeOptionName;

    modeOptionFunctions[modeOptionName] = newFunc;
  }
  return modeOptionFunctions;
}

/**
 * Generate modeOptions for the droplet editor based on some level data.
 */
exports.generateDropletModeOptions = function (config) {
  var modeOptions = {
    functions: {},
    categories: {
      arithmetic: { color: COLOR_ORANGE },
      logic: { color: COLOR_ORANGE },
      conditionals: { color: COLOR_BLUE },
      loops: {
        color: COLOR_BLUE,
        beginner: config.level.beginnerMode || false
      },
      functions: { color: COLOR_GREEN },
      returns: { color: COLOR_GREEN },
      comments: { color: COLOR_WHITE },
      containers: { color: COLOR_PURPLE },
      value: { color: COLOR_PURPLE },
      command: { color: COLOR_GREEN },
      assignments: { color: COLOR_PURPLE }
      // errors: { },
    },
    lockZeroParamFunctions: config.level.lockZeroParamFunctions
  };

  $.extend(modeOptions.functions, getModeOptionFunctionsFromConfig({ blocks: exports.dropletGlobalConfigBlocks }), getModeOptionFunctionsFromConfig({ blocks: exports.dropletBuiltinConfigBlocks }), getModeOptionFunctionsFromConfig(config.dropletConfig));

  return modeOptions;
};

/**
 * Returns a set of all blocks
 * @param {DropletConfig|null} dropletConfig custom configuration, may be null
 * @param {codeFunctions|null} codeFunctions with block overrides, may be null
 * @param paletteOnly boolean: filter to only those blocks that are in codeFunctions
 *   palette, or who share documentation (via docFunc) with other blocks that are
 * @returns {DropletBlock[]} a list of all available Droplet blocks,
 *      including the given config's blocks
 */
exports.getAllAvailableDropletBlocks = function (dropletConfig, codeFunctions, paletteOnly) {
  var hasConfiguredBlocks = dropletConfig && dropletConfig.blocks;
  var configuredBlocks = hasConfiguredBlocks ? dropletConfig.blocks : [];
  if (codeFunctions && hasConfiguredBlocks) {
    configuredBlocks = filteredBlocksFromConfig(codeFunctions, dropletConfig, null, { paletteOnly: paletteOnly });
  }
  return exports.dropletGlobalConfigBlocks.concat(exports.dropletBuiltinConfigBlocks).concat(standardConfig.blocks).concat(configuredBlocks);
};

exports.__TestInterface = {
  mergeCategoriesWithConfig: mergeCategoriesWithConfig,
  filteredBlocksFromConfig: filteredBlocksFromConfig
};

},{"./utils":"/home/ubuntu/staging/apps/build/js/utils.js"}],"/home/ubuntu/staging/apps/build/js/ObservableEvent.js":[function(require,module,exports){
// Strict linting: Absorb into global config when possible
/* jshint
 unused: true,
 eqeqeq: true,
 maxlen: 120
 */
'use strict';

/**
 * A subscription/notification atom, used to cleanly hook up callbacks
 * without attaching anything to the DOM or other global scope.
 * @constructor
 */
var ObservableEvent = module.exports = function () {
  /**
   * Objects observing this.
   * @type {Array}
   * @private
   */
  this.observerList_ = [];
};

/**
 * Subscribe a method to be called when notifyObservers is called.
 * @param {function} onNotify - method called when notifyObservers gets called.
 *        Will receive any arguments passed to notifyObservers.
 * @returns {Object} key - used to unregister from observable
 */
ObservableEvent.prototype.register = function (onNotify) {
  var key = { toCall: onNotify };
  Object.freeze(key);
  this.observerList_.push(key);
  return key;
};

/**
 * Unsubscribe from notifications.
 * @param {Object} keyObj - Key generated when registering
 * @returns {boolean} - Whether an unregistration actually occurred
 */
ObservableEvent.prototype.unregister = function (keyObj) {
  for (var i = 0; i < this.observerList_.length; i++) {
    if (keyObj === this.observerList_[i]) {
      this.observerList_.splice(i, 1);
      return true;
    }
  }
  return false;
};

/**
 * Call all methods subscribed to this ObservableEvent, passing through
 * any arguments.
 * @param {...} Any arguments, which are passed through to the observing
 *              functions.
 */
ObservableEvent.prototype.notifyObservers = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this.observerList_.forEach(function (observer) {
    observer.toCall.apply(undefined, args);
  });
};

},{}],"/home/ubuntu/staging/apps/build/js/DebugArea.js":[function(require,module,exports){
// Strict linting: Absorb into global config when possible
/* jshint
 unused: true,
 eqeqeq: true,
 maxlen: 120
 */

'use strict';

var i18n = require('./locale');
var dom = require('./dom');
var utils = require('./utils');

/**
 * Creates the debug area controller and configures it to operate on the given
 * elements.
 *
 * @param {HTMLDivElement} debugAreaRoot
 * @param {HTMLDivElement} codeTextboxRoot
 * @constructor
 */
var DebugArea = module.exports = function (debugAreaRoot, codeTextboxRoot) {
  if (!debugAreaRoot || !codeTextboxRoot) {
    throw new Error("debugAreaRoot and codeTextboxRoot are required");
  }

  /**
   * @type {jQuery}
   * @private
   */
  this.rootDiv_ = $(debugAreaRoot);

  /**
   * @type {jQuery}
   * @private
   */
  this.codeTextbox_ = $(codeTextboxRoot);

  /**
   * @type {boolean}
   * @private
   */
  this.isOpen_ = true;

  /**
   * @type {number}
   * @private
   */
  this.lastOpenHeight_ = this.rootDiv_.height();

  DebugArea.prototype.bindHandlersForDebugCommandsHeader.call(this);
};

/**
 * Binds mouseover, mouseout, click and touch handlers for the debug commands
 * header div.
 */
DebugArea.prototype.bindHandlersForDebugCommandsHeader = function () {
  var toggleDebugIcon = this.rootDiv_.find('#show-hide-debug-icon');
  dom.addClickTouchEvent(toggleDebugIcon[0], DebugArea.prototype.slideToggle.bind(this));
};

/** @returns {boolean} */
DebugArea.prototype.isOpen = function () {
  return this.isOpen_;
};

/** @returns {boolean} */
DebugArea.prototype.isShut = function () {
  return !this.isOpen_;
};

/**
 * Open/close the debug area to the reverse of its current state, using no
 * animation.
 */
DebugArea.snapToggle = function () {
  if (this.isOpen_) {
    this.snapShut();
  } else {
    this.snapOpen();
  }
};

DebugArea.prototype.snapOpen = function () {
  this.isOpen_ = true;
  this.setContentsVisible(true);
  this.setIconPointingDown(true);
  this.setHeight(this.lastOpenHeight_);

  // Set the 'clear' button visible
  this.rootDiv_.find('#clear-console-header').css('opacity', 1).css('visibility', 'visible');
};

DebugArea.prototype.snapShut = function () {
  this.isOpen_ = false;
  this.lastOpenHeight_ = this.rootDiv_.height();
  this.setContentsVisible(false);
  this.setIconPointingDown(false);
  this.setHeight(this.getHeightWhenClosed());

  // Set the 'clear' button hidden (not display:none, it should take up space)
  this.rootDiv_.find('#clear-console-header').css('opacity', 0).css('visibility', 'hidden');
};

/**
 * Open/close the debug area to the reverse of its current state, using a
 * slide animation.
 */
DebugArea.prototype.slideToggle = function () {
  if (this.isOpen_) {
    this.slideShut();
  } else {
    this.slideOpen();
  }
};

DebugArea.prototype.slideOpen = function () {
  this.isOpen_ = true;
  this.setContentsVisible(true);

  // Manually remove hover effect at start and end of animation to get *close*
  // to the correct effect.
  this.rootDiv_.animate({
    height: this.lastOpenHeight_
  }, {
    complete: (function () {
      this.setIconPointingDown(true);
    }).bind(this)
  });

  // Animate the bottom of the workspace at the same time
  this.codeTextbox_.animate({
    bottom: this.lastOpenHeight_
  }, {
    step: utils.fireResizeEvent
  });

  // Animate the 'clear' button appearing at the same time
  var clearButton = this.rootDiv_.find('#clear-console-header');
  clearButton.css('visibility', 'visible');
  clearButton.animate({
    opacity: 1.0
  });
};

DebugArea.prototype.slideShut = function () {
  this.isOpen_ = false;
  this.lastOpenHeight_ = this.rootDiv_.height();

  // We will leave the header and resize bar visible, so together they
  // constitute our height when closed.
  var closedHeight = this.getHeightWhenClosed();
  // Manually remove hover effect at start and end of animation to get *close*
  // to the correct effect.
  this.rootDiv_.animate({
    height: closedHeight
  }, {
    complete: (function () {
      this.setContentsVisible(false);
      this.setIconPointingDown(false);
    }).bind(this)
  });

  // Animate the bottom of the workspace at the same time
  this.codeTextbox_.animate({
    bottom: closedHeight
  }, {
    step: utils.fireResizeEvent,
    complete: utils.fireResizeEvent
  });

  // Animate the 'clear' button vanishing at the same time
  var clearButton = this.rootDiv_.find('#clear-console-header');
  clearButton.animate({
    opacity: 0.0
  }, {
    complete: function complete() {
      clearButton.css('visibility', 'hidden');
    }
  });
};

DebugArea.prototype.setContentsVisible = function (isVisible) {
  this.rootDiv_.find('#debug-commands').toggle(isVisible);
  this.rootDiv_.find('#debug-console').toggle(isVisible);
};

DebugArea.prototype.setIconPointingDown = function (isPointingDown) {
  var commandsHeader = this.rootDiv_.find('#debug-commands-header');

  var icon = this.rootDiv_.find('#show-hide-debug-icon');
  icon.toggleClass('fa-chevron-circle-up', !isPointingDown);
  icon.toggleClass('fa-chevron-circle-down', isPointingDown);

  var headerText = commandsHeader.find('.header-text');
  headerText.text(isPointingDown ? i18n.debugCommandsHeaderWhenOpen() : i18n.debugCommandsHeaderWhenClosed());
};

DebugArea.prototype.setHeight = function (newHeightInPixels) {
  this.rootDiv_.height(newHeightInPixels);
  this.codeTextbox_.css('bottom', newHeightInPixels);
  utils.fireResizeEvent();
};

DebugArea.prototype.getHeightWhenClosed = function () {
  return this.rootDiv_.find('#debug-area-header').height() + this.rootDiv_.find('#debugResizeBar').height();
};

},{"./dom":"/home/ubuntu/staging/apps/build/js/dom.js","./locale":"/home/ubuntu/staging/apps/build/js/locale.js","./utils":"/home/ubuntu/staging/apps/build/js/utils.js"}],"/home/ubuntu/staging/apps/build/js/utils.js":[function(require,module,exports){
/* global define */
// Strict linting: Absorb into global config when possible
/* jshint
 unused: true,
 eqeqeq: true,
 maxlen: 120
 */
'use strict';

var savedAmd;

// Do some hackery to make it so that lodash doesn't think it's being loaded
// via require js
if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
  savedAmd = define.amd;
  define.amd = false;
}

// get lodash
var _ = require('./lodash');
var Hammer = require('./hammer');

// undo hackery
if (typeof define === 'function' && savedAmd) {
  define.amd = savedAmd;
  savedAmd = null;
}

exports.getLodash = function () {
  return _;
};

exports.getHammer = function () {
  return Hammer;
};

exports.shallowCopy = function (source) {
  var result = {};
  for (var prop in source) {
    result[prop] = source[prop];
  }

  return result;
};

/**
 * Returns a clone of the object, stripping any functions on it.
 */
exports.cloneWithoutFunctions = function (object) {
  return JSON.parse(JSON.stringify(object));
};

/**
 * Returns a string with a double quote before and after.
 */
exports.quote = function (str) {
  return '"' + str + '"';
};

/**
 * Returns a new object with the properties from defaults overridden by any
 * properties in options. Leaves defaults and options unchanged.
 * NOTE: For new code, use $.extend({}, defaults, options) instead
 */
exports.extend = function (defaults, options) {
  var finalOptions = exports.shallowCopy(defaults);
  for (var prop in options) {
    finalOptions[prop] = options[prop];
  }

  return finalOptions;
};

exports.escapeHtml = function (unsafe) {
  return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
};

/**
 * Version of modulo which, unlike javascript's `%` operator,
 * will always return a positive remainder.
 * @param number
 * @param mod
 */
exports.mod = function (number, mod) {
  return (number % mod + mod) % mod;
};

/**
 * Generates an array of integers from start to end inclusive
 */
exports.range = function (start, end) {
  var ints = [];
  for (var i = start; i <= end; i++) {
    ints.push(i);
  }
  return ints;
};

/**
 * Given two functions, generates a function that returns the result of the
 * second function if and only if the first function returns true
 */
exports.executeIfConditional = function (conditional, fn) {
  return function () {
    if (conditional()) {
      return fn.apply(this, arguments);
    }
  };
};

/**
 * Removes all single and double quotes from a string
 * @param inputString
 * @returns {string} string without quotes
 */
exports.stripQuotes = function (inputString) {
  return inputString.replace(/["']/g, "");
};

/**
 * Defines an inheritance relationship between parent class and this class.
 */
Function.prototype.inherits = function (parent) {
  this.prototype = Object.create(parent.prototype);
  this.prototype.constructor = this;
  this.superPrototype = parent.prototype;
};

/**
 * Wrap a couple of our Blockly number validators to allow for ???.  This is
 * done so that level builders can specify required blocks with wildcard fields.
 */
exports.wrapNumberValidatorsForLevelBuilder = function () {
  var nonNeg = Blockly.FieldTextInput.nonnegativeIntegerValidator;
  var numVal = Blockly.FieldTextInput.numberValidator;

  Blockly.FieldTextInput.nonnegativeIntegerValidator = function (text) {
    if (text === '???') {
      return text;
    }
    return nonNeg(text);
  };

  Blockly.FieldTextInput.numberValidator = function (text) {
    if (text === '???') {
      return text;
    }
    return numVal(text);
  };
};

/**
 * Return a random key name from an object.
 *
 * Slightly modified from: http://stackoverflow.com/a/15106541
 */

exports.randomKey = function (obj) {
  var keys = Object.keys(obj);
  return keys[keys.length * Math.random() << 0];
};

/**
 * Generate a random identifier in a format matching the RFC-4122 specification.
 *
 * Taken from
 * {@link http://byronsalau.com/blog/how-to-create-a-guid-uuid-in-javascript/}
 *
 * @see RFC-4122 standard {@link http://www.ietf.org/rfc/rfc4122.txt}
 *
 * @returns {string} RFC4122-compliant UUID
 */
exports.createUuid = function () {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c === 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
};

exports.fireResizeEvent = function () {
  var ev = document.createEvent('Event');
  ev.initEvent('resize', true, true);
  window.dispatchEvent(ev);
};

// ECMAScript 6 polyfill for String.prototype.repeat
// Polyfill adapted from
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference
//        /Global_Objects/String/repeat
if (!String.prototype.repeat) {
  /**
   * The repeat() method constructs and returns a new string which contains
   * the specified number of copies of the string on which it was called,
   * concatenated together?
   * @param {number} count
   * @returns {string}
   */
  String.prototype.repeat = function (count) {
    if (this === null) {
      throw new TypeError('can\'t convert ' + this + ' to object');
    }
    var str = '' + this;
    count = +count;
    if (count !== count) {
      count = 0;
    }
    if (count < 0) {
      throw new RangeError('repeat count must be non-negative');
    }
    if (count === Infinity) {
      throw new RangeError('repeat count must be less than infinity');
    }
    count = Math.floor(count);
    if (str.length === 0 || count === 0) {
      return '';
    }
    // Ensuring count is a 31-bit integer allows us to heavily optimize the
    // main part. But anyway, most current (august 2014) browsers can't handle
    // strings 1 << 28 chars or longer, so:
    if (str.length * count >= 1 << 28) {
      throw new RangeError('repeat count must not overflow maximum string size');
    }
    var rpt = '';
    for (;;) {
      if ((count & 1) === 1) {
        rpt += str;
      }
      count >>>= 1;
      if (count === 0) {
        break;
      }
      str += str;
    }
    return rpt;
  };
}

/**
 * Similar to val || defaultVal, except it's gated on whether or not val is
 * undefined instead of whether val is falsey.
 * @returns {*} val if not undefined, otherwise defaultVal
 */
exports.valueOr = function (val, defaultVal) {
  return val === undefined ? defaultVal : val;
};

/**
 * Attempts to analyze whether or not err represents infinite recursion having
 * occurred. This error differs per browser, and it's possible that we don't
 * properly discover all cases.
 * Note: Other languages probably have localized messages, meaning we won't
 * catch them.
 */
exports.isInfiniteRecursionError = function (err) {
  // Chrome/Safari: message ends in a period in Safari, not in Chrome
  if (err instanceof RangeError && /^Maximum call stack size exceeded/.test(err.message)) {
    return true;
  }

  // Firefox
  /* jshint ignore:start */
  // Linter doesn't like our use of InternalError, even though we gate on its
  // existence.
  if (typeof InternalError !== 'undefined' && err instanceof InternalError && err.message === 'too much recursion') {
    return true;
  }
  /* jshint ignore:end */

  // IE
  if (err instanceof Error && err.message === 'Out of stack space') {
    return true;
  }

  return false;
};

// TODO(dave): move this logic to dashboard.
exports.getPegasusHost = function () {
  switch (window.location.hostname) {
    case 'studio.code.org':
    case 'learn.code.org':
      return 'code.org';
    default:
      var name = window.location.hostname.split('.')[0];
      switch (name) {
        case 'localhost':
          return 'localhost.code.org:3000';
        case 'development':
        case 'staging':
        case 'test':
        case 'levelbuilder':
          return name + '.code.org';
        case 'staging-studio':
          return 'staging.code.org';
        case 'test-studio':
          return 'test.code.org';
        case 'levelbuilder-studio':
          return 'levelbuilder.code.org';
        default:
          return null;
      }
  }
};

/**
 * IE9 throws an exception when trying to access the media field of a stylesheet
 */
exports.browserSupportsCssMedia = function () {
  var styleSheets = document.styleSheets;
  for (var i = 0; i < styleSheets.length; i++) {
    var rules = styleSheets[i].cssRules || styleSheets[i].rules;
    try {
      if (rules.length > 0) {
        // see if we can access media
        var media = rules[0].media; // jshint ignore:line
      }
    } catch (e) {
      return false;
    }
  }
  return true;
};

/**
 * Remove escaped characters and HTML to convert some rendered text to what should appear in user-edited controls
 * @param text
 * @returns String that has no more escape characters and multiple divs converted to newlines
 */
exports.unescapeText = function (text) {
  var cleanedText = text;
  cleanedText = cleanedText.replace(/<div>/gi, '\n'); // Divs generate newlines
  cleanedText = cleanedText.replace(/<[^>]+>/gi, ''); // Strip all other tags

  // This next step requires some explanation
  // In multiline text it's possible for the first line to render wrapped or unwrapped.
  //     Line 1
  //     Line 2
  //   Can render as either of:
  //     Line 1<div>Line 2</div>
  //     <div>Line 1</div><div>Line 2</div>
  //
  // But leading blank lines will always render wrapped and should be preserved
  //
  //     Line 2
  //     Line 3
  //   Renders as
  //    <div><br></div><div>Line 2</div><div>Line 3</div>
  //
  // To handle this behavior we strip leading newlines UNLESS they are followed
  // by another newline, using a negative lookahead (?!)
  cleanedText = cleanedText.replace(/^\n(?!\n)/, ''); // Strip leading nondoubled newline

  cleanedText = cleanedText.replace(/&nbsp;/gi, ' '); // Unescape nonbreaking spaces
  cleanedText = cleanedText.replace(/&gt;/gi, '>'); // Unescape >
  cleanedText = cleanedText.replace(/&lt;/gi, '<'); // Unescape <
  cleanedText = cleanedText.replace(/&amp;/gi, '&'); // Unescape & (must happen last!)
  return cleanedText;
};

/**
 * Escape special characters in a piece of text, and convert newlines to seperate divs
 * @param text
 * @returns String with special characters escaped and newlines converted divs
 */
exports.escapeText = function (text) {
  var escapedText = text.toString();
  escapedText = escapedText.replace(/&/g, '&amp;'); // Escape & (must happen first!)
  escapedText = escapedText.replace(/</g, '&lt;'); // Escape <
  escapedText = escapedText.replace(/>/g, '&gt;'); // Escape >
  escapedText = escapedText.replace(/  /g, ' &nbsp;'); // Escape doubled spaces

  // Now wrap each line except the first line in a <div>,
  // replacing blank lines with <div><br><div>
  var lines = escapedText.split('\n');
  var returnValue = lines[0] + lines.slice(1).map(function (line) {
    return '<div>' + (line.length ? line : '<br>') + '</div>';
  }).join('');

  return returnValue;
};

/**
 * Converts degrees into radians.
 *
 * @param degrees - The degrees to convert to radians
 * @return `degrees` converted to radians
 */
exports.degreesToRadians = function (degrees) {
  return degrees * (Math.PI / 180);
};

/**
 * Simple wrapper around localStorage.setItem that catches any exceptions (for
 * example when we call setItem in Safari's private mode)
 * @return {boolean} True if we set successfully
 */
exports.trySetLocalStorage = function (item, value) {
  try {
    localStorage.setItem(item, value);
    return true;
  } catch (e) {
    return false;
  }
};

},{"./hammer":"/home/ubuntu/staging/apps/build/js/hammer.js","./lodash":"/home/ubuntu/staging/apps/build/js/lodash.js"}],"/home/ubuntu/staging/apps/build/js/lodash.js":[function(require,module,exports){
(function (global){
/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash include="debounce,reject,map,value,range,without,sample,create,flatten,isEmpty,wrap,size,bind,contains,last,clone,cloneDeep,isEqual,find,sortBy,throttle,uniq" --output src/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
'use strict';

;(function () {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used internally to indicate various things */
  var indicatorObject = {};

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date() + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to fix the JScript [[DontEnum]] bug */
  var shadowedProps = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      errorClass = '[object Error]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used as the data object for `iteratorTemplate` */
  var iteratorData = {
    'args': '',
    'array': null,
    'bottom': '',
    'firstArg': '',
    'init': '',
    'keys': null,
    'loop': '',
    'shadowedProps': null,
    'support': null,
    'top': '',
    'useHas': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used as a reference to the global object */
  var root = objectTypes[typeof window] && window || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object' ? cache && baseIndexOf(cache, value) > -1 ? 0 : -1 : cache ? 0 : -1;
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[length / 2 | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' && mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Checks if `value` is a DOM node in IE < 9.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a DOM node, else `false`.
   */
  function isNode(value) {
    // IE < 9 presents DOM nodes as `Object` objects except they have `toString`
    // methods that are `typeof` "string" and still can coerce nodes to strings
    return typeof value.toString != 'function' && typeof (value + '') == 'string';
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Used for `Array` method references.
   *
   * Normally `Array.prototype` would suffice, however, using an array literal
   * avoids issues in Narwhal.
   */
  var arrayRef = [];

  /** Used for native method references */
  var errorProto = Error.prototype,
      objectProto = Object.prototype,
      stringProto = String.prototype;

  /** Used to resolve the internal [[Class]] of values */
  var toString = objectProto.toString;

  /** Used to detect if a method is native */
  var reNative = RegExp('^' + String(toString).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/toString| for [^\]]+/g, '.*?') + '$');

  /** Native method shortcuts */
  var ceil = Math.ceil,
      floor = Math.floor,
      fnToString = Function.prototype.toString,
      hasOwnProperty = objectProto.hasOwnProperty,
      push = arrayRef.push,
      propertyIsEnumerable = objectProto.propertyIsEnumerable,
      unshift = arrayRef.unshift;

  /** Used to set meta data on functions */
  var defineProperty = (function () {
    // IE 8 only accepts DOM elements
    try {
      var o = {},
          func = isNative(func = Object.defineProperty) && func,
          result = func(o, o, o) && func;
    } catch (e) {}
    return result;
  })();

  /* Native method shortcuts for methods with the same name as other `lodash` methods */
  var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
      nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
      nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
      nativeMax = Math.max,
      nativeMin = Math.min,
      nativeRandom = Math.random;

  /** Used to lookup a built-in constructor by [[Class]] */
  var ctorByClass = {};
  ctorByClass[arrayClass] = Array;
  ctorByClass[boolClass] = Boolean;
  ctorByClass[dateClass] = Date;
  ctorByClass[funcClass] = Function;
  ctorByClass[objectClass] = Object;
  ctorByClass[numberClass] = Number;
  ctorByClass[regexpClass] = RegExp;
  ctorByClass[stringClass] = String;

  /** Used to avoid iterating non-enumerable properties in IE < 9 */
  var nonEnumProps = {};
  nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };
  nonEnumProps[boolClass] = nonEnumProps[stringClass] = { 'constructor': true, 'toString': true, 'valueOf': true };
  nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = { 'constructor': true, 'toString': true };
  nonEnumProps[objectClass] = { 'constructor': true };

  (function () {
    var length = shadowedProps.length;
    while (length--) {
      var key = shadowedProps[length];
      for (var className in nonEnumProps) {
        if (hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], key)) {
          nonEnumProps[className][key] = false;
        }
      }
    }
  })();

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` object which wraps the given value to enable intuitive
   * method chaining.
   *
   * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
   * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
   * and `unshift`
   *
   * Chaining is supported in custom builds as long as the `value` method is
   * implicitly or explicitly included in the build.
   *
   * The chainable wrapper functions are:
   * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
   * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
   * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
   * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
   * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
   * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
   * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
   * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
   * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
   * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
   * and `zip`
   *
   * The non-chainable wrapper functions are:
   * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
   * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
   * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
   * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
   * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
   * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
   * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
   * `template`, `unescape`, `uniqueId`, and `value`
   *
   * The wrapper functions `first` and `last` return wrapped values when `n` is
   * provided, otherwise they return unwrapped values.
   *
   * Explicit chaining can be enabled by using the `_.chain` method.
   *
   * @name _
   * @constructor
   * @category Chaining
   * @param {*} value The value to wrap in a `lodash` instance.
   * @returns {Object} Returns a `lodash` instance.
   * @example
   *
   * var wrapped = _([1, 2, 3]);
   *
   * // returns an unwrapped value
   * wrapped.reduce(function(sum, num) {
   *   return sum + num;
   * });
   * // => 6
   *
   * // returns a wrapped value
   * var squares = wrapped.map(function(num) {
   *   return num * num;
   * });
   *
   * _.isArray(squares);
   * // => false
   *
   * _.isArray(squares.value());
   * // => true
   */
  function lodash(value) {
    // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
    return value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__') ? value : new lodashWrapper(value);
  }

  /**
   * A fast path for creating `lodash` wrapper objects.
   *
   * @private
   * @param {*} value The value to wrap in a `lodash` instance.
   * @param {boolean} chainAll A flag to enable chaining for all methods
   * @returns {Object} Returns a `lodash` instance.
   */
  function lodashWrapper(value, chainAll) {
    this.__chain__ = !!chainAll;
    this.__wrapped__ = value;
  }
  // ensure `new lodashWrapper` is an instance of `lodash`
  lodashWrapper.prototype = lodash.prototype;

  /**
   * An object used to flag environments features.
   *
   * @static
   * @memberOf _
   * @type Object
   */
  var support = lodash.support = {};

  (function () {
    var ctor = function ctor() {
      this.x = 1;
    },
        object = { '0': 1, 'length': 1 },
        props = [];

    ctor.prototype = { 'valueOf': 1, 'y': 1 };
    for (var key in new ctor()) {
      props.push(key);
    }
    for (key in arguments) {}

    /**
     * Detect if an `arguments` object's [[Class]] is resolvable (all but Firefox < 4, IE < 9).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.argsClass = toString.call(arguments) == argsClass;

    /**
     * Detect if `arguments` objects are `Object` objects (all but Narwhal and Opera < 10.5).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.argsObject = arguments.constructor == Object && !(arguments instanceof Array);

    /**
     * Detect if `name` or `message` properties of `Error.prototype` are
     * enumerable by default. (IE < 9, Safari < 5.1)
     *
     * @memberOf _.support
     * @type boolean
     */
    support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');

    /**
     * Detect if `prototype` properties are enumerable by default.
     *
     * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
     * (if the prototype or a property on the prototype has been set)
     * incorrectly sets a function's `prototype` property [[Enumerable]]
     * value to `true`.
     *
     * @memberOf _.support
     * @type boolean
     */
    support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(root.WinRTError) && reThis.test(function () {
      return this;
    });

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * Detect if `arguments` object indexes are non-enumerable
     * (Firefox < 4, IE < 9, PhantomJS, Safari < 5.1).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.nonEnumArgs = key != 0;

    /**
     * Detect if properties shadowing those on `Object.prototype` are non-enumerable.
     *
     * In IE < 9 an objects own properties, shadowing non-enumerable ones, are
     * made non-enumerable as well (a.k.a the JScript [[DontEnum]] bug).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.nonEnumShadows = !/valueOf/.test(props);

    /**
     * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.
     *
     * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`
     * and `splice()` functions that fail to remove the last element, `value[0]`,
     * of array-like objects even though the `length` property is set to `0`.
     * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
     * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.
     *
     * @memberOf _.support
     * @type boolean
     */
    support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);

    /**
     * Detect lack of support for accessing string characters by index.
     *
     * IE < 8 can't access characters by index and IE 8 can only access
     * characters by index on string literals.
     *
     * @memberOf _.support
     * @type boolean
     */
    support.unindexedChars = 'x'[0] + Object('x')[0] != 'xx';

    /**
     * Detect if a DOM node's [[Class]] is resolvable (all but IE < 9)
     * and that the JS engine errors when attempting to coerce an object to
     * a string without a `toString` function.
     *
     * @memberOf _.support
     * @type boolean
     */
    try {
      support.nodeClass = !(toString.call(document) == objectClass && !({ 'toString': 0 } + ''));
    } catch (e) {
      support.nodeClass = true;
    }
  })(1);

  /*--------------------------------------------------------------------------*/

  /**
   * The template used to create iterator functions.
   *
   * @private
   * @param {Object} data The data object used to populate the text.
   * @returns {string} Returns the interpolated text.
   */
  var iteratorTemplate = function iteratorTemplate(obj) {

    var __p = 'var index, iterable = ' + obj.firstArg + ', result = ' + obj.init + ';\nif (!iterable) return result;\n' + obj.top + ';';
    if (obj.array) {
      __p += '\nvar length = iterable.length; index = -1;\nif (' + obj.array + ') {  ';
      if (support.unindexedChars) {
        __p += '\n  if (isString(iterable)) {\n    iterable = iterable.split(\'\')\n  }  ';
      }
      __p += '\n  while (++index < length) {\n    ' + obj.loop + ';\n  }\n}\nelse {  ';
    } else if (support.nonEnumArgs) {
      __p += '\n  var length = iterable.length; index = -1;\n  if (length && isArguments(iterable)) {\n    while (++index < length) {\n      index += \'\';\n      ' + obj.loop + ';\n    }\n  } else {  ';
    }

    if (support.enumPrototypes) {
      __p += '\n  var skipProto = typeof iterable == \'function\';\n  ';
    }

    if (support.enumErrorProps) {
      __p += '\n  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\n  ';
    }

    var conditions = [];if (support.enumPrototypes) {
      conditions.push('!(skipProto && index == "prototype")');
    }if (support.enumErrorProps) {
      conditions.push('!(skipErrorProps && (index == "message" || index == "name"))');
    }

    if (obj.useHas && obj.keys) {
      __p += '\n  var ownIndex = -1,\n      ownProps = objectTypes[typeof iterable] && keys(iterable),\n      length = ownProps ? ownProps.length : 0;\n\n  while (++ownIndex < length) {\n    index = ownProps[ownIndex];\n';
      if (conditions.length) {
        __p += '    if (' + conditions.join(' && ') + ') {\n  ';
      }
      __p += obj.loop + ';    ';
      if (conditions.length) {
        __p += '\n    }';
      }
      __p += '\n  }  ';
    } else {
      __p += '\n  for (index in iterable) {\n';
      if (obj.useHas) {
        conditions.push("hasOwnProperty.call(iterable, index)");
      }if (conditions.length) {
        __p += '    if (' + conditions.join(' && ') + ') {\n  ';
      }
      __p += obj.loop + ';    ';
      if (conditions.length) {
        __p += '\n    }';
      }
      __p += '\n  }    ';
      if (support.nonEnumShadows) {
        __p += '\n\n  if (iterable !== objectProto) {\n    var ctor = iterable.constructor,\n        isProto = iterable === (ctor && ctor.prototype),\n        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\n        nonEnum = nonEnumProps[className];\n      ';
        for (k = 0; k < 7; k++) {
          __p += '\n    index = \'' + obj.shadowedProps[k] + '\';\n    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))';
          if (!obj.useHas) {
            __p += ' || (!nonEnum[index] && iterable[index] !== objectProto[index])';
          }
          __p += ') {\n      ' + obj.loop + ';\n    }      ';
        }
        __p += '\n  }    ';
      }
    }

    if (obj.array || support.nonEnumArgs) {
      __p += '\n}';
    }
    __p += obj.bottom + ';\nreturn result';

    return __p;
  };

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.bind` that creates the bound function and
   * sets its meta data.
   *
   * @private
   * @param {Array} bindData The bind data array.
   * @returns {Function} Returns the new bound function.
   */
  function baseBind(bindData) {
    var func = bindData[0],
        partialArgs = bindData[2],
        thisArg = bindData[4];

    function bound() {
      // `Function#bind` spec
      // http://es5.github.io/#x15.3.4.5
      if (partialArgs) {
        // avoid `arguments` object deoptimizations by using `slice` instead
        // of `Array.prototype.slice.call` and not assigning `arguments` to a
        // variable as a ternary expression
        var args = slice(partialArgs);
        push.apply(args, arguments);
      }
      // mimic the constructor's `return` behavior
      // http://es5.github.io/#x13.2.2
      if (this instanceof bound) {
        // ensure `new bound` is an instance of `func`
        var thisBinding = baseCreate(func.prototype),
            result = func.apply(thisBinding, args || arguments);
        return isObject(result) ? result : thisBinding;
      }
      return func.apply(thisArg, args || arguments);
    }
    setBindData(bound, bindData);
    return bound;
  }

  /**
   * The base implementation of `_.clone` without argument juggling or support
   * for `thisArg` binding.
   *
   * @private
   * @param {*} value The value to clone.
   * @param {boolean} [isDeep=false] Specify a deep clone.
   * @param {Function} [callback] The function to customize cloning values.
   * @param {Array} [stackA=[]] Tracks traversed source objects.
   * @param {Array} [stackB=[]] Associates clones with source counterparts.
   * @returns {*} Returns the cloned value.
   */
  function baseClone(value, isDeep, callback, stackA, stackB) {
    if (callback) {
      var result = callback(value);
      if (typeof result != 'undefined') {
        return result;
      }
    }
    // inspect [[Class]]
    var isObj = isObject(value);
    if (isObj) {
      var className = toString.call(value);
      if (!cloneableClasses[className] || !support.nodeClass && isNode(value)) {
        return value;
      }
      var ctor = ctorByClass[className];
      switch (className) {
        case boolClass:
        case dateClass:
          return new ctor(+value);

        case numberClass:
        case stringClass:
          return new ctor(value);

        case regexpClass:
          result = ctor(value.source, reFlags.exec(value));
          result.lastIndex = value.lastIndex;
          return result;
      }
    } else {
      return value;
    }
    var isArr = isArray(value);
    if (isDeep) {
      // check for circular references and return corresponding clone
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == value) {
          return stackB[length];
        }
      }
      result = isArr ? ctor(value.length) : {};
    } else {
      result = isArr ? slice(value) : assign({}, value);
    }
    // add array properties assigned by `RegExp#exec`
    if (isArr) {
      if (hasOwnProperty.call(value, 'index')) {
        result.index = value.index;
      }
      if (hasOwnProperty.call(value, 'input')) {
        result.input = value.input;
      }
    }
    // exit for shallow clone
    if (!isDeep) {
      return result;
    }
    // add the source value to the stack of traversed objects
    // and associate it with its clone
    stackA.push(value);
    stackB.push(result);

    // recursively populate clone (susceptible to call stack limits)
    (isArr ? baseEach : forOwn)(value, function (objValue, key) {
      result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
    });

    if (initedStack) {
      releaseArray(stackA);
      releaseArray(stackB);
    }
    return result;
  }

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} prototype The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  function baseCreate(prototype, properties) {
    return isObject(prototype) ? nativeCreate(prototype) : {};
  }
  // fallback for browsers without `Object.create`
  if (!nativeCreate) {
    baseCreate = (function () {
      function Object() {}
      return function (prototype) {
        if (isObject(prototype)) {
          Object.prototype = prototype;
          var result = new Object();
          Object.prototype = null;
        }
        return result || root.Object();
      };
    })();
  }

  /**
   * The base implementation of `_.createCallback` without support for creating
   * "_.pluck" or "_.where" style callbacks.
   *
   * @private
   * @param {*} [func=identity] The value to convert to a callback.
   * @param {*} [thisArg] The `this` binding of the created callback.
   * @param {number} [argCount] The number of arguments the callback accepts.
   * @returns {Function} Returns a callback function.
   */
  function baseCreateCallback(func, thisArg, argCount) {
    if (typeof func != 'function') {
      return identity;
    }
    // exit early for no `thisArg` or already bound by `Function#bind`
    if (typeof thisArg == 'undefined' || !('prototype' in func)) {
      return func;
    }
    var bindData = func.__bindData__;
    if (typeof bindData == 'undefined') {
      if (support.funcNames) {
        bindData = !func.name;
      }
      bindData = bindData || !support.funcDecomp;
      if (!bindData) {
        var source = fnToString.call(func);
        if (!support.funcNames) {
          bindData = !reFuncName.test(source);
        }
        if (!bindData) {
          // checks if `func` references the `this` keyword and stores the result
          bindData = reThis.test(source);
          setBindData(func, bindData);
        }
      }
    }
    // exit early if there are no `this` references or `func` is bound
    if (bindData === false || bindData !== true && bindData[1] & 1) {
      return func;
    }
    switch (argCount) {
      case 1:
        return function (value) {
          return func.call(thisArg, value);
        };
      case 2:
        return function (a, b) {
          return func.call(thisArg, a, b);
        };
      case 3:
        return function (value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
      case 4:
        return function (accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
    }
    return bind(func, thisArg);
  }

  /**
   * The base implementation of `createWrapper` that creates the wrapper and
   * sets its meta data.
   *
   * @private
   * @param {Array} bindData The bind data array.
   * @returns {Function} Returns the new function.
   */
  function baseCreateWrapper(bindData) {
    var func = bindData[0],
        bitmask = bindData[1],
        partialArgs = bindData[2],
        partialRightArgs = bindData[3],
        thisArg = bindData[4],
        arity = bindData[5];

    var isBind = bitmask & 1,
        isBindKey = bitmask & 2,
        isCurry = bitmask & 4,
        isCurryBound = bitmask & 8,
        key = func;

    function bound() {
      var thisBinding = isBind ? thisArg : this;
      if (partialArgs) {
        var args = slice(partialArgs);
        push.apply(args, arguments);
      }
      if (partialRightArgs || isCurry) {
        args || (args = slice(arguments));
        if (partialRightArgs) {
          push.apply(args, partialRightArgs);
        }
        if (isCurry && args.length < arity) {
          bitmask |= 16 & ~32;
          return baseCreateWrapper([func, isCurryBound ? bitmask : bitmask & ~3, args, null, thisArg, arity]);
        }
      }
      args || (args = arguments);
      if (isBindKey) {
        func = thisBinding[key];
      }
      if (this instanceof bound) {
        thisBinding = baseCreate(func.prototype);
        var result = func.apply(thisBinding, args);
        return isObject(result) ? result : thisBinding;
      }
      return func.apply(thisBinding, args);
    }
    setBindData(bound, bindData);
    return bound;
  }

  /**
   * The base implementation of `_.difference` that accepts a single array
   * of values to exclude.
   *
   * @private
   * @param {Array} array The array to process.
   * @param {Array} [values] The array of values to exclude.
   * @returns {Array} Returns a new array of filtered values.
   */
  function baseDifference(array, values) {
    var index = -1,
        indexOf = getIndexOf(),
        length = array ? array.length : 0,
        isLarge = length >= largeArraySize && indexOf === baseIndexOf,
        result = [];

    if (isLarge) {
      var cache = createCache(values);
      if (cache) {
        indexOf = cacheIndexOf;
        values = cache;
      } else {
        isLarge = false;
      }
    }
    while (++index < length) {
      var value = array[index];
      if (indexOf(values, value) < 0) {
        result.push(value);
      }
    }
    if (isLarge) {
      releaseObject(values);
    }
    return result;
  }

  /**
   * The base implementation of `_.flatten` without support for callback
   * shorthands or `thisArg` binding.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
   * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
   * @param {number} [fromIndex=0] The index to start from.
   * @returns {Array} Returns a new flattened array.
   */
  function baseFlatten(array, isShallow, isStrict, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (value && typeof value == 'object' && typeof value.length == 'number' && (isArray(value) || isArguments(value))) {
        // recursively flatten arrays (susceptible to call stack limits)
        if (!isShallow) {
          value = baseFlatten(value, isShallow, isStrict);
        }
        var valIndex = -1,
            valLength = value.length,
            resIndex = result.length;

        result.length += valLength;
        while (++valIndex < valLength) {
          result[resIndex++] = value[valIndex];
        }
      } else if (!isStrict) {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.isEqual`, without support for `thisArg` binding,
   * that allows partial "_.where" style comparisons.
   *
   * @private
   * @param {*} a The value to compare.
   * @param {*} b The other value to compare.
   * @param {Function} [callback] The function to customize comparing values.
   * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
   * @param {Array} [stackA=[]] Tracks traversed `a` objects.
   * @param {Array} [stackB=[]] Tracks traversed `b` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(_x, _x2, _x3, _x4, _x5, _x6) {
    var _again = true;

    _function: while (_again) {
      var a = _x,
          b = _x2,
          callback = _x3,
          isWhere = _x4,
          stackA = _x5,
          stackB = _x6;
      _again = false;

      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || 1 / a == 1 / b;
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return a != +a ? b != +b
          // but treat `+0` vs. `-0` as not equal
          : a == 0 ? 1 / a == 1 / b : a == +b;

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          _x = aWrapped ? a.__wrapped__ : a;
          _x2 = bWrapped ? b.__wrapped__ : b;
          _x3 = callback;
          _x4 = isWhere;
          _x5 = stackA;
          _x6 = stackB;
          _again = true;
          result = type = otherType = className = otherClass = isArr = aWrapped = bWrapped = undefined;
          continue _function;
        }
        // exit for functions and DOM nodes
        if (className != objectClass || !support.nodeClass && (isNode(a) || isNode(b))) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
            ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && 'constructor' in a && 'constructor' in b) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if (result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      } else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function (value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB);
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function (value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return result = --size > -1;
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }
  }

  /**
   * The base implementation of `_.random` without argument juggling or support
   * for returning floating-point numbers.
   *
   * @private
   * @param {number} min The minimum possible value.
   * @param {number} max The maximum possible value.
   * @returns {number} Returns a random number.
   */
  function baseRandom(min, max) {
    return min + floor(nativeRandom() * (max - min + 1));
  }

  /**
   * The base implementation of `_.uniq` without support for callback shorthands
   * or `thisArg` binding.
   *
   * @private
   * @param {Array} array The array to process.
   * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
   * @param {Function} [callback] The function called per iteration.
   * @returns {Array} Returns a duplicate-value-free array.
   */
  function baseUniq(array, isSorted, callback) {
    var index = -1,
        indexOf = getIndexOf(),
        length = array ? array.length : 0,
        result = [];

    var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
        seen = callback || isLarge ? getArray() : result;

    if (isLarge) {
      var cache = createCache(seen);
      indexOf = cacheIndexOf;
      seen = cache;
    }
    while (++index < length) {
      var value = array[index],
          computed = callback ? callback(value, index, array) : value;

      if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
        if (callback || isLarge) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
    if (isLarge) {
      releaseArray(seen.array);
      releaseObject(seen);
    } else if (callback) {
      releaseArray(seen);
    }
    return result;
  }

  /**
   * Creates a function that, when called, either curries or invokes `func`
   * with an optional `this` binding and partially applied arguments.
   *
   * @private
   * @param {Function|string} func The function or method name to reference.
   * @param {number} bitmask The bitmask of method flags to compose.
   *  The bitmask may be composed of the following flags:
   *  1 - `_.bind`
   *  2 - `_.bindKey`
   *  4 - `_.curry`
   *  8 - `_.curry` (bound)
   *  16 - `_.partial`
   *  32 - `_.partialRight`
   * @param {Array} [partialArgs] An array of arguments to prepend to those
   *  provided to the new function.
   * @param {Array} [partialRightArgs] An array of arguments to append to those
   *  provided to the new function.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {number} [arity] The arity of `func`.
   * @returns {Function} Returns the new function.
   */
  function createWrapper(_x7, _x8, _x9, _x10, _x11, _x12) {
    var _arguments2 = arguments;
    var _again2 = true;

    _function2: while (_again2) {
      var func = _x7,
          bitmask = _x8,
          partialArgs = _x9,
          partialRightArgs = _x10,
          thisArg = _x11,
          arity = _x12;
      _again2 = false;

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError();
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        _arguments2 = bindData;
        _x7 = _arguments2[0];
        _x8 = _arguments2[1];
        _x9 = _arguments2[2];
        _x10 = _arguments2[3];
        _x11 = _arguments2[4];
        _x12 = _arguments2[5];
        _again2 = true;
        isBind = isBindKey = isCurry = isCurryBound = isPartial = isPartialRight = bindData = undefined;
        continue _function2;
      }
      // fast path for `_.bind`
      var creater = bitmask == 1 || bitmask === 17 ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }
  }

  /**
   * Creates compiled iteration functions.
   *
   * @private
   * @param {...Object} [options] The compile options object(s).
   * @param {string} [options.array] Code to determine if the iterable is an array or array-like.
   * @param {boolean} [options.useHas] Specify using `hasOwnProperty` checks in the object loop.
   * @param {Function} [options.keys] A reference to `_.keys` for use in own property iteration.
   * @param {string} [options.args] A comma separated string of iteration function arguments.
   * @param {string} [options.top] Code to execute before the iteration branches.
   * @param {string} [options.loop] Code to execute in the object loop.
   * @param {string} [options.bottom] Code to execute after the iteration branches.
   * @returns {Function} Returns the compiled function.
   */
  function createIterator() {
    // data properties
    iteratorData.shadowedProps = shadowedProps;

    // iterator options
    iteratorData.array = iteratorData.bottom = iteratorData.loop = iteratorData.top = '';
    iteratorData.init = 'iterable';
    iteratorData.useHas = true;

    // merge options into a template data object
    for (var object, index = 0; object = arguments[index]; index++) {
      for (var key in object) {
        iteratorData[key] = object[key];
      }
    }
    var args = iteratorData.args;
    iteratorData.firstArg = /^[^,]+/.exec(args)[0];

    // create the function factory
    var factory = Function('baseCreateCallback, errorClass, errorProto, hasOwnProperty, ' + 'indicatorObject, isArguments, isArray, isString, keys, objectProto, ' + 'objectTypes, nonEnumProps, stringClass, stringProto, toString', 'return function(' + args + ') {\n' + iteratorTemplate(iteratorData) + '\n}');

    // return the compiled function
    return factory(baseCreateCallback, errorClass, errorProto, hasOwnProperty, indicatorObject, isArguments, isArray, isString, iteratorData.keys, objectProto, objectTypes, nonEnumProps, stringClass, stringProto, toString);
  }

  /**
   * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
   * customized, this method returns the custom method, otherwise it returns
   * the `baseIndexOf` function.
   *
   * @private
   * @returns {Function} Returns the "indexOf" function.
   */
  function getIndexOf() {
    var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
    return result;
  }

  /**
   * Checks if `value` is a native function.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
   */
  function isNative(value) {
    return typeof value == 'function' && reNative.test(value);
  }

  /**
   * Sets `this` binding data on a given function.
   *
   * @private
   * @param {Function} func The function to set data on.
   * @param {Array} value The data array to set.
   */
  var setBindData = !defineProperty ? noop : function (func, value) {
    descriptor.value = value;
    defineProperty(func, '__bindData__', descriptor);
  };

  /*--------------------------------------------------------------------------*/

  /**
   * Checks if `value` is an `arguments` object.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
   * @example
   *
   * (function() { return _.isArguments(arguments); })(1, 2, 3);
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  function isArguments(value) {
    return value && typeof value == 'object' && typeof value.length == 'number' && toString.call(value) == argsClass || false;
  }
  // fallback for browsers that can't detect `arguments` objects by [[Class]]
  if (!support.argsClass) {
    isArguments = function (value) {
      return value && typeof value == 'object' && typeof value.length == 'number' && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee') || false;
    };
  }

  /**
   * Checks if `value` is an array.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
   * @example
   *
   * (function() { return _.isArray(arguments); })();
   * // => false
   *
   * _.isArray([1, 2, 3]);
   * // => true
   */
  var isArray = nativeIsArray || function (value) {
    return value && typeof value == 'object' && typeof value.length == 'number' && toString.call(value) == arrayClass || false;
  };

  /**
   * A fallback implementation of `Object.keys` which produces an array of the
   * given object's own enumerable property names.
   *
   * @private
   * @type Function
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns an array of property names.
   */
  var shimKeys = createIterator({
    'args': 'object',
    'init': '[]',
    'top': 'if (!(objectTypes[typeof object])) return result',
    'loop': 'result.push(index)'
  });

  /**
   * Creates an array composed of the own enumerable property names of an object.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns an array of property names.
   * @example
   *
   * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
   * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
   */
  var keys = !nativeKeys ? shimKeys : function (object) {
    if (!isObject(object)) {
      return [];
    }
    if (support.enumPrototypes && typeof object == 'function' || support.nonEnumArgs && object.length && isArguments(object)) {
      return shimKeys(object);
    }
    return nativeKeys(object);
  };

  /** Reusable iterator options shared by `each`, `forIn`, and `forOwn` */
  var eachIteratorOptions = {
    'args': 'collection, callback, thisArg',
    'top': "callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3)",
    'array': "typeof length == 'number'",
    'keys': keys,
    'loop': 'if (callback(iterable[index], index, collection) === false) return result'
  };

  /** Reusable iterator options for `assign` and `defaults` */
  var defaultsIteratorOptions = {
    'args': 'object, source, guard',
    'top': 'var args = arguments,\n' + '    argsIndex = 0,\n' + "    argsLength = typeof guard == 'number' ? 2 : args.length;\n" + 'while (++argsIndex < argsLength) {\n' + '  iterable = args[argsIndex];\n' + '  if (iterable && objectTypes[typeof iterable]) {',
    'keys': keys,
    'loop': "if (typeof result[index] == 'undefined') result[index] = iterable[index]",
    'bottom': '  }\n}'
  };

  /** Reusable iterator options for `forIn` and `forOwn` */
  var forOwnIteratorOptions = {
    'top': 'if (!objectTypes[typeof iterable]) return result;\n' + eachIteratorOptions.top,
    'array': false
  };

  /**
   * A function compiled to iterate `arguments` objects, arrays, objects, and
   * strings consistenly across environments, executing the callback for each
   * element in the collection. The callback is bound to `thisArg` and invoked
   * with three arguments; (value, index|key, collection). Callbacks may exit
   * iteration early by explicitly returning `false`.
   *
   * @private
   * @type Function
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array|Object|string} Returns `collection`.
   */
  var baseEach = createIterator(eachIteratorOptions);

  /*--------------------------------------------------------------------------*/

  /**
   * Assigns own enumerable properties of source object(s) to the destination
   * object. Subsequent sources will overwrite property assignments of previous
   * sources. If a callback is provided it will be executed to produce the
   * assigned values. The callback is bound to `thisArg` and invoked with two
   * arguments; (objectValue, sourceValue).
   *
   * @static
   * @memberOf _
   * @type Function
   * @alias extend
   * @category Objects
   * @param {Object} object The destination object.
   * @param {...Object} [source] The source objects.
   * @param {Function} [callback] The function to customize assigning values.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns the destination object.
   * @example
   *
   * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
   * // => { 'name': 'fred', 'employer': 'slate' }
   *
   * var defaults = _.partialRight(_.assign, function(a, b) {
   *   return typeof a == 'undefined' ? b : a;
   * });
   *
   * var object = { 'name': 'barney' };
   * defaults(object, { 'name': 'fred', 'employer': 'slate' });
   * // => { 'name': 'barney', 'employer': 'slate' }
   */
  var assign = createIterator(defaultsIteratorOptions, {
    'top': defaultsIteratorOptions.top.replace(';', ';\n' + "if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n" + '  var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n' + "} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n" + '  callback = args[--argsLength];\n' + '}'),
    'loop': 'result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]'
  });

  /**
   * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
   * be cloned, otherwise they will be assigned by reference. If a callback
   * is provided it will be executed to produce the cloned values. If the
   * callback returns `undefined` cloning will be handled by the method instead.
   * The callback is bound to `thisArg` and invoked with one argument; (value).
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to clone.
   * @param {boolean} [isDeep=false] Specify a deep clone.
   * @param {Function} [callback] The function to customize cloning values.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the cloned value.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * var shallow = _.clone(characters);
   * shallow[0] === characters[0];
   * // => true
   *
   * var deep = _.clone(characters, true);
   * deep[0] === characters[0];
   * // => false
   *
   * _.mixin({
   *   'clone': _.partialRight(_.clone, function(value) {
   *     return _.isElement(value) ? value.cloneNode(false) : undefined;
   *   })
   * });
   *
   * var clone = _.clone(document.body);
   * clone.childNodes.length;
   * // => 0
   */
  function clone(value, isDeep, callback, thisArg) {
    // allows working with "Collections" methods without using their `index`
    // and `collection` arguments for `isDeep` and `callback`
    if (typeof isDeep != 'boolean' && isDeep != null) {
      thisArg = callback;
      callback = isDeep;
      isDeep = false;
    }
    return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
  }

  /**
   * Creates a deep clone of `value`. If a callback is provided it will be
   * executed to produce the cloned values. If the callback returns `undefined`
   * cloning will be handled by the method instead. The callback is bound to
   * `thisArg` and invoked with one argument; (value).
   *
   * Note: This method is loosely based on the structured clone algorithm. Functions
   * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
   * objects created by constructors other than `Object` are cloned to plain `Object` objects.
   * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to deep clone.
   * @param {Function} [callback] The function to customize cloning values.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the deep cloned value.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * var deep = _.cloneDeep(characters);
   * deep[0] === characters[0];
   * // => false
   *
   * var view = {
   *   'label': 'docs',
   *   'node': element
   * };
   *
   * var clone = _.cloneDeep(view, function(value) {
   *   return _.isElement(value) ? value.cloneNode(true) : undefined;
   * });
   *
   * clone.node == view.node;
   * // => false
   */
  function cloneDeep(value, callback, thisArg) {
    return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
  }

  /**
   * Creates an object that inherits from the given `prototype` object. If a
   * `properties` object is provided its own enumerable properties are assigned
   * to the created object.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} prototype The object to inherit from.
   * @param {Object} [properties] The properties to assign to the object.
   * @returns {Object} Returns the new object.
   * @example
   *
   * function Shape() {
   *   this.x = 0;
   *   this.y = 0;
   * }
   *
   * function Circle() {
   *   Shape.call(this);
   * }
   *
   * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
   *
   * var circle = new Circle;
   * circle instanceof Circle;
   * // => true
   *
   * circle instanceof Shape;
   * // => true
   */
  function create(prototype, properties) {
    var result = baseCreate(prototype);
    return properties ? assign(result, properties) : result;
  }

  /**
   * Iterates over own and inherited enumerable properties of an object,
   * executing the callback for each property. The callback is bound to `thisArg`
   * and invoked with three arguments; (value, key, object). Callbacks may exit
   * iteration early by explicitly returning `false`.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Objects
   * @param {Object} object The object to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns `object`.
   * @example
   *
   * function Shape() {
   *   this.x = 0;
   *   this.y = 0;
   * }
   *
   * Shape.prototype.move = function(x, y) {
   *   this.x += x;
   *   this.y += y;
   * };
   *
   * _.forIn(new Shape, function(value, key) {
   *   console.log(key);
   * });
   * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
   */
  var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, {
    'useHas': false
  });

  /**
   * Iterates over own enumerable properties of an object, executing the callback
   * for each property. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, key, object). Callbacks may exit iteration early by
   * explicitly returning `false`.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Objects
   * @param {Object} object The object to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns `object`.
   * @example
   *
   * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
   *   console.log(key);
   * });
   * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
   */
  var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);

  /**
   * Creates a sorted array of property names of all enumerable properties,
   * own and inherited, of `object` that have function values.
   *
   * @static
   * @memberOf _
   * @alias methods
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns an array of property names that have function values.
   * @example
   *
   * _.functions(_);
   * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
   */
  function functions(object) {
    var result = [];
    forIn(object, function (value, key) {
      if (isFunction(value)) {
        result.push(key);
      }
    });
    return result.sort();
  }

  /**
   * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
   * length of `0` and objects with no own enumerable properties are considered
   * "empty".
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Array|Object|string} value The value to inspect.
   * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
   * @example
   *
   * _.isEmpty([1, 2, 3]);
   * // => false
   *
   * _.isEmpty({});
   * // => true
   *
   * _.isEmpty('');
   * // => true
   */
  function isEmpty(value) {
    var result = true;
    if (!value) {
      return result;
    }
    var className = toString.call(value),
        length = value.length;

    if (className == arrayClass || className == stringClass || (support.argsClass ? className == argsClass : isArguments(value)) || className == objectClass && typeof length == 'number' && isFunction(value.splice)) {
      return !length;
    }
    forOwn(value, function () {
      return result = false;
    });
    return result;
  }

  /**
   * Performs a deep comparison between two values to determine if they are
   * equivalent to each other. If a callback is provided it will be executed
   * to compare values. If the callback returns `undefined` comparisons will
   * be handled by the method instead. The callback is bound to `thisArg` and
   * invoked with two arguments; (a, b).
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} a The value to compare.
   * @param {*} b The other value to compare.
   * @param {Function} [callback] The function to customize comparing values.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'name': 'fred' };
   * var copy = { 'name': 'fred' };
   *
   * object == copy;
   * // => false
   *
   * _.isEqual(object, copy);
   * // => true
   *
   * var words = ['hello', 'goodbye'];
   * var otherWords = ['hi', 'goodbye'];
   *
   * _.isEqual(words, otherWords, function(a, b) {
   *   var reGreet = /^(?:hello|hi)$/i,
   *       aGreet = _.isString(a) && reGreet.test(a),
   *       bGreet = _.isString(b) && reGreet.test(b);
   *
   *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
   * });
   * // => true
   */
  function isEqual(a, b, callback, thisArg) {
    return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
  }

  /**
   * Checks if `value` is a function.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   */
  function isFunction(value) {
    return typeof value == 'function';
  }
  // fallback for older versions of Chrome and Safari
  if (isFunction(/x/)) {
    isFunction = function (value) {
      return typeof value == 'function' && toString.call(value) == funcClass;
    };
  }

  /**
   * Checks if `value` is the language type of Object.
   * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(1);
   * // => false
   */
  function isObject(value) {
    // check if the value is the ECMAScript language type of Object
    // http://es5.github.io/#x8
    // and avoid a V8 bug
    // http://code.google.com/p/v8/issues/detail?id=2291
    return !!(value && objectTypes[typeof value]);
  }

  /**
   * Checks if `value` is a string.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
   * @example
   *
   * _.isString('fred');
   * // => true
   */
  function isString(value) {
    return typeof value == 'string' || value && typeof value == 'object' && toString.call(value) == stringClass || false;
  }

  /**
   * Creates an array composed of the own enumerable property values of `object`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns an array of property values.
   * @example
   *
   * _.values({ 'one': 1, 'two': 2, 'three': 3 });
   * // => [1, 2, 3] (property order is not guaranteed across environments)
   */
  function values(object) {
    var index = -1,
        props = keys(object),
        length = props.length,
        result = Array(length);

    while (++index < length) {
      result[index] = object[props[index]];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Checks if a given value is present in a collection using strict equality
   * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
   * offset from the end of the collection.
   *
   * @static
   * @memberOf _
   * @alias include
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {*} target The value to check for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
   * @example
   *
   * _.contains([1, 2, 3], 1);
   * // => true
   *
   * _.contains([1, 2, 3], 1, 2);
   * // => false
   *
   * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
   * // => true
   *
   * _.contains('pebbles', 'eb');
   * // => true
   */
  function contains(collection, target, fromIndex) {
    var index = -1,
        indexOf = getIndexOf(),
        length = collection ? collection.length : 0,
        result = false;

    fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
    if (isArray(collection)) {
      result = indexOf(collection, target, fromIndex) > -1;
    } else if (typeof length == 'number') {
      result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
    } else {
      baseEach(collection, function (value) {
        if (++index >= fromIndex) {
          return !(result = value === target);
        }
      });
    }
    return result;
  }

  /**
   * Iterates over elements of a collection, returning an array of all elements
   * the callback returns truey for. The callback is bound to `thisArg` and
   * invoked with three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias select
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of elements that passed the callback check.
   * @example
   *
   * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
   * // => [2, 4, 6]
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36, 'blocked': false },
   *   { 'name': 'fred',   'age': 40, 'blocked': true }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.filter(characters, 'blocked');
   * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
   *
   * // using "_.where" callback shorthand
   * _.filter(characters, { 'age': 36 });
   * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
   */
  function filter(collection, callback, thisArg) {
    var result = [];
    callback = lodash.createCallback(callback, thisArg, 3);

    if (isArray(collection)) {
      var index = -1,
          length = collection.length;

      while (++index < length) {
        var value = collection[index];
        if (callback(value, index, collection)) {
          result.push(value);
        }
      }
    } else {
      baseEach(collection, function (value, index, collection) {
        if (callback(value, index, collection)) {
          result.push(value);
        }
      });
    }
    return result;
  }

  /**
   * Iterates over elements of a collection, returning the first element that
   * the callback returns truey for. The callback is bound to `thisArg` and
   * invoked with three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias detect, findWhere
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the found element, else `undefined`.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney',  'age': 36, 'blocked': false },
   *   { 'name': 'fred',    'age': 40, 'blocked': true },
   *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
   * ];
   *
   * _.find(characters, function(chr) {
   *   return chr.age < 40;
   * });
   * // => { 'name': 'barney', 'age': 36, 'blocked': false }
   *
   * // using "_.where" callback shorthand
   * _.find(characters, { 'age': 1 });
   * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
   *
   * // using "_.pluck" callback shorthand
   * _.find(characters, 'blocked');
   * // => { 'name': 'fred', 'age': 40, 'blocked': true }
   */
  function find(collection, callback, thisArg) {
    callback = lodash.createCallback(callback, thisArg, 3);

    if (isArray(collection)) {
      var index = -1,
          length = collection.length;

      while (++index < length) {
        var value = collection[index];
        if (callback(value, index, collection)) {
          return value;
        }
      }
    } else {
      var result;
      baseEach(collection, function (value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }
  }

  /**
   * Iterates over elements of a collection, executing the callback for each
   * element. The callback is bound to `thisArg` and invoked with three arguments;
   * (value, index|key, collection). Callbacks may exit iteration early by
   * explicitly returning `false`.
   *
   * Note: As with other "Collections" methods, objects with a `length` property
   * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
   * may be used for object iteration.
   *
   * @static
   * @memberOf _
   * @alias each
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array|Object|string} Returns `collection`.
   * @example
   *
   * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
   * // => logs each number and returns '1,2,3'
   *
   * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
   * // => logs each number and returns the object (property order is not guaranteed across environments)
   */
  function forEach(collection, callback, thisArg) {
    if (callback && typeof thisArg == 'undefined' && isArray(collection)) {
      var index = -1,
          length = collection.length;

      while (++index < length) {
        if (callback(collection[index], index, collection) === false) {
          break;
        }
      }
    } else {
      baseEach(collection, callback, thisArg);
    }
    return collection;
  }

  /**
   * Creates an array of values by running each element in the collection
   * through the callback. The callback is bound to `thisArg` and invoked with
   * three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias collect
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of the results of each `callback` execution.
   * @example
   *
   * _.map([1, 2, 3], function(num) { return num * 3; });
   * // => [3, 6, 9]
   *
   * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
   * // => [3, 6, 9] (property order is not guaranteed across environments)
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.map(characters, 'name');
   * // => ['barney', 'fred']
   */
  function map(collection, callback, thisArg) {
    var index = -1,
        length = collection ? collection.length : 0,
        result = Array(typeof length == 'number' ? length : 0);

    callback = lodash.createCallback(callback, thisArg, 3);
    if (isArray(collection)) {
      while (++index < length) {
        result[index] = callback(collection[index], index, collection);
      }
    } else {
      baseEach(collection, function (value, key, collection) {
        result[++index] = callback(value, key, collection);
      });
    }
    return result;
  }

  /**
   * The opposite of `_.filter` this method returns the elements of a
   * collection that the callback does **not** return truey for.
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of elements that failed the callback check.
   * @example
   *
   * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
   * // => [1, 3, 5]
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36, 'blocked': false },
   *   { 'name': 'fred',   'age': 40, 'blocked': true }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.reject(characters, 'blocked');
   * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
   *
   * // using "_.where" callback shorthand
   * _.reject(characters, { 'age': 36 });
   * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
   */
  function reject(collection, callback, thisArg) {
    callback = lodash.createCallback(callback, thisArg, 3);
    return filter(collection, function (value, index, collection) {
      return !callback(value, index, collection);
    });
  }

  /**
   * Retrieves a random element or `n` random elements from a collection.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to sample.
   * @param {number} [n] The number of elements to sample.
   * @param- {Object} [guard] Allows working with functions like `_.map`
   *  without using their `index` arguments as `n`.
   * @returns {Array} Returns the random sample(s) of `collection`.
   * @example
   *
   * _.sample([1, 2, 3, 4]);
   * // => 2
   *
   * _.sample([1, 2, 3, 4], 2);
   * // => [3, 1]
   */
  function sample(collection, n, guard) {
    if (collection && typeof collection.length != 'number') {
      collection = values(collection);
    } else if (support.unindexedChars && isString(collection)) {
      collection = collection.split('');
    }
    if (n == null || guard) {
      return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
    }
    var result = shuffle(collection);
    result.length = nativeMin(nativeMax(0, n), result.length);
    return result;
  }

  /**
   * Creates an array of shuffled values, using a version of the Fisher-Yates
   * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to shuffle.
   * @returns {Array} Returns a new shuffled collection.
   * @example
   *
   * _.shuffle([1, 2, 3, 4, 5, 6]);
   * // => [4, 1, 6, 3, 5, 2]
   */
  function shuffle(collection) {
    var index = -1,
        length = collection ? collection.length : 0,
        result = Array(typeof length == 'number' ? length : 0);

    forEach(collection, function (value) {
      var rand = baseRandom(0, ++index);
      result[index] = result[rand];
      result[rand] = value;
    });
    return result;
  }

  /**
   * Gets the size of the `collection` by returning `collection.length` for arrays
   * and array-like objects or the number of own enumerable properties for objects.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to inspect.
   * @returns {number} Returns `collection.length` or number of own enumerable properties.
   * @example
   *
   * _.size([1, 2]);
   * // => 2
   *
   * _.size({ 'one': 1, 'two': 2, 'three': 3 });
   * // => 3
   *
   * _.size('pebbles');
   * // => 7
   */
  function size(collection) {
    var length = collection ? collection.length : 0;
    return typeof length == 'number' ? length : keys(collection).length;
  }

  /**
   * Creates an array of elements, sorted in ascending order by the results of
   * running each element in a collection through the callback. This method
   * performs a stable sort, that is, it will preserve the original sort order
   * of equal elements. The callback is bound to `thisArg` and invoked with
   * three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an array of property names is provided for `callback` the collection
   * will be sorted by each property value.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Array|Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of sorted elements.
   * @example
   *
   * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
   * // => [3, 1, 2]
   *
   * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
   * // => [3, 1, 2]
   *
   * var characters = [
   *   { 'name': 'barney',  'age': 36 },
   *   { 'name': 'fred',    'age': 40 },
   *   { 'name': 'barney',  'age': 26 },
   *   { 'name': 'fred',    'age': 30 }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.map(_.sortBy(characters, 'age'), _.values);
   * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
   *
   * // sorting by multiple properties
   * _.map(_.sortBy(characters, ['name', 'age']), _.values);
   * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
   */
  function sortBy(collection, callback, thisArg) {
    var index = -1,
        isArr = isArray(callback),
        length = collection ? collection.length : 0,
        result = Array(typeof length == 'number' ? length : 0);

    if (!isArr) {
      callback = lodash.createCallback(callback, thisArg, 3);
    }
    forEach(collection, function (value, key, collection) {
      var object = result[++index] = getObject();
      if (isArr) {
        object.criteria = map(callback, function (key) {
          return value[key];
        });
      } else {
        (object.criteria = getArray())[0] = callback(value, key, collection);
      }
      object.index = index;
      object.value = value;
    });

    length = result.length;
    result.sort(compareAscending);
    while (length--) {
      var object = result[length];
      result[length] = object.value;
      if (!isArr) {
        releaseArray(object.criteria);
      }
      releaseObject(object);
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Flattens a nested array (the nesting can be to any depth). If `isShallow`
   * is truey, the array will only be flattened a single level. If a callback
   * is provided each element of the array is passed through the callback before
   * flattening. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, index, array).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to flatten.
   * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new flattened array.
   * @example
   *
   * _.flatten([1, [2], [3, [[4]]]]);
   * // => [1, 2, 3, 4];
   *
   * _.flatten([1, [2], [3, [[4]]]], true);
   * // => [1, 2, 3, [[4]]];
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
   *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.flatten(characters, 'pets');
   * // => ['hoppy', 'baby puss', 'dino']
   */
  function flatten(array, isShallow, callback, thisArg) {
    // juggle arguments
    if (typeof isShallow != 'boolean' && isShallow != null) {
      thisArg = callback;
      callback = typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array ? null : isShallow;
      isShallow = false;
    }
    if (callback != null) {
      array = map(array, callback, thisArg);
    }
    return baseFlatten(array, isShallow);
  }

  /**
   * Gets the index at which the first occurrence of `value` is found using
   * strict equality for comparisons, i.e. `===`. If the array is already sorted
   * providing `true` for `fromIndex` will run a faster binary search.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {boolean|number} [fromIndex=0] The index to search from or `true`
   *  to perform a binary search on a sorted array.
   * @returns {number} Returns the index of the matched value or `-1`.
   * @example
   *
   * _.indexOf([1, 2, 3, 1, 2, 3], 2);
   * // => 1
   *
   * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
   * // => 4
   *
   * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
   * // => 2
   */
  function indexOf(array, value, fromIndex) {
    if (typeof fromIndex == 'number') {
      var length = array ? array.length : 0;
      fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
    } else if (fromIndex) {
      var index = sortedIndex(array, value);
      return array[index] === value ? index : -1;
    }
    return baseIndexOf(array, value, fromIndex);
  }

  /**
   * Gets the last element or last `n` elements of an array. If a callback is
   * provided elements at the end of the array are returned as long as the
   * callback returns truey. The callback is bound to `thisArg` and invoked
   * with three arguments; (value, index, array).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to query.
   * @param {Function|Object|number|string} [callback] The function called
   *  per element or the number of elements to return. If a property name or
   *  object is provided it will be used to create a "_.pluck" or "_.where"
   *  style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the last element(s) of `array`.
   * @example
   *
   * _.last([1, 2, 3]);
   * // => 3
   *
   * _.last([1, 2, 3], 2);
   * // => [2, 3]
   *
   * _.last([1, 2, 3], function(num) {
   *   return num > 1;
   * });
   * // => [2, 3]
   *
   * var characters = [
   *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
   *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
   *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.pluck(_.last(characters, 'blocked'), 'name');
   * // => ['fred', 'pebbles']
   *
   * // using "_.where" callback shorthand
   * _.last(characters, { 'employer': 'na' });
   * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
   */
  function last(array, callback, thisArg) {
    var n = 0,
        length = array ? array.length : 0;

    if (typeof callback != 'number' && callback != null) {
      var index = length;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (index-- && callback(array[index], index, array)) {
        n++;
      }
    } else {
      n = callback;
      if (n == null || thisArg) {
        return array ? array[length - 1] : undefined;
      }
    }
    return slice(array, nativeMax(0, length - n));
  }

  /**
   * Creates an array of numbers (positive and/or negative) progressing from
   * `start` up to but not including `end`. If `start` is less than `stop` a
   * zero-length range is created unless a negative `step` is specified.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {number} [start=0] The start of the range.
   * @param {number} end The end of the range.
   * @param {number} [step=1] The value to increment or decrement by.
   * @returns {Array} Returns a new range array.
   * @example
   *
   * _.range(4);
   * // => [0, 1, 2, 3]
   *
   * _.range(1, 5);
   * // => [1, 2, 3, 4]
   *
   * _.range(0, 20, 5);
   * // => [0, 5, 10, 15]
   *
   * _.range(0, -4, -1);
   * // => [0, -1, -2, -3]
   *
   * _.range(1, 4, 0);
   * // => [1, 1, 1]
   *
   * _.range(0);
   * // => []
   */
  function range(start, end, step) {
    start = +start || 0;
    step = typeof step == 'number' ? step : +step || 1;

    if (end == null) {
      end = start;
      start = 0;
    }
    // use `Array(length)` so engines like Chakra and V8 avoid slower modes
    // http://youtu.be/XAqIpGU8ZZk#t=17m25s
    var index = -1,
        length = nativeMax(0, ceil((end - start) / (step || 1))),
        result = Array(length);

    while (++index < length) {
      result[index] = start;
      start += step;
    }
    return result;
  }

  /**
   * Uses a binary search to determine the smallest index at which a value
   * should be inserted into a given sorted array in order to maintain the sort
   * order of the array. If a callback is provided it will be executed for
   * `value` and each element of `array` to compute their sort ranking. The
   * callback is bound to `thisArg` and invoked with one argument; (value).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to inspect.
   * @param {*} value The value to evaluate.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {number} Returns the index at which `value` should be inserted
   *  into `array`.
   * @example
   *
   * _.sortedIndex([20, 30, 50], 40);
   * // => 2
   *
   * // using "_.pluck" callback shorthand
   * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
   * // => 2
   *
   * var dict = {
   *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
   * };
   *
   * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
   *   return dict.wordToNumber[word];
   * });
   * // => 2
   *
   * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
   *   return this.wordToNumber[word];
   * }, dict);
   * // => 2
   */
  function sortedIndex(array, value, callback, thisArg) {
    var low = 0,
        high = array ? array.length : low;

    // explicitly reference `identity` for better inlining in Firefox
    callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
    value = callback(value);

    while (low < high) {
      var mid = low + high >>> 1;
      callback(array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  }

  /**
   * Creates a duplicate-value-free version of an array using strict equality
   * for comparisons, i.e. `===`. If the array is sorted, providing
   * `true` for `isSorted` will use a faster algorithm. If a callback is provided
   * each element of `array` is passed through the callback before uniqueness
   * is computed. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, index, array).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias unique
   * @category Arrays
   * @param {Array} array The array to process.
   * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a duplicate-value-free array.
   * @example
   *
   * _.uniq([1, 2, 1, 3, 1]);
   * // => [1, 2, 3]
   *
   * _.uniq([1, 1, 2, 2, 3], true);
   * // => [1, 2, 3]
   *
   * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
   * // => ['A', 'b', 'C']
   *
   * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
   * // => [1, 2.5, 3]
   *
   * // using "_.pluck" callback shorthand
   * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
   * // => [{ 'x': 1 }, { 'x': 2 }]
   */
  function uniq(array, isSorted, callback, thisArg) {
    // juggle arguments
    if (typeof isSorted != 'boolean' && isSorted != null) {
      thisArg = callback;
      callback = typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array ? null : isSorted;
      isSorted = false;
    }
    if (callback != null) {
      callback = lodash.createCallback(callback, thisArg, 3);
    }
    return baseUniq(array, isSorted, callback);
  }

  /**
   * Creates an array excluding all provided values using strict equality for
   * comparisons, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to filter.
   * @param {...*} [value] The values to exclude.
   * @returns {Array} Returns a new array of filtered values.
   * @example
   *
   * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
   * // => [2, 3, 4]
   */
  function without(array) {
    return baseDifference(array, slice(arguments, 1));
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a function that, when called, invokes `func` with the `this`
   * binding of `thisArg` and prepends any additional `bind` arguments to those
   * provided to the bound function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to bind.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {...*} [arg] Arguments to be partially applied.
   * @returns {Function} Returns the new bound function.
   * @example
   *
   * var func = function(greeting) {
   *   return greeting + ' ' + this.name;
   * };
   *
   * func = _.bind(func, { 'name': 'fred' }, 'hi');
   * func();
   * // => 'hi fred'
   */
  function bind(func, thisArg) {
    return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
  }

  /**
   * Creates a function that will delay the execution of `func` until after
   * `wait` milliseconds have elapsed since the last time it was invoked.
   * Provide an options object to indicate that `func` should be invoked on
   * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
   * to the debounced function will return the result of the last `func` call.
   *
   * Note: If `leading` and `trailing` options are `true` `func` will be called
   * on the trailing edge of the timeout only if the the debounced function is
   * invoked more than once during the `wait` timeout.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to debounce.
   * @param {number} wait The number of milliseconds to delay.
   * @param {Object} [options] The options object.
   * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
   * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
   * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // avoid costly calculations while the window size is in flux
   * var lazyLayout = _.debounce(calculateLayout, 150);
   * jQuery(window).on('resize', lazyLayout);
   *
   * // execute `sendMail` when the click event is fired, debouncing subsequent calls
   * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * });
   *
   * // ensure `batchLog` is executed once after 1 second of debounced calls
   * var source = new EventSource('/stream');
   * source.addEventListener('message', _.debounce(batchLog, 250, {
   *   'maxWait': 1000
   * }, false);
   */
  function debounce(func, wait, options) {
    var args,
        maxTimeoutId,
        result,
        stamp,
        thisArg,
        timeoutId,
        trailingCall,
        lastCalled = 0,
        maxWait = false,
        trailing = true;

    if (!isFunction(func)) {
      throw new TypeError();
    }
    wait = nativeMax(0, wait) || 0;
    if (options === true) {
      var leading = true;
      trailing = false;
    } else if (isObject(options)) {
      leading = options.leading;
      maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
      trailing = 'trailing' in options ? options.trailing : trailing;
    }
    var delayed = function delayed() {
      var remaining = wait - (now() - stamp);
      if (remaining <= 0) {
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        var isCalled = trailingCall;
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (isCalled) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      } else {
        timeoutId = setTimeout(delayed, remaining);
      }
    };

    var maxDelayed = function maxDelayed() {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      maxTimeoutId = timeoutId = trailingCall = undefined;
      if (trailing || maxWait !== wait) {
        lastCalled = now();
        result = func.apply(thisArg, args);
        if (!timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
      }
    };

    return function () {
      args = arguments;
      stamp = now();
      thisArg = this;
      trailingCall = trailing && (timeoutId || !leading);

      if (maxWait === false) {
        var leadingCall = leading && !timeoutId;
      } else {
        if (!maxTimeoutId && !leading) {
          lastCalled = stamp;
        }
        var remaining = maxWait - (stamp - lastCalled),
            isCalled = remaining <= 0;

        if (isCalled) {
          if (maxTimeoutId) {
            maxTimeoutId = clearTimeout(maxTimeoutId);
          }
          lastCalled = stamp;
          result = func.apply(thisArg, args);
        } else if (!maxTimeoutId) {
          maxTimeoutId = setTimeout(maxDelayed, remaining);
        }
      }
      if (isCalled && timeoutId) {
        timeoutId = clearTimeout(timeoutId);
      } else if (!timeoutId && wait !== maxWait) {
        timeoutId = setTimeout(delayed, wait);
      }
      if (leadingCall) {
        isCalled = true;
        result = func.apply(thisArg, args);
      }
      if (isCalled && !timeoutId && !maxTimeoutId) {
        args = thisArg = null;
      }
      return result;
    };
  }

  /**
   * Creates a function that, when executed, will only call the `func` function
   * at most once per every `wait` milliseconds. Provide an options object to
   * indicate that `func` should be invoked on the leading and/or trailing edge
   * of the `wait` timeout. Subsequent calls to the throttled function will
   * return the result of the last `func` call.
   *
   * Note: If `leading` and `trailing` options are `true` `func` will be called
   * on the trailing edge of the timeout only if the the throttled function is
   * invoked more than once during the `wait` timeout.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to throttle.
   * @param {number} wait The number of milliseconds to throttle executions to.
   * @param {Object} [options] The options object.
   * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
   * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * // avoid excessively updating the position while scrolling
   * var throttled = _.throttle(updatePosition, 100);
   * jQuery(window).on('scroll', throttled);
   *
   * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
   * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
   *   'trailing': false
   * }));
   */
  function throttle(func, wait, options) {
    var leading = true,
        trailing = true;

    if (!isFunction(func)) {
      throw new TypeError();
    }
    if (options === false) {
      leading = false;
    } else if (isObject(options)) {
      leading = 'leading' in options ? options.leading : leading;
      trailing = 'trailing' in options ? options.trailing : trailing;
    }
    debounceOptions.leading = leading;
    debounceOptions.maxWait = wait;
    debounceOptions.trailing = trailing;

    return debounce(func, wait, debounceOptions);
  }

  /**
   * Creates a function that provides `value` to the wrapper function as its
   * first argument. Additional arguments provided to the function are appended
   * to those provided to the wrapper function. The wrapper is executed with
   * the `this` binding of the created function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {*} value The value to wrap.
   * @param {Function} wrapper The wrapper function.
   * @returns {Function} Returns the new function.
   * @example
   *
   * var p = _.wrap(_.escape, function(func, text) {
   *   return '<p>' + func(text) + '</p>';
   * });
   *
   * p('Fred, Wilma, & Pebbles');
   * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
   */
  function wrap(value, wrapper) {
    return createWrapper(wrapper, 16, [value]);
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Produces a callback bound to an optional `thisArg`. If `func` is a property
   * name the created callback will return the property value for a given element.
   * If `func` is an object the created callback will return `true` for elements
   * that contain the equivalent object properties, otherwise it will return `false`.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {*} [func=identity] The value to convert to a callback.
   * @param {*} [thisArg] The `this` binding of the created callback.
   * @param {number} [argCount] The number of arguments the callback accepts.
   * @returns {Function} Returns a callback function.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * // wrap to create custom callback shorthands
   * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
   *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
   *   return !match ? func(callback, thisArg) : function(object) {
   *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
   *   };
   * });
   *
   * _.filter(characters, 'age__gt38');
   * // => [{ 'name': 'fred', 'age': 40 }]
   */
  function createCallback(func, thisArg, argCount) {
    var type = typeof func;
    if (func == null || type == 'function') {
      return baseCreateCallback(func, thisArg, argCount);
    }
    // handle "_.pluck" style callback shorthands
    if (type != 'object') {
      return property(func);
    }
    var props = keys(func),
        key = props[0],
        a = func[key];

    // handle "_.where" style callback shorthands
    if (props.length == 1 && a === a && !isObject(a)) {
      // fast path the common case of providing an object with a single

      return function (object) {
        var b = object[key];
        return a === b && (a !== 0 || 1 / a == 1 / b);
      };
    }
    return function (object) {
      var length = props.length,
          result = false;

      while (length--) {
        if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
          break;
        }
      }
      return result;
    };
  }

  /**
   * This method returns the first argument provided to it.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'name': 'fred' };
   * _.identity(object) === object;
   * // => true
   */
  function identity(value) {
    return value;
  }

  /**
   * Adds function properties of a source object to the destination object.
   * If `object` is a function methods will be added to its prototype as well.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Function|Object} [object=lodash] object The destination object.
   * @param {Object} source The object of functions to add.
   * @param {Object} [options] The options object.
   * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
   * @example
   *
   * function capitalize(string) {
   *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
   * }
   *
   * _.mixin({ 'capitalize': capitalize });
   * _.capitalize('fred');
   * // => 'Fred'
   *
   * _('fred').capitalize().value();
   * // => 'Fred'
   *
   * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
   * _('fred').capitalize();
   * // => 'Fred'
   */
  function mixin(object, source, options) {
    var chain = true,
        methodNames = source && functions(source);

    if (!source || !options && !methodNames.length) {
      if (options == null) {
        options = source;
      }
      ctor = lodashWrapper;
      source = object;
      object = lodash;
      methodNames = functions(source);
    }
    if (options === false) {
      chain = false;
    } else if (isObject(options) && 'chain' in options) {
      chain = options.chain;
    }
    var ctor = object,
        isFunc = isFunction(ctor);

    forEach(methodNames, function (methodName) {
      var func = object[methodName] = source[methodName];
      if (isFunc) {
        ctor.prototype[methodName] = function () {
          var chainAll = this.__chain__,
              value = this.__wrapped__,
              args = [value];

          push.apply(args, arguments);
          var result = func.apply(object, args);
          if (chain || chainAll) {
            if (value === result && isObject(result)) {
              return this;
            }
            result = new ctor(result);
            result.__chain__ = chainAll;
          }
          return result;
        };
      }
    });
  }

  /**
   * A no-operation function.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @example
   *
   * var object = { 'name': 'fred' };
   * _.noop(object) === undefined;
   * // => true
   */
  function noop() {}
  // no operation performed

  /**
   * Gets the number of milliseconds that have elapsed since the Unix epoch
   * (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @example
   *
   * var stamp = _.now();
   * _.defer(function() { console.log(_.now() - stamp); });
   * // => logs the number of milliseconds it took for the deferred function to be called
   */
  var now = isNative(now = Date.now) && now || function () {
    return new Date().getTime();
  };

  /**
   * Creates a "_.pluck" style function, which returns the `key` value of a
   * given object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {string} key The name of the property to retrieve.
   * @returns {Function} Returns the new function.
   * @example
   *
   * var characters = [
   *   { 'name': 'fred',   'age': 40 },
   *   { 'name': 'barney', 'age': 36 }
   * ];
   *
   * var getName = _.property('name');
   *
   * _.map(characters, getName);
   * // => ['barney', 'fred']
   *
   * _.sortBy(characters, getName);
   * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
   */
  function property(key) {
    return function (object) {
      return object[key];
    };
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` object that wraps the given value with explicit
   * method chaining enabled.
   *
   * @static
   * @memberOf _
   * @category Chaining
   * @param {*} value The value to wrap.
   * @returns {Object} Returns the wrapper object.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney',  'age': 36 },
   *   { 'name': 'fred',    'age': 40 },
   *   { 'name': 'pebbles', 'age': 1 }
   * ];
   *
   * var youngest = _.chain(characters)
   *     .sortBy('age')
   *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
   *     .first()
   *     .value();
   * // => 'pebbles is 1'
   */
  function chain(value) {
    value = new lodashWrapper(value);
    value.__chain__ = true;
    return value;
  }

  /**
   * Enables explicit method chaining on the wrapper object.
   *
   * @name chain
   * @memberOf _
   * @category Chaining
   * @returns {*} Returns the wrapper object.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * // without explicit chaining
   * _(characters).first();
   * // => { 'name': 'barney', 'age': 36 }
   *
   * // with explicit chaining
   * _(characters).chain()
   *   .first()
   *   .pick('age')
   *   .value();
   * // => { 'age': 36 }
   */
  function wrapperChain() {
    this.__chain__ = true;
    return this;
  }

  /**
   * Produces the `toString` result of the wrapped value.
   *
   * @name toString
   * @memberOf _
   * @category Chaining
   * @returns {string} Returns the string result.
   * @example
   *
   * _([1, 2, 3]).toString();
   * // => '1,2,3'
   */
  function wrapperToString() {
    return String(this.__wrapped__);
  }

  /**
   * Extracts the wrapped value.
   *
   * @name valueOf
   * @memberOf _
   * @alias value
   * @category Chaining
   * @returns {*} Returns the wrapped value.
   * @example
   *
   * _([1, 2, 3]).valueOf();
   * // => [1, 2, 3]
   */
  function wrapperValueOf() {
    return this.__wrapped__;
  }

  /*--------------------------------------------------------------------------*/

  lodash.assign = assign;
  lodash.bind = bind;
  lodash.chain = chain;
  lodash.create = create;
  lodash.createCallback = createCallback;
  lodash.debounce = debounce;
  lodash.filter = filter;
  lodash.flatten = flatten;
  lodash.forEach = forEach;
  lodash.forIn = forIn;
  lodash.forOwn = forOwn;
  lodash.functions = functions;
  lodash.keys = keys;
  lodash.map = map;
  lodash.property = property;
  lodash.range = range;
  lodash.reject = reject;
  lodash.shuffle = shuffle;
  lodash.sortBy = sortBy;
  lodash.throttle = throttle;
  lodash.uniq = uniq;
  lodash.values = values;
  lodash.without = without;
  lodash.wrap = wrap;

  // add aliases
  lodash.collect = map;
  lodash.each = forEach;
  lodash.extend = assign;
  lodash.methods = functions;
  lodash.select = filter;
  lodash.unique = uniq;

  // add functions to `lodash.prototype`
  mixin(lodash);

  /*--------------------------------------------------------------------------*/

  // add functions that return unwrapped values when chaining
  lodash.clone = clone;
  lodash.cloneDeep = cloneDeep;
  lodash.contains = contains;
  lodash.find = find;
  lodash.identity = identity;
  lodash.indexOf = indexOf;
  lodash.isArguments = isArguments;
  lodash.isArray = isArray;
  lodash.isEmpty = isEmpty;
  lodash.isEqual = isEqual;
  lodash.isFunction = isFunction;
  lodash.isObject = isObject;
  lodash.isString = isString;
  lodash.mixin = mixin;
  lodash.noop = noop;
  lodash.now = now;
  lodash.size = size;
  lodash.sortedIndex = sortedIndex;

  lodash.detect = find;
  lodash.findWhere = find;
  lodash.include = contains;

  mixin((function () {
    var source = {};
    forOwn(lodash, function (func, methodName) {
      if (!lodash.prototype[methodName]) {
        source[methodName] = func;
      }
    });
    return source;
  })(), false);

  /*--------------------------------------------------------------------------*/

  lodash.last = last;
  lodash.sample = sample;

  forOwn(lodash, function (func, methodName) {
    var callbackable = methodName !== 'sample';
    if (!lodash.prototype[methodName]) {
      lodash.prototype[methodName] = function (n, guard) {
        var chainAll = this.__chain__,
            result = func(this.__wrapped__, n, guard);

        return !chainAll && (n == null || guard && !(callbackable && typeof n == 'function')) ? result : new lodashWrapper(result, chainAll);
      };
    }
  });

  /*--------------------------------------------------------------------------*/

  /**
   * The semantic version number.
   *
   * @static
   * @memberOf _
   * @type string
   */
  lodash.VERSION = '2.4.1';

  // add "Chaining" functions to the wrapper
  lodash.prototype.chain = wrapperChain;
  lodash.prototype.toString = wrapperToString;
  lodash.prototype.value = wrapperValueOf;
  lodash.prototype.valueOf = wrapperValueOf;

  // add `Array` functions that return unwrapped values
  baseEach(['join', 'pop', 'shift'], function (methodName) {
    var func = arrayRef[methodName];
    lodash.prototype[methodName] = function () {
      var chainAll = this.__chain__,
          result = func.apply(this.__wrapped__, arguments);

      return chainAll ? new lodashWrapper(result, chainAll) : result;
    };
  });

  // add `Array` functions that return the existing wrapped value
  baseEach(['push', 'reverse', 'sort', 'unshift'], function (methodName) {
    var func = arrayRef[methodName];
    lodash.prototype[methodName] = function () {
      func.apply(this.__wrapped__, arguments);
      return this;
    };
  });

  // add `Array` functions that return new wrapped values
  baseEach(['concat', 'slice', 'splice'], function (methodName) {
    var func = arrayRef[methodName];
    lodash.prototype[methodName] = function () {
      return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
    };
  });

  // avoid array-like object bugs with `Array#shift` and `Array#splice`
  // in IE < 9, Firefox < 10, Narwhal, and RingoJS
  if (!support.spliceObjects) {
    baseEach(['pop', 'shift', 'splice'], function (methodName) {
      var func = arrayRef[methodName],
          isSplice = methodName == 'splice';

      lodash.prototype[methodName] = function () {
        var chainAll = this.__chain__,
            value = this.__wrapped__,
            result = func.apply(value, arguments);

        if (value.length === 0) {
          delete value[0];
        }
        return chainAll || isSplice ? new lodashWrapper(result, chainAll) : result;
      };
    });
  }

  /*--------------------------------------------------------------------------*/

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = lodash;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function () {
      return lodash;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
      // in Node.js or RingoJS
      if (moduleExports) {
        (freeModule.exports = lodash)._ = lodash;
      }
      // in Narwhal or Rhino -require
      else {
          freeExports._ = lodash;
        }
    } else {
      // in a browser or Rhino
      root._ = lodash;
    }
}).call(undefined);
// property containing a primitive value

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/home/ubuntu/staging/apps/build/js/hammer.js":[function(require,module,exports){
/*! Hammer.JS - v1.1.3 - 2014-05-22
 * http://eightmedia.github.io/hammer.js
 *
 * Copyright (c) 2014 Jorik Tangelder <j.tangelder@gmail.com>;
 * Licensed under the MIT license */

'use strict';

(function (window, undefined) {
    'use strict';

    /**
     * @main
     * @module hammer
     *
     * @class Hammer
     * @static
     */

    /**
     * Hammer, use this to create instances
     * ````
     * var hammertime = new Hammer(myElement);
     * ````
     *
     * @method Hammer
     * @param {HTMLElement} element
     * @param {Object} [options={}]
     * @return {Hammer.Instance}
     */
    var Hammer = function Hammer(element, options) {
        return new Hammer.Instance(element, options || {});
    };

    /**
     * version, as defined in package.json
     * the value will be set at each build
     * @property VERSION
     * @final
     * @type {String}
     */
    Hammer.VERSION = '1.1.3';

    /**
     * default settings.
     * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled
     * by setting it's name (like `swipe`) to false.
     * You can set the defaults for all instances by changing this object before creating an instance.
     * @example
     * ````
     *  Hammer.defaults.drag = false;
     *  Hammer.defaults.behavior.touchAction = 'pan-y';
     *  delete Hammer.defaults.behavior.userSelect;
     * ````
     * @property defaults
     * @type {Object}
     */
    Hammer.defaults = {
        /**
         * this setting object adds styles and attributes to the element to prevent the browser from doing
         * its native behavior. The css properties are auto prefixed for the browsers when needed.
         * @property defaults.behavior
         * @type {Object}
         */
        behavior: {
            /**
             * Disables text selection to improve the dragging gesture. When the value is `none` it also sets
             * `onselectstart=false` for IE on the element. Mainly for desktop browsers.
             * @property defaults.behavior.userSelect
             * @type {String}
             * @default 'none'
             */
            userSelect: 'none',

            /**
             * Specifies whether and how a given region can be manipulated by the user (for instance, by panning or zooming).
             * Used by Chrome 35> and IE10>. By default this makes the element blocking any touch event.
             * @property defaults.behavior.touchAction
             * @type {String}
             * @default: 'pan-y'
             */
            touchAction: 'pan-y',

            /**
             * Disables the default callout shown when you touch and hold a touch target.
             * On iOS, when you touch and hold a touch target such as a link, Safari displays
             * a callout containing information about the link. This property allows you to disable that callout.
             * @property defaults.behavior.touchCallout
             * @type {String}
             * @default 'none'
             */
            touchCallout: 'none',

            /**
             * Specifies whether zooming is enabled. Used by IE10>
             * @property defaults.behavior.contentZooming
             * @type {String}
             * @default 'none'
             */
            contentZooming: 'none',

            /**
             * Specifies that an entire element should be draggable instead of its contents.
             * Mainly for desktop browsers.
             * @property defaults.behavior.userDrag
             * @type {String}
             * @default 'none'
             */
            userDrag: 'none',

            /**
             * Overrides the highlight color shown when the user taps a link or a JavaScript
             * clickable element in Safari on iPhone. This property obeys the alpha value, if specified.
             *
             * If you don't specify an alpha value, Safari on iPhone applies a default alpha value
             * to the color. To disable tap highlighting, set the alpha value to 0 (invisible).
             * If you set the alpha value to 1.0 (opaque), the element is not visible when tapped.
             * @property defaults.behavior.tapHighlightColor
             * @type {String}
             * @default 'rgba(0,0,0,0)'
             */
            tapHighlightColor: 'rgba(0,0,0,0)'
        }
    };

    /**
     * hammer document where the base events are added at
     * @property DOCUMENT
     * @type {HTMLElement}
     * @default window.document
     */
    Hammer.DOCUMENT = document;

    /**
     * detect support for pointer events
     * @property HAS_POINTEREVENTS
     * @type {Boolean}
     */
    Hammer.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;

    /**
     * detect support for touch events
     * @property HAS_TOUCHEVENTS
     * @type {Boolean}
     */
    Hammer.HAS_TOUCHEVENTS = 'ontouchstart' in window;

    /**
     * detect mobile browsers
     * @property IS_MOBILE
     * @type {Boolean}
     */
    Hammer.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);

    /**
     * detect if we want to support mouseevents at all
     * @property NO_MOUSEEVENTS
     * @type {Boolean}
     */
    Hammer.NO_MOUSEEVENTS = Hammer.HAS_TOUCHEVENTS && Hammer.IS_MOBILE || Hammer.HAS_POINTEREVENTS;

    /**
     * interval in which Hammer recalculates current velocity/direction/angle in ms
     * @property CALCULATE_INTERVAL
     * @type {Number}
     * @default 25
     */
    Hammer.CALCULATE_INTERVAL = 25;

    /**
     * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`
     * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)
     * @property EVENT_TYPES
     * @private
     * @writeOnce
     * @type {Object}
     */
    var EVENT_TYPES = {};

    /**
     * direction strings, for safe comparisons
     * @property DIRECTION_DOWN|LEFT|UP|RIGHT
     * @final
     * @type {String}
     * @default 'down' 'left' 'up' 'right'
     */
    var DIRECTION_DOWN = Hammer.DIRECTION_DOWN = 'down';
    var DIRECTION_LEFT = Hammer.DIRECTION_LEFT = 'left';
    var DIRECTION_UP = Hammer.DIRECTION_UP = 'up';
    var DIRECTION_RIGHT = Hammer.DIRECTION_RIGHT = 'right';

    /**
     * pointertype strings, for safe comparisons
     * @property POINTER_MOUSE|TOUCH|PEN
     * @final
     * @type {String}
     * @default 'mouse' 'touch' 'pen'
     */
    var POINTER_MOUSE = Hammer.POINTER_MOUSE = 'mouse';
    var POINTER_TOUCH = Hammer.POINTER_TOUCH = 'touch';
    var POINTER_PEN = Hammer.POINTER_PEN = 'pen';

    /**
     * eventtypes
     * @property EVENT_START|MOVE|END|RELEASE|TOUCH
     * @final
     * @type {String}
     * @default 'start' 'change' 'move' 'end' 'release' 'touch'
     */
    var EVENT_START = Hammer.EVENT_START = 'start';
    var EVENT_MOVE = Hammer.EVENT_MOVE = 'move';
    var EVENT_END = Hammer.EVENT_END = 'end';
    var EVENT_RELEASE = Hammer.EVENT_RELEASE = 'release';
    var EVENT_TOUCH = Hammer.EVENT_TOUCH = 'touch';

    /**
     * if the window events are set...
     * @property READY
     * @writeOnce
     * @type {Boolean}
     * @default false
     */
    Hammer.READY = false;

    /**
     * plugins namespace
     * @property plugins
     * @type {Object}
     */
    Hammer.plugins = Hammer.plugins || {};

    /**
     * gestures namespace
     * see `/gestures` for the definitions
     * @property gestures
     * @type {Object}
     */
    Hammer.gestures = Hammer.gestures || {};

    /**
     * setup events to detect gestures on the document
     * this function is called when creating an new instance
     * @private
     */
    function setup() {
        if (Hammer.READY) {
            return;
        }

        // find what eventtypes we add listeners to
        Event.determineEventTypes();

        // Register all gestures inside Hammer.gestures
        Utils.each(Hammer.gestures, function (gesture) {
            Detection.register(gesture);
        });

        // Add touch events on the document
        Event.onTouch(Hammer.DOCUMENT, EVENT_MOVE, Detection.detect);
        Event.onTouch(Hammer.DOCUMENT, EVENT_END, Detection.detect);

        // Hammer is ready...!
        Hammer.READY = true;
    }

    /**
     * @module hammer
     *
     * @class Utils
     * @static
     */
    var Utils = Hammer.utils = {
        /**
         * extend method, could also be used for cloning when `dest` is an empty object.
         * changes the dest object
         * @method extend
         * @param {Object} dest
         * @param {Object} src
         * @param {Boolean} [merge=false]  do a merge
         * @return {Object} dest
         */
        extend: function extend(dest, src, merge) {
            for (var key in src) {
                if (!src.hasOwnProperty(key) || dest[key] !== undefined && merge) {
                    continue;
                }
                dest[key] = src[key];
            }
            return dest;
        },

        /**
         * simple addEventListener wrapper
         * @method on
         * @param {HTMLElement} element
         * @param {String} type
         * @param {Function} handler
         */
        on: function on(element, type, handler) {
            element.addEventListener(type, handler, false);
        },

        /**
         * simple removeEventListener wrapper
         * @method off
         * @param {HTMLElement} element
         * @param {String} type
         * @param {Function} handler
         */
        off: function off(element, type, handler) {
            element.removeEventListener(type, handler, false);
        },

        /**
         * forEach over arrays and objects
         * @method each
         * @param {Object|Array} obj
         * @param {Function} iterator
         * @param {any} iterator.item
         * @param {Number} iterator.index
         * @param {Object|Array} iterator.obj the source object
         * @param {Object} context value to use as `this` in the iterator
         */
        each: function each(obj, iterator, context) {
            var i, len;

            // native forEach on arrays
            if ('forEach' in obj) {
                obj.forEach(iterator, context);
                // arrays
            } else if (obj.length !== undefined) {
                    for (i = 0, len = obj.length; i < len; i++) {
                        if (iterator.call(context, obj[i], i, obj) === false) {
                            return;
                        }
                    }
                    // objects
                } else {
                        for (i in obj) {
                            if (obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj) === false) {
                                return;
                            }
                        }
                    }
        },

        /**
         * find if a string contains the string using indexOf
         * @method inStr
         * @param {String} src
         * @param {String} find
         * @return {Boolean} found
         */
        inStr: function inStr(src, find) {
            return src.indexOf(find) > -1;
        },

        /**
         * find if a array contains the object using indexOf or a simple polyfill
         * @method inArray
         * @param {String} src
         * @param {String} find
         * @return {Boolean|Number} false when not found, or the index
         */
        inArray: function inArray(src, find) {
            if (src.indexOf) {
                var index = src.indexOf(find);
                return index === -1 ? false : index;
            } else {
                for (var i = 0, len = src.length; i < len; i++) {
                    if (src[i] === find) {
                        return i;
                    }
                }
                return false;
            }
        },

        /**
         * convert an array-like object (`arguments`, `touchlist`) to an array
         * @method toArray
         * @param {Object} obj
         * @return {Array}
         */
        toArray: function toArray(obj) {
            return Array.prototype.slice.call(obj, 0);
        },

        /**
         * find if a node is in the given parent
         * @method hasParent
         * @param {HTMLElement} node
         * @param {HTMLElement} parent
         * @return {Boolean} found
         */
        hasParent: function hasParent(node, parent) {
            while (node) {
                if (node == parent) {
                    return true;
                }
                node = node.parentNode;
            }
            return false;
        },

        /**
         * get the center of all the touches
         * @method getCenter
         * @param {Array} touches
         * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties
         */
        getCenter: function getCenter(touches) {
            var pageX = [],
                pageY = [],
                clientX = [],
                clientY = [],
                min = Math.min,
                max = Math.max;

            // no need to loop when only one touch
            if (touches.length === 1) {
                return {
                    pageX: touches[0].pageX,
                    pageY: touches[0].pageY,
                    clientX: touches[0].clientX,
                    clientY: touches[0].clientY
                };
            }

            Utils.each(touches, function (touch) {
                pageX.push(touch.pageX);
                pageY.push(touch.pageY);
                clientX.push(touch.clientX);
                clientY.push(touch.clientY);
            });

            return {
                pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,
                pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,
                clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,
                clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2
            };
        },

        /**
         * calculate the velocity between two points. unit is in px per ms.
         * @method getVelocity
         * @param {Number} deltaTime
         * @param {Number} deltaX
         * @param {Number} deltaY
         * @return {Object} velocity `x` and `y`
         */
        getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {
            return {
                x: Math.abs(deltaX / deltaTime) || 0,
                y: Math.abs(deltaY / deltaTime) || 0
            };
        },

        /**
         * calculate the angle between two coordinates
         * @method getAngle
         * @param {Touch} touch1
         * @param {Touch} touch2
         * @return {Number} angle
         */
        getAngle: function getAngle(touch1, touch2) {
            var x = touch2.clientX - touch1.clientX,
                y = touch2.clientY - touch1.clientY;

            return Math.atan2(y, x) * 180 / Math.PI;
        },

        /**
         * do a small comparision to get the direction between two touches.
         * @method getDirection
         * @param {Touch} touch1
         * @param {Touch} touch2
         * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`
         */
        getDirection: function getDirection(touch1, touch2) {
            var x = Math.abs(touch1.clientX - touch2.clientX),
                y = Math.abs(touch1.clientY - touch2.clientY);

            if (x >= y) {
                return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
            }
            return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;
        },

        /**
         * calculate the distance between two touches
         * @method getDistance
         * @param {Touch}touch1
         * @param {Touch} touch2
         * @return {Number} distance
         */
        getDistance: function getDistance(touch1, touch2) {
            var x = touch2.clientX - touch1.clientX,
                y = touch2.clientY - touch1.clientY;

            return Math.sqrt(x * x + y * y);
        },

        /**
         * calculate the scale factor between two touchLists
         * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
         * @method getScale
         * @param {Array} start array of touches
         * @param {Array} end array of touches
         * @return {Number} scale
         */
        getScale: function getScale(start, end) {
            // need two fingers...
            if (start.length >= 2 && end.length >= 2) {
                return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
            }
            return 1;
        },

        /**
         * calculate the rotation degrees between two touchLists
         * @method getRotation
         * @param {Array} start array of touches
         * @param {Array} end array of touches
         * @return {Number} rotation
         */
        getRotation: function getRotation(start, end) {
            // need two fingers
            if (start.length >= 2 && end.length >= 2) {
                return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
            }
            return 0;
        },

        /**
         * find out if the direction is vertical   *
         * @method isVertical
         * @param {String} direction matches `DIRECTION_UP|DOWN`
         * @return {Boolean} is_vertical
         */
        isVertical: function isVertical(direction) {
            return direction == DIRECTION_UP || direction == DIRECTION_DOWN;
        },

        /**
         * set css properties with their prefixes
         * @param {HTMLElement} element
         * @param {String} prop
         * @param {String} value
         * @param {Boolean} [toggle=true]
         * @return {Boolean}
         */
        setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {
            var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];
            prop = Utils.toCamelCase(prop);

            for (var i = 0; i < prefixes.length; i++) {
                var p = prop;
                // prefixes
                if (prefixes[i]) {
                    p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);
                }

                // test the style
                if (p in element.style) {
                    element.style[p] = (toggle == null || toggle) && value || '';
                    break;
                }
            }
        },

        /**
         * toggle browser default behavior by setting css properties.
         * `userSelect='none'` also sets `element.onselectstart` to false
         * `userDrag='none'` also sets `element.ondragstart` to false
         *
         * @method toggleBehavior
         * @param {HtmlElement} element
         * @param {Object} props
         * @param {Boolean} [toggle=true]
         */
        toggleBehavior: function toggleBehavior(element, props, toggle) {
            if (!props || !element || !element.style) {
                return;
            }

            // set the css properties
            Utils.each(props, function (value, prop) {
                Utils.setPrefixedCss(element, prop, value, toggle);
            });

            var falseFn = toggle && function () {
                return false;
            };

            // also the disable onselectstart
            if (props.userSelect == 'none') {
                element.onselectstart = falseFn;
            }
            // and disable ondragstart
            if (props.userDrag == 'none') {
                element.ondragstart = falseFn;
            }
        },

        /**
         * convert a string with underscores to camelCase
         * so prevent_default becomes preventDefault
         * @param {String} str
         * @return {String} camelCaseStr
         */
        toCamelCase: function toCamelCase(str) {
            return str.replace(/[_-]([a-z])/g, function (s) {
                return s[1].toUpperCase();
            });
        }
    };

    /**
     * @module hammer
     */
    /**
     * @class Event
     * @static
     */
    var Event = Hammer.event = {
        /**
         * when touch events have been fired, this is true
         * this is used to stop mouse events
         * @property prevent_mouseevents
         * @private
         * @type {Boolean}
         */
        preventMouseEvents: false,

        /**
         * if EVENT_START has been fired
         * @property started
         * @private
         * @type {Boolean}
         */
        started: false,

        /**
         * when the mouse is hold down, this is true
         * @property should_detect
         * @private
         * @type {Boolean}
         */
        shouldDetect: false,

        /**
         * simple event binder with a hook and support for multiple types
         * @method on
         * @param {HTMLElement} element
         * @param {String} type
         * @param {Function} handler
         * @param {Function} [hook]
         * @param {Object} hook.type
         */
        on: function on(element, type, handler, hook) {
            var types = type.split(' ');
            Utils.each(types, function (type) {
                Utils.on(element, type, handler);
                hook && hook(type);
            });
        },

        /**
         * simple event unbinder with a hook and support for multiple types
         * @method off
         * @param {HTMLElement} element
         * @param {String} type
         * @param {Function} handler
         * @param {Function} [hook]
         * @param {Object} hook.type
         */
        off: function off(element, type, handler, hook) {
            var types = type.split(' ');
            Utils.each(types, function (type) {
                Utils.off(element, type, handler);
                hook && hook(type);
            });
        },

        /**
         * the core touch event handler.
         * this finds out if we should to detect gestures
         * @method onTouch
         * @param {HTMLElement} element
         * @param {String} eventType matches `EVENT_START|MOVE|END`
         * @param {Function} handler
         * @return onTouchHandler {Function} the core event handler
         */
        onTouch: function onTouch(element, eventType, handler) {
            var self = this;

            var onTouchHandler = function onTouchHandler(ev) {
                var srcType = ev.type.toLowerCase(),
                    isPointer = Hammer.HAS_POINTEREVENTS,
                    isMouse = Utils.inStr(srcType, 'mouse'),
                    triggerType;

                // if we are in a mouseevent, but there has been a touchevent triggered in this session
                // we want to do nothing. simply break out of the event.
                if (isMouse && self.preventMouseEvents) {
                    return;

                    // mousebutton must be down
                } else if (isMouse && eventType == EVENT_START && ev.button === 0) {
                        self.preventMouseEvents = false;
                        self.shouldDetect = true;
                    } else if (isPointer && eventType == EVENT_START) {
                        self.shouldDetect = ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev);
                        // just a valid start event, but no mouse
                    } else if (!isMouse && eventType == EVENT_START) {
                            self.preventMouseEvents = true;
                            self.shouldDetect = true;
                        }

                // update the pointer event before entering the detection
                if (isPointer && eventType != EVENT_END) {
                    PointerEvent.updatePointer(eventType, ev);
                }

                // we are in a touch/down state, so allowed detection of gestures
                if (self.shouldDetect) {
                    triggerType = self.doDetect.call(self, ev, eventType, element, handler);
                }

                // ...and we are done with the detection
                // so reset everything to start each detection totally fresh
                if (triggerType == EVENT_END) {
                    self.preventMouseEvents = false;
                    self.shouldDetect = false;
                    PointerEvent.reset();
                    // update the pointerevent object after the detection
                }

                if (isPointer && eventType == EVENT_END) {
                    PointerEvent.updatePointer(eventType, ev);
                }
            };

            this.on(element, EVENT_TYPES[eventType], onTouchHandler);
            return onTouchHandler;
        },

        /**
         * the core detection method
         * this finds out what hammer-touch-events to trigger
         * @method doDetect
         * @param {Object} ev
         * @param {String} eventType matches `EVENT_START|MOVE|END`
         * @param {HTMLElement} element
         * @param {Function} handler
         * @return {String} triggerType matches `EVENT_START|MOVE|END`
         */
        doDetect: function doDetect(ev, eventType, element, handler) {
            var touchList = this.getTouchList(ev, eventType);
            var touchListLength = touchList.length;
            var triggerType = eventType;
            var triggerChange = touchList.trigger; // used by fakeMultitouch plugin
            var changedLength = touchListLength;

            // at each touchstart-like event we want also want to trigger a TOUCH event...
            if (eventType == EVENT_START) {
                triggerChange = EVENT_TOUCH;
                // ...the same for a touchend-like event
            } else if (eventType == EVENT_END) {
                    triggerChange = EVENT_RELEASE;

                    // keep track of how many touches have been removed
                    changedLength = touchList.length - (ev.changedTouches ? ev.changedTouches.length : 1);
                }

            // after there are still touches on the screen,
            // we just want to trigger a MOVE event. so change the START or END to a MOVE
            // but only after detection has been started, the first time we actualy want a START
            if (changedLength > 0 && this.started) {
                triggerType = EVENT_MOVE;
            }

            // detection has been started, we keep track of this, see above
            this.started = true;

            // generate some event data, some basic information
            var evData = this.collectEventData(element, triggerType, touchList, ev);

            // trigger the triggerType event before the change (TOUCH, RELEASE) events
            // but the END event should be at last
            if (eventType != EVENT_END) {
                handler.call(Detection, evData);
            }

            // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed
            if (triggerChange) {
                evData.changedLength = changedLength;
                evData.eventType = triggerChange;

                handler.call(Detection, evData);

                evData.eventType = triggerType;
                delete evData.changedLength;
            }

            // trigger the END event
            if (triggerType == EVENT_END) {
                handler.call(Detection, evData);

                // ...and we are done with the detection
                // so reset everything to start each detection totally fresh
                this.started = false;
            }

            return triggerType;
        },

        /**
         * we have different events for each device/browser
         * determine what we need and set them in the EVENT_TYPES constant
         * the `onTouch` method is bind to these properties.
         * @method determineEventTypes
         * @return {Object} events
         */
        determineEventTypes: function determineEventTypes() {
            var types;
            if (Hammer.HAS_POINTEREVENTS) {
                if (window.PointerEvent) {
                    types = ['pointerdown', 'pointermove', 'pointerup pointercancel lostpointercapture'];
                } else {
                    types = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp MSPointerCancel MSLostPointerCapture'];
                }
            } else if (Hammer.NO_MOUSEEVENTS) {
                types = ['touchstart', 'touchmove', 'touchend touchcancel'];
            } else {
                types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];
            }

            EVENT_TYPES[EVENT_START] = types[0];
            EVENT_TYPES[EVENT_MOVE] = types[1];
            EVENT_TYPES[EVENT_END] = types[2];
            return EVENT_TYPES;
        },

        /**
         * create touchList depending on the event
         * @method getTouchList
         * @param {Object} ev
         * @param {String} eventType
         * @return {Array} touches
         */
        getTouchList: function getTouchList(ev, eventType) {
            // get the fake pointerEvent touchlist
            if (Hammer.HAS_POINTEREVENTS) {
                return PointerEvent.getTouchList();
            }

            // get the touchlist
            if (ev.touches) {
                if (eventType == EVENT_MOVE) {
                    return ev.touches;
                }

                var identifiers = [];
                var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));
                var touchList = [];

                Utils.each(concat, function (touch) {
                    if (Utils.inArray(identifiers, touch.identifier) === false) {
                        touchList.push(touch);
                    }
                    identifiers.push(touch.identifier);
                });

                return touchList;
            }

            // make fake touchList from mouse position
            ev.identifier = 1;
            return [ev];
        },

        /**
         * collect basic event data
         * @method collectEventData
         * @param {HTMLElement} element
         * @param {String} eventType matches `EVENT_START|MOVE|END`
         * @param {Array} touches
         * @param {Object} ev
         * @return {Object} ev
         */
        collectEventData: function collectEventData(element, eventType, touches, ev) {
            // find out pointerType
            var pointerType = POINTER_TOUCH;
            if (Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {
                pointerType = POINTER_MOUSE;
            } else if (PointerEvent.matchType(POINTER_PEN, ev)) {
                pointerType = POINTER_PEN;
            }

            return {
                center: Utils.getCenter(touches),
                timeStamp: Date.now(),
                target: ev.target,
                touches: touches,
                eventType: eventType,
                pointerType: pointerType,
                srcEvent: ev,

                /**
                 * prevent the browser default actions
                 * mostly used to disable scrolling of the browser
                 */
                preventDefault: function preventDefault() {
                    var srcEvent = this.srcEvent;
                    srcEvent.preventManipulation && srcEvent.preventManipulation();
                    srcEvent.preventDefault && srcEvent.preventDefault();
                },

                /**
                 * stop bubbling the event up to its parents
                 */
                stopPropagation: function stopPropagation() {
                    this.srcEvent.stopPropagation();
                },

                /**
                 * immediately stop gesture detection
                 * might be useful after a swipe was detected
                 * @return {*}
                 */
                stopDetect: function stopDetect() {
                    return Detection.stopDetect();
                }
            };
        }
    };

    /**
     * @module hammer
     *
     * @class PointerEvent
     * @static
     */
    var PointerEvent = Hammer.PointerEvent = {
        /**
         * holds all pointers, by `identifier`
         * @property pointers
         * @type {Object}
         */
        pointers: {},

        /**
         * get the pointers as an array
         * @method getTouchList
         * @return {Array} touchlist
         */
        getTouchList: function getTouchList() {
            var touchlist = [];
            // we can use forEach since pointerEvents only is in IE10
            Utils.each(this.pointers, function (pointer) {
                touchlist.push(pointer);
            });

            return touchlist;
        },

        /**
         * update the position of a pointer
         * @method updatePointer
         * @param {String} eventType matches `EVENT_START|MOVE|END`
         * @param {Object} pointerEvent
         */
        updatePointer: function updatePointer(eventType, pointerEvent) {
            if (eventType == EVENT_END) {
                delete this.pointers[pointerEvent.pointerId];
            } else {
                pointerEvent.identifier = pointerEvent.pointerId;
                this.pointers[pointerEvent.pointerId] = pointerEvent;
            }
        },

        /**
         * check if ev matches pointertype
         * @method matchType
         * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`
         * @param {PointerEvent} ev
         */
        matchType: function matchType(pointerType, ev) {
            if (!ev.pointerType) {
                return false;
            }

            var pt = ev.pointerType,
                types = {};

            types[POINTER_MOUSE] = pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE);
            types[POINTER_TOUCH] = pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH);
            types[POINTER_PEN] = pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN);
            return types[pointerType];
        },

        /**
         * reset the stored pointers
         * @method reset
         */
        reset: function resetList() {
            this.pointers = {};
        }
    };

    /**
     * @module hammer
     *
     * @class Detection
     * @static
     */
    var Detection = Hammer.detection = {
        // contains all registred Hammer.gestures in the correct order
        gestures: [],

        // data of the current Hammer.gesture detection session
        current: null,

        // the previous Hammer.gesture session data
        // is a full clone of the previous gesture.current object
        previous: null,

        // when this becomes true, no gestures are fired
        stopped: false,

        /**
         * start Hammer.gesture detection
         * @method startDetect
         * @param {Hammer.Instance} inst
         * @param {Object} eventData
         */
        startDetect: function startDetect(inst, eventData) {
            // already busy with a Hammer.gesture detection on an element
            if (this.current) {
                return;
            }

            this.stopped = false;

            // holds current session
            this.current = {
                inst: inst, // reference to HammerInstance we're working for
                startEvent: Utils.extend({}, eventData), // start eventData for distances, timing etc
                lastEvent: false, // last eventData
                lastCalcEvent: false, // last eventData for calculations.
                futureCalcEvent: false, // last eventData for calculations.
                lastCalcData: {}, // last lastCalcData
                name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc
            };

            this.detect(eventData);
        },

        /**
         * Hammer.gesture detection
         * @method detect
         * @param {Object} eventData
         * @return {any}
         */
        detect: function detect(eventData) {
            if (!this.current || this.stopped) {
                return;
            }

            // extend event data with calculations about scale, distance etc
            eventData = this.extendEventData(eventData);

            // hammer instance and instance options
            var inst = this.current.inst,
                instOptions = inst.options;

            // call Hammer.gesture handlers
            Utils.each(this.gestures, function triggerGesture(gesture) {
                // only when the instance options have enabled this gesture
                if (!this.stopped && inst.enabled && instOptions[gesture.name]) {
                    gesture.handler.call(gesture, eventData, inst);
                }
            }, this);

            // store as previous event event
            if (this.current) {
                this.current.lastEvent = eventData;
            }

            if (eventData.eventType == EVENT_END) {
                this.stopDetect();
            }

            return eventData;
        },

        /**
         * clear the Hammer.gesture vars
         * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected
         * to stop other Hammer.gestures from being fired
         * @method stopDetect
         */
        stopDetect: function stopDetect() {
            // clone current data to the store as the previous gesture
            // used for the double tap gesture, since this is an other gesture detect session
            this.previous = Utils.extend({}, this.current);

            // reset the current
            this.current = null;
            this.stopped = true;
        },

        /**
         * calculate velocity, angle and direction
         * @method getVelocityData
         * @param {Object} ev
         * @param {Object} center
         * @param {Number} deltaTime
         * @param {Number} deltaX
         * @param {Number} deltaY
         */
        getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {
            var cur = this.current,
                recalc = false,
                calcEv = cur.lastCalcEvent,
                calcData = cur.lastCalcData;

            if (calcEv && ev.timeStamp - calcEv.timeStamp > Hammer.CALCULATE_INTERVAL) {
                center = calcEv.center;
                deltaTime = ev.timeStamp - calcEv.timeStamp;
                deltaX = ev.center.clientX - calcEv.center.clientX;
                deltaY = ev.center.clientY - calcEv.center.clientY;
                recalc = true;
            }

            if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
                cur.futureCalcEvent = ev;
            }

            if (!cur.lastCalcEvent || recalc) {
                calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);
                calcData.angle = Utils.getAngle(center, ev.center);
                calcData.direction = Utils.getDirection(center, ev.center);

                cur.lastCalcEvent = cur.futureCalcEvent || ev;
                cur.futureCalcEvent = ev;
            }

            ev.velocityX = calcData.velocity.x;
            ev.velocityY = calcData.velocity.y;
            ev.interimAngle = calcData.angle;
            ev.interimDirection = calcData.direction;
        },

        /**
         * extend eventData for Hammer.gestures
         * @method extendEventData
         * @param {Object} ev
         * @return {Object} ev
         */
        extendEventData: function extendEventData(ev) {
            var cur = this.current,
                startEv = cur.startEvent,
                lastEv = cur.lastEvent || startEv;

            // update the start touchlist to calculate the scale/rotation
            if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
                startEv.touches = [];
                Utils.each(ev.touches, function (touch) {
                    startEv.touches.push({
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                });
            }

            var deltaTime = ev.timeStamp - startEv.timeStamp,
                deltaX = ev.center.clientX - startEv.center.clientX,
                deltaY = ev.center.clientY - startEv.center.clientY;

            this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);

            Utils.extend(ev, {
                startEvent: startEv,

                deltaTime: deltaTime,
                deltaX: deltaX,
                deltaY: deltaY,

                distance: Utils.getDistance(startEv.center, ev.center),
                angle: Utils.getAngle(startEv.center, ev.center),
                direction: Utils.getDirection(startEv.center, ev.center),
                scale: Utils.getScale(startEv.touches, ev.touches),
                rotation: Utils.getRotation(startEv.touches, ev.touches)
            });

            return ev;
        },

        /**
         * register new gesture
         * @method register
         * @param {Object} gesture object, see `gestures/` for documentation
         * @return {Array} gestures
         */
        register: function register(gesture) {
            // add an enable gesture options if there is no given
            var options = gesture.defaults || {};
            if (options[gesture.name] === undefined) {
                options[gesture.name] = true;
            }

            // extend Hammer default options with the Hammer.gesture options
            Utils.extend(Hammer.defaults, options, true);

            // set its index
            gesture.index = gesture.index || 1000;

            // add Hammer.gesture to the list
            this.gestures.push(gesture);

            // sort the list by index
            this.gestures.sort(function (a, b) {
                if (a.index < b.index) {
                    return -1;
                }
                if (a.index > b.index) {
                    return 1;
                }
                return 0;
            });

            return this.gestures;
        }
    };

    /**
     * @module hammer
     */

    /**
     * create new hammer instance
     * all methods should return the instance itself, so it is chainable.
     *
     * @class Instance
     * @constructor
     * @param {HTMLElement} element
     * @param {Object} [options={}] options are merged with `Hammer.defaults`
     * @return {Hammer.Instance}
     */
    Hammer.Instance = function (element, options) {
        var self = this;

        // setup HammerJS window events and register all gestures
        // this also sets up the default options
        setup();

        /**
         * @property element
         * @type {HTMLElement}
         */
        this.element = element;

        /**
         * @property enabled
         * @type {Boolean}
         * @protected
         */
        this.enabled = true;

        /**
         * options, merged with the defaults
         * options with an _ are converted to camelCase
         * @property options
         * @type {Object}
         */
        Utils.each(options, function (value, name) {
            delete options[name];
            options[Utils.toCamelCase(name)] = value;
        });

        this.options = Utils.extend(Utils.extend({}, Hammer.defaults), options || {});

        // add some css to the element to prevent the browser from doing its native behavoir
        if (this.options.behavior) {
            Utils.toggleBehavior(this.element, this.options.behavior, true);
        }

        /**
         * event start handler on the element to start the detection
         * @property eventStartHandler
         * @type {Object}
         */
        this.eventStartHandler = Event.onTouch(element, EVENT_START, function (ev) {
            if (self.enabled && ev.eventType == EVENT_START) {
                Detection.startDetect(self, ev);
            } else if (ev.eventType == EVENT_TOUCH) {
                Detection.detect(ev);
            }
        });

        /**
         * keep a list of user event handlers which needs to be removed when calling 'dispose'
         * @property eventHandlers
         * @type {Array}
         */
        this.eventHandlers = [];
    };

    Hammer.Instance.prototype = {
        /**
         * bind events to the instance
         * @method on
         * @chainable
         * @param {String} gestures multiple gestures by splitting with a space
         * @param {Function} handler
         * @param {Object} handler.ev event object
         */
        on: function onEvent(gestures, handler) {
            var self = this;
            Event.on(self.element, gestures, handler, function (type) {
                self.eventHandlers.push({ gesture: type, handler: handler });
            });
            return self;
        },

        /**
         * unbind events to the instance
         * @method off
         * @chainable
         * @param {String} gestures
         * @param {Function} handler
         */
        off: function offEvent(gestures, handler) {
            var self = this;

            Event.off(self.element, gestures, handler, function (type) {
                var index = Utils.inArray({ gesture: type, handler: handler });
                if (index !== false) {
                    self.eventHandlers.splice(index, 1);
                }
            });
            return self;
        },

        /**
         * trigger gesture event
         * @method trigger
         * @chainable
         * @param {String} gesture
         * @param {Object} [eventData]
         */
        trigger: function triggerEvent(gesture, eventData) {
            // optional
            if (!eventData) {
                eventData = {};
            }

            // create DOM event
            var event = Hammer.DOCUMENT.createEvent('Event');
            event.initEvent(gesture, true, true);
            event.gesture = eventData;

            // trigger on the target if it is in the instance element,
            // this is for event delegation tricks
            var element = this.element;
            if (Utils.hasParent(eventData.target, element)) {
                element = eventData.target;
            }

            element.dispatchEvent(event);
            return this;
        },

        /**
         * enable of disable hammer.js detection
         * @method enable
         * @chainable
         * @param {Boolean} state
         */
        enable: function enable(state) {
            this.enabled = state;
            return this;
        },

        /**
         * dispose this hammer instance
         * @method dispose
         * @return {Null}
         */
        dispose: function dispose() {
            var i, eh;

            // undo all changes made by stop_browser_behavior
            Utils.toggleBehavior(this.element, this.options.behavior, false);

            // unbind all custom event handlers
            for (i = -1; eh = this.eventHandlers[++i];) {
                Utils.off(this.element, eh.gesture, eh.handler);
            }

            this.eventHandlers = [];

            // unbind the start event listener
            Event.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);

            return null;
        }
    };

    /**
     * @module gestures
     */
    /**
     * Move with x fingers (default 1) around on the page.
     * Preventing the default browser behavior is a good way to improve feel and working.
     * ````
     *  hammertime.on("drag", function(ev) {
     *    console.log(ev);
     *    ev.gesture.preventDefault();
     *  });
     * ````
     *
     * @class Drag
     * @static
     */
    /**
     * @event drag
     * @param {Object} ev
     */
    /**
     * @event dragstart
     * @param {Object} ev
     */
    /**
     * @event dragend
     * @param {Object} ev
     */
    /**
     * @event drapleft
     * @param {Object} ev
     */
    /**
     * @event dragright
     * @param {Object} ev
     */
    /**
     * @event dragup
     * @param {Object} ev
     */
    /**
     * @event dragdown
     * @param {Object} ev
     */

    /**
     * @param {String} name
     */
    (function (name) {
        var triggered = false;

        function dragGesture(ev, inst) {
            var cur = Detection.current;

            // max touches
            if (inst.options.dragMaxTouches > 0 && ev.touches.length > inst.options.dragMaxTouches) {
                return;
            }

            switch (ev.eventType) {
                case EVENT_START:
                    triggered = false;
                    break;

                case EVENT_MOVE:
                    // when the distance we moved is too small we skip this gesture
                    // or we can be already in dragging
                    if (ev.distance < inst.options.dragMinDistance && cur.name != name) {
                        return;
                    }

                    var startCenter = cur.startEvent.center;

                    // we are dragging!
                    if (cur.name != name) {
                        cur.name = name;
                        if (inst.options.dragDistanceCorrection && ev.distance > 0) {
                            // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.
                            // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.
                            // It might be useful to save the original start point somewhere
                            var factor = Math.abs(inst.options.dragMinDistance / ev.distance);
                            startCenter.pageX += ev.deltaX * factor;
                            startCenter.pageY += ev.deltaY * factor;
                            startCenter.clientX += ev.deltaX * factor;
                            startCenter.clientY += ev.deltaY * factor;

                            // recalculate event data using new start point
                            ev = Detection.extendEventData(ev);
                        }
                    }

                    // lock drag to axis?
                    if (cur.lastEvent.dragLockToAxis || inst.options.dragLockToAxis && inst.options.dragLockMinDistance <= ev.distance) {
                        ev.dragLockToAxis = true;
                    }

                    // keep direction on the axis that the drag gesture started on
                    var lastDirection = cur.lastEvent.direction;
                    if (ev.dragLockToAxis && lastDirection !== ev.direction) {
                        if (Utils.isVertical(lastDirection)) {
                            ev.direction = ev.deltaY < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                        } else {
                            ev.direction = ev.deltaX < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                        }
                    }

                    // first time, trigger dragstart event
                    if (!triggered) {
                        inst.trigger(name + 'start', ev);
                        triggered = true;
                    }

                    // trigger events
                    inst.trigger(name, ev);
                    inst.trigger(name + ev.direction, ev);

                    var isVertical = Utils.isVertical(ev.direction);

                    // block the browser events
                    if (inst.options.dragBlockVertical && isVertical || inst.options.dragBlockHorizontal && !isVertical) {
                        ev.preventDefault();
                    }
                    break;

                case EVENT_RELEASE:
                    if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {
                        inst.trigger(name + 'end', ev);
                        triggered = false;
                    }
                    break;

                case EVENT_END:
                    triggered = false;
                    break;
            }
        }

        Hammer.gestures.Drag = {
            name: name,
            index: 50,
            handler: dragGesture,
            defaults: {
                /**
                 * minimal movement that have to be made before the drag event gets triggered
                 * @property dragMinDistance
                 * @type {Number}
                 * @default 10
                 */
                dragMinDistance: 10,

                /**
                 * Set dragDistanceCorrection to true to make the starting point of the drag
                 * be calculated from where the drag was triggered, not from where the touch started.
                 * Useful to avoid a jerk-starting drag, which can make fine-adjustments
                 * through dragging difficult, and be visually unappealing.
                 * @property dragDistanceCorrection
                 * @type {Boolean}
                 * @default true
                 */
                dragDistanceCorrection: true,

                /**
                 * set 0 for unlimited, but this can conflict with transform
                 * @property dragMaxTouches
                 * @type {Number}
                 * @default 1
                 */
                dragMaxTouches: 1,

                /**
                 * prevent default browser behavior when dragging occurs
                 * be careful with it, it makes the element a blocking element
                 * when you are using the drag gesture, it is a good practice to set this true
                 * @property dragBlockHorizontal
                 * @type {Boolean}
                 * @default false
                 */
                dragBlockHorizontal: false,

                /**
                 * same as `dragBlockHorizontal`, but for vertical movement
                 * @property dragBlockVertical
                 * @type {Boolean}
                 * @default false
                 */
                dragBlockVertical: false,

                /**
                 * dragLockToAxis keeps the drag gesture on the axis that it started on,
                 * It disallows vertical directions if the initial direction was horizontal, and vice versa.
                 * @property dragLockToAxis
                 * @type {Boolean}
                 * @default false
                 */
                dragLockToAxis: false,

                /**
                 * drag lock only kicks in when distance > dragLockMinDistance
                 * This way, locking occurs only when the distance has become large enough to reliably determine the direction
                 * @property dragLockMinDistance
                 * @type {Number}
                 * @default 25
                 */
                dragLockMinDistance: 25
            }
        };
    })('drag');

    /**
     * @module gestures
     */
    /**
     * trigger a simple gesture event, so you can do anything in your handler.
     * only usable if you know what your doing...
     *
     * @class Gesture
     * @static
     */
    /**
     * @event gesture
     * @param {Object} ev
     */
    Hammer.gestures.Gesture = {
        name: 'gesture',
        index: 1337,
        handler: function releaseGesture(ev, inst) {
            inst.trigger(this.name, ev);
        }
    };

    /**
     * @module gestures
     */
    /**
     * Touch stays at the same place for x time
     *
     * @class Hold
     * @static
     */
    /**
     * @event hold
     * @param {Object} ev
     */

    /**
     * @param {String} name
     */
    (function (name) {
        var timer;

        function holdGesture(ev, inst) {
            var options = inst.options,
                current = Detection.current;

            switch (ev.eventType) {
                case EVENT_START:
                    clearTimeout(timer);

                    // set the gesture so we can check in the timeout if it still is
                    current.name = name;

                    // set timer and if after the timeout it still is hold,
                    // we trigger the hold event
                    timer = setTimeout(function () {
                        if (current && current.name == name) {
                            inst.trigger(name, ev);
                        }
                    }, options.holdTimeout);
                    break;

                case EVENT_MOVE:
                    if (ev.distance > options.holdThreshold) {
                        clearTimeout(timer);
                    }
                    break;

                case EVENT_RELEASE:
                    clearTimeout(timer);
                    break;
            }
        }

        Hammer.gestures.Hold = {
            name: name,
            index: 10,
            defaults: {
                /**
                 * @property holdTimeout
                 * @type {Number}
                 * @default 500
                 */
                holdTimeout: 500,

                /**
                 * movement allowed while holding
                 * @property holdThreshold
                 * @type {Number}
                 * @default 2
                 */
                holdThreshold: 2
            },
            handler: holdGesture
        };
    })('hold');

    /**
     * @module gestures
     */
    /**
     * when a touch is being released from the page
     *
     * @class Release
     * @static
     */
    /**
     * @event release
     * @param {Object} ev
     */
    Hammer.gestures.Release = {
        name: 'release',
        index: Infinity,
        handler: function releaseGesture(ev, inst) {
            if (ev.eventType == EVENT_RELEASE) {
                inst.trigger(this.name, ev);
            }
        }
    };

    /**
     * @module gestures
     */
    /**
     * triggers swipe events when the end velocity is above the threshold
     * for best usage, set `preventDefault` (on the drag gesture) to `true`
     * ````
     *  hammertime.on("dragleft swipeleft", function(ev) {
     *    console.log(ev);
     *    ev.gesture.preventDefault();
     *  });
     * ````
     *
     * @class Swipe
     * @static
     */
    /**
     * @event swipe
     * @param {Object} ev
     */
    /**
     * @event swipeleft
     * @param {Object} ev
     */
    /**
     * @event swiperight
     * @param {Object} ev
     */
    /**
     * @event swipeup
     * @param {Object} ev
     */
    /**
     * @event swipedown
     * @param {Object} ev
     */
    Hammer.gestures.Swipe = {
        name: 'swipe',
        index: 40,
        defaults: {
            /**
             * @property swipeMinTouches
             * @type {Number}
             * @default 1
             */
            swipeMinTouches: 1,

            /**
             * @property swipeMaxTouches
             * @type {Number}
             * @default 1
             */
            swipeMaxTouches: 1,

            /**
             * horizontal swipe velocity
             * @property swipeVelocityX
             * @type {Number}
             * @default 0.6
             */
            swipeVelocityX: 0.6,

            /**
             * vertical swipe velocity
             * @property swipeVelocityY
             * @type {Number}
             * @default 0.6
             */
            swipeVelocityY: 0.6
        },

        handler: function swipeGesture(ev, inst) {
            if (ev.eventType == EVENT_RELEASE) {
                var touches = ev.touches.length,
                    options = inst.options;

                // max touches
                if (touches < options.swipeMinTouches || touches > options.swipeMaxTouches) {
                    return;
                }

                // when the distance we moved is too small we skip this gesture
                // or we can be already in dragging
                if (ev.velocityX > options.swipeVelocityX || ev.velocityY > options.swipeVelocityY) {
                    // trigger swipe events
                    inst.trigger(this.name, ev);
                    inst.trigger(this.name + ev.direction, ev);
                }
            }
        }
    };

    /**
     * @module gestures
     */
    /**
     * Single tap and a double tap on a place
     *
     * @class Tap
     * @static
     */
    /**
     * @event tap
     * @param {Object} ev
     */
    /**
     * @event doubletap
     * @param {Object} ev
     */

    /**
     * @param {String} name
     */
    (function (name) {
        var hasMoved = false;

        function tapGesture(ev, inst) {
            var options = inst.options,
                current = Detection.current,
                prev = Detection.previous,
                sincePrev,
                didDoubleTap;

            switch (ev.eventType) {
                case EVENT_START:
                    hasMoved = false;
                    break;

                case EVENT_MOVE:
                    hasMoved = hasMoved || ev.distance > options.tapMaxDistance;
                    break;

                case EVENT_END:
                    if (!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {
                        // previous gesture, for the double tap since these are two different gesture detections
                        sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;
                        didDoubleTap = false;

                        // check if double tap
                        if (prev && prev.name == name && sincePrev && sincePrev < options.doubleTapInterval && ev.distance < options.doubleTapDistance) {
                            inst.trigger('doubletap', ev);
                            didDoubleTap = true;
                        }

                        // do a single tap
                        if (!didDoubleTap || options.tapAlways) {
                            current.name = name;
                            inst.trigger(current.name, ev);
                        }
                    }
                    break;
            }
        }

        Hammer.gestures.Tap = {
            name: name,
            index: 100,
            handler: tapGesture,
            defaults: {
                /**
                 * max time of a tap, this is for the slow tappers
                 * @property tapMaxTime
                 * @type {Number}
                 * @default 250
                 */
                tapMaxTime: 250,

                /**
                 * max distance of movement of a tap, this is for the slow tappers
                 * @property tapMaxDistance
                 * @type {Number}
                 * @default 10
                 */
                tapMaxDistance: 10,

                /**
                 * always trigger the `tap` event, even while double-tapping
                 * @property tapAlways
                 * @type {Boolean}
                 * @default true
                 */
                tapAlways: true,

                /**
                 * max distance between two taps
                 * @property doubleTapDistance
                 * @type {Number}
                 * @default 20
                 */
                doubleTapDistance: 20,

                /**
                 * max time between two taps
                 * @property doubleTapInterval
                 * @type {Number}
                 * @default 300
                 */
                doubleTapInterval: 300
            }
        };
    })('tap');

    /**
     * @module gestures
     */
    /**
     * when a touch is being touched at the page
     *
     * @class Touch
     * @static
     */
    /**
     * @event touch
     * @param {Object} ev
     */
    Hammer.gestures.Touch = {
        name: 'touch',
        index: -Infinity,
        defaults: {
            /**
             * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,
             * but it improves gestures like transforming and dragging.
             * be careful with using this, it can be very annoying for users to be stuck on the page
             * @property preventDefault
             * @type {Boolean}
             * @default false
             */
            preventDefault: false,

            /**
             * disable mouse events, so only touch (or pen!) input triggers events
             * @property preventMouse
             * @type {Boolean}
             * @default false
             */
            preventMouse: false
        },
        handler: function touchGesture(ev, inst) {
            if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {
                ev.stopDetect();
                return;
            }

            if (inst.options.preventDefault) {
                ev.preventDefault();
            }

            if (ev.eventType == EVENT_TOUCH) {
                inst.trigger('touch', ev);
            }
        }
    };

    /**
     * @module gestures
     */
    /**
     * User want to scale or rotate with 2 fingers
     * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the
     * `preventDefault` option.
     *
     * @class Transform
     * @static
     */
    /**
     * @event transform
     * @param {Object} ev
     */
    /**
     * @event transformstart
     * @param {Object} ev
     */
    /**
     * @event transformend
     * @param {Object} ev
     */
    /**
     * @event pinchin
     * @param {Object} ev
     */
    /**
     * @event pinchout
     * @param {Object} ev
     */
    /**
     * @event rotate
     * @param {Object} ev
     */

    /**
     * @param {String} name
     */
    (function (name) {
        var triggered = false;

        function transformGesture(ev, inst) {
            switch (ev.eventType) {
                case EVENT_START:
                    triggered = false;
                    break;

                case EVENT_MOVE:
                    // at least multitouch
                    if (ev.touches.length < 2) {
                        return;
                    }

                    var scaleThreshold = Math.abs(1 - ev.scale);
                    var rotationThreshold = Math.abs(ev.rotation);

                    // when the distance we moved is too small we skip this gesture
                    // or we can be already in dragging
                    if (scaleThreshold < inst.options.transformMinScale && rotationThreshold < inst.options.transformMinRotation) {
                        return;
                    }

                    // we are transforming!
                    Detection.current.name = name;

                    // first time, trigger dragstart event
                    if (!triggered) {
                        inst.trigger(name + 'start', ev);
                        triggered = true;
                    }

                    inst.trigger(name, ev); // basic transform event

                    // trigger rotate event
                    if (rotationThreshold > inst.options.transformMinRotation) {
                        inst.trigger('rotate', ev);
                    }

                    // trigger pinch event
                    if (scaleThreshold > inst.options.transformMinScale) {
                        inst.trigger('pinch', ev);
                        inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);
                    }
                    break;

                case EVENT_RELEASE:
                    if (triggered && ev.changedLength < 2) {
                        inst.trigger(name + 'end', ev);
                        triggered = false;
                    }
                    break;
            }
        }

        Hammer.gestures.Transform = {
            name: name,
            index: 45,
            defaults: {
                /**
                 * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
                 * @property transformMinScale
                 * @type {Number}
                 * @default 0.01
                 */
                transformMinScale: 0.01,

                /**
                 * rotation in degrees
                 * @property transformMinRotation
                 * @type {Number}
                 * @default 1
                 */
                transformMinRotation: 1
            },

            handler: transformGesture
        };
    })('transform');

    /**
     * @module hammer
     */

    // AMD export
    if (typeof define == 'function' && define.amd) {
        define(function () {
            return Hammer;
        });
        // commonjs export
    } else if (typeof module !== 'undefined' && module.exports) {
            module.exports = Hammer;
            // browser export
        } else {
                window.Hammer = Hammer;
            }
})(window);

},{}],"/home/ubuntu/staging/apps/build/js/locale.js":[function(require,module,exports){
// base locale

"use strict";

module.exports = window.blockly.common_locale;

},{}],"/home/ubuntu/staging/apps/build/js/dom.js":[function(require,module,exports){
'use strict';

exports.addReadyListener = function (callback) {
  if (document.readyState === "complete") {
    setTimeout(callback, 1);
  } else {
    window.addEventListener('load', callback, false);
  }
};

exports.getTouchEventName = function (eventName) {
  var isIE11Touch = window.navigator.pointerEnabled;
  var isIE10Touch = window.navigator.msPointerEnabled;
  var isStandardTouch = ('ontouchend' in document.documentElement);

  var key;
  if (isIE11Touch) {
    key = "ie11";
  } else if (isIE10Touch) {
    key = "ie10";
  } else if (isStandardTouch) {
    key = "standard";
  }
  if (key && TOUCH_MAP[eventName]) {
    return TOUCH_MAP[eventName][key];
  }
};

var addEvent = function addEvent(element, eventName, handler) {
  // Scope bound event map to this addEvent call - we only provide for unbinding
  // what we bind right here.
  var boundEvents = {};

  var bindEvent = function bindEvent(type, eventName, handler) {
    element.addEventListener(eventName, handler, false);
    boundEvents[type] = { name: eventName, handler: handler };
  };

  var unbindEvent = function unbindEvent(type) {
    var eventInfo = boundEvents[type];
    if (eventInfo) {
      element.removeEventListener(eventInfo.name, eventInfo.handler);
      delete boundEvents[type];
    }
  };

  // Add click handler
  bindEvent('click', eventName, handler);

  // Optionally add touch handler
  var touchEvent = exports.getTouchEventName(eventName);
  if (touchEvent) {
    bindEvent('touch', touchEvent, function (e) {
      // Stop mouse events and suppress default event handler to prevent
      // unintentional double-clicking
      e.preventDefault();
      unbindEvent('click');
      handler.call(this, e);
    });
  }

  // Return function that unbinds all handlers
  return function () {
    unbindEvent('click');
    unbindEvent('touch');
  };
};

exports.addMouseDownTouchEvent = function (element, handler) {
  return addEvent(element, 'mousedown', handler);
};

exports.addMouseUpTouchEvent = function (element, handler) {
  return addEvent(element, 'mouseup', handler);
};

exports.addMouseMoveTouchEvent = function (element, handler) {
  return addEvent(element, 'mousemove', handler);
};

exports.addClickTouchEvent = function (element, handler) {
  return addEvent(element, 'click', handler);
};

// A map from standard touch events to various aliases.
var TOUCH_MAP = {
  //  Incomplete list, add as needed.
  click: {
    standard: 'touchstart',
    ie10: 'MSPointerDown',
    ie11: 'pointerdown'
  },
  mousedown: {
    standard: 'touchstart',
    ie10: 'MSPointerDown',
    ie11: 'pointerdown'
  },
  mouseup: {
    standard: 'touchend',
    ie10: 'MSPointerUp',
    ie11: 'pointerup'
  },
  mousemove: {
    standard: 'touchmove',
    ie10: 'MSPointerMove',
    ie11: 'pointermove'
  }
};

exports.isMobile = function () {
  var reg = /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile/;
  return reg.test(window.navigator.userAgent);
};

exports.isWindowsTouch = function () {
  var reg = /MSIE.*Touch/;
  return reg.test(window.navigator.userAgent);
};

exports.isAndroid = function () {
  var reg = /Android/;
  return reg.test(window.navigator.userAgent);
};

exports.isIOS = function () {
  var reg = /iP(hone|od|ad)/;
  return reg.test(window.navigator.userAgent);
};

exports.isIPad = function () {
  var reg = /iPad/i;
  return reg.test(window.navigator.userAgent);
};

},{}],"/home/ubuntu/staging/apps/build/js/CommandHistory.js":[function(require,module,exports){
/** @file Provide browsable command history to a textbox with limited depth. */
// Strict linting: Absorb into global config when possible
/* jshint
 unused: true,
 eqeqeq: true,
 maxlen: 120
 */
'use strict';

var CommandHistory = module.exports = function () {
  /**
   * Ordered collection of command entries.
   * @private {string[]}
   */
  this.commands_ = [];

  /**
   * Current index into commands_, where 0 is the oldest command stored
   * @private {number}
   */
  this.currentIndex_ = 0;

  /**
   * The maximum number of entries to store in the command history, to
   * prevent ever-increasing memory for this feature.
   * @private {number}
   */
  this.maxEntries_ = 64;
};

/**
 * Add the given command to the current command history.  If the command
 * history has already reached its maximum depth, the oldest command will
 * drop off so that the newest command can be added.
 * @param {string} command
 */
CommandHistory.prototype.push = function (command) {
  if (this.commands_.length >= this.maxEntries_) {
    this.commands_.shift();
    this.currentIndex_ -= 1;
  }
  this.commands_.push(command);
  this.currentIndex_ = this.commands_.length;
};

/**
 * Move back in time by one entry, returning the command at the new
 * command index.
 * @param {string} currentInput
 * @returns {string}
 */
CommandHistory.prototype.goBack = function (currentInput) {
  this.alterHistory_(this.currentIndex_, currentInput);

  if (this.currentIndex_ > 0) {
    this.currentIndex_ -= 1;
  }
  if (typeof this.commands_[this.currentIndex_] !== 'undefined') {
    return this.commands_[this.currentIndex_];
  }
  return currentInput;
};

/**
 * Move forward in time by one entry, returning the command at the new
 * command index.
 * @param {string} currentInput
 * @returns {string}
 */
CommandHistory.prototype.goForward = function (currentInput) {
  this.alterHistory_(this.currentIndex_, currentInput);

  if (this.currentIndex_ < this.commands_.length) {
    this.currentIndex_ += 1;
  }
  if (this.currentIndex_ === this.commands_.length && currentInput === this.commands_[this.currentIndex_ - 1]) {
    return '';
  }
  if (typeof this.commands_[this.currentIndex_] !== 'undefined') {
    return this.commands_[this.currentIndex_];
  }
  return currentInput;
};

/**
 * Overwrites the currently viewed command entry in the history with a new
 * value.  Will do nothing if attempting overwrite an empty entry.
 * @param {!number} index - position in command history to rewrite
 * @param {!string} newValue
 * @private
 */
CommandHistory.prototype.alterHistory_ = function (index, newValue) {
  if (this.commands_[index] !== undefined) {
    this.commands_[index] = newValue;
  }
};

},{}]},{},[])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJidWlsZC9qcy9sZXZlbF9iYXNlLmpzIiwibm9kZV9tb2R1bGVzL2NhbnZnL2NhbnZnLmpzIiwibm9kZV9tb2R1bGVzL3N0YWNrYmx1ci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZ2Jjb2xvci9pbmRleC5qcyIsImJ1aWxkL2pzL2NhbnZnL3N2Z190b2RhdGF1cmwuanMiLCJidWlsZC9qcy9zaGFyZWRGdW5jdGlvbmFsQmxvY2tzLmpzIiwiYnVpbGQvanMvdGVtcGxhdGVzL0FwcFZpZXcuanN4IiwiYnVpbGQvanMvdGVtcGxhdGVzL3Zpc3VhbGl6YXRpb25Db2x1bW4uaHRtbC5lanMiLCJidWlsZC9qcy90ZW1wbGF0ZXMvY29kZVdvcmtzcGFjZS5odG1sLmVqcyIsImJ1aWxkL2pzL3NraW5zLmpzIiwiYnVpbGQvanMvYXNzZXRNYW5hZ2VtZW50L2dldEFzc2V0RHJvcGRvd24uanMiLCJidWlsZC9qcy90aW1lb3V0TGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZGlzdC9sb2Rhc2guanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzLWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsImJ1aWxkL2pzL2Fzc2V0TWFuYWdlbWVudC9zaG93LmpzIiwiYnVpbGQvanMvYXNzZXRNYW5hZ2VtZW50L0Fzc2V0TWFuYWdlci5qc3giLCJidWlsZC9qcy9hc3NldE1hbmFnZW1lbnQvQXNzZXRVcGxvYWRlci5qc3giLCJidWlsZC9qcy9hc3NldE1hbmFnZW1lbnQvQXNzZXRSb3cuanN4IiwiYnVpbGQvanMvYXNzZXRNYW5hZ2VtZW50L0Fzc2V0VGh1bWJuYWlsLmpzeCIsImJ1aWxkL2pzL3RlbXBsYXRlcy9TdHVkaW9BcHBXcmFwcGVyLmpzeCIsImJ1aWxkL2pzL3RlbXBsYXRlcy9Sb3RhdGVDb250YWluZXIuanN4IiwiYnVpbGQvanMvdGVtcGxhdGVzL1Byb3RlY3RlZFN0YXRlZnVsRGl2LmpzeCIsImJ1aWxkL2pzL2FwcE1haW4uanMiLCJidWlsZC9qcy9yZXF1aXJlZF9ibG9ja191dGlscy5qcyIsImJ1aWxkL2pzL2Jsb2Nrc0NvbW1vbi5qcyIsImJ1aWxkL2pzL1N0dWRpb0FwcC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJidWlsZC9qcy90ZW1wbGF0ZXMvbWFrZVlvdXJPd24uaHRtbC5lanMiLCJidWlsZC9qcy90ZW1wbGF0ZXMvbGVhcm4uaHRtbC5lanMiLCJidWlsZC9qcy90ZW1wbGF0ZXMvYnVpbGRlci5odG1sLmVqcyIsImJ1aWxkL2pzL3RlbXBsYXRlcy9hbGVydC5qc3giLCJidWlsZC9qcy90ZW1wbGF0ZXMvV2lyZWZyYW1lU2VuZFRvUGhvbmUuanN4IiwiYnVpbGQvanMvdGVtcGxhdGVzL1ZlcnNpb25IaXN0b3J5LmpzeCIsImJ1aWxkL2pzL3RlbXBsYXRlcy9WZXJzaW9uUm93LmpzeCIsImJ1aWxkL2pzL3RlbXBsYXRlcy9JbnN0cnVjdGlvbnMuanN4IiwiYnVpbGQvanMvbG9nVG9DbG91ZC5qcyIsImJ1aWxkL2pzL2ZlZWRiYWNrLmpzIiwiYnVpbGQvanMvdGVtcGxhdGVzL3Ryb3BoeS5odG1sLmVqcyIsImJ1aWxkL2pzL3RlbXBsYXRlcy9zaG93Q29kZS5odG1sLmVqcyIsImJ1aWxkL2pzL3RlbXBsYXRlcy9zaGFyaW5nLmh0bWwuZWpzIiwiYnVpbGQvanMvdGVtcGxhdGVzL3NoYXJlRmFpbHVyZS5odG1sLmVqcyIsImJ1aWxkL2pzL3RlbXBsYXRlcy9jb2RlLmh0bWwuZWpzIiwiYnVpbGQvanMvdGVtcGxhdGVzL2J1dHRvbnMuaHRtbC5lanMiLCJidWlsZC9qcy9wdXp6bGVSYXRpbmdVdGlscy5qcyIsImJ1aWxkL2pzL3RlbXBsYXRlcy9wdXp6bGVSYXRpbmcuaHRtbC5lanMiLCJidWlsZC9qcy9mZWVkYmFja0Jsb2Nrcy5qcyIsImJ1aWxkL2pzL2NsaWVudEFwaS5qcyIsImJ1aWxkL2pzL2Jsb2NrX3V0aWxzLmpzIiwiYnVpbGQvanMvYmxvY2tUb29sdGlwcy9Ecm9wbGV0VG9vbHRpcE1hbmFnZXIuanMiLCJidWlsZC9qcy9ibG9ja1Rvb2x0aXBzL0Ryb3BsZXRCbG9ja1Rvb2x0aXBNYW5hZ2VyLmpzIiwiYnVpbGQvanMvYmxvY2tUb29sdGlwcy9Ecm9wbGV0RnVuY3Rpb25Ub29sdGlwLmpzIiwiYnVpbGQvanMvYmxvY2tUb29sdGlwcy9Ecm9wbGV0QXV0b2NvbXBsZXRlUG9wdXBUb29sdGlwTWFuYWdlci5qcyIsImJ1aWxkL2pzL2Jsb2NrVG9vbHRpcHMvRHJvcGxldEZ1bmN0aW9uVG9vbHRpcC5odG1sLmVqcyIsImJ1aWxkL2pzL2Jsb2NrVG9vbHRpcHMvRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyLmpzIiwiYnVpbGQvanMvYmxvY2tUb29sdGlwcy90b29sdGlwVXRpbHMuanMiLCJidWlsZC9qcy9ibG9ja1Rvb2x0aXBzL0Ryb3BsZXRQYXJhbWV0ZXJUb29sdGlwLmh0bWwuZWpzIiwiYnVpbGQvanMvYXV0aG9yZWRIaW50cy5qcyIsImJ1aWxkL2pzL3RlbXBsYXRlcy9saWdodGJ1bGJfZGltLnN2Zy5lanMiLCJidWlsZC9qcy90ZW1wbGF0ZXMvbGlnaHRidWxiLnN2Zy5lanMiLCJidWlsZC9qcy90ZW1wbGF0ZXMvSGludHNEaXNwbGF5LmpzeCIsImJ1aWxkL2pzL3RlbXBsYXRlcy9IaW50LmpzeCIsImJ1aWxkL2pzL3RlbXBsYXRlcy9IaW50U2VsZWN0LmpzeCIsImJ1aWxkL2pzL2F1dGhvcmVkSGludFV0aWxzLmpzIiwiYnVpbGQvanMveG1sLmpzIiwiYnVpbGQvanMvYXNzZXRNYW5hZ2VtZW50L2Fzc2V0UHJlZml4LmpzIiwiYnVpbGQvanMvYXNzZXRNYW5hZ2VtZW50L2Fzc2V0TGlzdFN0b3JlLmpzIiwiYnVpbGQvanMvYWNlbW9kZS9tb2RlLWphdmFzY3JpcHRfY29kZW9yZy5qcyIsImJ1aWxkL2pzL2FjZW1vZGUvYW5ub3RhdGlvbkxpc3QuanMiLCJidWlsZC9qcy9hY2Vtb2RlL2Vycm9yTWFwcGVyLmpzIiwiYnVpbGQvanMvUmVzaXplU2Vuc29yLmpzIiwiYnVpbGQvanMvTXVzaWNDb250cm9sbGVyLmpzIiwiYnVpbGQvanMvSnNJbnRlcnByZXRlckxvZ2dlci5qcyIsImJ1aWxkL2pzL0pzRGVidWdnZXJVaS5qcyIsImJ1aWxkL2pzL3NsaWRlci5qcyIsImJ1aWxkL2pzL2NvbnN0YW50cy5qcyIsImJ1aWxkL2pzL09ic2VydmVyLmpzIiwiYnVpbGQvanMvSnNEZWJ1Z2dlclVpLmh0bWwuZWpzIiwibm9kZV9tb2R1bGVzL2Vqcy9saWIvZWpzLmpzIiwibm9kZV9tb2R1bGVzL2Vqcy9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvZWpzL2xpYi9maWx0ZXJzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwiYnVpbGQvanMvSlNJbnRlcnByZXRlci5qcyIsImJ1aWxkL2pzL2NvZGVnZW4uanMiLCJidWlsZC9qcy9kcm9wbGV0VXRpbHMuanMiLCJidWlsZC9qcy9PYnNlcnZhYmxlRXZlbnQuanMiLCJidWlsZC9qcy9EZWJ1Z0FyZWEuanMiLCJidWlsZC9qcy91dGlscy5qcyIsImJ1aWxkL2pzL2xvZGFzaC5qcyIsImJ1aWxkL2pzL2hhbW1lci5qcyIsImJ1aWxkL2pzL2xvY2FsZS5qcyIsImJ1aWxkL2pzL2RvbS5qcyIsImJ1aWxkL2pzL0NvbW1hbmRIaXN0b3J5LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7QUNTQSxPQUFPLENBQUMsSUFBSSxHQUFHLFVBQVMsSUFBSSxFQUFFO0FBQzVCLFNBQU87QUFDTCxRQUFJLEVBQUUsY0FBUyxLQUFLLEVBQUU7QUFDcEIsYUFBTyxLQUFLLENBQUMsSUFBSSxJQUFJLHlCQUF5QixJQUMxQyxLQUFLLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFdBQVcsRUFBRSxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztLQUNyRTtBQUNELFFBQUksRUFBRSx5QkFBeUI7QUFDL0IsVUFBTSxFQUFFLEVBQUMsTUFBTSxFQUFFLElBQUksRUFBQztHQUN2QixDQUFDO0NBQ0gsQ0FBQzs7Ozs7Ozs7O0FBU0YsT0FBTyxDQUFDLFdBQVcsR0FBRyxVQUFTLFNBQVMsRUFBRSxRQUFRLEVBQUU7QUFDbEQsU0FBTztBQUNMLFFBQUksRUFBRSxjQUFTLEtBQUssRUFBRTtBQUNwQixhQUFPLEtBQUssQ0FBQyxJQUFJLElBQUkseUJBQXlCLElBQzFDLEtBQUssQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsV0FBVyxFQUFFLElBQUksU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDO0tBQzFFO0FBQ0QsUUFBSSxFQUFFLHlCQUF5QjtBQUMvQixTQUFLLEVBQUUsa0JBQWtCLEdBQUcsU0FBUyxHQUFHLGVBQWUsR0FBRyxRQUFRLEdBQzlELHFCQUFxQjtHQUMxQixDQUFDO0NBQ0gsQ0FBQzs7Ozs7Ozs7OztBQVVGLE9BQU8sQ0FBQyxNQUFNLEdBQUcsVUFBUyxJQUFJLEVBQUU7QUFDOUIsU0FBTztBQUNMLFFBQUksRUFBRSxjQUFTLEtBQUssRUFBRTtBQUNwQixhQUFPLEtBQUssQ0FBQyxJQUFJLElBQUksd0JBQXdCLElBQ3pDLEtBQUssQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsV0FBVyxFQUFFLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0tBQ3JFO0FBQ0QsUUFBSSxFQUFFLHdCQUF3QjtBQUM5QixVQUFNLEVBQUUsRUFBQyxNQUFNLEVBQUUsSUFBSSxFQUFDO0dBQ3ZCLENBQUM7Q0FDSCxDQUFDOzs7QUN4REY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak5BO0FBQ0E7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdjdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3BCQSxJQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQztBQUNqRCxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUMsU0FBUyxDQUFDOzs7Ozs7Ozs7QUFTbEQsTUFBTSxDQUFDLE9BQU8sR0FBRyxVQUFTLFdBQVcsRUFBRSxVQUFVLEVBQUU7QUFDakQsTUFBSSxPQUFPLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxL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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNiQSxNQUFNLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUM7OztBQUNqQyxXQUFT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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTs7Ozs7Ozs7Ozs7QUNPQSxJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDbkMsSUFBSSxlQUFlLEdBQUcsT0FBTyxDQUFDLG1CQUFtQixDQUFDLENBQUM7QUFDbkQsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7OztBQWMvQixJQUFJLGFBQWEsR0FBRyxNQUFNLENBQUMsT0FBTyxHQUFHLFVBQVUsT0FBTyxFQUFFO0FB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SSxRQUFRLElBQUksSUFBSSxJQUFJLFFBQVEsRUFBRTtBQUN4QyxVQUFJLEdBQUcsUUFBUSxDQUFDO0tBQ2pCO0FBQ0QsUUFBSSxHQUFHLEdBQUcsSUFBSSxJQUFJLFFBQVEsR0FBRyxLQUFLLEdBQUcsU0FBUyxHQUFHLEtBQUssQ0FBQztBQUN2RCxTQUFLLEdBQUcsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFBLElBQUssS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDOztBQUU1QyxXQUFPLElBQUksSUFBSSxRQUFRLEdBQ2xCLEtBQUssSUFBSSxXQUFXLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FDaEQsS0FBSyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQUFBQyxDQUFDO0dBQ3RCOzs7Ozs7OztBQVFELFdBQVMsU0FBUyxDQUFDLEtBQUssRUFBRTtBQUN4QixRQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSztRQUNsQixJQUFJLEdBQUcsT0FBTyxLQUFLLENBQUM7O0FBRXhCLFFBQUksSUFBSSxJQUFJLFNBQVMsSUFBSSxLQUFLLElBQUksSUFBSSxFQUFFO0FBQ3RDLFdBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUM7S0FDckIsTUFBTTtBQUNMLFVBQUksSUFBSSxJQUFJLFFBQVEsSUFBSSxJQUFJLElBQUksUUFBUSxFQUFFO0FBQ3hDLFlBQUksR0FBRyxRQUFRLENBQUM7T0FDakI7QUFDRCxVQUFJLEdBQUcsR0FBRyxJQUFJLElBQUksUUFBUSxHQUFHLEtBQUssR0FBRyxTQUFTLEdBQUcsS0FBSztVQUNsRCxTQUFTLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUEsQUFBQyxDQUFDOztBQUVsRCxVQUFJLElBQUksSUFBSSxRQUFRLEVBQUU7QUFDcEIsU0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEtBQUssU0FBUyxD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SyxDQUFDO0FBQ3JCLFFBQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0FBQ3ZCLFFBQU0sQ0FBQyxjQUFjLEdBQUcsY0FBYyxDQUFDO0FBQ3ZDLFFBQU0sQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0FBQzNCLFFBQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0FBQ3ZCLFFBQU0sQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO0FBQ3pCLFFBQU0sQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO0FBQ3pCLFFBQU0sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3JCLFFBQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0FBQ3ZCLFFBQU0sQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0FBQzdCLFFBQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ25CLFFBQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQ2pCLFFBQU0sQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0FBQzNCLFFBQU0sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3JCLFFBQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0FBQ3ZCLFFBQU0sQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO0FBQ3pCLFFBQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0FBQ3ZCLFFBQU0sQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0FBQzNCLFFBQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ25CLFFBQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0FBQ3ZCLFFBQU0sQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO0FBQ3pCLFFBQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDOzs7QUFHbkIsUUFBTSxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUM7QUFDckIsUUFBTSxDQUFDLElBQUksR0FBRyxPQUFPLENBQUM7QUFDdEIsUUFBTSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7QUFDdkIsUUFBTSxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUM7QUFDM0IsUUFBTSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7QUFDdkIsUUFBTSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7OztBQUdyQixPQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7Ozs7O0FBS2QsUUFBTSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDckIsUUFBTSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7QUFDN0IsUUFBTSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7QUFDM0IsUUFBTSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7QUFDbkIsUUFBTSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7QUFDM0IsUUFBTSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7QUFDekIsUUFBTSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7QUFDakMsUUFBTSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7QUFDekIsUUFBTSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7QUFDekIsUUFBTSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7QUFDekIsUUFBTSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7QUFDL0IsUUFBTSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7QUFDM0IsUUFBTSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7QUFDM0IsUUFBTSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDckIsUUFBTSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7QUFDbkIsUUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFDakIsUUFBTSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7QUFDbkIsUUFBTSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7O0FBRWpDLFFBQU0sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO0FBQ3JCLFFBQU0sQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLFFBQU0sQ0FBQyxPQUFPLEdBQUcsUUFBUSxDQUFDOztBQUUxQixPQUFLLENBQUMsQ0FBQSxZQUFXO0FBQ2YsUUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFBO0FBQ2YsVUFBTSxDQUFDLE1BQU0sRUFBRSxVQUFTLElBQUksRUFBRSxVQUFVLEVBQUU7QUFDeEMsVUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLEVBQUU7QUFDakMsY0FBTSxDQUFDLFVBQVUsQ0FBQyxHQUFHLElBQUksQ0FBQztPQUMzQjtLQUNGLENBQUMsQ0FBQztBQUNILFdBQU8sTUFBTSxDQUFDO0dBQ2YsQ0FBQSxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7Ozs7QUFJWixRQUFNLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztBQUNuQixRQUFNLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQzs7QUFFdkIsUUFBTSxDQUFDLE1BQU0sRUFBRSxVQUFTLElBQUksRUFBRSxVQUFVLEVBQUU7QUFDeEMsUUFBSSxZQUFZLEdBQUcsVUFBVSxLQUFLLFFBQVEsQ0FBQztBQUMzQyxRQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsRUFBRTtBQUNqQyxZQUFNLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxHQUFFLFVBQVMsQ0FBQyxFQUFFLEtBQUssRUFBRTtBQUMvQyxZQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUztZQUN6QixNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDOztBQUU5QyxlQUFPLENBQUMsUUFBUSxLQUFLLENBQUMsSUFBSSxJQUFJLElBQUssS0FBSyxJQUFJLEVBQUUsWUFBWSxJQUFJLE9BQU8sQ0FBQyxJQUFJLFVBQVUsQ0FBQSxBQUFDLENBQUMsQUFBQyxHQUNuRixNQUFNLEdBQ04sSUFBSSxhQUFhLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO09BQ3pDLENBQUM7S0FDSDtHQUNGLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7QUFXSCxRQUFNLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQzs7O0FBR3pCLFFBQU0sQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLFlBQVksQ0FBQztBQUN0QyxRQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsR0FBRyxlQUFlLENBQUM7QUFDNUMsUUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEdBQUcsY0FBYyxDQUFDO0FBQ3hDLFFBQU0sQ0FBQyxTQUFTLENBQUMsT0FBTyxHQUFHLGNBQWMsQ0FBQzs7O0FBRzFDLFVBQVEsQ0FBQyxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLEVBQUUsVUFBUyxVQUFVLEVBQUU7QUFDdEQsUUFBSSxJQUFJLEdBQUcsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ2hDLFVBQU0sQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLEdBQUcsWUFBVztBQUN4QyxVQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUztVQUN6QixNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDOztBQUVyRCxhQUFPLFFBQVEsR0FDWCxJQUFJLGFBQWEsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLEdBQ25DLE1BQU0sQ0FBQztLQUNaLENBQUM7R0FDSCxDQUFDLENBQUM7OztBQUdILFVBQVEsQ0FBQyxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLFNBQVMsQ0FBQyxFQUFFLFVBQVMsVUFBVSxFQUFFO0FBQ3BFLFFBQUksSUFBSSxHQUFHLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNoQyxVQUFNLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxHQUFHLFlBQVc7QUFDeEMsVUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ3hDLGFBQU8sSUFBSSxDQUFDO0tBQ2IsQ0FBQztHQUNILENBQUMsQ0FBQzs7O0FBR0gsVUFBUSxDQUFDLENBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxRQUFRLENBQUMsRUFBRSxVQUFTLFVBQVUsRUFBRTtBQUMzRCxRQUFJLElBQUksR0FBRyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDaEMsVUFBTSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsR0FBRyxZQUFXO0FBQ3hDLGFBQU8sSUFBSSxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLFNBQVMsQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztLQUNuRixDQUFDO0dBQ0gsQ0FBQyxDQUFDOzs7O0FBSUgsTUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUU7QUFDMUIsWUFBUSxDQUFDLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxRQUFRLENBQUMsRUFBRSxVQUFTLFVBQVUsRUFBRTtBQUN4RCxVQUFJLElBQUksR0FBRyxRQUFRLENBQUMsVUFBVSxDQUFDO1VBQzNCLFFBQVEsR0FBRyxVQUFVLElBQUksUUFBUSxDQUFDOztBQUV0QyxZQUFNLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxHQUFHLFlBQVc7QUFDeEMsWUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLFNBQVM7WUFDekIsS0FBSyxHQUFHLElBQUksQ0FBQyxXQUFXO1lBQ3hCLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsQ0FBQzs7QUFFMUMsWUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtBQUN0QixpQkFBTyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDakI7QUFDRCxlQUFPLEFBQUMsUUFBUSxJQUFJLFFBQVEsR0FDeEIsSUFBSSxhQUFhLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxHQUNuQyxNQUFNLENBQUM7T0FDWixDQUFDO0tBQ0gsQ0FBQyxDQUFDO0dBQ0o7Ozs7O0FBS0QsTUFBSSxPQUFPLE1BQU0sSUFBSSxVQUFVLElBQUksT0FBTyxNQUFNLENBQUMsR0FBRyxJQUFJLFFBQVEsSUFBSSxNQUFNLENBQUMsR0FBRyxFQUFFOzs7O0FBSTlFLFFBQUksQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDOzs7O0FBSWhCLFVBQU0sQ0FBQyxZQUFXO0FBQ2hCLGFBQU8sTUFBTSxDQUFDO0tBQ2YsQ0FBQyxDQUFDO0dBQ0o7O09BRUksSUFBSSxXQUFXLElBQUksVUFBVSxFQUFFOztBQUVsQyxVQUFJLGFBQWEsRUFBRTtBQUNqQixTQUFDLFVBQVUsQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFBLENBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQztPQUMxQzs7V0FFSTtBQUNILHFCQUFXLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztTQUN4QjtLQUNGLE1BQ0k7O0FBRUgsVUFBSSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUM7S0FDakI7Q0FDRixDQUFBLENBQUMsSUFBSSxXQUFNLENBQUU7Ozs7Ozs7Ozs7Ozs7O0FDNW1IZCxDQUFDLFVBQVMsTUFBTSxFQUFFLFNBQVMsRUFBRTtBQUMzQixnQkFBWSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQmYsUUFBSSxNQUFNLEdBQUcsU0FBUyxNQUFNLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUMzQyxlQUFPLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsT0FBTyxJQUFJLEVBQUUsQ0FBQyxDQUFDO0tBQ3RELENBQUM7Ozs7Ozs7OztBQVNGLFVBQU0sQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0J6QixVQUFNLENBQUMsUUFBUSxHQUFHOzs7Ozs7O0FBT2QsZ0JBQVEsRUFBRTs7Ozs7Ozs7QUFRTixzQkFBVSxFQUFFLE1BQU07Ozs7Ozs7OztBQVNsQix1QkFBVyxFQUFFLE9BQU87Ozs7Ozs7Ozs7QUFVcEIsd0JBQVksRUFBRSxNQUFNOzs7Ozs7OztBQVFwQiwwQkFBYyxFQUFFLE1BQU07Ozs7Ozs7OztBQVN0QixvQkFBUSxFQUFFLE1BQU07Ozs7Ozs7Ozs7Ozs7QUFhaEIsNkJBQWlCLEVBQUUsZUFBZTtTQUNyQztLQUNKLENBQUM7Ozs7Ozs7O0FBUUYsVUFBTSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7Ozs7Ozs7QUFPM0IsVUFBTSxDQUFDLGlCQUFpQixHQUFHLFNBQVMsQ0FBQyxjQUFjLElBQUksU0FBUyxDQUFDLGdCQUFnQixDQUFDOzs7Ozs7O0FBT2xGLFVBQU0sQ0FBQyxlQUFlLEdBQUksY0FBYyxJQUFJLE1BQU0sQUFBQyxDQUFDOzs7Ozs7O0FBT3BELFVBQU0sQ0FBQyxTQUFTLEdBQUcsNENBQTRDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQzs7Ozs7OztBQU8xRixVQUFNLENBQUMsY0FBYyxHQUFHLEFBQUMsTUFBTSxDQUFDLGVBQWUsSUFBSSxNQUFNLENBQUMsU0FBUyxJQUFLLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQzs7Ozs7Ozs7QUFRakcsVUFBTSxDQUFDLGtCQUFrQixHQUFHLEVBQUUsQ0FBQzs7Ozs7Ozs7OztBQVUvQixRQUFJLFdBQVcsR0FBRyxFQUFFLENBQUM7Ozs7Ozs7OztBQVNyQixRQUFJLGNBQWMsR0FBRyxNQUFNLENBQUMsY0FBYyxHQUFHLE1BQU0sQ0FBQztBQUNwRCxRQUFJLGNBQWMsR0FBRyxNQUFNLENBQUMsY0FBYyxHQUFHLE1BQU0sQ0FBQztBQUNwRCxRQUFJLFlBQVksR0FBRyxNQUFNLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztBQUM5QyxRQUFJLGVBQWUsR0FBRyxNQUFNLENBQUMsZUFBZSxHQUFHLE9BQU8sQ0FBQzs7Ozs7Ozs7O0FBU3ZELFFBQUksYUFBYSxHQUFHLE1BQU0sQ0FBQyxhQUFhLEdBQUcsT0FBTyxDQUFDO0FBQ25ELFFBQUksYUFBYSxHQUFHLE1BQU0sQ0FBQyxhQUFhLEdBQUcsT0FBTyxDQUFDO0FBQ25ELFFBQUksV0FBVyxHQUFHLE1BQU0sQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDOzs7Ozs7Ozs7QUFTN0MsUUFBSSxXQUFXLEdBQUcsTUFBTSxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUM7QUFDL0MsUUFBSSxVQUFVLEdBQUcsTUFBTSxDQUFDLFVBQVUsR0FBRyxNQUFNLENBQUM7QUFDNUMsUUFBSSxTQUFTLEdBQUcsTUFBTSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7QUFDekMsUUFBSSxhQUFhLEdBQUcsTUFBTSxDQUFDLGFBQWEsR0FBRyxTQUFTLENBQUM7QUFDckQsUUFBSSxXQUFXLEdBQUcsTUFBTSxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUM7Ozs7Ozs7OztBQVMvQyxVQUFNLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQzs7Ozs7OztBQU9yQixVQUFNLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLElBQUksRUFBRSxDQUFDOzs7Ozs7OztBQVF0QyxVQUFNLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQyxRQUFRLElBQUksRUFBRSxDQUFDOzs7Ozs7O0FBT3hDLGFBQVMsS0FBSyxHQUFHO0FBQ2IsWUFBRyxNQUFNLENBQUMsS0FBSyxFQUFFO0FBQ2IsbUJBQU87U0FDVjs7O0FBR0QsYUFBSyxDQUFDLG1CQUFtQixFQUFFLENBQUM7OztBQUc1QixhQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsVUFBUyxPQUFPLEVBQUU7QUFDMUMscUJBQVMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDL0IsQ0FBQyxDQUFDOzs7QUFHSCxhQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsVUFBVSxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUM3RCxhQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQzs7O0FBRzVELGNBQU0sQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0tBQ3ZCOzs7Ozs7OztBQVFELFFBQUksS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLEdBQUc7Ozs7Ozs7Ozs7QUFVdkIsY0FBTSxFQUFFLFNBQVMsTUFBTSxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFO0FBQ3RDLGlCQUFJLElBQUksR0FBRyxJQUFJLEdBQUcsRUFBRTtBQUNoQixvQkFBRyxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLElBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLFNBQVMsSUFBSSxLQUFLLEFBQUMsRUFBRTtBQUMvRCw2QkFBUztpQkFDWjtBQUNELG9CQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ3hCO0FBQ0QsbUJBQU8sSUFBSSxDQUFDO1NBQ2Y7Ozs7Ozs7OztBQVNELFVBQUUsRUFBRSxTQUFTLEVBQUUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRTtBQUNwQyxtQkFBTyxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDbEQ7Ozs7Ozs7OztBQVNELFdBQUcsRUFBRSxTQUFTLEdBQUcsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRTtBQUN0QyxtQkFBTyxDQUFDLG1CQUFtQixDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDckQ7Ozs7Ozs7Ozs7OztBQVlELFlBQUksRUFBRSxTQUFTLElBQUksQ0FBQyxHQUFHLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRTtBQUN4QyxnQkFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDOzs7QUFHWCxnQkFBRyxTQUFTLElBQUksR0FBRyxFQUFFO0FBQ2pCLG1CQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQzs7YUFFbEMsTUFBTSxJQUFHLEdBQUcsQ0FBQyxNQUFNLEtBQUssU0FBUyxFQUFFO0FBQ2hDLHlCQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN2Qyw0QkFBRyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxLQUFLLEtBQUssRUFBRTtBQUNqRCxtQ0FBTzt5QkFDVjtxQkFDSjs7aUJBRUosTUFBTTtBQUNILDZCQUFJLENBQUMsSUFBSSxHQUFHLEVBQUU7QUFDVixnQ0FBRyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxJQUNwQixRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxLQUFLLEtBQUssRUFBRTtBQUNsRCx1Q0FBTzs2QkFDVjt5QkFDSjtxQkFDSjtTQUNKOzs7Ozs7Ozs7QUFTRCxhQUFLLEVBQUUsU0FBUyxLQUFLLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRTtBQUM3QixtQkFBTyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ2pDOzs7Ozs7Ozs7QUFTRCxlQUFPLEVBQUUsU0FBUyxPQUFPLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRTtBQUNqQyxnQkFBRyxHQUFHLENBQUMsT0FBTyxFQUFFO0FBQ1osb0JBQUksS0FBSyxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDOUIsdUJBQU8sQUFBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLEdBQUksS0FBSyxHQUFHLEtBQUssQ0FBQzthQUN6QyxNQUFNO0FBQ0gscUJBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDM0Msd0JBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksRUFBRTtBQUNoQiwrQkFBTyxDQUFDLENBQUM7cUJBQ1o7aUJBQ0o7QUFDRCx1QkFBTyxLQUFLLENBQUM7YUFDaEI7U0FDSjs7Ozs7Ozs7QUFRRCxlQUFPLEVBQUUsU0FBUyxPQUFPLENBQUMsR0FBRyxFQUFFO0FBQzNCLG1CQUFPLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDN0M7Ozs7Ozs7OztBQVNELGlCQUFTLEVBQUUsU0FBUyxTQUFTLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRTtBQUN4QyxtQkFBTSxJQUFJLEVBQUU7QUFDUixvQkFBRyxJQUFJLElBQUksTUFBTSxFQUFFO0FBQ2YsMkJBQU8sSUFBSSxDQUFDO2lCQUNmO0FBQ0Qsb0JBQUksR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO2FBQzFCO0FBQ0QsbUJBQU8sS0FBSyxDQUFDO1NBQ2hCOzs7Ozs7OztBQVFELGlCQUFTLEVBQUUsU0FBUyxTQUFTLENBQUMsT0FBTyxFQUFFO0FBQ25DLGdCQUFJLEtBQUssR0FBRyxFQUFFO2dCQUNWLEtBQUssR0FBRyxFQUFFO2dCQUNWLE9BQU8sR0FBRyxFQUFFO2dCQUNaLE9BQU8sR0FBRyxFQUFFO2dCQUNaLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRztnQkFDZCxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQzs7O0FBR25CLGdCQUFHLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO0FBQ3JCLHVCQUFPO0FBQ0gseUJBQUssRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSztBQUN2Qix5QkFBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLO0FBQ3ZCLDJCQUFPLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU87QUFDM0IsMkJBQU8sRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTztpQkFDOUIsQ0FBQzthQUNMOztBQUVELGlCQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxVQUFTLEtBQUssRUFBRTtBQUNoQyxxQkFBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDeEIscUJBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3hCLHVCQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUM1Qix1QkFBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDL0IsQ0FBQyxDQUFDOztBQUVILG1CQUFPO0FBQ0gscUJBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFBLEdBQUksQ0FBQztBQUM1RCxxQkFBSyxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUEsR0FBSSxDQUFDO0FBQzVELHVCQUFPLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQSxHQUFJLENBQUM7QUFDbEUsdUJBQU8sRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFBLEdBQUksQ0FBQzthQUNyRSxDQUFDO1NBQ0w7Ozs7Ozs7Ozs7QUFVRCxtQkFBVyxFQUFFLFNBQVMsV0FBVyxDQUFDLFNBQVMsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFO0FBQ3pELG1CQUFPO0FBQ0gsaUJBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDO0FBQ3BDLGlCQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQzthQUN2QyxDQUFDO1NBQ0w7Ozs7Ozs7OztBQVNELGdCQUFRLEVBQUUsU0FBUyxRQUFRLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRTtBQUN4QyxnQkFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTztnQkFDbkMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQzs7QUFFeEMsbUJBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7U0FDM0M7Ozs7Ozs7OztBQVNELG9CQUFZLEVBQUUsU0FBUyxZQUFZLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRTtBQUNoRCxnQkFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUM7Z0JBQzdDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDOztBQUVsRCxnQkFBRyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ1AsdUJBQU8sTUFBTSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxHQUFHLENBQUMsR0FBRyxjQUFjLEdBQUcsZUFBZSxDQUFDO2FBQ2pGO0FBQ0QsbUJBQU8sTUFBTSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxHQUFHLENBQUMsR0FBRyxZQUFZLEdBQUcsY0FBYyxDQUFDO1NBQzlFOzs7Ozs7Ozs7QUFTRCxtQkFBVyxFQUFFLFNBQVMsV0FBVyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUU7QUFDOUMsZ0JBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU87Z0JBQ25DLENBQUMsR0FBRyxNQUFNLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUM7O0FBRXhDLG1CQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQUFBQyxDQUFDLEdBQUcsQ0FBQyxHQUFLLENBQUMsR0FBRyxDQUFDLEFBQUMsQ0FBQyxDQUFDO1NBQ3ZDOzs7Ozs7Ozs7O0FBVUQsZ0JBQVEsRUFBRSxTQUFTLFFBQVEsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFOztBQUVwQyxnQkFBRyxLQUFLLENBQUMsTUFBTSxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRTtBQUNyQyx1QkFBTyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNsRjtBQUNELG1CQUFPLENBQUMsQ0FBQztTQUNaOzs7Ozs7Ozs7QUFTRCxtQkFBVyxFQUFFLFNBQVMsV0FBVyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUU7O0FBRTFDLGdCQUFHLEtBQUssQ0FBQyxNQUFNLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFO0FBQ3JDLHVCQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQzVFO0FBQ0QsbUJBQU8sQ0FBQyxDQUFDO1NBQ1o7Ozs7Ozs7O0FBUUQsa0JBQVUsRUFBRSxTQUFTLFVBQVUsQ0FBQyxTQUFTLEVBQUU7QUFDdkMsbUJBQU8sU0FBUyxJQUFJLFlBQVksSUFBSSxTQUFTLElBQUksY0FBYyxDQUFDO1NBQ25FOzs7Ozs7Ozs7O0FBVUQsc0JBQWMsRUFBRSxTQUFTLGNBQWMsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUU7QUFDbEUsZ0JBQUksUUFBUSxHQUFHLENBQUMsRUFBRSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ2hELGdCQUFJLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7QUFFL0IsaUJBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3JDLG9CQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7O0FBRWIsb0JBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFO0FBQ1oscUJBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDOUQ7OztBQUdELG9CQUFHLENBQUMsSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFO0FBQ25CLDJCQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxJQUFJLElBQUksSUFBSSxNQUFNLENBQUEsSUFBSyxLQUFLLElBQUksRUFBRSxDQUFDO0FBQzdELDBCQUFNO2lCQUNUO2FBQ0o7U0FDSjs7Ozs7Ozs7Ozs7O0FBWUQsc0JBQWMsRUFBRSxTQUFTLGNBQWMsQ0FBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRTtBQUM1RCxnQkFBRyxDQUFDLEtBQUssSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUU7QUFDckMsdUJBQU87YUFDVjs7O0FBR0QsaUJBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFVBQVMsS0FBSyxFQUFFLElBQUksRUFBRTtBQUNwQyxxQkFBSyxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQzthQUN0RCxDQUFDLENBQUM7O0FBRUgsZ0JBQUksT0FBTyxHQUFHLE1BQU0sSUFBSSxZQUFXO0FBQy9CLHVCQUFPLEtBQUssQ0FBQzthQUNoQixDQUFDOzs7QUFHRixnQkFBRyxLQUFLLENBQUMsVUFBVSxJQUFJLE1BQU0sRUFBRTtBQUMzQix1QkFBTyxDQUFDLGFBQWEsR0FBRyxPQUFPLENBQUM7YUFDbkM7O0FBRUQsZ0JBQUcsS0FBSyxDQUFDLFFBQVEsSUFBSSxNQUFNLEVBQUU7QUFDekIsdUJBQU8sQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDO2FBQ2pDO1NBQ0o7Ozs7Ozs7O0FBUUQsbUJBQVcsRUFBRSxTQUFTLFdBQVcsQ0FBQyxHQUFHLEVBQUU7QUFDbkMsbUJBQU8sR0FBRyxDQUFDLE9BQU8sQ0FBQyxjQUFjLEVBQUUsVUFBUyxDQUFDLEVBQUU7QUFDM0MsdUJBQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO2FBQzdCLENBQUMsQ0FBQztTQUNOO0tBQ0osQ0FBQzs7Ozs7Ozs7O0FBVUYsUUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssR0FBRzs7Ozs7Ozs7QUFRdkIsMEJBQWtCLEVBQUUsS0FBSzs7Ozs7Ozs7QUFRekIsZUFBTyxFQUFFLEtBQUs7Ozs7Ozs7O0FBUWQsb0JBQVksRUFBRSxLQUFLOzs7Ozs7Ozs7OztBQVduQixVQUFFLEVBQUUsU0FBUyxFQUFFLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFO0FBQzFDLGdCQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzVCLGlCQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxVQUFTLElBQUksRUFBRTtBQUM3QixxQkFBSyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ2pDLG9CQUFJLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3RCLENBQUMsQ0FBQztTQUNOOzs7Ozs7Ozs7OztBQVdELFdBQUcsRUFBRSxTQUFTLEdBQUcsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUU7QUFDNUMsZ0JBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDNUIsaUJBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFVBQVMsSUFBSSxFQUFFO0FBQzdCLHFCQUFLLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDbEMsb0JBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDdEIsQ0FBQyxDQUFDO1NBQ047Ozs7Ozs7Ozs7O0FBV0QsZUFBTyxFQUFFLFNBQVMsT0FBTyxDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFO0FBQ25ELGdCQUFJLElBQUksR0FBRyxJQUFJLENBQUM7O0FBRWhCLGdCQUFJLGNBQWMsR0FBRyxTQUFTLGNBQWMsQ0FBQyxFQUFFLEVBQUU7QUFDN0Msb0JBQUksT0FBTyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFO29CQUMvQixTQUFTLEdBQUcsTUFBTSxDQUFDLGlCQUFpQjtvQkFDcEMsT0FBTyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQztvQkFDdkMsV0FBVyxDQUFDOzs7O0FBSWhCLG9CQUFHLE9BQU8sSUFBSSxJQUFJLENBQUMsa0JBQWtCLEVBQUU7QUFDbkMsMkJBQU87OztpQkFHVixNQUFNLElBQUcsT0FBTyxJQUFJLFNBQVMsSUFBSSxXQUFXLElBQUksRUFBRSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7QUFDOUQsNEJBQUksQ0FBQyxrQkFBa0IsR0FBRyxLQUFLLENBQUM7QUFDaEMsNEJBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO3FCQUM1QixNQUFNLElBQUcsU0FBUyxJQUFJLFNBQVMsSUFBSSxXQUFXLEVBQUU7QUFDN0MsNEJBQUksQ0FBQyxZQUFZLEdBQUksRUFBRSxDQUFDLE9BQU8sS0FBSyxDQUFDLElBQUksWUFBWSxDQUFDLFNBQVMsQ0FBQyxhQUFhLEVBQUUsRUFBRSxDQUFDLEFBQUMsQ0FBQzs7cUJBRXZGLE1BQU0sSUFBRyxDQUFDLE9BQU8sSUFBSSxTQUFTLElBQUksV0FBVyxFQUFFO0FBQzVDLGdDQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDO0FBQy9CLGdDQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQzt5QkFDNUI7OztBQUdELG9CQUFHLFNBQVMsSUFBSSxTQUFTLElBQUksU0FBUyxFQUFFO0FBQ3BDLGdDQUFZLENBQUMsYUFBYSxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQztpQkFDN0M7OztBQUdELG9CQUFHLElBQUksQ0FBQyxZQUFZLEVBQUU7QUFDbEIsK0JBQVcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRSxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7aUJBQzNFOzs7O0FBSUQsb0JBQUcsV0FBVyxJQUFJLFNBQVMsRUFBRTtBQUN6Qix3QkFBSSxDQUFDLGtCQUFrQixHQUFHLEtBQUssQ0FBQztBQUNoQyx3QkFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7QUFDMUIsZ0NBQVksQ0FBQyxLQUFLLEVBQUUsQ0FBQzs7aUJBRXhCOztBQUVELG9CQUFHLFNBQVMsSUFBSSxTQUFTLElBQUksU0FBUyxFQUFFO0FBQ3BDLGdDQUFZLENBQUMsYUFBYSxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQztpQkFDN0M7YUFDSixDQUFDOztBQUVGLGdCQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxXQUFXLENBQUMsU0FBUyxDQUFDLEVBQUUsY0FBYyxDQUFDLENBQUM7QUFDekQsbUJBQU8sY0FBYyxDQUFDO1NBQ3pCOzs7Ozs7Ozs7Ozs7QUFZRCxnQkFBUSxFQUFFLFNBQVMsUUFBUSxDQUFDLEVBQUUsRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN6RCxnQkFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDakQsZ0JBQUksZUFBZSxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUM7QUFDdkMsZ0JBQUksV0FBVyxHQUFHLFNBQVMsQ0FBQztBQUM1QixnQkFBSSxhQUFhLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQztBQUN0QyxnQkFBSSxhQUFhLEdBQUcsZUFBZSxDQUFDOzs7QUFHcEMsZ0JBQUcsU0FBUyxJQUFJLFdBQVcsRUFBRTtBQUN6Qiw2QkFBYSxHQUFHLFdBQVcsQ0FBQzs7YUFFL0IsTUFBTSxJQUFHLFNBQVMsSUFBSSxTQUFTLEVBQUU7QUFDOUIsaUNBQWEsR0FBRyxhQUFhLENBQUM7OztBQUc5QixpQ0FBYSxHQUFHLFNBQVMsQ0FBQyxNQUFNLElBQUksQUFBQyxFQUFFLENBQUMsY0FBYyxHQUFJLEVBQUUsQ0FBQyxjQUFjLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQSxBQUFDLENBQUM7aUJBQzNGOzs7OztBQUtELGdCQUFHLGFBQWEsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtBQUNsQywyQkFBVyxHQUFHLFVBQVUsQ0FBQzthQUM1Qjs7O0FBR0QsZ0JBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDOzs7QUFHcEIsZ0JBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQzs7OztBQUl4RSxnQkFBRyxTQUFTLElBQUksU0FBUyxFQUFFO0FBQ3ZCLHVCQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQzthQUNuQzs7O0FBR0QsZ0JBQUcsYUFBYSxFQUFFO0FBQ2Qsc0JBQU0sQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFDO0FBQ3JDLHNCQUFNLENBQUMsU0FBUyxHQUFHLGFBQWEsQ0FBQzs7QUFFakMsdUJBQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDOztBQUVoQyxzQkFBTSxDQUFDLFNBQVMsR0FBRyxXQUFXLENBQUM7QUFDL0IsdUJBQU8sTUFBTSxDQUFDLGFBQWEsQ0FBQzthQUMvQjs7O0FBR0QsZ0JBQUcsV0FBVyxJQUFJLFNBQVMsRUFBRTtBQUN6Qix1QkFBTyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLENBQUM7Ozs7QUFJaEMsb0JBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO2FBQ3hCOztBQUVELG1CQUFPLFdBQVcsQ0FBQztTQUN0Qjs7Ozs7Ozs7O0FBU0QsMkJBQW1CLEVBQUUsU0FBUyxtQkFBbUIsR0FBRztBQUNoRCxnQkFBSSxLQUFLLENBQUM7QUFDVixnQkFBRyxNQUFNLENBQUMsaUJBQWlCLEVBQUU7QUFDekIsb0JBQUcsTUFBTSxDQUFDLFlBQVksRUFBRTtBQUNwQix5QkFBSyxHQUFHLENBQ0osYUFBYSxFQUNiLGFBQWEsRUFDYiw0Q0FBNEMsQ0FDL0MsQ0FBQztpQkFDTCxNQUFNO0FBQ0gseUJBQUssR0FBRyxDQUNKLGVBQWUsRUFDZixlQUFlLEVBQ2Ysa0RBQWtELENBQ3JELENBQUM7aUJBQ0w7YUFDSixNQUFNLElBQUcsTUFBTSxDQUFDLGNBQWMsRUFBRTtBQUM3QixxQkFBSyxHQUFHLENBQ0osWUFBWSxFQUNaLFdBQVcsRUFDWCxzQkFBc0IsQ0FDekIsQ0FBQzthQUNMLE1BQU07QUFDSCxxQkFBSyxHQUFHLENBQ0osc0JBQXNCLEVBQ3RCLHFCQUFxQixFQUNyQiw4QkFBOEIsQ0FDakMsQ0FBQzthQUNMOztBQUVELHVCQUFXLENBQUMsV0FBVyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BDLHVCQUFXLENBQUMsVUFBVSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ25DLHVCQUFXLENBQUMsU0FBUyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2xDLG1CQUFPLFdBQVcsQ0FBQztTQUN0Qjs7Ozs7Ozs7O0FBU0Qsb0JBQVksRUFBRSxTQUFTLFlBQVksQ0FBQyxFQUFFLEVBQUUsU0FBUyxFQUFFOztBQUUvQyxnQkFBRyxNQUFNLENBQUMsaUJBQWlCLEVBQUU7QUFDekIsdUJBQU8sWUFBWSxDQUFDLFlBQVksRUFBRSxDQUFDO2FBQ3RDOzs7QUFHRCxnQkFBRyxFQUFFLENBQUMsT0FBTyxFQUFFO0FBQ1gsb0JBQUcsU0FBUyxJQUFJLFVBQVUsRUFBRTtBQUN4QiwyQkFBTyxFQUFFLENBQUMsT0FBTyxDQUFDO2lCQUNyQjs7QUFFRCxvQkFBSSxXQUFXLEdBQUcsRUFBRSxDQUFDO0FBQ3JCLG9CQUFJLE1BQU0sR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUM7QUFDcEYsb0JBQUksU0FBUyxHQUFHLEVBQUUsQ0FBQzs7QUFFbkIscUJBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFVBQVMsS0FBSyxFQUFFO0FBQy9CLHdCQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLEtBQUssQ0FBQyxVQUFVLENBQUMsS0FBSyxLQUFLLEVBQUU7QUFDdkQsaUNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7cUJBQ3pCO0FBQ0QsK0JBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2lCQUN0QyxDQUFDLENBQUM7O0FBRUgsdUJBQU8sU0FBUyxDQUFDO2FBQ3BCOzs7QUFHRCxjQUFFLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQztBQUNsQixtQkFBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ2Y7Ozs7Ozs7Ozs7O0FBV0Qsd0JBQWdCLEVBQUUsU0FBUyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUU7O0FBRXpFLGdCQUFJLFdBQVcsR0FBRyxhQUFhLENBQUM7QUFDaEMsZ0JBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxJQUFJLFlBQVksQ0FBQyxTQUFTLENBQUMsYUFBYSxFQUFFLEVBQUUsQ0FBQyxFQUFFO0FBQzNFLDJCQUFXLEdBQUcsYUFBYSxDQUFDO2FBQy9CLE1BQU0sSUFBRyxZQUFZLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUMsRUFBRTtBQUMvQywyQkFBVyxHQUFHLFdBQVcsQ0FBQzthQUM3Qjs7QUFFRCxtQkFBTztBQUNILHNCQUFNLEVBQUUsS0FBSyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUM7QUFDaEMseUJBQVMsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFO0FBQ3JCLHNCQUFNLEVBQUUsRUFBRSxDQUFDLE1BQU07QUFDakIsdUJBQU8sRUFBRSxPQUFPO0FBQ2hCLHlCQUFTLEVBQUUsU0FBUztBQUNwQiwyQkFBVyxFQUFFLFdBQVc7QUFDeEIsd0JBQVEsRUFBRSxFQUFFOzs7Ozs7QUFNWiw4QkFBYyxFQUFFLDBCQUFXO0FBQ3ZCLHdCQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO0FBQzdCLDRCQUFRLENBQUMsbUJBQW1CLElBQUksUUFBUSxDQUFDLG1CQUFtQixFQUFFLENBQUM7QUFDL0QsNEJBQVEsQ0FBQyxjQUFjLElBQUksUUFBUSxDQUFDLGNBQWMsRUFBRSxDQUFDO2lCQUN4RDs7Ozs7QUFLRCwrQkFBZSxFQUFFLDJCQUFXO0FBQ3hCLHdCQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsRUFBRSxDQUFDO2lCQUNuQzs7Ozs7OztBQU9ELDBCQUFVLEVBQUUsc0JBQVc7QUFDbkIsMkJBQU8sU0FBUyxDQUFDLFVBQVUsRUFBRSxDQUFDO2lCQUNqQzthQUNKLENBQUM7U0FDTDtLQUNKLENBQUM7Ozs7Ozs7O0FBU0YsUUFBSSxZQUFZLEdBQUcsTUFBTSxDQUFDLFlBQVksR0FBRzs7Ozs7O0FBTXJDLGdCQUFRLEVBQUUsRUFBRTs7Ozs7OztBQU9aLG9CQUFZLEVBQUUsU0FBUyxZQUFZLEdBQUc7QUFDbEMsZ0JBQUksU0FBUyxHQUFHLEVBQUUsQ0FBQzs7QUFFbkIsaUJBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxVQUFTLE9BQU8sRUFBRTtBQUN4Qyx5QkFBUyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUMzQixDQUFDLENBQUM7O0FBRUgsbUJBQU8sU0FBUyxDQUFDO1NBQ3BCOzs7Ozs7OztBQVFELHFCQUFhLEVBQUUsU0FBUyxhQUFhLENBQUMsU0FBUyxFQUFFLFlBQVksRUFBRTtBQUMzRCxnQkFBRyxTQUFTLElBQUksU0FBUyxFQUFFO0FBQ3ZCLHVCQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2FBQ2hELE1BQU07QUFDSCw0QkFBWSxDQUFDLFVBQVUsR0FBRyxZQUFZLENBQUMsU0FBUyxDQUFDO0FBQ2pELG9CQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsR0FBRyxZQUFZLENBQUM7YUFDeEQ7U0FDSjs7Ozs7Ozs7QUFRRCxpQkFBUyxFQUFFLFNBQVMsU0FBUyxDQUFDLFdBQVcsRUFBRSxFQUFFLEVBQUU7QUFDM0MsZ0JBQUcsQ0FBQyxFQUFFLENBQUMsV0FBVyxFQUFFO0FBQ2hCLHVCQUFPLEtBQUssQ0FBQzthQUNoQjs7QUFFRCxnQkFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLFdBQVc7Z0JBQ25CLEtBQUssR0FBRyxFQUFFLENBQUM7O0FBRWYsaUJBQUssQ0FBQyxhQUFhLENBQUMsR0FBSSxFQUFFLE1BQU0sRUFBRSxDQUFDLG9CQUFvQixJQUFJLGFBQWEsQ0FBQSxBQUFDLEFBQUMsQ0FBQztBQUMzRSxpQkFBSyxDQUFDLGFBQWEsQ0FBQyxHQUFJLEVBQUUsTUFBTSxFQUFFLENBQUMsb0JBQW9CLElBQUksYUFBYSxDQUFBLEFBQUMsQUFBQyxDQUFDO0FBQzNFLGlCQUFLLENBQUMsV0FBVyxDQUFDLEdBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQyxrQkFBa0IsSUFBSSxXQUFXLENBQUEsQUFBQyxBQUFDLENBQUM7QUFDckUsbUJBQU8sS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1NBQzdCOzs7Ozs7QUFNRCxhQUFLLEVBQUUsU0FBUyxTQUFTLEdBQUc7QUFDeEIsZ0JBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO1NBQ3RCO0tBQ0osQ0FBQzs7Ozs7Ozs7QUFTRixRQUFJLFNBQVMsR0FBRyxNQUFNLENBQUMsU0FBUyxHQUFHOztBQUUvQixnQkFBUSxFQUFFLEVBQUU7OztBQUdaLGVBQU8sRUFBRSxJQUFJOzs7O0FBSWIsZ0JBQVEsRUFBRSxJQUFJOzs7QUFHZCxlQUFPLEVBQUUsS0FBSzs7Ozs7Ozs7QUFRZCxtQkFBVyxFQUFFLFNBQVMsV0FBVyxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUU7O0FBRS9DLGdCQUFHLElBQUksQ0FBQyxPQUFPLEVBQUU7QUFDYix1QkFBTzthQUNWOztBQUVELGdCQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQzs7O0FBR3JCLGdCQUFJLENBQUMsT0FBTyxHQUFHO0FBQ1gsb0JBQUksRUFBRSxJQUFJO0FBQ1YsMEJBQVUsRUFBRSxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxTQUFTLENBQUM7QUFDdkMseUJBQVMsRUFBRSxLQUFLO0FBQ2hCLDZCQUFhLEVBQUUsS0FBSztBQUNwQiwrQkFBZSxFQUFFLEtBQUs7QUFDdEIsNEJBQVksRUFBRSxFQUFFO0FBQ2hCLG9CQUFJLEVBQUUsRUFBRTthQUNYLENBQUM7O0FBRUYsZ0JBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDMUI7Ozs7Ozs7O0FBUUQsY0FBTSxFQUFFLFNBQVMsTUFBTSxDQUFDLFNBQVMsRUFBRTtBQUMvQixnQkFBRyxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtBQUM5Qix1QkFBTzthQUNWOzs7QUFHRCxxQkFBUyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDLENBQUM7OztBQUc1QyxnQkFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJO2dCQUN4QixXQUFXLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQzs7O0FBRy9CLGlCQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsU0FBUyxjQUFjLENBQUMsT0FBTyxFQUFFOztBQUV2RCxvQkFBRyxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLE9BQU8sSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQzNELDJCQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO2lCQUNsRDthQUNKLEVBQUUsSUFBSSxDQUFDLENBQUM7OztBQUdULGdCQUFHLElBQUksQ0FBQyxPQUFPLEVBQUU7QUFDYixvQkFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO2FBQ3RDOztBQUVELGdCQUFHLFNBQVMsQ0FBQyxTQUFTLElBQUksU0FBUyxFQUFFO0FBQ2pDLG9CQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7YUFDckI7O0FBRUQsbUJBQU8sU0FBUyxDQUFDO1NBQ3BCOzs7Ozs7OztBQVFELGtCQUFVLEVBQUUsU0FBUyxVQUFVLEdBQUc7OztBQUc5QixnQkFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7OztBQUcvQyxnQkFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7QUFDcEIsZ0JBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1NBQ3ZCOzs7Ozs7Ozs7OztBQVdELHlCQUFpQixFQUFFLFNBQVMsaUJBQWlCLENBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRTtBQUNqRixnQkFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLE9BQU87Z0JBQ2xCLE1BQU0sR0FBRyxLQUFLO2dCQUNkLE1BQU0sR0FBRyxHQUFHLENBQUMsYUFBYTtnQkFDMUIsUUFBUSxHQUFHLEdBQUcsQ0FBQyxZQUFZLENBQUM7O0FBRWhDLGdCQUFHLE1BQU0sSUFBSSxFQUFFLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLGtCQUFrQixFQUFFO0FBQ3RFLHNCQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztBQUN2Qix5QkFBUyxHQUFHLEVBQUUsQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQztBQUM1QyxzQkFBTSxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO0FBQ25ELHNCQUFNLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUM7QUFDbkQsc0JBQU0sR0FBRyxJQUFJLENBQUM7YUFDakI7O0FBRUQsZ0JBQUcsRUFBRSxDQUFDLFNBQVMsSUFBSSxXQUFXLElBQUksRUFBRSxDQUFDLFNBQVMsSUFBSSxhQUFhLEVBQUU7QUFDN0QsbUJBQUcsQ0FBQyxlQUFlLEdBQUcsRUFBRSxDQUFDO2FBQzVCOztBQUVELGdCQUFHLENBQUMsR0FBRyxDQUFDLGFBQWEsSUFBSSxNQUFNLEVBQUU7QUFDN0Isd0JBQVEsQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ2pFLHdCQUFRLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNuRCx3QkFBUSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUM7O0FBRTNELG1CQUFHLENBQUMsYUFBYSxHQUFHLEdBQUcsQ0FBQyxlQUFlLElBQUksRUFBRSxDQUFDO0FBQzlDLG1CQUFHLENBQUMsZUFBZSxHQUFHLEVBQUUsQ0FBQzthQUM1Qjs7QUFFRCxjQUFFLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQ25DLGNBQUUsQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7QUFDbkMsY0FBRSxDQUFDLFlBQVksR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDO0FBQ2pDLGNBQUUsQ0FBQyxnQkFBZ0IsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO1NBQzVDOzs7Ozs7OztBQVFELHVCQUFlLEVBQUUsU0FBUyxlQUFlLENBQUMsRUFBRSxFQUFFO0FBQzFDLGdCQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsT0FBTztnQkFDbEIsT0FBTyxHQUFHLEdBQUcsQ0FBQyxVQUFVO2dCQUN4QixNQUFNLEdBQUcsR0FBRyxDQUFDLFNBQVMsSUFBSSxPQUFPLENBQUM7OztBQUd0QyxnQkFBRyxFQUFFLENBQUMsU0FBUyxJQUFJLFdBQVcsSUFBSSxFQUFFLENBQUMsU0FBUyxJQUFJLGFBQWEsRUFBRTtBQUM3RCx1QkFBTyxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7QUFDckIscUJBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxVQUFTLEtBQUssRUFBRTtBQUNuQywyQkFBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7QUFDakIsK0JBQU8sRUFBRSxLQUFLLENBQUMsT0FBTztBQUN0QiwrQkFBTyxFQUFFLEtBQUssQ0FBQyxPQUFPO3FCQUN6QixDQUFDLENBQUM7aUJBQ04sQ0FBQyxDQUFDO2FBQ047O0FBRUQsZ0JBQUksU0FBUyxHQUFHLEVBQUUsQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLFNBQVM7Z0JBQzVDLE1BQU0sR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLE9BQU87Z0JBQ25ELE1BQU0sR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQzs7QUFFeEQsZ0JBQUksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDOztBQUVyRSxpQkFBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUU7QUFDYiwwQkFBVSxFQUFFLE9BQU87O0FBRW5CLHlCQUFTLEVBQUUsU0FBUztBQUNwQixzQkFBTSxFQUFFLE1BQU07QUFDZCxzQkFBTSxFQUFFLE1BQU07O0FBRWQsd0JBQVEsRUFBRSxLQUFLLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQztBQUN0RCxxQkFBSyxFQUFFLEtBQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDO0FBQ2hELHlCQUFTLEVBQUUsS0FBSyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUM7QUFDeEQscUJBQUssRUFBRSxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQztBQUNsRCx3QkFBUSxFQUFFLEtBQUssQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDO2FBQzNELENBQUMsQ0FBQzs7QUFFSCxtQkFBTyxFQUFFLENBQUM7U0FDYjs7Ozs7Ozs7QUFRRCxnQkFBUSxFQUFFLFNBQVMsUUFBUSxDQUFDLE9BQU8sRUFBRTs7QUFFakMsZ0JBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxRQUFRLElBQUksRUFBRSxDQUFDO0FBQ3JDLGdCQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssU0FBUyxFQUFFO0FBQ3BDLHVCQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQzthQUNoQzs7O0FBR0QsaUJBQUssQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7OztBQUc3QyxtQkFBTyxDQUFDLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQzs7O0FBR3RDLGdCQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQzs7O0FBRzVCLGdCQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxVQUFTLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDOUIsb0JBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFO0FBQ2xCLDJCQUFPLENBQUMsQ0FBQyxDQUFDO2lCQUNiO0FBQ0Qsb0JBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFO0FBQ2xCLDJCQUFPLENBQUMsQ0FBQztpQkFDWjtBQUNELHVCQUFPLENBQUMsQ0FBQzthQUNaLENBQUMsQ0FBQzs7QUFFSCxtQkFBTyxJQUFJLENBQUMsUUFBUSxDQUFDO1NBQ3hCO0tBQ0osQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCRixVQUFNLENBQUMsUUFBUSxHQUFHLFVBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN6QyxZQUFJLElBQUksR0FBRyxJQUFJLENBQUM7Ozs7QUFJaEIsYUFBSyxFQUFFLENBQUM7Ozs7OztBQU1SLFlBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDOzs7Ozs7O0FBT3ZCLFlBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDOzs7Ozs7OztBQVFwQixhQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxVQUFTLEtBQUssRUFBRSxJQUFJLEVBQUU7QUFDdEMsbUJBQU8sT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3JCLG1CQUFPLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztTQUM1QyxDQUFDLENBQUM7O0FBRUgsWUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRSxPQUFPLElBQUksRUFBRSxDQUFDLENBQUM7OztBQUc5RSxZQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFO0FBQ3RCLGlCQUFLLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDbkU7Ozs7Ozs7QUFPRCxZQUFJLENBQUMsaUJBQWlCLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsV0FBVyxFQUFFLFVBQVMsRUFBRSxFQUFFO0FBQ3RFLGdCQUFHLElBQUksQ0FBQyxPQUFPLElBQUksRUFBRSxDQUFDLFNBQVMsSUFBSSxXQUFXLEVBQUU7QUFDNUMseUJBQVMsQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2FBQ25DLE1BQU0sSUFBRyxFQUFFLENBQUMsU0FBUyxJQUFJLFdBQVcsRUFBRTtBQUNuQyx5QkFBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQzthQUN4QjtTQUNKLENBQUMsQ0FBQzs7Ozs7OztBQU9ILFlBQUksQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDO0tBQzNCLENBQUM7O0FBRUYsVUFBTSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEdBQUc7Ozs7Ozs7OztBQVN4QixVQUFFLEVBQUUsU0FBUyxPQUFPLENBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRTtBQUNwQyxnQkFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ2hCLGlCQUFLLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxVQUFTLElBQUksRUFBRTtBQUNyRCxvQkFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO2FBQ2hFLENBQUMsQ0FBQztBQUNILG1CQUFPLElBQUksQ0FBQztTQUNmOzs7Ozs7Ozs7QUFTRCxXQUFHLEVBQUUsU0FBUyxRQUFRLENBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRTtBQUN0QyxnQkFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDOztBQUVoQixpQkFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsVUFBUyxJQUFJLEVBQUU7QUFDdEQsb0JBQUksS0FBSyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO0FBQy9ELG9CQUFHLEtBQUssS0FBSyxLQUFLLEVBQUU7QUFDaEIsd0JBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztpQkFDdkM7YUFDSixDQUFDLENBQUM7QUFDSCxtQkFBTyxJQUFJLENBQUM7U0FDZjs7Ozs7Ozs7O0FBU0QsZUFBTyxFQUFFLFNBQVMsWUFBWSxDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUU7O0FBRS9DLGdCQUFHLENBQUMsU0FBUyxFQUFFO0FBQ1gseUJBQVMsR0FBRyxFQUFFLENBQUM7YUFDbEI7OztBQUdELGdCQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNqRCxpQkFBSyxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3JDLGlCQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQzs7OztBQUkxQixnQkFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztBQUMzQixnQkFBRyxLQUFLLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLEVBQUU7QUFDM0MsdUJBQU8sR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDO2FBQzlCOztBQUVELG1CQUFPLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzdCLG1CQUFPLElBQUksQ0FBQztTQUNmOzs7Ozs7OztBQVFELGNBQU0sRUFBRSxTQUFTLE1BQU0sQ0FBQyxLQUFLLEVBQUU7QUFDM0IsZ0JBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO0FBQ3JCLG1CQUFPLElBQUksQ0FBQztTQUNmOzs7Ozs7O0FBT0QsZUFBTyxFQUFFLFNBQVMsT0FBTyxHQUFHO0FBQ3hCLGdCQUFJLENBQUMsRUFBRSxFQUFFLENBQUM7OztBQUdWLGlCQUFLLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7OztBQUdqRSxpQkFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBSTtBQUN6QyxxQkFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2FBQ25EOztBQUVELGdCQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQzs7O0FBR3hCLGlCQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsV0FBVyxDQUFDLFdBQVcsQ0FBQyxFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDOztBQUUxRSxtQkFBTyxJQUFJLENBQUM7U0FDZjtLQUNKLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbURGLEtBQUMsVUFBUyxJQUFJLEVBQUU7QUFDWixZQUFJLFNBQVMsR0FBRyxLQUFLLENBQUM7O0FBRXRCLGlCQUFTLFdBQVcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFO0FBQzNCLGdCQUFJLEdBQUcsR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDOzs7QUFHNUIsZ0JBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEdBQUcsQ0FBQyxJQUM5QixFQUFFLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRTtBQUNqRCx1QkFBTzthQUNWOztBQUVELG9CQUFPLEVBQUUsQ0FBQyxTQUFTO0FBQ2YscUJBQUssV0FBVztBQUNaLDZCQUFTLEdBQUcsS0FBSyxDQUFDO0FBQ2xCLDBCQUFNOztBQUFBLEFBRVYscUJBQUssVUFBVTs7O0FBR1gsd0JBQUcsRUFBRSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGVBQWUsSUFDekMsR0FBRyxDQUFDLElBQUksSUFBSSxJQUFJLEVBQUU7QUFDbEIsK0JBQU87cUJBQ1Y7O0FBRUQsd0JBQUksV0FBVyxHQUFHLEdBQUcsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDOzs7QUFHeEMsd0JBQUcsR0FBRyxDQUFDLElBQUksSUFBSSxJQUFJLEVBQUU7QUFDakIsMkJBQUcsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ2hCLDRCQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsc0JBQXNCLElBQUksRUFBRSxDQUFDLFFBQVEsR0FBRyxDQUFDLEVBQUU7Ozs7QUFJdkQsZ0NBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ2xFLHVDQUFXLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0FBQ3hDLHVDQUFXLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0FBQ3hDLHVDQUFXLENBQUMsT0FBTyxJQUFJLEVBQUUsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0FBQzFDLHVDQUFXLENBQUMsT0FBTyxJQUFJLEVBQUUsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDOzs7QUFHMUMsOEJBQUUsR0FBRyxTQUFTLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxDQUFDO3lCQUN0QztxQkFDSjs7O0FBR0Qsd0JBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxjQUFjLElBQ3pCLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxJQUN6QixJQUFJLENBQUMsT0FBTyxDQUFDLG1CQUFtQixJQUFJLEVBQUUsQ0FBQyxRQUFRLEFBQzlDLEVBQUU7QUFDUCwwQkFBRSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7cUJBQzVCOzs7QUFHRCx3QkFBSSxhQUFhLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUM7QUFDNUMsd0JBQUcsRUFBRSxDQUFDLGNBQWMsSUFBSSxhQUFhLEtBQUssRUFBRSxDQUFDLFNBQVMsRUFBRTtBQUNwRCw0QkFBRyxLQUFLLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxFQUFFO0FBQ2hDLDhCQUFFLENBQUMsU0FBUyxHQUFHLEFBQUMsRUFBRSxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUksWUFBWSxHQUFHLGNBQWMsQ0FBQzt5QkFDbEUsTUFBTTtBQUNILDhCQUFFLENBQUMsU0FBUyxHQUFHLEFBQUMsRUFBRSxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUksY0FBYyxHQUFHLGVBQWUsQ0FBQzt5QkFDckU7cUJBQ0o7OztBQUdELHdCQUFHLENBQUMsU0FBUyxFQUFFO0FBQ1gsNEJBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNqQyxpQ0FBUyxHQUFHLElBQUksQ0FBQztxQkFDcEI7OztBQUdELHdCQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztBQUN2Qix3QkFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQzs7QUFFdEMsd0JBQUksVUFBVSxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDOzs7QUFHaEQsd0JBQUcsQUFBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGlCQUFpQixJQUFJLFVBQVUsSUFDM0MsSUFBSSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsSUFBSSxDQUFDLFVBQVUsQUFBQyxFQUFFO0FBQ25ELDBCQUFFLENBQUMsY0FBYyxFQUFFLENBQUM7cUJBQ3ZCO0FBQ0QsMEJBQU07O0FBQUEsQUFFVixxQkFBSyxhQUFhO0FBQ2Qsd0JBQUcsU0FBUyxJQUFJLEVBQUUsQ0FBQyxhQUFhLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEVBQUU7QUFDN0QsNEJBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztBQUMvQixpQ0FBUyxHQUFHLEtBQUssQ0FBQztxQkFDckI7QUFDRCwwQkFBTTs7QUFBQSxBQUVWLHFCQUFLLFNBQVM7QUFDViw2QkFBUyxHQUFHLEtBQUssQ0FBQztBQUNsQiwwQkFBTTtBQUFBLGFBQ2I7U0FDSjs7QUFFRCxjQUFNLENBQUMsUUFBUSxDQUFDLElBQUksR0FBRztBQUNuQixnQkFBSSxFQUFFLElBQUk7QUFDVixpQkFBSyxFQUFFLEVBQUU7QUFDVCxtQkFBTyxFQUFFLFdBQVc7QUFDcEIsb0JBQVEsRUFBRTs7Ozs7OztBQU9OLCtCQUFlLEVBQUUsRUFBRTs7Ozs7Ozs7Ozs7QUFXbkIsc0NBQXNCLEVBQUUsSUFBSTs7Ozs7Ozs7QUFRNUIsOEJBQWMsRUFBRSxDQUFDOzs7Ozs7Ozs7O0FBVWpCLG1DQUFtQixFQUFFLEtBQUs7Ozs7Ozs7O0FBUTFCLGlDQUFpQixFQUFFLEtBQUs7Ozs7Ozs7OztBQVN4Qiw4QkFBYyxFQUFFLEtBQUs7Ozs7Ozs7OztBQVNyQixtQ0FBbUIsRUFBRSxFQUFFO2FBQzFCO1NBQ0osQ0FBQztLQUNMLENBQUEsQ0FBRSxNQUFNLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztBQWdCWCxVQUFNLENBQUMsUUFBUSxDQUFDLE9BQU8sR0FBRztBQUN0QixZQUFJLEVBQUUsU0FBUztBQUNmLGFBQUssRUFBRSxJQUFJO0FBQ1gsZUFBTyxFQUFFLFNBQVMsY0FBYyxDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUU7QUFDdkMsZ0JBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztTQUMvQjtLQUNKLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkYsS0FBQyxVQUFTLElBQUksRUFBRTtBQUNaLFlBQUksS0FBSyxDQUFDOztBQUVWLGlCQUFTLFdBQVcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFO0FBQzNCLGdCQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTztnQkFDdEIsT0FBTyxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUM7O0FBRWhDLG9CQUFPLEVBQUUsQ0FBQyxTQUFTO0FBQ2YscUJBQUssV0FBVztBQUNaLGdDQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7OztBQUdwQiwyQkFBTyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7Ozs7QUFJcEIseUJBQUssR0FBRyxVQUFVLENBQUMsWUFBVztBQUMxQiw0QkFBRyxPQUFPLElBQUksT0FBTyxDQUFDLElBQUksSUFBSSxJQUFJLEVBQUU7QUFDaEMsZ0NBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO3lCQUMxQjtxQkFDSixFQUFFLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUN4QiwwQkFBTTs7QUFBQSxBQUVWLHFCQUFLLFVBQVU7QUFDWCx3QkFBRyxFQUFFLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxhQUFhLEVBQUU7QUFDcEMsb0NBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztxQkFDdkI7QUFDRCwwQkFBTTs7QUFBQSxBQUVWLHFCQUFLLGFBQWE7QUFDZCxnQ0FBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3BCLDBCQUFNO0FBQUEsYUFDYjtTQUNKOztBQUVELGNBQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxHQUFHO0FBQ25CLGdCQUFJLEVBQUUsSUFBSTtBQUNWLGlCQUFLLEVBQUUsRUFBRTtBQUNULG9CQUFRLEVBQUU7Ozs7OztBQU1OLDJCQUFXLEVBQUUsR0FBRzs7Ozs7Ozs7QUFRaEIsNkJBQWEsRUFBRSxDQUFDO2FBQ25CO0FBQ0QsbUJBQU8sRUFBRSxXQUFXO1NBQ3ZCLENBQUM7S0FDTCxDQUFBLENBQUUsTUFBTSxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7OztBQWVYLFVBQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxHQUFHO0FBQ3RCLFlBQUksRUFBRSxTQUFTO0FBQ2YsYUFBSyxFQUFFLFFBQVE7QUFDZixlQUFPLEVBQUUsU0FBUyxjQUFjLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRTtBQUN2QyxnQkFBRyxFQUFFLENBQUMsU0FBUyxJQUFJLGFBQWEsRUFBRTtBQUM5QixvQkFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2FBQy9CO1NBQ0o7S0FDSixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNDRixVQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssR0FBRztBQUNwQixZQUFJLEVBQUUsT0FBTztBQUNiLGFBQUssRUFBRSxFQUFFO0FBQ1QsZ0JBQVEsRUFBRTs7Ozs7O0FBTU4sMkJBQWUsRUFBRSxDQUFDOzs7Ozs7O0FBT2xCLDJCQUFlLEVBQUUsQ0FBQzs7Ozs7Ozs7QUFRbEIsMEJBQWMsRUFBRSxHQUFHOzs7Ozs7OztBQVFuQiwwQkFBYyxFQUFFLEdBQUc7U0FDdEI7O0FBRUQsZUFBTyxFQUFFLFNBQVMsWUFBWSxDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUU7QUFDckMsZ0JBQUcsRUFBRSxDQUFDLFNBQVMsSUFBSSxhQUFhLEVBQUU7QUFDOUIsb0JBQUksT0FBTyxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsTUFBTTtvQkFDM0IsT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7OztBQUczQixvQkFBRyxPQUFPLEdBQUcsT0FBTyxDQUFDLGVBQWUsSUFDaEMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxlQUFlLEVBQUU7QUFDbkMsMkJBQU87aUJBQ1Y7Ozs7QUFJRCxvQkFBRyxFQUFFLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQyxjQUFjLElBQ3BDLEVBQUUsQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLGNBQWMsRUFBRTs7QUFFdkMsd0JBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztBQUM1Qix3QkFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDLENBQUM7aUJBQzlDO2FBQ0o7U0FDSjtLQUNKLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJGLEtBQUMsVUFBUyxJQUFJLEVBQUU7QUFDWixZQUFJLFFBQVEsR0FBRyxLQUFLLENBQUM7O0FBRXJCLGlCQUFTLFVBQVUsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFO0FBQzFCLGdCQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTztnQkFDdEIsT0FBTyxHQUFHLFNBQVMsQ0FBQyxPQUFPO2dCQUMzQixJQUFJLEdBQUcsU0FBUyxDQUFDLFFBQVE7Z0JBQ3pCLFNBQVM7Z0JBQ1QsWUFBWSxDQUFDOztBQUVqQixvQkFBTyxFQUFFLENBQUMsU0FBUztBQUNmLHFCQUFLLFdBQVc7QUFDWiw0QkFBUSxHQUFHLEtBQUssQ0FBQztBQUNqQiwwQkFBTTs7QUFBQSxBQUVWLHFCQUFLLFVBQVU7QUFDWCw0QkFBUSxHQUFHLFFBQVEsSUFBSyxFQUFFLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxjQUFjLEFBQUMsQ0FBQztBQUM5RCwwQkFBTTs7QUFBQSxBQUVWLHFCQUFLLFNBQVM7QUFDVix3QkFBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsVUFBVSxJQUFJLENBQUMsUUFBUSxFQUFFOztBQUUzRixpQ0FBUyxHQUFHLElBQUksSUFBSSxJQUFJLENBQUMsU0FBUyxJQUFJLEVBQUUsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUM7QUFDOUUsb0NBQVksR0FBRyxLQUFLLENBQUM7OztBQUdyQiw0QkFBRyxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLElBQ3ZCLFNBQVMsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixBQUFDLElBQ3BELEVBQUUsQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixFQUFFO0FBQ3pDLGdDQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUM5Qix3Q0FBWSxHQUFHLElBQUksQ0FBQzt5QkFDdkI7OztBQUdELDRCQUFHLENBQUMsWUFBWSxJQUFJLE9BQU8sQ0FBQyxTQUFTLEVBQUU7QUFDbkMsbUNBQU8sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ3BCLGdDQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7eUJBQ2xDO3FCQUNKO0FBQ0QsMEJBQU07QUFBQSxhQUNiO1NBQ0o7O0FBRUQsY0FBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEdBQUc7QUFDbEIsZ0JBQUksRUFBRSxJQUFJO0FBQ1YsaUJBQUssRUFBRSxHQUFHO0FBQ1YsbUJBQU8sRUFBRSxVQUFVO0FBQ25CLG9CQUFRLEVBQUU7Ozs7Ozs7QUFPTiwwQkFBVSxFQUFFLEdBQUc7Ozs7Ozs7O0FBUWYsOEJBQWMsRUFBRSxFQUFFOzs7Ozs7OztBQVFsQix5QkFBUyxFQUFFLElBQUk7Ozs7Ozs7O0FBUWYsaUNBQWlCLEVBQUUsRUFBRTs7Ozs7Ozs7QUFRckIsaUNBQWlCLEVBQUUsR0FBRzthQUN6QjtTQUNKLENBQUM7S0FDTCxDQUFBLENBQUUsS0FBSyxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7OztBQWVWLFVBQU0sQ0FBQyxRQUFRLENBQUMsS0FBSyxHQUFHO0FBQ3BCLFlBQUksRUFBRSxPQUFPO0FBQ2IsYUFBSyxFQUFFLENBQUMsUUFBUTtBQUNoQixnQkFBUSxFQUFFOzs7Ozs7Ozs7QUFTTiwwQkFBYyxFQUFFLEtBQUs7Ozs7Ozs7O0FBUXJCLHdCQUFZLEVBQUUsS0FBSztTQUN0QjtBQUNELGVBQU8sRUFBRSxTQUFTLFlBQVksQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFO0FBQ3JDLGdCQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxJQUFJLEVBQUUsQ0FBQyxXQUFXLElBQUksYUFBYSxFQUFFO0FBQzdELGtCQUFFLENBQUMsVUFBVSxFQUFFLENBQUM7QUFDaEIsdUJBQU87YUFDVjs7QUFFRCxnQkFBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRTtBQUM1QixrQkFBRSxDQUFDLGNBQWMsRUFBRSxDQUFDO2FBQ3ZCOztBQUVELGdCQUFHLEVBQUUsQ0FBQyxTQUFTLElBQUksV0FBVyxFQUFFO0FBQzVCLG9CQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQzthQUM3QjtTQUNKO0tBQ0osQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5Q0YsS0FBQyxVQUFTLElBQUksRUFBRTtBQUNaLFlBQUksU0FBUyxHQUFHLEtBQUssQ0FBQzs7QUFFdEIsaUJBQVMsZ0JBQWdCLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRTtBQUNoQyxvQkFBTyxFQUFFLENBQUMsU0FBUztBQUNmLHFCQUFLLFdBQVc7QUFDWiw2QkFBUyxHQUFHLEtBQUssQ0FBQztBQUNsQiwwQkFBTTs7QUFBQSxBQUVWLHFCQUFLLFVBQVU7O0FBRVgsd0JBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO0FBQ3RCLCtCQUFPO3FCQUNWOztBQUVELHdCQUFJLGNBQWMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDNUMsd0JBQUksaUJBQWlCLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUM7Ozs7QUFJOUMsd0JBQUcsY0FBYyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsaUJBQWlCLElBQzlDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsb0JBQW9CLEVBQUU7QUFDdkQsK0JBQU87cUJBQ1Y7OztBQUdELDZCQUFTLENBQUMsT0FBTyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7OztBQUc5Qix3QkFBRyxDQUFDLFNBQVMsRUFBRTtBQUNYLDRCQUFJLENBQUMsT0FBTyxDQUFDLElBQUksR0FBRyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDakMsaUNBQVMsR0FBRyxJQUFJLENBQUM7cUJBQ3BCOztBQUVELHdCQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQzs7O0FBR3ZCLHdCQUFHLGlCQUFpQixHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsb0JBQW9CLEVBQUU7QUFDdEQsNEJBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO3FCQUM5Qjs7O0FBR0Qsd0JBQUcsY0FBYyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsaUJBQWlCLEVBQUU7QUFDaEQsNEJBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQzFCLDRCQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUMsS0FBSyxHQUFHLENBQUMsR0FBRyxJQUFJLEdBQUcsS0FBSyxDQUFBLEFBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztxQkFDN0Q7QUFDRCwwQkFBTTs7QUFBQSxBQUVWLHFCQUFLLGFBQWE7QUFDZCx3QkFBRyxTQUFTLElBQUksRUFBRSxDQUFDLGFBQWEsR0FBRyxDQUFDLEVBQUU7QUFDbEMsNEJBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztBQUMvQixpQ0FBUyxHQUFHLEtBQUssQ0FBQztxQkFDckI7QUFDRCwwQkFBTTtBQUFBLGFBQ2I7U0FDSjs7QUFFRCxjQUFNLENBQUMsUUFBUSxDQUFDLFNBQVMsR0FBRztBQUN4QixnQkFBSSxFQUFFLElBQUk7QUFDVixpQkFBSyxFQUFFLEVBQUU7QUFDVCxvQkFBUSxFQUFFOzs7Ozs7O0FBT04saUNBQWlCLEVBQUUsSUFBSTs7Ozs7Ozs7QUFRdkIsb0NBQW9CLEVBQUUsQ0FBQzthQUMxQjs7QUFFRCxtQkFBTyxFQUFFLGdCQUFnQjtTQUM1QixDQUFDO0tBQ0wsQ0FBQSxDQUFFLFdBQVcsQ0FBQyxDQUFDOzs7Ozs7O0FBT2hCLFFBQUcsT0FBTyxNQUFNLElBQUksVUFBVSxJQUFJLE1BQU0sQ0FBQyxHQUFHLEVBQUU7QUFDMUMsY0FBTSxDQUFDLFlBQVc7QUFDZCxtQkFBTyxNQUFNLENBQUM7U0FDakIsQ0FBQyxDQUFDOztLQUVOLE1BQU0sSUFBRyxPQUFPLE1BQU0sS0FBSyxXQUFXLElBQUksTUFBTSxDQUFDLE9BQU8sRUFBRTtBQUN2RCxrQkFBTSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7O1NBRTNCLE1BQU07QUFDSCxzQkFBTSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7YUFDMUI7Q0FFQSxDQUFBLENBQUUsTUFBTSxDQUFDLENBQUM7Ozs7Ozs7QUNobkVYLE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUM7Ozs7O0FDRjlDLE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRyxVQUFTLFFBQVEsRUFBRTtBQUM1QyxNQUFJLFFBQVEsQ0FBQyxVQUFVLEtBQUssVUFBVSxFQUFFO0FBQ3RDLGNBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7R0FDekIsTUFBTTtBQUNMLFVBQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDO0dBQ2xEO0NBQ0YsQ0FBQzs7QUFFRixPQUFPLENBQUMsaUJBQWlCLEdBQUcsVUFBUyxTQUFTLEVBQUU7QUFDOUMsTUFBSSxXQUFXLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUM7QUFDbEQsTUFBSSxXQUFXLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQztBQUNwRCxNQUFJLGVBQWUsSUFBRyxZQUFZLElBQUksUUFBUSxDQUFDLGVBQWUsQ0FBQSxDQUFDOztBQUUvRCxNQUFJLEdBQUcsQ0FBQztBQUNSLE1BQUksV0FBVyxFQUFFO0FBQ2YsT0FBRyxHQUFHLE1BQU0sQ0FBQztHQUNkLE1BQU0sSUFBSSxXQUFXLEVBQUU7QUFDdEIsT0FBRyxHQUFHLE1BQU0sQ0FBQztHQUNkLE1BQU0sSUFBSSxlQUFlLEVBQUU7QUFDMUIsT0FBRyxHQUFHLFVBQVUsQ0FBQztHQUNsQjtBQUNELE1BQUksR0FBRyxJQUFJLFNBQVMsQ0FBQyxTQUFTLENBQUMsRUFBRTtBQUMvQixXQUFPLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztHQUNsQztDQUNGLENBQUM7O0FBRUYsSUFBSSxRQUFRLEdBQUcsU0FBWCxRQUFRLENBQVksT0FBTyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUU7OztBQUduRCxNQUFJLFdBQVcsR0FBRyxFQUFFLENBQUM7O0FBRXJCLE1BQUksU0FBUyxHQUFHLFNBQVosU0FBUyxDQUFhLElBQUksRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFO0FBQ2xELFdBQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ3BELGVBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDO0dBQzNELENBQUM7O0FBRUYsTUFBSSxXQUFXLEdBQUcsU0FBZCxXQUFXLENBQWEsSUFBSSxFQUFFO0FBQ2hDLFFBQUksU0FBUyxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNsQyxRQUFJLFNBQVMsRUFBRTtBQUNiLGFBQU8sQ0FBQyxtQkFBbUIsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUMvRCxhQUFPLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUMxQjtHQUNGLENBQUM7OztBQUdGLFdBQVMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDOzs7QUFHdkMsTUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ3RELE1BQUksVUFBVSxFQUFFO0FBQ2QsYUFBUyxDQUFDLE9BQU8sRUFBRSxVQUFVLEVBQUUsVUFBUyxDQUFDLEVBQUU7OztBQUd6QyxPQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDbkIsaUJBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNyQixhQUFPLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztLQUN2QixDQUFDLENBQUM7R0FDSjs7O0FBR0QsU0FBTyxZQUFZO0FBQ2pCLGVBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNyQixlQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7R0FDdEIsQ0FBQztDQUNILENBQUM7O0FBRUYsT0FBTyxDQUFDLHNCQUFzQixHQUFHLFVBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUMxRCxTQUFPLFFBQVEsQ0FBQyxPQUFPLEVBQUUsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0NBQ2hELENBQUM7O0FBRUYsT0FBTyxDQUFDLG9CQUFvQixHQUFHLFVBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN4RCxTQUFPLFFBQVEsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0NBQzlDLENBQUM7O0FBRUYsT0FBTyxDQUFDLHNCQUFzQixHQUFHLFVBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUMxRCxTQUFPLFFBQVEsQ0FBQyxPQUFPLEVBQUUsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0NBQ2hELENBQUM7O0FBRUYsT0FBTyxDQUFDLGtCQUFrQixHQUFHLFVBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN0RCxTQUFPLFFBQVEsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0NBQzVDLENBQUM7OztBQUdGLElBQUksU0FBUyxHQUFHOztBQUVkLE9BQUssRUFBRTtBQUNMLFlBQVEsRUFBRSxZQUFZO0FBQ3RCLFFBQUksRUFBRSxlQUFlO0FBQ3JCLFFBQUksRUFBRSxhQUFhO0dBQ3BCO0FBQ0QsV0FBUyxFQUFFO0FBQ1QsWUFBUSxFQUFFLFlBQVk7QUFDdEIsUUFBSSxFQUFFLGVBQWU7QUFDckIsUUFBSSxFQUFFLGFBQWE7R0FDcEI7QUFDRCxTQUFPLEVBQUU7QUFDUCxZQUFRLEVBQUUsVUFBVTtBQUNwQixRQUFJLEVBQUUsYUFBYTtBQUNuQixRQUFJLEVBQUUsV0FBVztHQUNsQjtBQUNELFdBQVMsRUFBRTtBQUNULFlBQVEsRUFBRSxXQUFXO0FBQ3JCLFFBQUksRUFBRSxlQUFlO0FBQ3JCLFFBQUksRUFBRSxhQUFhO0dBQ3BCO0NBQ0YsQ0FBQzs7QUFFRixPQUFPLENBQUMsUUFBUSxHQUFHLFlBQVc7QUFDNUIsTUFBSSxHQUFHLEdBQUcsbURBQW1ELENBQUM7QUFDOUQsU0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUM7Q0FDN0MsQ0FBQzs7QUFFRixPQUFPLENBQUMsY0FBYyxHQUFHLFlBQVc7QUFDbEMsTUFBSSxHQUFHLEdBQUcsYUFBYSxDQUFDO0FBQ3hCLFNBQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0NBQzdDLENBQUM7O0FBRUYsT0FBTyxDQUFDLFNBQVMsR0FBRyxZQUFXO0FBQzdCLE1BQUksR0FBRyxHQUFHLFNBQVMsQ0FBQztBQUNwQixTQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQztDQUM3QyxDQUFDOztBQUVGLE9BQU8sQ0FBQyxLQUFLLEdBQUcsWUFBVztBQUN6QixNQUFJLEdBQUcsR0FBRyxnQkFBZ0IsQ0FBQztBQUMzQixTQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQztDQUM3QyxDQUFDOztBQUVGLE9BQU8sQ0FBQyxNQUFNLEdBQUcsWUFBVztBQUMxQixNQUFJLEdBQUcsR0FBRyxPQUFPLENBQUM7QUFDbEIsU0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUM7Q0FDN0MsQ0FBQzs7Ozs7Ozs7OztBQzNIRixZQUFZLENBQUM7O0FBRWIsSUFBSSxjQUFjLEdBQUcsTUFBTSxDQUFDLE9BQU8sR0FBRyxZQUFZOzs7OztBQUtoRCxNQUFJLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQzs7Ozs7O0FBTXBCLE1BQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDOzs7Ozs7O0FBT3ZCLE1BQUksQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDO0NBQ3ZCLENBQUM7Ozs7Ozs7O0FBUUYsY0FBYyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsVUFBVSxPQUFPLEVBQUU7QUFDakQsTUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFO0FBQzdDLFFBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDdkIsUUFBSSxDQUFDLGFBQWEsSUFBSSxDQUFDLENBQUM7R0FDekI7QUFDRCxNQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUM3QixNQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDO0NBQzVDLENBQUM7Ozs7Ozs7O0FBUUYsY0FBYyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsVUFBVSxZQUFZLEVBQUU7QUFDeEQsTUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLFlBQVksQ0FBQyxDQUFDOztBQUVyRCxNQUFJLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxFQUFFO0FBQzFCLFFBQUksQ0FBQyxhQUFhLElBQUksQ0FBQyxDQUFDO0dBQ3pCO0FBQ0QsTUFBSSxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLFdBQVcsRUFBRTtBQUM3RCxXQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0dBQzNDO0FBQ0QsU0FBTyxZQUFZLENBQUM7Q0FDckIsQ0FBQzs7Ozs7Ozs7QUFRRixjQUFjLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxVQUFVLFlBQVksRUFBRTtBQUMzRCxNQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsWUFBWSxDQUFDLENBQUM7O0FBRXJELE1BQUksSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRTtBQUM5QyxRQUFJLENBQUMsYUFBYSxJQUFJLENBQUMsQ0FBQztHQUN6QjtBQUNELE1BQUksSUFBSSxDQUFDLGFBQWEsS0FBSyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sSUFDNUMsWUFBWSxLQUFLLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUMsRUFBRTtBQUMzRCxXQUFPLEVBQUUsQ0FBQztHQUNYO0FBQ0QsTUFBSSxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLFdBQVcsRUFBRTtBQUM3RCxXQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0dBQzNDO0FBQ0QsU0FBTyxZQUFZLENBQUM7Q0FDckIsQ0FBQzs7Ozs7Ozs7O0FBU0YsY0FBYyxDQUFDLFNBQVMsQ0FBQyxhQUFhLEdBQUcsVUFBVSxLQUFLLEVBQUUsUUFBUSxFQUFFO0FBQ2xFLE1BQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsS0FBSyxTQUFTLEVBQUU7QUFDdkMsUUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsR0FBRyxRQUFRLENBQUM7R0FDbEM7Q0FDRixDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIEZ1bmN0aW9ucyBmb3IgY2hlY2tpbmcgcmVxdWlyZWQgYmxvY2tzLlxuXG4vKipcbiAqIEdlbmVyYXRlIGEgcmVxdWlyZWQgYmxvY2tzIGRpY3Rpb25hcnkgZm9yIGEgY2FsbCB0byBhIHByb2NlZHVyZSB0aGF0IGRvZXNcbiAqIG5vdCBoYXZlIGEgcmV0dXJuIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb2NlZHVyZSBiZWluZyBjYWxsZWQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgcmVxdWlyZWQgYmxvY2tzIGRpY3Rpb25hcnkgYWJsZSB0byBjaGVjayBmb3IgYW5kXG4gKiAgICAgZ2VuZXJhdGUgdGhlIHNwZWNpZmllZCBibG9jay5cbiAqL1xuZXhwb3J0cy5jYWxsID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4ge1xuICAgIHRlc3Q6IGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgICByZXR1cm4gYmxvY2sudHlwZSA9PSAncHJvY2VkdXJlc19jYWxsbm9yZXR1cm4nICYmXG4gICAgICAgICAgYmxvY2suZ2V0VGl0bGVWYWx1ZSgnTkFNRScpLnRvTG93ZXJDYXNlKCkgPT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH0sXG4gICAgdHlwZTogJ3Byb2NlZHVyZXNfY2FsbG5vcmV0dXJuJyxcbiAgICB0aXRsZXM6IHsnTkFNRSc6IG5hbWV9XG4gIH07XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgcmVxdWlyZWQgYmxvY2tzIGRpY3Rpb25hcnkgZm9yIGEgY2FsbCB0byBhIHByb2NlZHVyZSB3aXRoIGFcbiAqIHNpbmdsZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jX25hbWUgVGhlIG5hbWUgb2YgdGhlIHByb2NlZHVyZSBiZWluZyBjYWxsZWQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgcmVxdWlyZWQgYmxvY2tzIGRpY3Rpb25hcnkgYWJsZSB0byBjaGVjayBmb3IgYW5kXG4gKiAgICAgZ2VuZXJhdGUgdGhlIHNwZWNpZmllZCBibG9jay5cbiAqL1xuZXhwb3J0cy5jYWxsV2l0aEFyZyA9IGZ1bmN0aW9uKGZ1bmNfbmFtZSwgYXJnX25hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICB0ZXN0OiBmdW5jdGlvbihibG9jaykge1xuICAgICAgcmV0dXJuIGJsb2NrLnR5cGUgPT0gJ3Byb2NlZHVyZXNfY2FsbG5vcmV0dXJuJyAmJlxuICAgICAgICAgIGJsb2NrLmdldFRpdGxlVmFsdWUoJ05BTUUnKS50b0xvd2VyQ2FzZSgpID09IGZ1bmNfbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH0sXG4gICAgdHlwZTogJ3Byb2NlZHVyZXNfY2FsbG5vcmV0dXJuJyxcbiAgICBleHRyYTogJzxtdXRhdGlvbiBuYW1lPVwiJyArIGZ1bmNfbmFtZSArICdcIj48YXJnIG5hbWU9XCInICsgYXJnX25hbWUgK1xuICAgICAgICAnXCI+PC9hcmc+PC9tdXRhdGlvbj4nXG4gIH07XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgcmVxdWlyZWQgYmxvY2tzIGRpY3Rpb25hcnkgZm9yIHRoZSBkZWZpbml0aW9uIG9mIGEgcHJvY2VkdXJlXG4gKiB0aGF0IGRvZXMgbm90IGhhdmUgYSByZXR1cm4gdmFsdWUuICBUaGlzIGRvZXMgbm90IGNoZWNrIGlmIGFueSBhcmd1bWVudHNcbiAqIGFyZSBkZWZpbmVkIGZvciB0aGUgcHJvY2VkdXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb2NlZHVyZSBiZWluZyBkZWZpbmVkLlxuICogQHJldHVybiB7T2JqZWN0fSBBIHJlcXVpcmVkIGJsb2NrcyBkaWN0aW9uYXJ5IGFibGUgdG8gY2hlY2sgZm9yIGFuZFxuICogICAgIGdlbmVyYXRlIHRoZSBzcGVjaWZpZWQgYmxvY2suXG4gKi9cbmV4cG9ydHMuZGVmaW5lID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4ge1xuICAgIHRlc3Q6IGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgICByZXR1cm4gYmxvY2sudHlwZSA9PSAncHJvY2VkdXJlc19kZWZub3JldHVybicgJiZcbiAgICAgICAgICBibG9jay5nZXRUaXRsZVZhbHVlKCdOQU1FJykudG9Mb3dlckNhc2UoKSA9PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfSxcbiAgICB0eXBlOiAncHJvY2VkdXJlc19kZWZub3JldHVybicsXG4gICAgdGl0bGVzOiB7J05BTUUnOiBuYW1lfVxuICB9O1xufTtcbiIsIi8qXHJcbiAqIGNhbnZnLmpzIC0gSmF2YXNjcmlwdCBTVkcgcGFyc2VyIGFuZCByZW5kZXJlciBvbiBDYW52YXNcclxuICogTUlUIExpY2Vuc2VkXHJcbiAqIEdhYmUgTGVybmVyIChnYWJlbGVybmVyQGdtYWlsLmNvbSlcclxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2NhbnZnL1xyXG4gKlxyXG4gKiBSZXF1aXJlczogcmdiY29sb3IuanMgLSBodHRwOi8vd3d3LnBocGllZC5jb20vcmdiLWNvbG9yLXBhcnNlci1pbi1qYXZhc2NyaXB0L1xyXG4gKi9cclxuIChmdW5jdGlvbiAoIGdsb2JhbCwgZmFjdG9yeSApIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHQvLyBleHBvcnQgYXMgQU1ELi4uXHJcblx0aWYgKCB0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kICkge1xyXG5cdFx0ZGVmaW5lKCdjYW52Z01vZHVsZScsIFsgJ3JnYmNvbG9yJywgJ3N0YWNrYmx1cicgXSwgZmFjdG9yeSApO1xyXG5cdH1cclxuXHJcblx0Ly8gLi4ub3IgYXMgYnJvd3NlcmlmeVxyXG5cdGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSggJ3JnYmNvbG9yJyApLCByZXF1aXJlKCAnc3RhY2tibHVyJyApICk7XHJcblx0fVxyXG5cclxuXHRnbG9iYWwuY2FudmcgPSBmYWN0b3J5KCBnbG9iYWwuUkdCQ29sb3IsIGdsb2JhbC5zdGFja0JsdXIgKTtcclxuXHJcbn0oIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24gKCBSR0JDb2xvciwgc3RhY2tCbHVyICkge1xyXG5cclxuXHQvLyBjYW52Zyh0YXJnZXQsIHMpXHJcblx0Ly8gZW1wdHkgcGFyYW1ldGVyczogcmVwbGFjZSBhbGwgJ3N2ZycgZWxlbWVudHMgb24gcGFnZSB3aXRoICdjYW52YXMnIGVsZW1lbnRzXHJcblx0Ly8gdGFyZ2V0OiBjYW52YXMgZWxlbWVudCBvciB0aGUgaWQgb2YgYSBjYW52YXMgZWxlbWVudFxyXG5cdC8vIHM6IHN2ZyBzdHJpbmcsIHVybCB0byBzdmcgZmlsZSwgb3IgeG1sIGRvY3VtZW50XHJcblx0Ly8gb3B0czogb3B0aW9uYWwgaGFzaCBvZiBvcHRpb25zXHJcblx0Ly9cdFx0IGlnbm9yZU1vdXNlOiB0cnVlID0+IGlnbm9yZSBtb3VzZSBldmVudHNcclxuXHQvL1x0XHQgaWdub3JlQW5pbWF0aW9uOiB0cnVlID0+IGlnbm9yZSBhbmltYXRpb25zXHJcblx0Ly9cdFx0IGlnbm9yZURpbWVuc2lvbnM6IHRydWUgPT4gZG9lcyBub3QgdHJ5IHRvIHJlc2l6ZSBjYW52YXNcclxuXHQvL1x0XHQgaWdub3JlQ2xlYXI6IHRydWUgPT4gZG9lcyBub3QgY2xlYXIgY2FudmFzXHJcblx0Ly9cdFx0IG9mZnNldFg6IGludCA9PiBkcmF3cyBhdCBhIHggb2Zmc2V0XHJcblx0Ly9cdFx0IG9mZnNldFk6IGludCA9PiBkcmF3cyBhdCBhIHkgb2Zmc2V0XHJcblx0Ly9cdFx0IHNjYWxlV2lkdGg6IGludCA9PiBzY2FsZXMgaG9yaXpvbnRhbGx5IHRvIHdpZHRoXHJcblx0Ly9cdFx0IHNjYWxlSGVpZ2h0OiBpbnQgPT4gc2NhbGVzIHZlcnRpY2FsbHkgdG8gaGVpZ2h0XHJcblx0Ly9cdFx0IHJlbmRlckNhbGxiYWNrOiBmdW5jdGlvbiA9PiB3aWxsIGNhbGwgdGhlIGZ1bmN0aW9uIGFmdGVyIHRoZSBmaXJzdCByZW5kZXIgaXMgY29tcGxldGVkXHJcblx0Ly9cdFx0IGZvcmNlUmVkcmF3OiBmdW5jdGlvbiA9PiB3aWxsIGNhbGwgdGhlIGZ1bmN0aW9uIG9uIGV2ZXJ5IGZyYW1lLCBpZiBpdCByZXR1cm5zIHRydWUsIHdpbGwgcmVkcmF3XHJcblx0dmFyIGNhbnZnID0gZnVuY3Rpb24gKHRhcmdldCwgcywgb3B0cykge1xyXG5cdFx0Ly8gbm8gcGFyYW1ldGVyc1xyXG5cdFx0aWYgKHRhcmdldCA9PSBudWxsICYmIHMgPT0gbnVsbCAmJiBvcHRzID09IG51bGwpIHtcclxuXHRcdFx0dmFyIHN2Z1RhZ3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdmcnKTtcclxuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPHN2Z1RhZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgc3ZnVGFnID0gc3ZnVGFnc1tpXTtcclxuXHRcdFx0XHR2YXIgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG5cdFx0XHRcdGMud2lkdGggPSBzdmdUYWcuY2xpZW50V2lkdGg7XHJcblx0XHRcdFx0Yy5oZWlnaHQgPSBzdmdUYWcuY2xpZW50SGVpZ2h0O1xyXG5cdFx0XHRcdHN2Z1RhZy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjLCBzdmdUYWcpO1xyXG5cdFx0XHRcdHN2Z1RhZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN2Z1RhZyk7XHJcblx0XHRcdFx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0XHRcdGRpdi5hcHBlbmRDaGlsZChzdmdUYWcpO1xyXG5cdFx0XHRcdGNhbnZnKGMsIGRpdi5pbm5lckhUTUwpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHlwZW9mIHRhcmdldCA9PSAnc3RyaW5nJykge1xyXG5cdFx0XHR0YXJnZXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YXJnZXQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHN0b3JlIGNsYXNzIG9uIGNhbnZhc1xyXG5cdFx0aWYgKHRhcmdldC5zdmcgIT0gbnVsbCkgdGFyZ2V0LnN2Zy5zdG9wKCk7XHJcblx0XHR2YXIgc3ZnID0gYnVpbGQob3B0cyB8fCB7fSk7XHJcblx0XHQvLyBvbiBpLmUuIDggZm9yIGZsYXNoIGNhbnZhcywgd2UgY2FuJ3QgYXNzaWduIHRoZSBwcm9wZXJ0eSBzbyBjaGVjayBmb3IgaXRcclxuXHRcdGlmICghKHRhcmdldC5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmIHRhcmdldC5jaGlsZE5vZGVzWzBdLm5vZGVOYW1lID09ICdPQkpFQ1QnKSkgdGFyZ2V0LnN2ZyA9IHN2ZztcclxuXHJcblx0XHR2YXIgY3R4ID0gdGFyZ2V0LmdldENvbnRleHQoJzJkJyk7XHJcblx0XHRpZiAodHlwZW9mIHMuZG9jdW1lbnRFbGVtZW50ICE9ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdC8vIGxvYWQgZnJvbSB4bWwgZG9jXHJcblx0XHRcdHN2Zy5sb2FkWG1sRG9jKGN0eCwgcyk7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmIChzLnN1YnN0cigwLDEpID09ICc8Jykge1xyXG5cdFx0XHQvLyBsb2FkIGZyb20geG1sIHN0cmluZ1xyXG5cdFx0XHRzdmcubG9hZFhtbChjdHgsIHMpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdC8vIGxvYWQgZnJvbSB1cmxcclxuXHRcdFx0c3ZnLmxvYWQoY3R4LCBzKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC5tYXRjaGVzXHJcblx0dmFyIG1hdGNoZXNTZWxlY3RvcjtcclxuXHRpZiAodHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgIT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdG1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKG5vZGUsIHNlbGVjdG9yKSB7XHJcblx0XHRcdHJldHVybiBub2RlLm1hdGNoZXMoc2VsZWN0b3IpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2UgaWYgKHR5cGVvZiBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgIT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdG1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKG5vZGUsIHNlbGVjdG9yKSB7XHJcblx0XHRcdHJldHVybiBub2RlLndlYmtpdE1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSBpZiAodHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciAhPSAndW5kZWZpbmVkJykge1xyXG5cdFx0bWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24obm9kZSwgc2VsZWN0b3IpIHtcclxuXHRcdFx0cmV0dXJuIG5vZGUubW96TWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcclxuXHRcdH07XHJcblx0fSBlbHNlIGlmICh0eXBlb2YgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgIT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdG1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKG5vZGUsIHNlbGVjdG9yKSB7XHJcblx0XHRcdHJldHVybiBub2RlLm1zTWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcclxuXHRcdH07XHJcblx0fSBlbHNlIGlmICh0eXBlb2YgRWxlbWVudC5wcm90b3R5cGUub01hdGNoZXNTZWxlY3RvciAhPSAndW5kZWZpbmVkJykge1xyXG5cdFx0bWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24obm9kZSwgc2VsZWN0b3IpIHtcclxuXHRcdFx0cmV0dXJuIG5vZGUub01hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyByZXF1aXJlcyBTaXp6bGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3dpa2kvU2l6emxlLURvY3VtZW50YXRpb25cclxuXHRcdC8vIG9yIGpRdWVyeTogaHR0cDovL2pxdWVyeS5jb20vZG93bmxvYWQvXHJcblx0XHQvLyBvciBaZXB0bzogaHR0cDovL3plcHRvanMuY29tLyNcclxuXHRcdC8vIHdpdGhvdXQgaXQsIHRoaXMgaXMgYSBSZWZlcmVuY2VFcnJvclxyXG5cclxuXHRcdGlmICh0eXBlb2YgalF1ZXJ5ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBaZXB0byA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRtYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiAobm9kZSwgc2VsZWN0b3IpIHtcclxuXHRcdFx0XHRyZXR1cm4gJChub2RlKS5pcyhzZWxlY3Rvcik7XHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBtYXRjaGVzU2VsZWN0b3IgPT09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdG1hdGNoZXNTZWxlY3RvciA9IFNpenpsZS5tYXRjaGVzU2VsZWN0b3I7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBzbGlnaHRseSBtb2RpZmllZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9rZWVnYW5zdHJlZXQvc3BlY2lmaWNpdHkvYmxvYi9tYXN0ZXIvc3BlY2lmaWNpdHkuanNcclxuXHR2YXIgYXR0cmlidXRlUmVnZXggPSAvKFxcW1teXFxdXStcXF0pL2c7XHJcblx0dmFyIGlkUmVnZXggPSAvKCNbXlxcc1xcKz5+XFwuXFxbOl0rKS9nO1xyXG5cdHZhciBjbGFzc1JlZ2V4ID0gLyhcXC5bXlxcc1xcKz5+XFwuXFxbOl0rKS9nO1xyXG5cdHZhciBwc2V1ZG9FbGVtZW50UmVnZXggPSAvKDo6W15cXHNcXCs+flxcLlxcWzpdK3w6Zmlyc3QtbGluZXw6Zmlyc3QtbGV0dGVyfDpiZWZvcmV8OmFmdGVyKS9naTtcclxuXHR2YXIgcHNldWRvQ2xhc3NXaXRoQnJhY2tldHNSZWdleCA9IC8oOltcXHctXStcXChbXlxcKV0qXFwpKS9naTtcclxuXHR2YXIgcHNldWRvQ2xhc3NSZWdleCA9IC8oOlteXFxzXFwrPn5cXC5cXFs6XSspL2c7XHJcblx0dmFyIGVsZW1lbnRSZWdleCA9IC8oW15cXHNcXCs+flxcLlxcWzpdKykvZztcclxuXHRmdW5jdGlvbiBnZXRTZWxlY3RvclNwZWNpZmljaXR5KHNlbGVjdG9yKSB7XHJcblx0XHR2YXIgdHlwZUNvdW50ID0gWzAsIDAsIDBdO1xyXG5cdFx0dmFyIGZpbmRNYXRjaCA9IGZ1bmN0aW9uKHJlZ2V4LCB0eXBlKSB7XHJcblx0XHRcdHZhciBtYXRjaGVzID0gc2VsZWN0b3IubWF0Y2gocmVnZXgpO1xyXG5cdFx0XHRpZiAobWF0Y2hlcyA9PSBudWxsKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHR5cGVDb3VudFt0eXBlXSArPSBtYXRjaGVzLmxlbmd0aDtcclxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKHJlZ2V4LCAnICcpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoLzpub3RcXCgoW15cXCldKilcXCkvZywgJyAgICAgJDEgJyk7XHJcblx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoL3tbXl0qL2dtLCAnICcpO1xyXG5cdFx0ZmluZE1hdGNoKGF0dHJpYnV0ZVJlZ2V4LCAxKTtcclxuXHRcdGZpbmRNYXRjaChpZFJlZ2V4LCAwKTtcclxuXHRcdGZpbmRNYXRjaChjbGFzc1JlZ2V4LCAxKTtcclxuXHRcdGZpbmRNYXRjaChwc2V1ZG9FbGVtZW50UmVnZXgsIDIpO1xyXG5cdFx0ZmluZE1hdGNoKHBzZXVkb0NsYXNzV2l0aEJyYWNrZXRzUmVnZXgsIDEpO1xyXG5cdFx0ZmluZE1hdGNoKHBzZXVkb0NsYXNzUmVnZXgsIDEpO1xyXG5cdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKC9bXFwqXFxzXFwrPn5dL2csICcgJyk7XHJcblx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoL1sjXFwuXS9nLCAnICcpO1xyXG5cdFx0ZmluZE1hdGNoKGVsZW1lbnRSZWdleCwgMik7XHJcblx0XHRyZXR1cm4gdHlwZUNvdW50LmpvaW4oJycpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gYnVpbGQob3B0cykge1xyXG5cdFx0dmFyIHN2ZyA9IHsgb3B0czogb3B0cyB9O1xyXG5cclxuXHRcdHN2Zy5GUkFNRVJBVEUgPSAzMDtcclxuXHRcdHN2Zy5NQVhfVklSVFVBTF9QSVhFTFMgPSAzMDAwMDtcclxuXHJcblx0XHRzdmcubG9nID0gZnVuY3Rpb24obXNnKSB7fTtcclxuXHRcdGlmIChzdmcub3B0c1snbG9nJ10gPT0gdHJ1ZSAmJiB0eXBlb2YgY29uc29sZSAhPSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRzdmcubG9nID0gZnVuY3Rpb24obXNnKSB7IGNvbnNvbGUubG9nKG1zZyk7IH07XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGdsb2JhbHNcclxuXHRcdHN2Zy5pbml0ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdHZhciB1bmlxdWVJZCA9IDA7XHJcblx0XHRcdHN2Zy5VbmlxdWVJZCA9IGZ1bmN0aW9uICgpIHsgdW5pcXVlSWQrKzsgcmV0dXJuICdjYW52ZycgKyB1bmlxdWVJZDtcdH07XHJcblx0XHRcdHN2Zy5EZWZpbml0aW9ucyA9IHt9O1xyXG5cdFx0XHRzdmcuU3R5bGVzID0ge307XHJcblx0XHRcdHN2Zy5TdHlsZXNTcGVjaWZpY2l0eSA9IHt9O1xyXG5cdFx0XHRzdmcuQW5pbWF0aW9ucyA9IFtdO1xyXG5cdFx0XHRzdmcuSW1hZ2VzID0gW107XHJcblx0XHRcdHN2Zy5jdHggPSBjdHg7XHJcblx0XHRcdHN2Zy5WaWV3UG9ydCA9IG5ldyAoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHRoaXMudmlld1BvcnRzID0gW107XHJcblx0XHRcdFx0dGhpcy5DbGVhciA9IGZ1bmN0aW9uKCkgeyB0aGlzLnZpZXdQb3J0cyA9IFtdOyB9XHJcblx0XHRcdFx0dGhpcy5TZXRDdXJyZW50ID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkgeyB0aGlzLnZpZXdQb3J0cy5wdXNoKHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTsgfVxyXG5cdFx0XHRcdHRoaXMuUmVtb3ZlQ3VycmVudCA9IGZ1bmN0aW9uKCkgeyB0aGlzLnZpZXdQb3J0cy5wb3AoKTsgfVxyXG5cdFx0XHRcdHRoaXMuQ3VycmVudCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy52aWV3UG9ydHNbdGhpcy52aWV3UG9ydHMubGVuZ3RoIC0gMV07IH1cclxuXHRcdFx0XHR0aGlzLndpZHRoID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLkN1cnJlbnQoKS53aWR0aDsgfVxyXG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLkN1cnJlbnQoKS5oZWlnaHQ7IH1cclxuXHRcdFx0XHR0aGlzLkNvbXB1dGVTaXplID0gZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdFx0aWYgKGQgIT0gbnVsbCAmJiB0eXBlb2YgZCA9PSAnbnVtYmVyJykgcmV0dXJuIGQ7XHJcblx0XHRcdFx0XHRpZiAoZCA9PSAneCcpIHJldHVybiB0aGlzLndpZHRoKCk7XHJcblx0XHRcdFx0XHRpZiAoZCA9PSAneScpIHJldHVybiB0aGlzLmhlaWdodCgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0aGlzLndpZHRoKCksIDIpICsgTWF0aC5wb3codGhpcy5oZWlnaHQoKSwgMikpIC8gTWF0aC5zcXJ0KDIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0XHRzdmcuaW5pdCgpO1xyXG5cclxuXHRcdC8vIGltYWdlcyBsb2FkZWRcclxuXHRcdHN2Zy5JbWFnZXNMb2FkZWQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPHN2Zy5JbWFnZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZiAoIXN2Zy5JbWFnZXNbaV0ubG9hZGVkKSByZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdHJpbVxyXG5cdFx0c3ZnLnRyaW0gPSBmdW5jdGlvbihzKSB7IHJldHVybiBzLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTsgfVxyXG5cclxuXHRcdC8vIGNvbXByZXNzIHNwYWNlc1xyXG5cdFx0c3ZnLmNvbXByZXNzU3BhY2VzID0gZnVuY3Rpb24ocykgeyByZXR1cm4gcy5yZXBsYWNlKC9bXFxzXFxyXFx0XFxuXSsvZ20sJyAnKTsgfVxyXG5cclxuXHRcdC8vIGFqYXhcclxuXHRcdHN2Zy5hamF4ID0gZnVuY3Rpb24odXJsKSB7XHJcblx0XHRcdHZhciBBSkFYO1xyXG5cdFx0XHRpZih3aW5kb3cuWE1MSHR0cFJlcXVlc3Qpe0FKQVg9bmV3IFhNTEh0dHBSZXF1ZXN0KCk7fVxyXG5cdFx0XHRlbHNle0FKQVg9bmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7fVxyXG5cdFx0XHRpZihBSkFYKXtcclxuXHRcdFx0ICAgQUpBWC5vcGVuKCdHRVQnLHVybCxmYWxzZSk7XHJcblx0XHRcdCAgIEFKQVguc2VuZChudWxsKTtcclxuXHRcdFx0ICAgcmV0dXJuIEFKQVgucmVzcG9uc2VUZXh0O1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHBhcnNlIHhtbFxyXG5cdFx0c3ZnLnBhcnNlWG1sID0gZnVuY3Rpb24oeG1sKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgV2luZG93cyAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgV2luZG93cy5EYXRhICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiBXaW5kb3dzLkRhdGEuWG1sICE9ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0dmFyIHhtbERvYyA9IG5ldyBXaW5kb3dzLkRhdGEuWG1sLkRvbS5YbWxEb2N1bWVudCgpO1xyXG5cdFx0XHRcdHZhciBzZXR0aW5ncyA9IG5ldyBXaW5kb3dzLkRhdGEuWG1sLkRvbS5YbWxMb2FkU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRzZXR0aW5ncy5wcm9oaWJpdER0ZCA9IGZhbHNlO1xyXG5cdFx0XHRcdHhtbERvYy5sb2FkWG1sKHhtbCwgc2V0dGluZ3MpO1xyXG5cdFx0XHRcdHJldHVybiB4bWxEb2M7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAod2luZG93LkRPTVBhcnNlcilcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XHJcblx0XHRcdFx0cmV0dXJuIHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sLCAndGV4dC94bWwnKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdHtcclxuXHRcdFx0XHR4bWwgPSB4bWwucmVwbGFjZSgvPCFET0NUWVBFIHN2Z1tePl0qPi8sICcnKTtcclxuXHRcdFx0XHR2YXIgeG1sRG9jID0gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxET00nKTtcclxuXHRcdFx0XHR4bWxEb2MuYXN5bmMgPSAnZmFsc2UnO1xyXG5cdFx0XHRcdHhtbERvYy5sb2FkWE1MKHhtbCk7XHJcblx0XHRcdFx0cmV0dXJuIHhtbERvYztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHN2Zy5Qcm9wZXJ0eSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcblx0XHRcdHRoaXMubmFtZSA9IG5hbWU7XHJcblx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHRcdH1cclxuXHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdmcuUHJvcGVydHkucHJvdG90eXBlLmhhc1ZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuICh0aGlzLnZhbHVlICE9IG51bGwgJiYgdGhpcy52YWx1ZSAhPT0gJycpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyByZXR1cm4gdGhlIG51bWVyaWNhbCB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcclxuXHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS5udW1WYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmICghdGhpcy5oYXNWYWx1ZSgpKSByZXR1cm4gMDtcclxuXHJcblx0XHRcdFx0dmFyIG4gPSBwYXJzZUZsb2F0KHRoaXMudmFsdWUpO1xyXG5cdFx0XHRcdGlmICgodGhpcy52YWx1ZSArICcnKS5tYXRjaCgvJSQvKSkge1xyXG5cdFx0XHRcdFx0biA9IG4gLyAxMDAuMDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIG47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUudmFsdWVPckRlZmF1bHQgPSBmdW5jdGlvbihkZWYpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5oYXNWYWx1ZSgpKSByZXR1cm4gdGhpcy52YWx1ZTtcclxuXHRcdFx0XHRyZXR1cm4gZGVmO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdmcuUHJvcGVydHkucHJvdG90eXBlLm51bVZhbHVlT3JEZWZhdWx0ID0gZnVuY3Rpb24oZGVmKSB7XHJcblx0XHRcdFx0aWYgKHRoaXMuaGFzVmFsdWUoKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKTtcclxuXHRcdFx0XHRyZXR1cm4gZGVmO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBjb2xvciBleHRlbnNpb25zXHJcblx0XHRcdFx0Ly8gYXVnbWVudCB0aGUgY3VycmVudCBjb2xvciB2YWx1ZSB3aXRoIHRoZSBvcGFjaXR5XHJcblx0XHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS5hZGRPcGFjaXR5ID0gZnVuY3Rpb24ob3BhY2l0eVByb3ApIHtcclxuXHRcdFx0XHRcdHZhciBuZXdWYWx1ZSA9IHRoaXMudmFsdWU7XHJcblx0XHRcdFx0XHRpZiAob3BhY2l0eVByb3AudmFsdWUgIT0gbnVsbCAmJiBvcGFjaXR5UHJvcC52YWx1ZSAhPSAnJyAmJiB0eXBlb2YgdGhpcy52YWx1ZSA9PSAnc3RyaW5nJykgeyAvLyBjYW4gb25seSBhZGQgb3BhY2l0eSB0byBjb2xvcnMsIG5vdCBwYXR0ZXJuc1xyXG5cdFx0XHRcdFx0XHR2YXIgY29sb3IgPSBuZXcgUkdCQ29sb3IodGhpcy52YWx1ZSk7XHJcblx0XHRcdFx0XHRcdGlmIChjb2xvci5vaykge1xyXG5cdFx0XHRcdFx0XHRcdG5ld1ZhbHVlID0gJ3JnYmEoJyArIGNvbG9yLnIgKyAnLCAnICsgY29sb3IuZyArICcsICcgKyBjb2xvci5iICsgJywgJyArIG9wYWNpdHlQcm9wLm51bVZhbHVlKCkgKyAnKSc7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBuZXcgc3ZnLlByb3BlcnR5KHRoaXMubmFtZSwgbmV3VmFsdWUpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGRlZmluaXRpb24gZXh0ZW5zaW9uc1xyXG5cdFx0XHRcdC8vIGdldCB0aGUgZGVmaW5pdGlvbiBmcm9tIHRoZSBkZWZpbml0aW9ucyB0YWJsZVxyXG5cdFx0XHRcdHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUuZ2V0RGVmaW5pdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0dmFyIG5hbWUgPSB0aGlzLnZhbHVlLm1hdGNoKC8jKFteXFwpJ1wiXSspLyk7XHJcblx0XHRcdFx0XHRpZiAobmFtZSkgeyBuYW1lID0gbmFtZVsxXTsgfVxyXG5cdFx0XHRcdFx0aWYgKCFuYW1lKSB7IG5hbWUgPSB0aGlzLnZhbHVlOyB9XHJcblx0XHRcdFx0XHRyZXR1cm4gc3ZnLkRlZmluaXRpb25zW25hbWVdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS5pc1VybERlZmluaXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0aGlzLnZhbHVlLmluZGV4T2YoJ3VybCgnKSA9PSAwXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzdmcuUHJvcGVydHkucHJvdG90eXBlLmdldEZpbGxTdHlsZURlZmluaXRpb24gPSBmdW5jdGlvbihlLCBvcGFjaXR5UHJvcCkge1xyXG5cdFx0XHRcdFx0dmFyIGRlZiA9IHRoaXMuZ2V0RGVmaW5pdGlvbigpO1xyXG5cclxuXHRcdFx0XHRcdC8vIGdyYWRpZW50XHJcblx0XHRcdFx0XHRpZiAoZGVmICE9IG51bGwgJiYgZGVmLmNyZWF0ZUdyYWRpZW50KSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBkZWYuY3JlYXRlR3JhZGllbnQoc3ZnLmN0eCwgZSwgb3BhY2l0eVByb3ApO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIHBhdHRlcm5cclxuXHRcdFx0XHRcdGlmIChkZWYgIT0gbnVsbCAmJiBkZWYuY3JlYXRlUGF0dGVybikge1xyXG5cdFx0XHRcdFx0XHRpZiAoZGVmLmdldEhyZWZBdHRyaWJ1dGUoKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHB0ID0gZGVmLmF0dHJpYnV0ZSgncGF0dGVyblRyYW5zZm9ybScpO1xyXG5cdFx0XHRcdFx0XHRcdGRlZiA9IGRlZi5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xyXG5cdFx0XHRcdFx0XHRcdGlmIChwdC5oYXNWYWx1ZSgpKSB7IGRlZi5hdHRyaWJ1dGUoJ3BhdHRlcm5UcmFuc2Zvcm0nLCB0cnVlKS52YWx1ZSA9IHB0LnZhbHVlOyB9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0cmV0dXJuIGRlZi5jcmVhdGVQYXR0ZXJuKHN2Zy5jdHgsIGUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGxlbmd0aCBleHRlbnNpb25zXHJcblx0XHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS5nZXREUEkgPSBmdW5jdGlvbih2aWV3UG9ydCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIDk2LjA7IC8vIFRPRE86IGNvbXB1dGU/XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzdmcuUHJvcGVydHkucHJvdG90eXBlLmdldEVNID0gZnVuY3Rpb24odmlld1BvcnQpIHtcclxuXHRcdFx0XHRcdHZhciBlbSA9IDEyO1xyXG5cclxuXHRcdFx0XHRcdHZhciBmb250U2l6ZSA9IG5ldyBzdmcuUHJvcGVydHkoJ2ZvbnRTaXplJywgc3ZnLkZvbnQuUGFyc2Uoc3ZnLmN0eC5mb250KS5mb250U2l6ZSk7XHJcblx0XHRcdFx0XHRpZiAoZm9udFNpemUuaGFzVmFsdWUoKSkgZW0gPSBmb250U2l6ZS50b1BpeGVscyh2aWV3UG9ydCk7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGVtO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS5nZXRVbml0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0dmFyIHMgPSB0aGlzLnZhbHVlKycnO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHMucmVwbGFjZSgvWzAtOVxcLlxcLV0vZywnJyk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBnZXQgdGhlIGxlbmd0aCBhcyBwaXhlbHNcclxuXHRcdFx0XHRzdmcuUHJvcGVydHkucHJvdG90eXBlLnRvUGl4ZWxzID0gZnVuY3Rpb24odmlld1BvcnQsIHByb2Nlc3NQZXJjZW50KSB7XHJcblx0XHRcdFx0XHRpZiAoIXRoaXMuaGFzVmFsdWUoKSkgcmV0dXJuIDA7XHJcblx0XHRcdFx0XHR2YXIgcyA9IHRoaXMudmFsdWUrJyc7XHJcblx0XHRcdFx0XHRpZiAocy5tYXRjaCgvZW0kLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiB0aGlzLmdldEVNKHZpZXdQb3J0KTtcclxuXHRcdFx0XHRcdGlmIChzLm1hdGNoKC9leCQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIHRoaXMuZ2V0RU0odmlld1BvcnQpIC8gMi4wO1xyXG5cdFx0XHRcdFx0aWYgKHMubWF0Y2goL3B4JC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpO1xyXG5cdFx0XHRcdFx0aWYgKHMubWF0Y2goL3B0JC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogdGhpcy5nZXREUEkodmlld1BvcnQpICogKDEuMCAvIDcyLjApO1xyXG5cdFx0XHRcdFx0aWYgKHMubWF0Y2goL3BjJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogMTU7XHJcblx0XHRcdFx0XHRpZiAocy5tYXRjaCgvY20kLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiB0aGlzLmdldERQSSh2aWV3UG9ydCkgLyAyLjU0O1xyXG5cdFx0XHRcdFx0aWYgKHMubWF0Y2goL21tJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogdGhpcy5nZXREUEkodmlld1BvcnQpIC8gMjUuNDtcclxuXHRcdFx0XHRcdGlmIChzLm1hdGNoKC9pbiQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIHRoaXMuZ2V0RFBJKHZpZXdQb3J0KTtcclxuXHRcdFx0XHRcdGlmIChzLm1hdGNoKC8lJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogc3ZnLlZpZXdQb3J0LkNvbXB1dGVTaXplKHZpZXdQb3J0KTtcclxuXHRcdFx0XHRcdHZhciBuID0gdGhpcy5udW1WYWx1ZSgpO1xyXG5cdFx0XHRcdFx0aWYgKHByb2Nlc3NQZXJjZW50ICYmIG4gPCAxLjApIHJldHVybiBuICogc3ZnLlZpZXdQb3J0LkNvbXB1dGVTaXplKHZpZXdQb3J0KTtcclxuXHRcdFx0XHRcdHJldHVybiBuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHRpbWUgZXh0ZW5zaW9uc1xyXG5cdFx0XHRcdC8vIGdldCB0aGUgdGltZSBhcyBtaWxsaXNlY29uZHNcclxuXHRcdFx0XHRzdmcuUHJvcGVydHkucHJvdG90eXBlLnRvTWlsbGlzZWNvbmRzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRpZiAoIXRoaXMuaGFzVmFsdWUoKSkgcmV0dXJuIDA7XHJcblx0XHRcdFx0XHR2YXIgcyA9IHRoaXMudmFsdWUrJyc7XHJcblx0XHRcdFx0XHRpZiAocy5tYXRjaCgvcyQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIDEwMDA7XHJcblx0XHRcdFx0XHRpZiAocy5tYXRjaCgvbXMkLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5udW1WYWx1ZSgpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGFuZ2xlIGV4dGVuc2lvbnNcclxuXHRcdFx0XHQvLyBnZXQgdGhlIGFuZ2xlIGFzIHJhZGlhbnNcclxuXHRcdFx0XHRzdmcuUHJvcGVydHkucHJvdG90eXBlLnRvUmFkaWFucyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0aWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHJldHVybiAwO1xyXG5cdFx0XHRcdFx0dmFyIHMgPSB0aGlzLnZhbHVlKycnO1xyXG5cdFx0XHRcdFx0aWYgKHMubWF0Y2goL2RlZyQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIChNYXRoLlBJIC8gMTgwLjApO1xyXG5cdFx0XHRcdFx0aWYgKHMubWF0Y2goL2dyYWQkLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiAoTWF0aC5QSSAvIDIwMC4wKTtcclxuXHRcdFx0XHRcdGlmIChzLm1hdGNoKC9yYWQkLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogKE1hdGguUEkgLyAxODAuMCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gdGV4dCBleHRlbnNpb25zXHJcblx0XHRcdFx0Ly8gZ2V0IHRoZSB0ZXh0IGJhc2VsaW5lXHJcblx0XHRcdFx0dmFyIHRleHRCYXNlbGluZU1hcHBpbmcgPSB7XHJcblx0XHRcdFx0XHQnYmFzZWxpbmUnOiAnYWxwaGFiZXRpYycsXHJcblx0XHRcdFx0XHQnYmVmb3JlLWVkZ2UnOiAndG9wJyxcclxuXHRcdFx0XHRcdCd0ZXh0LWJlZm9yZS1lZGdlJzogJ3RvcCcsXHJcblx0XHRcdFx0XHQnbWlkZGxlJzogJ21pZGRsZScsXHJcblx0XHRcdFx0XHQnY2VudHJhbCc6ICdtaWRkbGUnLFxyXG5cdFx0XHRcdFx0J2FmdGVyLWVkZ2UnOiAnYm90dG9tJyxcclxuXHRcdFx0XHRcdCd0ZXh0LWFmdGVyLWVkZ2UnOiAnYm90dG9tJyxcclxuXHRcdFx0XHRcdCdpZGVvZ3JhcGhpYyc6ICdpZGVvZ3JhcGhpYycsXHJcblx0XHRcdFx0XHQnYWxwaGFiZXRpYyc6ICdhbHBoYWJldGljJyxcclxuXHRcdFx0XHRcdCdoYW5naW5nJzogJ2hhbmdpbmcnLFxyXG5cdFx0XHRcdFx0J21hdGhlbWF0aWNhbCc6ICdhbHBoYWJldGljJ1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS50b1RleHRCYXNlbGluZSA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdGlmICghdGhpcy5oYXNWYWx1ZSgpKSByZXR1cm4gbnVsbDtcclxuXHRcdFx0XHRcdHJldHVybiB0ZXh0QmFzZWxpbmVNYXBwaW5nW3RoaXMudmFsdWVdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHQvLyBmb250c1xyXG5cdFx0c3ZnLkZvbnQgPSBuZXcgKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR0aGlzLlN0eWxlcyA9ICdub3JtYWx8aXRhbGljfG9ibGlxdWV8aW5oZXJpdCc7XHJcblx0XHRcdHRoaXMuVmFyaWFudHMgPSAnbm9ybWFsfHNtYWxsLWNhcHN8aW5oZXJpdCc7XHJcblx0XHRcdHRoaXMuV2VpZ2h0cyA9ICdub3JtYWx8Ym9sZHxib2xkZXJ8bGlnaHRlcnwxMDB8MjAwfDMwMHw0MDB8NTAwfDYwMHw3MDB8ODAwfDkwMHxpbmhlcml0JztcclxuXHJcblx0XHRcdHRoaXMuQ3JlYXRlRm9udCA9IGZ1bmN0aW9uKGZvbnRTdHlsZSwgZm9udFZhcmlhbnQsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5LCBpbmhlcml0KSB7XHJcblx0XHRcdFx0dmFyIGYgPSBpbmhlcml0ICE9IG51bGwgPyB0aGlzLlBhcnNlKGluaGVyaXQpIDogdGhpcy5DcmVhdGVGb250KCcnLCAnJywgJycsICcnLCAnJywgc3ZnLmN0eC5mb250KTtcclxuXHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0Zm9udEZhbWlseTogZm9udEZhbWlseSB8fCBmLmZvbnRGYW1pbHksXHJcblx0XHRcdFx0XHRmb250U2l6ZTogZm9udFNpemUgfHwgZi5mb250U2l6ZSxcclxuXHRcdFx0XHRcdGZvbnRTdHlsZTogZm9udFN0eWxlIHx8IGYuZm9udFN0eWxlLFxyXG5cdFx0XHRcdFx0Zm9udFdlaWdodDogZm9udFdlaWdodCB8fCBmLmZvbnRXZWlnaHQsXHJcblx0XHRcdFx0XHRmb250VmFyaWFudDogZm9udFZhcmlhbnQgfHwgZi5mb250VmFyaWFudCxcclxuXHRcdFx0XHRcdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbdGhpcy5mb250U3R5bGUsIHRoaXMuZm9udFZhcmlhbnQsIHRoaXMuZm9udFdlaWdodCwgdGhpcy5mb250U2l6ZSwgdGhpcy5mb250RmFtaWx5XS5qb2luKCcgJykgfVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cdFx0XHR0aGlzLlBhcnNlID0gZnVuY3Rpb24ocykge1xyXG5cdFx0XHRcdHZhciBmID0ge307XHJcblx0XHRcdFx0dmFyIGQgPSBzdmcudHJpbShzdmcuY29tcHJlc3NTcGFjZXMocyB8fCAnJykpLnNwbGl0KCcgJyk7XHJcblx0XHRcdFx0dmFyIHNldCA9IHsgZm9udFNpemU6IGZhbHNlLCBmb250U3R5bGU6IGZhbHNlLCBmb250V2VpZ2h0OiBmYWxzZSwgZm9udFZhcmlhbnQ6IGZhbHNlIH1cclxuXHRcdFx0XHR2YXIgZmYgPSAnJztcclxuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8ZC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0aWYgKCFzZXQuZm9udFN0eWxlICYmIHRoYXQuU3R5bGVzLmluZGV4T2YoZFtpXSkgIT0gLTEpIHsgaWYgKGRbaV0gIT0gJ2luaGVyaXQnKSBmLmZvbnRTdHlsZSA9IGRbaV07IHNldC5mb250U3R5bGUgPSB0cnVlOyB9XHJcblx0XHRcdFx0XHRlbHNlIGlmICghc2V0LmZvbnRWYXJpYW50ICYmIHRoYXQuVmFyaWFudHMuaW5kZXhPZihkW2ldKSAhPSAtMSkgeyBpZiAoZFtpXSAhPSAnaW5oZXJpdCcpIGYuZm9udFZhcmlhbnQgPSBkW2ldOyBzZXQuZm9udFN0eWxlID0gc2V0LmZvbnRWYXJpYW50ID0gdHJ1ZTtcdH1cclxuXHRcdFx0XHRcdGVsc2UgaWYgKCFzZXQuZm9udFdlaWdodCAmJiB0aGF0LldlaWdodHMuaW5kZXhPZihkW2ldKSAhPSAtMSkge1x0aWYgKGRbaV0gIT0gJ2luaGVyaXQnKSBmLmZvbnRXZWlnaHQgPSBkW2ldOyBzZXQuZm9udFN0eWxlID0gc2V0LmZvbnRWYXJpYW50ID0gc2V0LmZvbnRXZWlnaHQgPSB0cnVlOyB9XHJcblx0XHRcdFx0XHRlbHNlIGlmICghc2V0LmZvbnRTaXplKSB7IGlmIChkW2ldICE9ICdpbmhlcml0JykgZi5mb250U2l6ZSA9IGRbaV0uc3BsaXQoJy8nKVswXTsgc2V0LmZvbnRTdHlsZSA9IHNldC5mb250VmFyaWFudCA9IHNldC5mb250V2VpZ2h0ID0gc2V0LmZvbnRTaXplID0gdHJ1ZTsgfVxyXG5cdFx0XHRcdFx0ZWxzZSB7IGlmIChkW2ldICE9ICdpbmhlcml0JykgZmYgKz0gZFtpXTsgfVxyXG5cdFx0XHRcdH0gaWYgKGZmICE9ICcnKSBmLmZvbnRGYW1pbHkgPSBmZjtcclxuXHRcdFx0XHRyZXR1cm4gZjtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gcG9pbnRzIGFuZCBwYXRoc1xyXG5cdFx0c3ZnLlRvTnVtYmVyQXJyYXkgPSBmdW5jdGlvbihzKSB7XHJcblx0XHRcdHZhciBhID0gc3ZnLnRyaW0oc3ZnLmNvbXByZXNzU3BhY2VzKChzIHx8ICcnKS5yZXBsYWNlKC8sL2csICcgJykpKS5zcGxpdCgnICcpO1xyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8YS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGFbaV0gPSBwYXJzZUZsb2F0KGFbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBhO1xyXG5cdFx0fVxyXG5cdFx0c3ZnLlBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xyXG5cdFx0XHR0aGlzLnggPSB4O1xyXG5cdFx0XHR0aGlzLnkgPSB5O1xyXG5cdFx0fVxyXG5cdFx0XHRzdmcuUG9pbnQucHJvdG90eXBlLmFuZ2xlVG8gPSBmdW5jdGlvbihwKSB7XHJcblx0XHRcdFx0cmV0dXJuIE1hdGguYXRhbjIocC55IC0gdGhpcy55LCBwLnggLSB0aGlzLngpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdmcuUG9pbnQucHJvdG90eXBlLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24odikge1xyXG5cdFx0XHRcdHZhciB4cCA9IHRoaXMueCAqIHZbMF0gKyB0aGlzLnkgKiB2WzJdICsgdls0XTtcclxuXHRcdFx0XHR2YXIgeXAgPSB0aGlzLnggKiB2WzFdICsgdGhpcy55ICogdlszXSArIHZbNV07XHJcblx0XHRcdFx0dGhpcy54ID0geHA7XHJcblx0XHRcdFx0dGhpcy55ID0geXA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRzdmcuQ3JlYXRlUG9pbnQgPSBmdW5jdGlvbihzKSB7XHJcblx0XHRcdHZhciBhID0gc3ZnLlRvTnVtYmVyQXJyYXkocyk7XHJcblx0XHRcdHJldHVybiBuZXcgc3ZnLlBvaW50KGFbMF0sIGFbMV0pO1xyXG5cdFx0fVxyXG5cdFx0c3ZnLkNyZWF0ZVBhdGggPSBmdW5jdGlvbihzKSB7XHJcblx0XHRcdHZhciBhID0gc3ZnLlRvTnVtYmVyQXJyYXkocyk7XHJcblx0XHRcdHZhciBwYXRoID0gW107XHJcblx0XHRcdGZvciAodmFyIGk9MDsgaTxhLmxlbmd0aDsgaSs9Mikge1xyXG5cdFx0XHRcdHBhdGgucHVzaChuZXcgc3ZnLlBvaW50KGFbaV0sIGFbaSsxXSkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBwYXRoO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGJvdW5kaW5nIGJveFxyXG5cdFx0c3ZnLkJvdW5kaW5nQm94ID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHsgLy8gcGFzcyBpbiBpbml0aWFsIHBvaW50cyBpZiB5b3Ugd2FudFxyXG5cdFx0XHR0aGlzLngxID0gTnVtYmVyLk5hTjtcclxuXHRcdFx0dGhpcy55MSA9IE51bWJlci5OYU47XHJcblx0XHRcdHRoaXMueDIgPSBOdW1iZXIuTmFOO1xyXG5cdFx0XHR0aGlzLnkyID0gTnVtYmVyLk5hTjtcclxuXHJcblx0XHRcdHRoaXMueCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy54MTsgfVxyXG5cdFx0XHR0aGlzLnkgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMueTE7IH1cclxuXHRcdFx0dGhpcy53aWR0aCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy54MiAtIHRoaXMueDE7IH1cclxuXHRcdFx0dGhpcy5oZWlnaHQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMueTIgLSB0aGlzLnkxOyB9XHJcblxyXG5cdFx0XHR0aGlzLmFkZFBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xyXG5cdFx0XHRcdGlmICh4ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGlmIChpc05hTih0aGlzLngxKSB8fCBpc05hTih0aGlzLngyKSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLngxID0geDtcclxuXHRcdFx0XHRcdFx0dGhpcy54MiA9IHg7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoeCA8IHRoaXMueDEpIHRoaXMueDEgPSB4O1xyXG5cdFx0XHRcdFx0aWYgKHggPiB0aGlzLngyKSB0aGlzLngyID0geDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICh5ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGlmIChpc05hTih0aGlzLnkxKSB8fCBpc05hTih0aGlzLnkyKSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnkxID0geTtcclxuXHRcdFx0XHRcdFx0dGhpcy55MiA9IHk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoeSA8IHRoaXMueTEpIHRoaXMueTEgPSB5O1xyXG5cdFx0XHRcdFx0aWYgKHkgPiB0aGlzLnkyKSB0aGlzLnkyID0geTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5hZGRYID0gZnVuY3Rpb24oeCkgeyB0aGlzLmFkZFBvaW50KHgsIG51bGwpOyB9XHJcblx0XHRcdHRoaXMuYWRkWSA9IGZ1bmN0aW9uKHkpIHsgdGhpcy5hZGRQb2ludChudWxsLCB5KTsgfVxyXG5cclxuXHRcdFx0dGhpcy5hZGRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKGJiKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRQb2ludChiYi54MSwgYmIueTEpO1xyXG5cdFx0XHRcdHRoaXMuYWRkUG9pbnQoYmIueDIsIGJiLnkyKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5hZGRRdWFkcmF0aWNDdXJ2ZSA9IGZ1bmN0aW9uKHAweCwgcDB5LCBwMXgsIHAxeSwgcDJ4LCBwMnkpIHtcclxuXHRcdFx0XHR2YXIgY3AxeCA9IHAweCArIDIvMyAqIChwMXggLSBwMHgpOyAvLyBDUDEgPSBRUDAgKyAyLzMgKihRUDEtUVAwKVxyXG5cdFx0XHRcdHZhciBjcDF5ID0gcDB5ICsgMi8zICogKHAxeSAtIHAweSk7IC8vIENQMSA9IFFQMCArIDIvMyAqKFFQMS1RUDApXHJcblx0XHRcdFx0dmFyIGNwMnggPSBjcDF4ICsgMS8zICogKHAyeCAtIHAweCk7IC8vIENQMiA9IENQMSArIDEvMyAqKFFQMi1RUDApXHJcblx0XHRcdFx0dmFyIGNwMnkgPSBjcDF5ICsgMS8zICogKHAyeSAtIHAweSk7IC8vIENQMiA9IENQMSArIDEvMyAqKFFQMi1RUDApXHJcblx0XHRcdFx0dGhpcy5hZGRCZXppZXJDdXJ2ZShwMHgsIHAweSwgY3AxeCwgY3AyeCwgY3AxeSxcdGNwMnksIHAyeCwgcDJ5KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5hZGRCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uKHAweCwgcDB5LCBwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5KSB7XHJcblx0XHRcdFx0Ly8gZnJvbSBodHRwOi8vYmxvZy5oYWNrZXJzLWNhZmUubmV0LzIwMDkvMDYvaG93LXRvLWNhbGN1bGF0ZS1iZXppZXItY3VydmVzLWJvdW5kaW5nLmh0bWxcclxuXHRcdFx0XHR2YXIgcDAgPSBbcDB4LCBwMHldLCBwMSA9IFtwMXgsIHAxeV0sIHAyID0gW3AyeCwgcDJ5XSwgcDMgPSBbcDN4LCBwM3ldO1xyXG5cdFx0XHRcdHRoaXMuYWRkUG9pbnQocDBbMF0sIHAwWzFdKTtcclxuXHRcdFx0XHR0aGlzLmFkZFBvaW50KHAzWzBdLCBwM1sxXSk7XHJcblxyXG5cdFx0XHRcdGZvciAoaT0wOyBpPD0xOyBpKyspIHtcclxuXHRcdFx0XHRcdHZhciBmID0gZnVuY3Rpb24odCkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gTWF0aC5wb3coMS10LCAzKSAqIHAwW2ldXHJcblx0XHRcdFx0XHRcdCsgMyAqIE1hdGgucG93KDEtdCwgMikgKiB0ICogcDFbaV1cclxuXHRcdFx0XHRcdFx0KyAzICogKDEtdCkgKiBNYXRoLnBvdyh0LCAyKSAqIHAyW2ldXHJcblx0XHRcdFx0XHRcdCsgTWF0aC5wb3codCwgMykgKiBwM1tpXTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR2YXIgYiA9IDYgKiBwMFtpXSAtIDEyICogcDFbaV0gKyA2ICogcDJbaV07XHJcblx0XHRcdFx0XHR2YXIgYSA9IC0zICogcDBbaV0gKyA5ICogcDFbaV0gLSA5ICogcDJbaV0gKyAzICogcDNbaV07XHJcblx0XHRcdFx0XHR2YXIgYyA9IDMgKiBwMVtpXSAtIDMgKiBwMFtpXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoYSA9PSAwKSB7XHJcblx0XHRcdFx0XHRcdGlmIChiID09IDApIGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHR2YXIgdCA9IC1jIC8gYjtcclxuXHRcdFx0XHRcdFx0aWYgKDAgPCB0ICYmIHQgPCAxKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGkgPT0gMCkgdGhpcy5hZGRYKGYodCkpO1xyXG5cdFx0XHRcdFx0XHRcdGlmIChpID09IDEpIHRoaXMuYWRkWShmKHQpKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR2YXIgYjJhYyA9IE1hdGgucG93KGIsIDIpIC0gNCAqIGMgKiBhO1xyXG5cdFx0XHRcdFx0aWYgKGIyYWMgPCAwKSBjb250aW51ZTtcclxuXHRcdFx0XHRcdHZhciB0MSA9ICgtYiArIE1hdGguc3FydChiMmFjKSkgLyAoMiAqIGEpO1xyXG5cdFx0XHRcdFx0aWYgKDAgPCB0MSAmJiB0MSA8IDEpIHtcclxuXHRcdFx0XHRcdFx0aWYgKGkgPT0gMCkgdGhpcy5hZGRYKGYodDEpKTtcclxuXHRcdFx0XHRcdFx0aWYgKGkgPT0gMSkgdGhpcy5hZGRZKGYodDEpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHZhciB0MiA9ICgtYiAtIE1hdGguc3FydChiMmFjKSkgLyAoMiAqIGEpO1xyXG5cdFx0XHRcdFx0aWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcclxuXHRcdFx0XHRcdFx0aWYgKGkgPT0gMCkgdGhpcy5hZGRYKGYodDIpKTtcclxuXHRcdFx0XHRcdFx0aWYgKGkgPT0gMSkgdGhpcy5hZGRZKGYodDIpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuaXNQb2ludEluQm94ID0gZnVuY3Rpb24oeCwgeSkge1xyXG5cdFx0XHRcdHJldHVybiAodGhpcy54MSA8PSB4ICYmIHggPD0gdGhpcy54MiAmJiB0aGlzLnkxIDw9IHkgJiYgeSA8PSB0aGlzLnkyKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5hZGRQb2ludCh4MSwgeTEpO1xyXG5cdFx0XHR0aGlzLmFkZFBvaW50KHgyLCB5Mik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdHJhbnNmb3Jtc1xyXG5cdFx0c3ZnLlRyYW5zZm9ybSA9IGZ1bmN0aW9uKHYpIHtcclxuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cdFx0XHR0aGlzLlR5cGUgPSB7fVxyXG5cclxuXHRcdFx0Ly8gdHJhbnNsYXRlXHJcblx0XHRcdHRoaXMuVHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbihzKSB7XHJcblx0XHRcdFx0dGhpcy5wID0gc3ZnLkNyZWF0ZVBvaW50KHMpO1xyXG5cdFx0XHRcdHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHRcdGN0eC50cmFuc2xhdGUodGhpcy5wLnggfHwgMC4wLCB0aGlzLnAueSB8fCAwLjApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLnVuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHRcdGN0eC50cmFuc2xhdGUoLTEuMCAqIHRoaXMucC54IHx8IDAuMCwgLTEuMCAqIHRoaXMucC55IHx8IDAuMCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMuYXBwbHlUb1BvaW50ID0gZnVuY3Rpb24ocCkge1xyXG5cdFx0XHRcdFx0cC5hcHBseVRyYW5zZm9ybShbMSwgMCwgMCwgMSwgdGhpcy5wLnggfHwgMC4wLCB0aGlzLnAueSB8fCAwLjBdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHJvdGF0ZVxyXG5cdFx0XHR0aGlzLlR5cGUucm90YXRlID0gZnVuY3Rpb24ocykge1xyXG5cdFx0XHRcdHZhciBhID0gc3ZnLlRvTnVtYmVyQXJyYXkocyk7XHJcblx0XHRcdFx0dGhpcy5hbmdsZSA9IG5ldyBzdmcuUHJvcGVydHkoJ2FuZ2xlJywgYVswXSk7XHJcblx0XHRcdFx0dGhpcy5jeCA9IGFbMV0gfHwgMDtcclxuXHRcdFx0XHR0aGlzLmN5ID0gYVsyXSB8fCAwO1xyXG5cdFx0XHRcdHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHRcdGN0eC50cmFuc2xhdGUodGhpcy5jeCwgdGhpcy5jeSk7XHJcblx0XHRcdFx0XHRjdHgucm90YXRlKHRoaXMuYW5nbGUudG9SYWRpYW5zKCkpO1xyXG5cdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSgtdGhpcy5jeCwgLXRoaXMuY3kpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLnVuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHRcdGN0eC50cmFuc2xhdGUodGhpcy5jeCwgdGhpcy5jeSk7XHJcblx0XHRcdFx0XHRjdHgucm90YXRlKC0xLjAgKiB0aGlzLmFuZ2xlLnRvUmFkaWFucygpKTtcclxuXHRcdFx0XHRcdGN0eC50cmFuc2xhdGUoLXRoaXMuY3gsIC10aGlzLmN5KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy5hcHBseVRvUG9pbnQgPSBmdW5jdGlvbihwKSB7XHJcblx0XHRcdFx0XHR2YXIgYSA9IHRoaXMuYW5nbGUudG9SYWRpYW5zKCk7XHJcblx0XHRcdFx0XHRwLmFwcGx5VHJhbnNmb3JtKFsxLCAwLCAwLCAxLCB0aGlzLnAueCB8fCAwLjAsIHRoaXMucC55IHx8IDAuMF0pO1xyXG5cdFx0XHRcdFx0cC5hcHBseVRyYW5zZm9ybShbTWF0aC5jb3MoYSksIE1hdGguc2luKGEpLCAtTWF0aC5zaW4oYSksIE1hdGguY29zKGEpLCAwLCAwXSk7XHJcblx0XHRcdFx0XHRwLmFwcGx5VHJhbnNmb3JtKFsxLCAwLCAwLCAxLCAtdGhpcy5wLnggfHwgMC4wLCAtdGhpcy5wLnkgfHwgMC4wXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLlR5cGUuc2NhbGUgPSBmdW5jdGlvbihzKSB7XHJcblx0XHRcdFx0dGhpcy5wID0gc3ZnLkNyZWF0ZVBvaW50KHMpO1xyXG5cdFx0XHRcdHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHRcdGN0eC5zY2FsZSh0aGlzLnAueCB8fCAxLjAsIHRoaXMucC55IHx8IHRoaXMucC54IHx8IDEuMCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMudW5hcHBseSA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdFx0Y3R4LnNjYWxlKDEuMCAvIHRoaXMucC54IHx8IDEuMCwgMS4wIC8gdGhpcy5wLnkgfHwgdGhpcy5wLnggfHwgMS4wKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy5hcHBseVRvUG9pbnQgPSBmdW5jdGlvbihwKSB7XHJcblx0XHRcdFx0XHRwLmFwcGx5VHJhbnNmb3JtKFt0aGlzLnAueCB8fCAwLjAsIDAsIDAsIHRoaXMucC55IHx8IDAuMCwgMCwgMF0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5UeXBlLm1hdHJpeCA9IGZ1bmN0aW9uKHMpIHtcclxuXHRcdFx0XHR0aGlzLm0gPSBzdmcuVG9OdW1iZXJBcnJheShzKTtcclxuXHRcdFx0XHR0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0XHRjdHgudHJhbnNmb3JtKHRoaXMubVswXSwgdGhpcy5tWzFdLCB0aGlzLm1bMl0sIHRoaXMubVszXSwgdGhpcy5tWzRdLCB0aGlzLm1bNV0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLnVuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHRcdHZhciBhID0gdGhpcy5tWzBdO1xyXG5cdFx0XHRcdFx0dmFyIGIgPSB0aGlzLm1bMl07XHJcblx0XHRcdFx0XHR2YXIgYyA9IHRoaXMubVs0XTtcclxuXHRcdFx0XHRcdHZhciBkID0gdGhpcy5tWzFdO1xyXG5cdFx0XHRcdFx0dmFyIGUgPSB0aGlzLm1bM107XHJcblx0XHRcdFx0XHR2YXIgZiA9IHRoaXMubVs1XTtcclxuXHRcdFx0XHRcdHZhciBnID0gMC4wO1xyXG5cdFx0XHRcdFx0dmFyIGggPSAwLjA7XHJcblx0XHRcdFx0XHR2YXIgaSA9IDEuMDtcclxuXHRcdFx0XHRcdHZhciBkZXQgPSAxIC8gKGEqKGUqaS1mKmgpLWIqKGQqaS1mKmcpK2MqKGQqaC1lKmcpKTtcclxuXHRcdFx0XHRcdGN0eC50cmFuc2Zvcm0oXHJcblx0XHRcdFx0XHRcdGRldCooZSppLWYqaCksXHJcblx0XHRcdFx0XHRcdGRldCooZipnLWQqaSksXHJcblx0XHRcdFx0XHRcdGRldCooYypoLWIqaSksXHJcblx0XHRcdFx0XHRcdGRldCooYSppLWMqZyksXHJcblx0XHRcdFx0XHRcdGRldCooYipmLWMqZSksXHJcblx0XHRcdFx0XHRcdGRldCooYypkLWEqZilcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMuYXBwbHlUb1BvaW50ID0gZnVuY3Rpb24ocCkge1xyXG5cdFx0XHRcdFx0cC5hcHBseVRyYW5zZm9ybSh0aGlzLm0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5UeXBlLlNrZXdCYXNlID0gZnVuY3Rpb24ocykge1xyXG5cdFx0XHRcdHRoaXMuYmFzZSA9IHRoYXQuVHlwZS5tYXRyaXg7XHJcblx0XHRcdFx0dGhpcy5iYXNlKHMpO1xyXG5cdFx0XHRcdHRoaXMuYW5nbGUgPSBuZXcgc3ZnLlByb3BlcnR5KCdhbmdsZScsIHMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuVHlwZS5Ta2V3QmFzZS5wcm90b3R5cGUgPSBuZXcgdGhpcy5UeXBlLm1hdHJpeDtcclxuXHJcblx0XHRcdHRoaXMuVHlwZS5za2V3WCA9IGZ1bmN0aW9uKHMpIHtcclxuXHRcdFx0XHR0aGlzLmJhc2UgPSB0aGF0LlR5cGUuU2tld0Jhc2U7XHJcblx0XHRcdFx0dGhpcy5iYXNlKHMpO1xyXG5cdFx0XHRcdHRoaXMubSA9IFsxLCAwLCBNYXRoLnRhbih0aGlzLmFuZ2xlLnRvUmFkaWFucygpKSwgMSwgMCwgMF07XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5UeXBlLnNrZXdYLnByb3RvdHlwZSA9IG5ldyB0aGlzLlR5cGUuU2tld0Jhc2U7XHJcblxyXG5cdFx0XHR0aGlzLlR5cGUuc2tld1kgPSBmdW5jdGlvbihzKSB7XHJcblx0XHRcdFx0dGhpcy5iYXNlID0gdGhhdC5UeXBlLlNrZXdCYXNlO1xyXG5cdFx0XHRcdHRoaXMuYmFzZShzKTtcclxuXHRcdFx0XHR0aGlzLm0gPSBbMSwgTWF0aC50YW4odGhpcy5hbmdsZS50b1JhZGlhbnMoKSksIDAsIDEsIDAsIDBdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuVHlwZS5za2V3WS5wcm90b3R5cGUgPSBuZXcgdGhpcy5UeXBlLlNrZXdCYXNlO1xyXG5cclxuXHRcdFx0dGhpcy50cmFuc2Zvcm1zID0gW107XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dGhpcy50cmFuc2Zvcm1zW2ldLmFwcGx5KGN0eCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnVuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHRmb3IgKHZhciBpPXRoaXMudHJhbnNmb3Jtcy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XHJcblx0XHRcdFx0XHR0aGlzLnRyYW5zZm9ybXNbaV0udW5hcHBseShjdHgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5hcHBseVRvUG9pbnQgPSBmdW5jdGlvbihwKSB7XHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dGhpcy50cmFuc2Zvcm1zW2ldLmFwcGx5VG9Qb2ludChwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBkYXRhID0gc3ZnLnRyaW0oc3ZnLmNvbXByZXNzU3BhY2VzKHYpKS5yZXBsYWNlKC9cXCkoW2EtekEtWl0pL2csICcpICQxJykucmVwbGFjZSgvXFwpKFxccz8sXFxzPykvZywnKSAnKS5zcGxpdCgvXFxzKD89W2Etel0pLyk7XHJcblx0XHRcdGZvciAodmFyIGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIHR5cGUgPSBzdmcudHJpbShkYXRhW2ldLnNwbGl0KCcoJylbMF0pO1xyXG5cdFx0XHRcdHZhciBzID0gZGF0YVtpXS5zcGxpdCgnKCcpWzFdLnJlcGxhY2UoJyknLCcnKTtcclxuXHRcdFx0XHR2YXIgdHJhbnNmb3JtVHlwZSA9IHRoaXMuVHlwZVt0eXBlXTtcclxuXHRcdFx0XHRpZiAodHlwZW9mIHRyYW5zZm9ybVR5cGUgIT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHRcdHZhciB0cmFuc2Zvcm0gPSBuZXcgdHJhbnNmb3JtVHlwZShzKTtcclxuXHRcdFx0XHRcdHRyYW5zZm9ybS50eXBlID0gdHlwZTtcclxuXHRcdFx0XHRcdHRoaXMudHJhbnNmb3Jtcy5wdXNoKHRyYW5zZm9ybSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYXNwZWN0IHJhdGlvXHJcblx0XHRzdmcuQXNwZWN0UmF0aW8gPSBmdW5jdGlvbihjdHgsIGFzcGVjdFJhdGlvLCB3aWR0aCwgZGVzaXJlZFdpZHRoLCBoZWlnaHQsIGRlc2lyZWRIZWlnaHQsIG1pblgsIG1pblksIHJlZlgsIHJlZlkpIHtcclxuXHRcdFx0Ly8gYXNwZWN0IHJhdGlvIC0gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2Nvb3Jkcy5odG1sI1ByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGVcclxuXHRcdFx0YXNwZWN0UmF0aW8gPSBzdmcuY29tcHJlc3NTcGFjZXMoYXNwZWN0UmF0aW8pO1xyXG5cdFx0XHRhc3BlY3RSYXRpbyA9IGFzcGVjdFJhdGlvLnJlcGxhY2UoL15kZWZlclxccy8sJycpOyAvLyBpZ25vcmUgZGVmZXJcclxuXHRcdFx0dmFyIGFsaWduID0gYXNwZWN0UmF0aW8uc3BsaXQoJyAnKVswXSB8fCAneE1pZFlNaWQnO1xyXG5cdFx0XHR2YXIgbWVldE9yU2xpY2UgPSBhc3BlY3RSYXRpby5zcGxpdCgnICcpWzFdIHx8ICdtZWV0JztcclxuXHJcblx0XHRcdC8vIGNhbGN1bGF0ZSBzY2FsZVxyXG5cdFx0XHR2YXIgc2NhbGVYID0gd2lkdGggLyBkZXNpcmVkV2lkdGg7XHJcblx0XHRcdHZhciBzY2FsZVkgPSBoZWlnaHQgLyBkZXNpcmVkSGVpZ2h0O1xyXG5cdFx0XHR2YXIgc2NhbGVNaW4gPSBNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSk7XHJcblx0XHRcdHZhciBzY2FsZU1heCA9IE1hdGgubWF4KHNjYWxlWCwgc2NhbGVZKTtcclxuXHRcdFx0aWYgKG1lZXRPclNsaWNlID09ICdtZWV0JykgeyBkZXNpcmVkV2lkdGggKj0gc2NhbGVNaW47IGRlc2lyZWRIZWlnaHQgKj0gc2NhbGVNaW47IH1cclxuXHRcdFx0aWYgKG1lZXRPclNsaWNlID09ICdzbGljZScpIHsgZGVzaXJlZFdpZHRoICo9IHNjYWxlTWF4OyBkZXNpcmVkSGVpZ2h0ICo9IHNjYWxlTWF4OyB9XHJcblxyXG5cdFx0XHRyZWZYID0gbmV3IHN2Zy5Qcm9wZXJ0eSgncmVmWCcsIHJlZlgpO1xyXG5cdFx0XHRyZWZZID0gbmV3IHN2Zy5Qcm9wZXJ0eSgncmVmWScsIHJlZlkpO1xyXG5cdFx0XHRpZiAocmVmWC5oYXNWYWx1ZSgpICYmIHJlZlkuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdGN0eC50cmFuc2xhdGUoLXNjYWxlTWluICogcmVmWC50b1BpeGVscygneCcpLCAtc2NhbGVNaW4gKiByZWZZLnRvUGl4ZWxzKCd5JykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdC8vIGFsaWduXHJcblx0XHRcdFx0aWYgKGFsaWduLm1hdGNoKC9eeE1pZC8pICYmICgobWVldE9yU2xpY2UgPT0gJ21lZXQnICYmIHNjYWxlTWluID09IHNjYWxlWSkgfHwgKG1lZXRPclNsaWNlID09ICdzbGljZScgJiYgc2NhbGVNYXggPT0gc2NhbGVZKSkpIGN0eC50cmFuc2xhdGUod2lkdGggLyAyLjAgLSBkZXNpcmVkV2lkdGggLyAyLjAsIDApO1xyXG5cdFx0XHRcdGlmIChhbGlnbi5tYXRjaCgvWU1pZCQvKSAmJiAoKG1lZXRPclNsaWNlID09ICdtZWV0JyAmJiBzY2FsZU1pbiA9PSBzY2FsZVgpIHx8IChtZWV0T3JTbGljZSA9PSAnc2xpY2UnICYmIHNjYWxlTWF4ID09IHNjYWxlWCkpKSBjdHgudHJhbnNsYXRlKDAsIGhlaWdodCAvIDIuMCAtIGRlc2lyZWRIZWlnaHQgLyAyLjApO1xyXG5cdFx0XHRcdGlmIChhbGlnbi5tYXRjaCgvXnhNYXgvKSAmJiAoKG1lZXRPclNsaWNlID09ICdtZWV0JyAmJiBzY2FsZU1pbiA9PSBzY2FsZVkpIHx8IChtZWV0T3JTbGljZSA9PSAnc2xpY2UnICYmIHNjYWxlTWF4ID09IHNjYWxlWSkpKSBjdHgudHJhbnNsYXRlKHdpZHRoIC0gZGVzaXJlZFdpZHRoLCAwKTtcclxuXHRcdFx0XHRpZiAoYWxpZ24ubWF0Y2goL1lNYXgkLykgJiYgKChtZWV0T3JTbGljZSA9PSAnbWVldCcgJiYgc2NhbGVNaW4gPT0gc2NhbGVYKSB8fCAobWVldE9yU2xpY2UgPT0gJ3NsaWNlJyAmJiBzY2FsZU1heCA9PSBzY2FsZVgpKSkgY3R4LnRyYW5zbGF0ZSgwLCBoZWlnaHQgLSBkZXNpcmVkSGVpZ2h0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gc2NhbGVcclxuXHRcdFx0aWYgKGFsaWduID09ICdub25lJykgY3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcclxuXHRcdFx0ZWxzZSBpZiAobWVldE9yU2xpY2UgPT0gJ21lZXQnKSBjdHguc2NhbGUoc2NhbGVNaW4sIHNjYWxlTWluKTtcclxuXHRcdFx0ZWxzZSBpZiAobWVldE9yU2xpY2UgPT0gJ3NsaWNlJykgY3R4LnNjYWxlKHNjYWxlTWF4LCBzY2FsZU1heCk7XHJcblxyXG5cdFx0XHQvLyB0cmFuc2xhdGVcclxuXHRcdFx0Y3R4LnRyYW5zbGF0ZShtaW5YID09IG51bGwgPyAwIDogLW1pblgsIG1pblkgPT0gbnVsbCA/IDAgOiAtbWluWSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZWxlbWVudHNcclxuXHRcdHN2Zy5FbGVtZW50ID0ge31cclxuXHJcblx0XHRzdmcuRW1wdHlQcm9wZXJ0eSA9IG5ldyBzdmcuUHJvcGVydHkoJ0VNUFRZJywgJycpO1xyXG5cclxuXHRcdHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcclxuXHRcdFx0dGhpcy5zdHlsZXMgPSB7fTtcclxuXHRcdFx0dGhpcy5zdHlsZXNTcGVjaWZpY2l0eSA9IHt9O1xyXG5cdFx0XHR0aGlzLmNoaWxkcmVuID0gW107XHJcblxyXG5cdFx0XHQvLyBnZXQgb3IgY3JlYXRlIGF0dHJpYnV0ZVxyXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUsIGNyZWF0ZUlmTm90RXhpc3RzKSB7XHJcblx0XHRcdFx0dmFyIGEgPSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XHJcblx0XHRcdFx0aWYgKGEgIT0gbnVsbCkgcmV0dXJuIGE7XHJcblxyXG5cdFx0XHRcdGlmIChjcmVhdGVJZk5vdEV4aXN0cyA9PSB0cnVlKSB7IGEgPSBuZXcgc3ZnLlByb3BlcnR5KG5hbWUsICcnKTsgdGhpcy5hdHRyaWJ1dGVzW25hbWVdID0gYTsgfVxyXG5cdFx0XHRcdHJldHVybiBhIHx8IHN2Zy5FbXB0eVByb3BlcnR5O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmdldEhyZWZBdHRyaWJ1dGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRmb3IgKHZhciBhIGluIHRoaXMuYXR0cmlidXRlcykge1xyXG5cdFx0XHRcdFx0aWYgKGEgPT0gJ2hyZWYnIHx8IGEubWF0Y2goLzpocmVmJC8pKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbYV07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBzdmcuRW1wdHlQcm9wZXJ0eTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZ2V0IG9yIGNyZWF0ZSBzdHlsZSwgY3Jhd2xzIHVwIG5vZGUgdHJlZVxyXG5cdFx0XHR0aGlzLnN0eWxlID0gZnVuY3Rpb24obmFtZSwgY3JlYXRlSWZOb3RFeGlzdHMsIHNraXBBbmNlc3RvcnMpIHtcclxuXHRcdFx0XHR2YXIgcyA9IHRoaXMuc3R5bGVzW25hbWVdO1xyXG5cdFx0XHRcdGlmIChzICE9IG51bGwpIHJldHVybiBzO1xyXG5cclxuXHRcdFx0XHR2YXIgYSA9IHRoaXMuYXR0cmlidXRlKG5hbWUpO1xyXG5cdFx0XHRcdGlmIChhICE9IG51bGwgJiYgYS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHR0aGlzLnN0eWxlc1tuYW1lXSA9IGE7IC8vIG1vdmUgdXAgdG8gbWUgdG8gY2FjaGVcclxuXHRcdFx0XHRcdHJldHVybiBhO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHNraXBBbmNlc3RvcnMgIT0gdHJ1ZSkge1xyXG5cdFx0XHRcdFx0dmFyIHAgPSB0aGlzLnBhcmVudDtcclxuXHRcdFx0XHRcdGlmIChwICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHBzID0gcC5zdHlsZShuYW1lKTtcclxuXHRcdFx0XHRcdFx0aWYgKHBzICE9IG51bGwgJiYgcHMuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybiBwcztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGNyZWF0ZUlmTm90RXhpc3RzID09IHRydWUpIHsgcyA9IG5ldyBzdmcuUHJvcGVydHkobmFtZSwgJycpOyB0aGlzLnN0eWxlc1tuYW1lXSA9IHM7IH1cclxuXHRcdFx0XHRyZXR1cm4gcyB8fCBzdmcuRW1wdHlQcm9wZXJ0eTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYmFzZSByZW5kZXJcclxuXHRcdFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHQvLyBkb24ndCByZW5kZXIgZGlzcGxheT1ub25lXHJcblx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ2Rpc3BsYXknKS52YWx1ZSA9PSAnbm9uZScpIHJldHVybjtcclxuXHJcblx0XHRcdFx0Ly8gZG9uJ3QgcmVuZGVyIHZpc2liaWxpdHk9aGlkZGVuXHJcblx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ3Zpc2liaWxpdHknKS52YWx1ZSA9PSAnaGlkZGVuJykgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHRjdHguc2F2ZSgpO1xyXG5cdFx0XHRcdGlmICh0aGlzLnN0eWxlKCdtYXNrJykuaGFzVmFsdWUoKSkgeyAvLyBtYXNrXHJcblx0XHRcdFx0XHR2YXIgbWFzayA9IHRoaXMuc3R5bGUoJ21hc2snKS5nZXREZWZpbml0aW9uKCk7XHJcblx0XHRcdFx0XHRpZiAobWFzayAhPSBudWxsKSBtYXNrLmFwcGx5KGN0eCwgdGhpcyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKHRoaXMuc3R5bGUoJ2ZpbHRlcicpLmhhc1ZhbHVlKCkpIHsgLy8gZmlsdGVyXHJcblx0XHRcdFx0XHR2YXIgZmlsdGVyID0gdGhpcy5zdHlsZSgnZmlsdGVyJykuZ2V0RGVmaW5pdGlvbigpO1xyXG5cdFx0XHRcdFx0aWYgKGZpbHRlciAhPSBudWxsKSBmaWx0ZXIuYXBwbHkoY3R4LCB0aGlzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHR0aGlzLnNldENvbnRleHQoY3R4KTtcclxuXHRcdFx0XHRcdHRoaXMucmVuZGVyQ2hpbGRyZW4oY3R4KTtcclxuXHRcdFx0XHRcdHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGN0eC5yZXN0b3JlKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGJhc2Ugc2V0IGNvbnRleHRcclxuXHRcdFx0dGhpcy5zZXRDb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0Ly8gT1ZFUlJJREUgTUUhXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGJhc2UgY2xlYXIgY29udGV4dFxyXG5cdFx0XHR0aGlzLmNsZWFyQ29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdC8vIE9WRVJSSURFIE1FIVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBiYXNlIHJlbmRlciBjaGlsZHJlblxyXG5cdFx0XHR0aGlzLnJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHRoaXMuY2hpbGRyZW5baV0ucmVuZGVyKGN0eCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmFkZENoaWxkID0gZnVuY3Rpb24oY2hpbGROb2RlLCBjcmVhdGUpIHtcclxuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZE5vZGU7XHJcblx0XHRcdFx0aWYgKGNyZWF0ZSkgY2hpbGQgPSBzdmcuQ3JlYXRlRWxlbWVudChjaGlsZE5vZGUpO1xyXG5cdFx0XHRcdGNoaWxkLnBhcmVudCA9IHRoaXM7XHJcblx0XHRcdFx0aWYgKGNoaWxkLnR5cGUgIT0gJ3RpdGxlJykgeyB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1x0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmFkZFN0eWxlc0Zyb21TdHlsZURlZmluaXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0Ly8gYWRkIHN0eWxlc1xyXG5cdFx0XHRcdGZvciAodmFyIHNlbGVjdG9yIGluIHN2Zy5TdHlsZXMpIHtcclxuXHRcdFx0XHRcdGlmIChzZWxlY3RvclswXSAhPSAnQCcgJiYgbWF0Y2hlc1NlbGVjdG9yKG5vZGUsIHNlbGVjdG9yKSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgc3R5bGVzID0gc3ZnLlN0eWxlc1tzZWxlY3Rvcl07XHJcblx0XHRcdFx0XHRcdHZhciBzcGVjaWZpY2l0eSA9IHN2Zy5TdHlsZXNTcGVjaWZpY2l0eVtzZWxlY3Rvcl07XHJcblx0XHRcdFx0XHRcdGlmIChzdHlsZXMgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgZXhpc3RpbmdTcGVjaWZpY2l0eSA9IHRoaXMuc3R5bGVzU3BlY2lmaWNpdHlbbmFtZV07XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAodHlwZW9mIGV4aXN0aW5nU3BlY2lmaWNpdHkgPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0ZXhpc3RpbmdTcGVjaWZpY2l0eSA9ICcwMDAnO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHNwZWNpZmljaXR5ID4gZXhpc3RpbmdTcGVjaWZpY2l0eSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLnN0eWxlc1tuYW1lXSA9IHN0eWxlc1tuYW1lXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5zdHlsZXNTcGVjaWZpY2l0eVtuYW1lXSA9IHNwZWNpZmljaXR5O1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHRcdFx0XHJcblx0XHRcdC8vIE1pY3Jvc29mdCBFZGdlIGZpeFxyXG5cdFx0XHR2YXIgYWxsVXBwZXJjYXNlID0gbmV3IFJlZ0V4cChcIl5bQS1aXFwtXSskXCIpO1xyXG5cdFx0XHR2YXIgbm9ybWFsaXplQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcblx0XHRcdFx0aWYgKGFsbFVwcGVyY2FzZS50ZXN0KG5hbWUpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gbmFtZTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGlmIChub2RlICE9IG51bGwgJiYgbm9kZS5ub2RlVHlwZSA9PSAxKSB7IC8vRUxFTUVOVF9OT0RFXHJcblx0XHRcdFx0Ly8gYWRkIGF0dHJpYnV0ZXNcclxuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8bm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgYXR0cmlidXRlID0gbm9kZS5hdHRyaWJ1dGVzW2ldO1xyXG5cdFx0XHRcdFx0dmFyIG5vZGVOYW1lID0gbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyaWJ1dGUubm9kZU5hbWUpO1xyXG5cdFx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzW25vZGVOYW1lXSA9IG5ldyBzdmcuUHJvcGVydHkobm9kZU5hbWUsIGF0dHJpYnV0ZS52YWx1ZSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmFkZFN0eWxlc0Zyb21TdHlsZURlZmluaXRpb24oKTtcclxuXHJcblx0XHRcdFx0Ly8gYWRkIGlubGluZSBzdHlsZXNcclxuXHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ3N0eWxlJykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0dmFyIHN0eWxlcyA9IHRoaXMuYXR0cmlidXRlKCdzdHlsZScpLnZhbHVlLnNwbGl0KCc7Jyk7XHJcblx0XHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8c3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdGlmIChzdmcudHJpbShzdHlsZXNbaV0pICE9ICcnKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHN0eWxlID0gc3R5bGVzW2ldLnNwbGl0KCc6Jyk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIG5hbWUgPSBzdmcudHJpbShzdHlsZVswXSk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gc3ZnLnRyaW0oc3R5bGVbMV0pO1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuc3R5bGVzW25hbWVdID0gbmV3IHN2Zy5Qcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIGFkZCBpZFxyXG5cdFx0XHRcdGlmICh0aGlzLmF0dHJpYnV0ZSgnaWQnKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHRpZiAoc3ZnLkRlZmluaXRpb25zW3RoaXMuYXR0cmlidXRlKCdpZCcpLnZhbHVlXSA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHN2Zy5EZWZpbml0aW9uc1t0aGlzLmF0dHJpYnV0ZSgnaWQnKS52YWx1ZV0gPSB0aGlzO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gYWRkIGNoaWxkcmVuXHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGNoaWxkTm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tpXTtcclxuXHRcdFx0XHRcdGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT0gMSkgdGhpcy5hZGRDaGlsZChjaGlsZE5vZGUsIHRydWUpOyAvL0VMRU1FTlRfTk9ERVxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuY2FwdHVyZVRleHROb2RlcyAmJiAoY2hpbGROb2RlLm5vZGVUeXBlID09IDMgfHwgY2hpbGROb2RlLm5vZGVUeXBlID09IDQpKSB7XHJcblx0XHRcdFx0XHRcdHZhciB0ZXh0ID0gY2hpbGROb2RlLnZhbHVlIHx8IGNoaWxkTm9kZS50ZXh0IHx8IGNoaWxkTm9kZS50ZXh0Q29udGVudCB8fCAnJztcclxuXHRcdFx0XHRcdFx0aWYgKHN2Zy5jb21wcmVzc1NwYWNlcyh0ZXh0KSAhPSAnJykge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuYWRkQ2hpbGQobmV3IHN2Zy5FbGVtZW50LnRzcGFuKGNoaWxkTm9kZSksIGZhbHNlKTsgLy8gVEVYVF9OT0RFXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5zZXRDb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0Ly8gZmlsbFxyXG5cdFx0XHRcdGlmICh0aGlzLnN0eWxlKCdmaWxsJykuaXNVcmxEZWZpbml0aW9uKCkpIHtcclxuXHRcdFx0XHRcdHZhciBmcyA9IHRoaXMuc3R5bGUoJ2ZpbGwnKS5nZXRGaWxsU3R5bGVEZWZpbml0aW9uKHRoaXMsIHRoaXMuc3R5bGUoJ2ZpbGwtb3BhY2l0eScpKTtcclxuXHRcdFx0XHRcdGlmIChmcyAhPSBudWxsKSBjdHguZmlsbFN0eWxlID0gZnM7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKHRoaXMuc3R5bGUoJ2ZpbGwnKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHR2YXIgZmlsbFN0eWxlID0gdGhpcy5zdHlsZSgnZmlsbCcpO1xyXG5cdFx0XHRcdFx0aWYgKGZpbGxTdHlsZS52YWx1ZSA9PSAnY3VycmVudENvbG9yJykgZmlsbFN0eWxlLnZhbHVlID0gdGhpcy5zdHlsZSgnY29sb3InKS52YWx1ZTtcclxuXHRcdFx0XHRcdGlmIChmaWxsU3R5bGUudmFsdWUgIT0gJ2luaGVyaXQnKSBjdHguZmlsbFN0eWxlID0gKGZpbGxTdHlsZS52YWx1ZSA9PSAnbm9uZScgPyAncmdiYSgwLDAsMCwwKScgOiBmaWxsU3R5bGUudmFsdWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAodGhpcy5zdHlsZSgnZmlsbC1vcGFjaXR5JykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0dmFyIGZpbGxTdHlsZSA9IG5ldyBzdmcuUHJvcGVydHkoJ2ZpbGwnLCBjdHguZmlsbFN0eWxlKTtcclxuXHRcdFx0XHRcdGZpbGxTdHlsZSA9IGZpbGxTdHlsZS5hZGRPcGFjaXR5KHRoaXMuc3R5bGUoJ2ZpbGwtb3BhY2l0eScpKTtcclxuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGUudmFsdWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBzdHJva2VcclxuXHRcdFx0XHRpZiAodGhpcy5zdHlsZSgnc3Ryb2tlJykuaXNVcmxEZWZpbml0aW9uKCkpIHtcclxuXHRcdFx0XHRcdHZhciBmcyA9IHRoaXMuc3R5bGUoJ3N0cm9rZScpLmdldEZpbGxTdHlsZURlZmluaXRpb24odGhpcywgdGhpcy5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknKSk7XHJcblx0XHRcdFx0XHRpZiAoZnMgIT0gbnVsbCkgY3R4LnN0cm9rZVN0eWxlID0gZnM7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKHRoaXMuc3R5bGUoJ3N0cm9rZScpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdHZhciBzdHJva2VTdHlsZSA9IHRoaXMuc3R5bGUoJ3N0cm9rZScpO1xyXG5cdFx0XHRcdFx0aWYgKHN0cm9rZVN0eWxlLnZhbHVlID09ICdjdXJyZW50Q29sb3InKSBzdHJva2VTdHlsZS52YWx1ZSA9IHRoaXMuc3R5bGUoJ2NvbG9yJykudmFsdWU7XHJcblx0XHRcdFx0XHRpZiAoc3Ryb2tlU3R5bGUudmFsdWUgIT0gJ2luaGVyaXQnKSBjdHguc3Ryb2tlU3R5bGUgPSAoc3Ryb2tlU3R5bGUudmFsdWUgPT0gJ25vbmUnID8gJ3JnYmEoMCwwLDAsMCknIDogc3Ryb2tlU3R5bGUudmFsdWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAodGhpcy5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHR2YXIgc3Ryb2tlU3R5bGUgPSBuZXcgc3ZnLlByb3BlcnR5KCdzdHJva2UnLCBjdHguc3Ryb2tlU3R5bGUpO1xyXG5cdFx0XHRcdFx0c3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZS5hZGRPcGFjaXR5KHRoaXMuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JykpO1xyXG5cdFx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGUudmFsdWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICh0aGlzLnN0eWxlKCdzdHJva2Utd2lkdGgnKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHR2YXIgbmV3TGluZVdpZHRoID0gdGhpcy5zdHlsZSgnc3Ryb2tlLXdpZHRoJykudG9QaXhlbHMoKTtcclxuXHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSBuZXdMaW5lV2lkdGggPT0gMCA/IDAuMDAxIDogbmV3TGluZVdpZHRoOyAvLyBicm93c2VycyBkb24ndCByZXNwZWN0IDBcclxuXHRcdFx0ICAgIH1cclxuXHRcdFx0XHRpZiAodGhpcy5zdHlsZSgnc3Ryb2tlLWxpbmVjYXAnKS5oYXNWYWx1ZSgpKSBjdHgubGluZUNhcCA9IHRoaXMuc3R5bGUoJ3N0cm9rZS1saW5lY2FwJykudmFsdWU7XHJcblx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ3N0cm9rZS1saW5lam9pbicpLmhhc1ZhbHVlKCkpIGN0eC5saW5lSm9pbiA9IHRoaXMuc3R5bGUoJ3N0cm9rZS1saW5lam9pbicpLnZhbHVlO1xyXG5cdFx0XHRcdGlmICh0aGlzLnN0eWxlKCdzdHJva2UtbWl0ZXJsaW1pdCcpLmhhc1ZhbHVlKCkpIGN0eC5taXRlckxpbWl0ID0gdGhpcy5zdHlsZSgnc3Ryb2tlLW1pdGVybGltaXQnKS52YWx1ZTtcclxuXHRcdFx0XHRpZiAodGhpcy5zdHlsZSgnc3Ryb2tlLWRhc2hhcnJheScpLmhhc1ZhbHVlKCkgJiYgdGhpcy5zdHlsZSgnc3Ryb2tlLWRhc2hhcnJheScpLnZhbHVlICE9ICdub25lJykge1xyXG5cdFx0XHRcdFx0dmFyIGdhcHMgPSBzdmcuVG9OdW1iZXJBcnJheSh0aGlzLnN0eWxlKCdzdHJva2UtZGFzaGFycmF5JykudmFsdWUpO1xyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBjdHguc2V0TGluZURhc2ggIT0gJ3VuZGVmaW5lZCcpIHsgY3R4LnNldExpbmVEYXNoKGdhcHMpOyB9XHJcblx0XHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgY3R4LndlYmtpdExpbmVEYXNoICE9ICd1bmRlZmluZWQnKSB7IGN0eC53ZWJraXRMaW5lRGFzaCA9IGdhcHM7IH1cclxuXHRcdFx0XHRcdGVsc2UgaWYgKHR5cGVvZiBjdHgubW96RGFzaCAhPSAndW5kZWZpbmVkJyAmJiAhKGdhcHMubGVuZ3RoPT0xICYmIGdhcHNbMF09PTApKSB7IGN0eC5tb3pEYXNoID0gZ2FwczsgfVxyXG5cclxuXHRcdFx0XHRcdHZhciBvZmZzZXQgPSB0aGlzLnN0eWxlKCdzdHJva2UtZGFzaG9mZnNldCcpLm51bVZhbHVlT3JEZWZhdWx0KDEpO1xyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBjdHgubGluZURhc2hPZmZzZXQgIT0gJ3VuZGVmaW5lZCcpIHsgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gb2Zmc2V0OyB9XHJcblx0XHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgY3R4LndlYmtpdExpbmVEYXNoT2Zmc2V0ICE9ICd1bmRlZmluZWQnKSB7IGN0eC53ZWJraXRMaW5lRGFzaE9mZnNldCA9IG9mZnNldDsgfVxyXG5cdFx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIGN0eC5tb3pEYXNoT2Zmc2V0ICE9ICd1bmRlZmluZWQnKSB7IGN0eC5tb3pEYXNoT2Zmc2V0ID0gb2Zmc2V0OyB9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBmb250XHJcblx0XHRcdFx0aWYgKHR5cGVvZiBjdHguZm9udCAhPSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdFx0Y3R4LmZvbnQgPSBzdmcuRm9udC5DcmVhdGVGb250KFxyXG5cdFx0XHRcdFx0XHR0aGlzLnN0eWxlKCdmb250LXN0eWxlJykudmFsdWUsXHJcblx0XHRcdFx0XHRcdHRoaXMuc3R5bGUoJ2ZvbnQtdmFyaWFudCcpLnZhbHVlLFxyXG5cdFx0XHRcdFx0XHR0aGlzLnN0eWxlKCdmb250LXdlaWdodCcpLnZhbHVlLFxyXG5cdFx0XHRcdFx0XHR0aGlzLnN0eWxlKCdmb250LXNpemUnKS5oYXNWYWx1ZSgpID8gdGhpcy5zdHlsZSgnZm9udC1zaXplJykudG9QaXhlbHMoKSArICdweCcgOiAnJyxcclxuXHRcdFx0XHRcdFx0dGhpcy5zdHlsZSgnZm9udC1mYW1pbHknKS52YWx1ZSkudG9TdHJpbmcoKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIHRyYW5zZm9ybVxyXG5cdFx0XHRcdGlmICh0aGlzLnN0eWxlKCd0cmFuc2Zvcm0nLCBmYWxzZSwgdHJ1ZSkuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0dmFyIHRyYW5zZm9ybSA9IG5ldyBzdmcuVHJhbnNmb3JtKHRoaXMuc3R5bGUoJ3RyYW5zZm9ybScsIGZhbHNlLCB0cnVlKS52YWx1ZSk7XHJcblx0XHRcdFx0XHR0cmFuc2Zvcm0uYXBwbHkoY3R4KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIGNsaXBcclxuXHRcdFx0XHRpZiAodGhpcy5zdHlsZSgnY2xpcC1wYXRoJywgZmFsc2UsIHRydWUpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdHZhciBjbGlwID0gdGhpcy5zdHlsZSgnY2xpcC1wYXRoJywgZmFsc2UsIHRydWUpLmdldERlZmluaXRpb24oKTtcclxuXHRcdFx0XHRcdGlmIChjbGlwICE9IG51bGwpIGNsaXAuYXBwbHkoY3R4KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIG9wYWNpdHlcclxuXHRcdFx0XHRpZiAodGhpcy5zdHlsZSgnb3BhY2l0eScpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuc3R5bGUoJ29wYWNpdHknKS5udW1WYWx1ZSgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0c3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLnBhdGggPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHRpZiAoY3R4ICE9IG51bGwpIGN0eC5iZWdpblBhdGgoKTtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IHN2Zy5Cb3VuZGluZ0JveCgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0dGhpcy5wYXRoKGN0eCk7XHJcblx0XHRcdFx0c3ZnLk1vdXNlLmNoZWNrUGF0aCh0aGlzLCBjdHgpO1xyXG5cdFx0XHRcdGlmIChjdHguZmlsbFN0eWxlICE9ICcnKSB7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5zdHlsZSgnZmlsbC1ydWxlJykudmFsdWVPckRlZmF1bHQoJ2luaGVyaXQnKSAhPSAnaW5oZXJpdCcpIHsgY3R4LmZpbGwodGhpcy5zdHlsZSgnZmlsbC1ydWxlJykudmFsdWUpOyB9XHJcblx0XHRcdFx0XHRlbHNlIHsgY3R4LmZpbGwoKTsgfVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoY3R4LnN0cm9rZVN0eWxlICE9ICcnKSBjdHguc3Ryb2tlKCk7XHJcblxyXG5cdFx0XHRcdHZhciBtYXJrZXJzID0gdGhpcy5nZXRNYXJrZXJzKCk7XHJcblx0XHRcdFx0aWYgKG1hcmtlcnMgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ21hcmtlci1zdGFydCcpLmlzVXJsRGVmaW5pdGlvbigpKSB7XHJcblx0XHRcdFx0XHRcdHZhciBtYXJrZXIgPSB0aGlzLnN0eWxlKCdtYXJrZXItc3RhcnQnKS5nZXREZWZpbml0aW9uKCk7XHJcblx0XHRcdFx0XHRcdG1hcmtlci5yZW5kZXIoY3R4LCBtYXJrZXJzWzBdWzBdLCBtYXJrZXJzWzBdWzFdKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICh0aGlzLnN0eWxlKCdtYXJrZXItbWlkJykuaXNVcmxEZWZpbml0aW9uKCkpIHtcclxuXHRcdFx0XHRcdFx0dmFyIG1hcmtlciA9IHRoaXMuc3R5bGUoJ21hcmtlci1taWQnKS5nZXREZWZpbml0aW9uKCk7XHJcblx0XHRcdFx0XHRcdGZvciAodmFyIGk9MTtpPG1hcmtlcnMubGVuZ3RoLTE7aSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0bWFya2VyLnJlbmRlcihjdHgsIG1hcmtlcnNbaV1bMF0sIG1hcmtlcnNbaV1bMV0pO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAodGhpcy5zdHlsZSgnbWFya2VyLWVuZCcpLmlzVXJsRGVmaW5pdGlvbigpKSB7XHJcblx0XHRcdFx0XHRcdHZhciBtYXJrZXIgPSB0aGlzLnN0eWxlKCdtYXJrZXItZW5kJykuZ2V0RGVmaW5pdGlvbigpO1xyXG5cdFx0XHRcdFx0XHRtYXJrZXIucmVuZGVyKGN0eCwgbWFya2Vyc1ttYXJrZXJzLmxlbmd0aC0xXVswXSwgbWFya2Vyc1ttYXJrZXJzLmxlbmd0aC0xXVsxXSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMucGF0aCgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmdldE1hcmtlcnMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIHN2ZyBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5zdmcgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMuYmFzZUNsZWFyQ29udGV4dCA9IHRoaXMuY2xlYXJDb250ZXh0O1xyXG5cdFx0XHR0aGlzLmNsZWFyQ29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdHRoaXMuYmFzZUNsZWFyQ29udGV4dChjdHgpO1xyXG5cdFx0XHRcdHN2Zy5WaWV3UG9ydC5SZW1vdmVDdXJyZW50KCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYmFzZVNldENvbnRleHQgPSB0aGlzLnNldENvbnRleHQ7XHJcblx0XHRcdHRoaXMuc2V0Q29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdC8vIGluaXRpYWwgdmFsdWVzIGFuZCBkZWZhdWx0c1xyXG5cdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcclxuXHRcdFx0XHRjdHgubGluZUNhcCA9ICdidXR0JztcclxuXHRcdFx0XHRjdHgubGluZUpvaW4gPSAnbWl0ZXInO1xyXG5cdFx0XHRcdGN0eC5taXRlckxpbWl0ID0gNDtcclxuXHRcdFx0XHRpZiAodHlwZW9mIGN0eC5mb250ICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSAhPSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdFx0Y3R4LmZvbnQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjdHguY2FudmFzKS5nZXRQcm9wZXJ0eVZhbHVlKCdmb250Jyk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmJhc2VTZXRDb250ZXh0KGN0eCk7XHJcblxyXG5cdFx0XHRcdC8vIGNyZWF0ZSBuZXcgdmlldyBwb3J0XHJcblx0XHRcdFx0aWYgKCF0aGlzLmF0dHJpYnV0ZSgneCcpLmhhc1ZhbHVlKCkpIHRoaXMuYXR0cmlidXRlKCd4JywgdHJ1ZSkudmFsdWUgPSAwO1xyXG5cdFx0XHRcdGlmICghdGhpcy5hdHRyaWJ1dGUoJ3knKS5oYXNWYWx1ZSgpKSB0aGlzLmF0dHJpYnV0ZSgneScsIHRydWUpLnZhbHVlID0gMDtcclxuXHRcdFx0XHRjdHgudHJhbnNsYXRlKHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnKSwgdGhpcy5hdHRyaWJ1dGUoJ3knKS50b1BpeGVscygneScpKTtcclxuXHJcblx0XHRcdFx0dmFyIHdpZHRoID0gc3ZnLlZpZXdQb3J0LndpZHRoKCk7XHJcblx0XHRcdFx0dmFyIGhlaWdodCA9IHN2Zy5WaWV3UG9ydC5oZWlnaHQoKTtcclxuXHJcblx0XHRcdFx0aWYgKCF0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS5oYXNWYWx1ZSgpKSB0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnLCB0cnVlKS52YWx1ZSA9ICcxMDAlJztcclxuXHRcdFx0XHRpZiAoIXRoaXMuYXR0cmlidXRlKCdoZWlnaHQnKS5oYXNWYWx1ZSgpKSB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JywgdHJ1ZSkudmFsdWUgPSAnMTAwJSc7XHJcblx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzLnJvb3QgPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHRcdHdpZHRoID0gdGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJykudG9QaXhlbHMoJ3gnKTtcclxuXHRcdFx0XHRcdGhlaWdodCA9IHRoaXMuYXR0cmlidXRlKCdoZWlnaHQnKS50b1BpeGVscygneScpO1xyXG5cclxuXHRcdFx0XHRcdHZhciB4ID0gMDtcclxuXHRcdFx0XHRcdHZhciB5ID0gMDtcclxuXHRcdFx0XHRcdGlmICh0aGlzLmF0dHJpYnV0ZSgncmVmWCcpLmhhc1ZhbHVlKCkgJiYgdGhpcy5hdHRyaWJ1dGUoJ3JlZlknKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHRcdHggPSAtdGhpcy5hdHRyaWJ1dGUoJ3JlZlgnKS50b1BpeGVscygneCcpO1xyXG5cdFx0XHRcdFx0XHR5ID0gLXRoaXMuYXR0cmlidXRlKCdyZWZZJykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ292ZXJmbG93JykudmFsdWVPckRlZmF1bHQoJ2hpZGRlbicpICE9ICd2aXNpYmxlJykge1xyXG5cdFx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRcdFx0XHRcdGN0eC5tb3ZlVG8oeCwgeSk7XHJcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8od2lkdGgsIHkpO1xyXG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xyXG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKHgsIGhlaWdodCk7XHJcblx0XHRcdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0XHRcdFx0Y3R4LmNsaXAoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0c3ZnLlZpZXdQb3J0LlNldEN1cnJlbnQod2lkdGgsIGhlaWdodCk7XHJcblxyXG5cdFx0XHRcdC8vIHZpZXdib3hcclxuXHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ3ZpZXdCb3gnKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHR2YXIgdmlld0JveCA9IHN2Zy5Ub051bWJlckFycmF5KHRoaXMuYXR0cmlidXRlKCd2aWV3Qm94JykudmFsdWUpO1xyXG5cdFx0XHRcdFx0dmFyIG1pblggPSB2aWV3Qm94WzBdO1xyXG5cdFx0XHRcdFx0dmFyIG1pblkgPSB2aWV3Qm94WzFdO1xyXG5cdFx0XHRcdFx0d2lkdGggPSB2aWV3Qm94WzJdO1xyXG5cdFx0XHRcdFx0aGVpZ2h0ID0gdmlld0JveFszXTtcclxuXHJcblx0XHRcdFx0XHRzdmcuQXNwZWN0UmF0aW8oY3R4LFxyXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpLnZhbHVlLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdmcuVmlld1BvcnQud2lkdGgoKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0d2lkdGgsXHJcblx0XHRcdFx0XHRcdFx0XHRcdHN2Zy5WaWV3UG9ydC5oZWlnaHQoKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0aGVpZ2h0LFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRtaW5YLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRtaW5ZLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHJpYnV0ZSgncmVmWCcpLnZhbHVlLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHJpYnV0ZSgncmVmWScpLnZhbHVlKTtcclxuXHJcblx0XHRcdFx0XHRzdmcuVmlld1BvcnQuUmVtb3ZlQ3VycmVudCgpO1xyXG5cdFx0XHRcdFx0c3ZnLlZpZXdQb3J0LlNldEN1cnJlbnQodmlld0JveFsyXSwgdmlld0JveFszXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5zdmcucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gcmVjdCBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5yZWN0ID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMucGF0aCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdHZhciB4ID0gdGhpcy5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcpO1xyXG5cdFx0XHRcdHZhciB5ID0gdGhpcy5hdHRyaWJ1dGUoJ3knKS50b1BpeGVscygneScpO1xyXG5cdFx0XHRcdHZhciB3aWR0aCA9IHRoaXMuYXR0cmlidXRlKCd3aWR0aCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0dmFyIGhlaWdodCA9IHRoaXMuYXR0cmlidXRlKCdoZWlnaHQnKS50b1BpeGVscygneScpO1xyXG5cdFx0XHRcdHZhciByeCA9IHRoaXMuYXR0cmlidXRlKCdyeCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0dmFyIHJ5ID0gdGhpcy5hdHRyaWJ1dGUoJ3J5JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ3J4JykuaGFzVmFsdWUoKSAmJiAhdGhpcy5hdHRyaWJ1dGUoJ3J5JykuaGFzVmFsdWUoKSkgcnkgPSByeDtcclxuXHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ3J5JykuaGFzVmFsdWUoKSAmJiAhdGhpcy5hdHRyaWJ1dGUoJ3J4JykuaGFzVmFsdWUoKSkgcnggPSByeTtcclxuXHRcdFx0XHRyeCA9IE1hdGgubWluKHJ4LCB3aWR0aCAvIDIuMCk7XHJcblx0XHRcdFx0cnkgPSBNYXRoLm1pbihyeSwgaGVpZ2h0IC8gMi4wKTtcclxuXHRcdFx0XHRpZiAoY3R4ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcclxuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oeCArIHJ4LCB5KTtcclxuXHRcdFx0XHRcdGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcngsIHkpO1xyXG5cdFx0XHRcdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByeSlcclxuXHRcdFx0XHRcdGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcnkpO1xyXG5cdFx0XHRcdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByeCwgeSArIGhlaWdodClcclxuXHRcdFx0XHRcdGN0eC5saW5lVG8oeCArIHJ4LCB5ICsgaGVpZ2h0KTtcclxuXHRcdFx0XHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByeSlcclxuXHRcdFx0XHRcdGN0eC5saW5lVG8oeCwgeSArIHJ5KTtcclxuXHRcdFx0XHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByeCwgeSlcclxuXHRcdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBuZXcgc3ZnLkJvdW5kaW5nQm94KHgsIHksIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LnJlY3QucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBjaXJjbGUgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQuY2lyY2xlID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMucGF0aCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdHZhciBjeCA9IHRoaXMuYXR0cmlidXRlKCdjeCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0dmFyIGN5ID0gdGhpcy5hdHRyaWJ1dGUoJ2N5JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHR2YXIgciA9IHRoaXMuYXR0cmlidXRlKCdyJykudG9QaXhlbHMoKTtcclxuXHJcblx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRcdFx0XHRjdHguYXJjKGN4LCBjeSwgciwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xyXG5cdFx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIG5ldyBzdmcuQm91bmRpbmdCb3goY3ggLSByLCBjeSAtIHIsIGN4ICsgciwgY3kgKyByKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuY2lyY2xlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gZWxsaXBzZSBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5lbGxpcHNlID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMucGF0aCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdHZhciBLQVBQQSA9IDQgKiAoKE1hdGguc3FydCgyKSAtIDEpIC8gMyk7XHJcblx0XHRcdFx0dmFyIHJ4ID0gdGhpcy5hdHRyaWJ1dGUoJ3J4JykudG9QaXhlbHMoJ3gnKTtcclxuXHRcdFx0XHR2YXIgcnkgPSB0aGlzLmF0dHJpYnV0ZSgncnknKS50b1BpeGVscygneScpO1xyXG5cdFx0XHRcdHZhciBjeCA9IHRoaXMuYXR0cmlidXRlKCdjeCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0dmFyIGN5ID0gdGhpcy5hdHRyaWJ1dGUoJ2N5JykudG9QaXhlbHMoJ3knKTtcclxuXHJcblx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRcdFx0XHRjdHgubW92ZVRvKGN4LCBjeSAtIHJ5KTtcclxuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGN4ICsgKEtBUFBBICogcngpLCBjeSAtIHJ5LCAgY3ggKyByeCwgY3kgLSAoS0FQUEEgKiByeSksIGN4ICsgcngsIGN5KTtcclxuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGN4ICsgcngsIGN5ICsgKEtBUFBBICogcnkpLCBjeCArIChLQVBQQSAqIHJ4KSwgY3kgKyByeSwgY3gsIGN5ICsgcnkpO1xyXG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oY3ggLSAoS0FQUEEgKiByeCksIGN5ICsgcnksIGN4IC0gcngsIGN5ICsgKEtBUFBBICogcnkpLCBjeCAtIHJ4LCBjeSk7XHJcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjeCAtIHJ4LCBjeSAtIChLQVBQQSAqIHJ5KSwgY3ggLSAoS0FQUEEgKiByeCksIGN5IC0gcnksIGN4LCBjeSAtIHJ5KTtcclxuXHRcdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBuZXcgc3ZnLkJvdW5kaW5nQm94KGN4IC0gcngsIGN5IC0gcnksIGN4ICsgcngsIGN5ICsgcnkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5lbGxpcHNlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gbGluZSBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5saW5lID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMuZ2V0UG9pbnRzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIFtcclxuXHRcdFx0XHRcdG5ldyBzdmcuUG9pbnQodGhpcy5hdHRyaWJ1dGUoJ3gxJykudG9QaXhlbHMoJ3gnKSwgdGhpcy5hdHRyaWJ1dGUoJ3kxJykudG9QaXhlbHMoJ3knKSksXHJcblx0XHRcdFx0XHRuZXcgc3ZnLlBvaW50KHRoaXMuYXR0cmlidXRlKCd4MicpLnRvUGl4ZWxzKCd4JyksIHRoaXMuYXR0cmlidXRlKCd5MicpLnRvUGl4ZWxzKCd5JykpXTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5wYXRoID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0dmFyIHBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKCk7XHJcblxyXG5cdFx0XHRcdGlmIChjdHggIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xyXG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyhwb2ludHNbMV0ueCwgcG9pbnRzWzFdLnkpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIG5ldyBzdmcuQm91bmRpbmdCb3gocG9pbnRzWzBdLngsIHBvaW50c1swXS55LCBwb2ludHNbMV0ueCwgcG9pbnRzWzFdLnkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmdldE1hcmtlcnMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgcG9pbnRzID0gdGhpcy5nZXRQb2ludHMoKTtcclxuXHRcdFx0XHR2YXIgYSA9IHBvaW50c1swXS5hbmdsZVRvKHBvaW50c1sxXSk7XHJcblx0XHRcdFx0cmV0dXJuIFtbcG9pbnRzWzBdLCBhXSwgW3BvaW50c1sxXSwgYV1dO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5saW5lLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gcG9seWxpbmUgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQucG9seWxpbmUgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5wb2ludHMgPSBzdmcuQ3JlYXRlUGF0aCh0aGlzLmF0dHJpYnV0ZSgncG9pbnRzJykudmFsdWUpO1xyXG5cdFx0XHR0aGlzLnBhdGggPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHR2YXIgYmIgPSBuZXcgc3ZnLkJvdW5kaW5nQm94KHRoaXMucG9pbnRzWzBdLngsIHRoaXMucG9pbnRzWzBdLnkpO1xyXG5cdFx0XHRcdGlmIChjdHggIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyh0aGlzLnBvaW50c1swXS54LCB0aGlzLnBvaW50c1swXS55KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Zm9yICh2YXIgaT0xOyBpPHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRiYi5hZGRQb2ludCh0aGlzLnBvaW50c1tpXS54LCB0aGlzLnBvaW50c1tpXS55KTtcclxuXHRcdFx0XHRcdGlmIChjdHggIT0gbnVsbCkgY3R4LmxpbmVUbyh0aGlzLnBvaW50c1tpXS54LCB0aGlzLnBvaW50c1tpXS55KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGJiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmdldE1hcmtlcnMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgbWFya2VycyA9IFtdO1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLnBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcclxuXHRcdFx0XHRcdG1hcmtlcnMucHVzaChbdGhpcy5wb2ludHNbaV0sIHRoaXMucG9pbnRzW2ldLmFuZ2xlVG8odGhpcy5wb2ludHNbaSsxXSldKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKG1hcmtlcnMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0bWFya2Vycy5wdXNoKFt0aGlzLnBvaW50c1t0aGlzLnBvaW50cy5sZW5ndGgtMV0sIG1hcmtlcnNbbWFya2Vycy5sZW5ndGgtMV1bMV1dKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIG1hcmtlcnM7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LnBvbHlsaW5lLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gcG9seWdvbiBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5wb2x5Z29uID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5wb2x5bGluZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5iYXNlUGF0aCA9IHRoaXMucGF0aDtcclxuXHRcdFx0dGhpcy5wYXRoID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0dmFyIGJiID0gdGhpcy5iYXNlUGF0aChjdHgpO1xyXG5cdFx0XHRcdGlmIChjdHggIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyh0aGlzLnBvaW50c1swXS54LCB0aGlzLnBvaW50c1swXS55KTtcclxuXHRcdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGJiO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5wb2x5Z29uLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5wb2x5bGluZTtcclxuXHJcblx0XHQvLyBwYXRoIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LnBhdGggPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dmFyIGQgPSB0aGlzLmF0dHJpYnV0ZSgnZCcpLnZhbHVlO1xyXG5cdFx0XHQvLyBUT0RPOiBjb252ZXJ0IHRvIHJlYWwgbGV4ZXIgYmFzZWQgb24gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvcGF0aHMuaHRtbCNQYXRoRGF0YUJORlxyXG5cdFx0XHRkID0gZC5yZXBsYWNlKC8sL2dtLCcgJyk7IC8vIGdldCByaWQgb2YgYWxsIGNvbW1hc1xyXG5cdFx0XHQvLyBBcyB0aGUgZW5kIG9mIGEgbWF0Y2ggY2FuIGFsc28gYmUgdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IG1hdGNoLCB3ZSBuZWVkIHRvIHJ1biB0aGlzIHJlcGxhY2UgdHdpY2UuXHJcblx0XHRcdGZvcih2YXIgaT0wOyBpPDI7IGkrKylcclxuXHRcdFx0XHRkID0gZC5yZXBsYWNlKC8oW01tWnpMbEhoVnZDY1NzUXFUdEFhXSkoW15cXHNdKS9nbSwnJDEgJDInKTsgLy8gc3VmZml4IGNvbW1hbmRzIHdpdGggc3BhY2VzXHJcblx0XHRcdGQgPSBkLnJlcGxhY2UoLyhbXlxcc10pKFtNbVp6TGxIaFZ2Q2NTc1FxVHRBYV0pL2dtLCckMSAkMicpOyAvLyBwcmVmaXggY29tbWFuZHMgd2l0aCBzcGFjZXNcclxuXHRcdFx0ZCA9IGQucmVwbGFjZSgvKFswLTldKShbK1xcLV0pL2dtLCckMSAkMicpOyAvLyBzZXBhcmF0ZSBkaWdpdHMgb24gKy0gc2lnbnNcclxuXHRcdFx0Ly8gQWdhaW4sIHdlIG5lZWQgdG8gcnVuIHRoaXMgdHdpY2UgdG8gZmluZCBhbGwgb2NjdXJhbmNlc1xyXG5cdFx0XHRmb3IodmFyIGk9MDsgaTwyOyBpKyspXHJcblx0XHRcdFx0ZCA9IGQucmVwbGFjZSgvKFxcLlswLTldKikoXFwuKS9nbSwnJDEgJDInKTsgLy8gc2VwYXJhdGUgZGlnaXRzIHdoZW4gdGhleSBzdGFydCB3aXRoIGEgY29tbWFcclxuXHRcdFx0ZCA9IGQucmVwbGFjZSgvKFtBYV0oXFxzK1swLTldKyl7M30pXFxzKyhbMDFdKVxccyooWzAxXSkvZ20sJyQxICQzICQ0ICcpOyAvLyBzaG9ydGhhbmQgZWxsaXB0aWNhbCBhcmMgcGF0aCBzeW50YXhcclxuXHRcdFx0ZCA9IHN2Zy5jb21wcmVzc1NwYWNlcyhkKTsgLy8gY29tcHJlc3MgbXVsdGlwbGUgc3BhY2VzXHJcblx0XHRcdGQgPSBzdmcudHJpbShkKTtcclxuXHRcdFx0dGhpcy5QYXRoUGFyc2VyID0gbmV3IChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0dGhpcy50b2tlbnMgPSBkLnNwbGl0KCcgJyk7XHJcblxyXG5cdFx0XHRcdHRoaXMucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHRoaXMuaSA9IC0xO1xyXG5cdFx0XHRcdFx0dGhpcy5jb21tYW5kID0gJyc7XHJcblx0XHRcdFx0XHR0aGlzLnByZXZpb3VzQ29tbWFuZCA9ICcnO1xyXG5cdFx0XHRcdFx0dGhpcy5zdGFydCA9IG5ldyBzdmcuUG9pbnQoMCwgMCk7XHJcblx0XHRcdFx0XHR0aGlzLmNvbnRyb2wgPSBuZXcgc3ZnLlBvaW50KDAsIDApO1xyXG5cdFx0XHRcdFx0dGhpcy5jdXJyZW50ID0gbmV3IHN2Zy5Qb2ludCgwLCAwKTtcclxuXHRcdFx0XHRcdHRoaXMucG9pbnRzID0gW107XHJcblx0XHRcdFx0XHR0aGlzLmFuZ2xlcyA9IFtdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5pc0VuZCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuaSA+PSB0aGlzLnRva2Vucy5sZW5ndGggLSAxO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5pc0NvbW1hbmRPckVuZCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMuaXNFbmQoKSkgcmV0dXJuIHRydWU7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5pICsgMV0ubWF0Y2goL15bQS1aYS16XSQvKSAhPSBudWxsO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5pc1JlbGF0aXZlQ29tbWFuZCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0c3dpdGNoKHRoaXMuY29tbWFuZClcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0Y2FzZSAnbSc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ2wnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdoJzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAndic6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ2MnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdzJzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAncSc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ3QnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdhJzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAneic6XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmdldFRva2VuID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR0aGlzLmkrKztcclxuXHRcdFx0XHRcdHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLmldO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5nZXRTY2FsYXIgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHJldHVybiBwYXJzZUZsb2F0KHRoaXMuZ2V0VG9rZW4oKSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLm5leHRDb21tYW5kID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR0aGlzLnByZXZpb3VzQ29tbWFuZCA9IHRoaXMuY29tbWFuZDtcclxuXHRcdFx0XHRcdHRoaXMuY29tbWFuZCA9IHRoaXMuZ2V0VG9rZW4oKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuZ2V0UG9pbnQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHZhciBwID0gbmV3IHN2Zy5Qb2ludCh0aGlzLmdldFNjYWxhcigpLCB0aGlzLmdldFNjYWxhcigpKTtcclxuXHRcdFx0XHRcdHJldHVybiB0aGlzLm1ha2VBYnNvbHV0ZShwKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuZ2V0QXNDb250cm9sUG9pbnQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHZhciBwID0gdGhpcy5nZXRQb2ludCgpO1xyXG5cdFx0XHRcdFx0dGhpcy5jb250cm9sID0gcDtcclxuXHRcdFx0XHRcdHJldHVybiBwO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5nZXRBc0N1cnJlbnRQb2ludCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0dmFyIHAgPSB0aGlzLmdldFBvaW50KCk7XHJcblx0XHRcdFx0XHR0aGlzLmN1cnJlbnQgPSBwO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHA7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmdldFJlZmxlY3RlZENvbnRyb2xQb2ludCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMucHJldmlvdXNDb21tYW5kLnRvTG93ZXJDYXNlKCkgIT0gJ2MnICYmXHJcblx0XHRcdFx0XHQgICAgdGhpcy5wcmV2aW91c0NvbW1hbmQudG9Mb3dlckNhc2UoKSAhPSAncycgJiZcclxuXHRcdFx0XHRcdFx0dGhpcy5wcmV2aW91c0NvbW1hbmQudG9Mb3dlckNhc2UoKSAhPSAncScgJiZcclxuXHRcdFx0XHRcdFx0dGhpcy5wcmV2aW91c0NvbW1hbmQudG9Mb3dlckNhc2UoKSAhPSAndCcgKXtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY3VycmVudDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyByZWZsZWN0IHBvaW50XHJcblx0XHRcdFx0XHR2YXIgcCA9IG5ldyBzdmcuUG9pbnQoMiAqIHRoaXMuY3VycmVudC54IC0gdGhpcy5jb250cm9sLngsIDIgKiB0aGlzLmN1cnJlbnQueSAtIHRoaXMuY29udHJvbC55KTtcclxuXHRcdFx0XHRcdHJldHVybiBwO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5tYWtlQWJzb2x1dGUgPSBmdW5jdGlvbihwKSB7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5pc1JlbGF0aXZlQ29tbWFuZCgpKSB7XHJcblx0XHRcdFx0XHRcdHAueCArPSB0aGlzLmN1cnJlbnQueDtcclxuXHRcdFx0XHRcdFx0cC55ICs9IHRoaXMuY3VycmVudC55O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIHA7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmFkZE1hcmtlciA9IGZ1bmN0aW9uKHAsIGZyb20sIHByaW9yVG8pIHtcclxuXHRcdFx0XHRcdC8vIGlmIHRoZSBsYXN0IGFuZ2xlIGlzbid0IGZpbGxlZCBpbiBiZWNhdXNlIHdlIGRpZG4ndCBoYXZlIHRoaXMgcG9pbnQgeWV0IC4uLlxyXG5cdFx0XHRcdFx0aWYgKHByaW9yVG8gIT0gbnVsbCAmJiB0aGlzLmFuZ2xlcy5sZW5ndGggPiAwICYmIHRoaXMuYW5nbGVzW3RoaXMuYW5nbGVzLmxlbmd0aC0xXSA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuYW5nbGVzW3RoaXMuYW5nbGVzLmxlbmd0aC0xXSA9IHRoaXMucG9pbnRzW3RoaXMucG9pbnRzLmxlbmd0aC0xXS5hbmdsZVRvKHByaW9yVG8pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhpcy5hZGRNYXJrZXJBbmdsZShwLCBmcm9tID09IG51bGwgPyBudWxsIDogZnJvbS5hbmdsZVRvKHApKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuYWRkTWFya2VyQW5nbGUgPSBmdW5jdGlvbihwLCBhKSB7XHJcblx0XHRcdFx0XHR0aGlzLnBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHRcdFx0dGhpcy5hbmdsZXMucHVzaChhKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuZ2V0TWFya2VyUG9pbnRzID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnBvaW50czsgfVxyXG5cdFx0XHRcdHRoaXMuZ2V0TWFya2VyQW5nbGVzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8dGhpcy5hbmdsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuYW5nbGVzW2ldID09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBqPWkrMTsgajx0aGlzLmFuZ2xlcy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuYW5nbGVzW2pdICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5hbmdsZXNbaV0gPSB0aGlzLmFuZ2xlc1tqXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hbmdsZXM7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KShkKTtcclxuXHJcblx0XHRcdHRoaXMucGF0aCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdHZhciBwcCA9IHRoaXMuUGF0aFBhcnNlcjtcclxuXHRcdFx0XHRwcC5yZXNldCgpO1xyXG5cclxuXHRcdFx0XHR2YXIgYmIgPSBuZXcgc3ZnLkJvdW5kaW5nQm94KCk7XHJcblx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSBjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRcdFx0d2hpbGUgKCFwcC5pc0VuZCgpKSB7XHJcblx0XHRcdFx0XHRwcC5uZXh0Q29tbWFuZCgpO1xyXG5cdFx0XHRcdFx0c3dpdGNoIChwcC5jb21tYW5kKSB7XHJcblx0XHRcdFx0XHRjYXNlICdNJzpcclxuXHRcdFx0XHRcdGNhc2UgJ20nOlxyXG5cdFx0XHRcdFx0XHR2YXIgcCA9IHBwLmdldEFzQ3VycmVudFBvaW50KCk7XHJcblx0XHRcdFx0XHRcdHBwLmFkZE1hcmtlcihwKTtcclxuXHRcdFx0XHRcdFx0YmIuYWRkUG9pbnQocC54LCBwLnkpO1xyXG5cdFx0XHRcdFx0XHRpZiAoY3R4ICE9IG51bGwpIGN0eC5tb3ZlVG8ocC54LCBwLnkpO1xyXG5cdFx0XHRcdFx0XHRwcC5zdGFydCA9IHBwLmN1cnJlbnQ7XHJcblx0XHRcdFx0XHRcdHdoaWxlICghcHAuaXNDb21tYW5kT3JFbmQoKSkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBwID0gcHAuZ2V0QXNDdXJyZW50UG9pbnQoKTtcclxuXHRcdFx0XHRcdFx0XHRwcC5hZGRNYXJrZXIocCwgcHAuc3RhcnQpO1xyXG5cdFx0XHRcdFx0XHRcdGJiLmFkZFBvaW50KHAueCwgcC55KTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoY3R4ICE9IG51bGwpIGN0eC5saW5lVG8ocC54LCBwLnkpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnTCc6XHJcblx0XHRcdFx0XHRjYXNlICdsJzpcclxuXHRcdFx0XHRcdFx0d2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGMgPSBwcC5jdXJyZW50O1xyXG5cdFx0XHRcdFx0XHRcdHZhciBwID0gcHAuZ2V0QXNDdXJyZW50UG9pbnQoKTtcclxuXHRcdFx0XHRcdFx0XHRwcC5hZGRNYXJrZXIocCwgYyk7XHJcblx0XHRcdFx0XHRcdFx0YmIuYWRkUG9pbnQocC54LCBwLnkpO1xyXG5cdFx0XHRcdFx0XHRcdGlmIChjdHggIT0gbnVsbCkgY3R4LmxpbmVUbyhwLngsIHAueSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdIJzpcclxuXHRcdFx0XHRcdGNhc2UgJ2gnOlxyXG5cdFx0XHRcdFx0XHR3aGlsZSAoIXBwLmlzQ29tbWFuZE9yRW5kKCkpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgbmV3UCA9IG5ldyBzdmcuUG9pbnQoKHBwLmlzUmVsYXRpdmVDb21tYW5kKCkgPyBwcC5jdXJyZW50LnggOiAwKSArIHBwLmdldFNjYWxhcigpLCBwcC5jdXJyZW50LnkpO1xyXG5cdFx0XHRcdFx0XHRcdHBwLmFkZE1hcmtlcihuZXdQLCBwcC5jdXJyZW50KTtcclxuXHRcdFx0XHRcdFx0XHRwcC5jdXJyZW50ID0gbmV3UDtcclxuXHRcdFx0XHRcdFx0XHRiYi5hZGRQb2ludChwcC5jdXJyZW50LngsIHBwLmN1cnJlbnQueSk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSBjdHgubGluZVRvKHBwLmN1cnJlbnQueCwgcHAuY3VycmVudC55KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ1YnOlxyXG5cdFx0XHRcdFx0Y2FzZSAndic6XHJcblx0XHRcdFx0XHRcdHdoaWxlICghcHAuaXNDb21tYW5kT3JFbmQoKSkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBuZXdQID0gbmV3IHN2Zy5Qb2ludChwcC5jdXJyZW50LngsIChwcC5pc1JlbGF0aXZlQ29tbWFuZCgpID8gcHAuY3VycmVudC55IDogMCkgKyBwcC5nZXRTY2FsYXIoKSk7XHJcblx0XHRcdFx0XHRcdFx0cHAuYWRkTWFya2VyKG5ld1AsIHBwLmN1cnJlbnQpO1xyXG5cdFx0XHRcdFx0XHRcdHBwLmN1cnJlbnQgPSBuZXdQO1xyXG5cdFx0XHRcdFx0XHRcdGJiLmFkZFBvaW50KHBwLmN1cnJlbnQueCwgcHAuY3VycmVudC55KTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoY3R4ICE9IG51bGwpIGN0eC5saW5lVG8ocHAuY3VycmVudC54LCBwcC5jdXJyZW50LnkpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnQyc6XHJcblx0XHRcdFx0XHRjYXNlICdjJzpcclxuXHRcdFx0XHRcdFx0d2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGN1cnIgPSBwcC5jdXJyZW50O1xyXG5cdFx0XHRcdFx0XHRcdHZhciBwMSA9IHBwLmdldFBvaW50KCk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGNudHJsID0gcHAuZ2V0QXNDb250cm9sUG9pbnQoKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY3AgPSBwcC5nZXRBc0N1cnJlbnRQb2ludCgpO1xyXG5cdFx0XHRcdFx0XHRcdHBwLmFkZE1hcmtlcihjcCwgY250cmwsIHAxKTtcclxuXHRcdFx0XHRcdFx0XHRiYi5hZGRCZXppZXJDdXJ2ZShjdXJyLngsIGN1cnIueSwgcDEueCwgcDEueSwgY250cmwueCwgY250cmwueSwgY3AueCwgY3AueSk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSBjdHguYmV6aWVyQ3VydmVUbyhwMS54LCBwMS55LCBjbnRybC54LCBjbnRybC55LCBjcC54LCBjcC55KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ1MnOlxyXG5cdFx0XHRcdFx0Y2FzZSAncyc6XHJcblx0XHRcdFx0XHRcdHdoaWxlICghcHAuaXNDb21tYW5kT3JFbmQoKSkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjdXJyID0gcHAuY3VycmVudDtcclxuXHRcdFx0XHRcdFx0XHR2YXIgcDEgPSBwcC5nZXRSZWZsZWN0ZWRDb250cm9sUG9pbnQoKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY250cmwgPSBwcC5nZXRBc0NvbnRyb2xQb2ludCgpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjcCA9IHBwLmdldEFzQ3VycmVudFBvaW50KCk7XHJcblx0XHRcdFx0XHRcdFx0cHAuYWRkTWFya2VyKGNwLCBjbnRybCwgcDEpO1xyXG5cdFx0XHRcdFx0XHRcdGJiLmFkZEJlemllckN1cnZlKGN1cnIueCwgY3Vyci55LCBwMS54LCBwMS55LCBjbnRybC54LCBjbnRybC55LCBjcC54LCBjcC55KTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoY3R4ICE9IG51bGwpIGN0eC5iZXppZXJDdXJ2ZVRvKHAxLngsIHAxLnksIGNudHJsLngsIGNudHJsLnksIGNwLngsIGNwLnkpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnUSc6XHJcblx0XHRcdFx0XHRjYXNlICdxJzpcclxuXHRcdFx0XHRcdFx0d2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGN1cnIgPSBwcC5jdXJyZW50O1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjbnRybCA9IHBwLmdldEFzQ29udHJvbFBvaW50KCk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGNwID0gcHAuZ2V0QXNDdXJyZW50UG9pbnQoKTtcclxuXHRcdFx0XHRcdFx0XHRwcC5hZGRNYXJrZXIoY3AsIGNudHJsLCBjbnRybCk7XHJcblx0XHRcdFx0XHRcdFx0YmIuYWRkUXVhZHJhdGljQ3VydmUoY3Vyci54LCBjdXJyLnksIGNudHJsLngsIGNudHJsLnksIGNwLngsIGNwLnkpO1xyXG5cdFx0XHRcdFx0XHRcdGlmIChjdHggIT0gbnVsbCkgY3R4LnF1YWRyYXRpY0N1cnZlVG8oY250cmwueCwgY250cmwueSwgY3AueCwgY3AueSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdUJzpcclxuXHRcdFx0XHRcdGNhc2UgJ3QnOlxyXG5cdFx0XHRcdFx0XHR3aGlsZSAoIXBwLmlzQ29tbWFuZE9yRW5kKCkpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY3VyciA9IHBwLmN1cnJlbnQ7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGNudHJsID0gcHAuZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCk7XHJcblx0XHRcdFx0XHRcdFx0cHAuY29udHJvbCA9IGNudHJsO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjcCA9IHBwLmdldEFzQ3VycmVudFBvaW50KCk7XHJcblx0XHRcdFx0XHRcdFx0cHAuYWRkTWFya2VyKGNwLCBjbnRybCwgY250cmwpO1xyXG5cdFx0XHRcdFx0XHRcdGJiLmFkZFF1YWRyYXRpY0N1cnZlKGN1cnIueCwgY3Vyci55LCBjbnRybC54LCBjbnRybC55LCBjcC54LCBjcC55KTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoY3R4ICE9IG51bGwpIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNudHJsLngsIGNudHJsLnksIGNwLngsIGNwLnkpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnQSc6XHJcblx0XHRcdFx0XHRjYXNlICdhJzpcclxuXHRcdFx0XHRcdFx0d2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XHJcblx0XHRcdFx0XHRcdCAgICB2YXIgY3VyciA9IHBwLmN1cnJlbnQ7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHJ4ID0gcHAuZ2V0U2NhbGFyKCk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHJ5ID0gcHAuZ2V0U2NhbGFyKCk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHhBeGlzUm90YXRpb24gPSBwcC5nZXRTY2FsYXIoKSAqIChNYXRoLlBJIC8gMTgwLjApO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBsYXJnZUFyY0ZsYWcgPSBwcC5nZXRTY2FsYXIoKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgc3dlZXBGbGFnID0gcHAuZ2V0U2NhbGFyKCk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGNwID0gcHAuZ2V0QXNDdXJyZW50UG9pbnQoKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gQ29udmVyc2lvbiBmcm9tIGVuZHBvaW50IHRvIGNlbnRlciBwYXJhbWV0ZXJpemF0aW9uXHJcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzXHJcblx0XHRcdFx0XHRcdFx0Ly8geDEnLCB5MSdcclxuXHRcdFx0XHRcdFx0XHR2YXIgY3VycnAgPSBuZXcgc3ZnLlBvaW50KFxyXG5cdFx0XHRcdFx0XHRcdFx0TWF0aC5jb3MoeEF4aXNSb3RhdGlvbikgKiAoY3Vyci54IC0gY3AueCkgLyAyLjAgKyBNYXRoLnNpbih4QXhpc1JvdGF0aW9uKSAqIChjdXJyLnkgLSBjcC55KSAvIDIuMCxcclxuXHRcdFx0XHRcdFx0XHRcdC1NYXRoLnNpbih4QXhpc1JvdGF0aW9uKSAqIChjdXJyLnggLSBjcC54KSAvIDIuMCArIE1hdGguY29zKHhBeGlzUm90YXRpb24pICogKGN1cnIueSAtIGNwLnkpIC8gMi4wXHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0XHQvLyBhZGp1c3QgcmFkaWlcclxuXHRcdFx0XHRcdFx0XHR2YXIgbCA9IE1hdGgucG93KGN1cnJwLngsMikvTWF0aC5wb3cocngsMikrTWF0aC5wb3coY3VycnAueSwyKS9NYXRoLnBvdyhyeSwyKTtcclxuXHRcdFx0XHRcdFx0XHRpZiAobCA+IDEpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHJ4ICo9IE1hdGguc3FydChsKTtcclxuXHRcdFx0XHRcdFx0XHRcdHJ5ICo9IE1hdGguc3FydChsKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0Ly8gY3gnLCBjeSdcclxuXHRcdFx0XHRcdFx0XHR2YXIgcyA9IChsYXJnZUFyY0ZsYWcgPT0gc3dlZXBGbGFnID8gLTEgOiAxKSAqIE1hdGguc3FydChcclxuXHRcdFx0XHRcdFx0XHRcdCgoTWF0aC5wb3cocngsMikqTWF0aC5wb3cocnksMikpLShNYXRoLnBvdyhyeCwyKSpNYXRoLnBvdyhjdXJycC55LDIpKS0oTWF0aC5wb3cocnksMikqTWF0aC5wb3coY3VycnAueCwyKSkpIC9cclxuXHRcdFx0XHRcdFx0XHRcdChNYXRoLnBvdyhyeCwyKSpNYXRoLnBvdyhjdXJycC55LDIpK01hdGgucG93KHJ5LDIpKk1hdGgucG93KGN1cnJwLngsMikpXHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoaXNOYU4ocykpIHMgPSAwO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjcHAgPSBuZXcgc3ZnLlBvaW50KHMgKiByeCAqIGN1cnJwLnkgLyByeSwgcyAqIC1yeSAqIGN1cnJwLnggLyByeCk7XHJcblx0XHRcdFx0XHRcdFx0Ly8gY3gsIGN5XHJcblx0XHRcdFx0XHRcdFx0dmFyIGNlbnRwID0gbmV3IHN2Zy5Qb2ludChcclxuXHRcdFx0XHRcdFx0XHRcdChjdXJyLnggKyBjcC54KSAvIDIuMCArIE1hdGguY29zKHhBeGlzUm90YXRpb24pICogY3BwLnggLSBNYXRoLnNpbih4QXhpc1JvdGF0aW9uKSAqIGNwcC55LFxyXG5cdFx0XHRcdFx0XHRcdFx0KGN1cnIueSArIGNwLnkpIC8gMi4wICsgTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikgKiBjcHAueCArIE1hdGguY29zKHhBeGlzUm90YXRpb24pICogY3BwLnlcclxuXHRcdFx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0XHRcdC8vIHZlY3RvciBtYWduaXR1ZGVcclxuXHRcdFx0XHRcdFx0XHR2YXIgbSA9IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh2WzBdLDIpICsgTWF0aC5wb3codlsxXSwyKSk7IH1cclxuXHRcdFx0XHRcdFx0XHQvLyByYXRpbyBiZXR3ZWVuIHR3byB2ZWN0b3JzXHJcblx0XHRcdFx0XHRcdFx0dmFyIHIgPSBmdW5jdGlvbih1LCB2KSB7IHJldHVybiAodVswXSp2WzBdK3VbMV0qdlsxXSkgLyAobSh1KSptKHYpKSB9XHJcblx0XHRcdFx0XHRcdFx0Ly8gYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9yc1xyXG5cdFx0XHRcdFx0XHRcdHZhciBhID0gZnVuY3Rpb24odSwgdikgeyByZXR1cm4gKHVbMF0qdlsxXSA8IHVbMV0qdlswXSA/IC0xIDogMSkgKiBNYXRoLmFjb3Mocih1LHYpKTsgfVxyXG5cdFx0XHRcdFx0XHRcdC8vIGluaXRpYWwgYW5nbGVcclxuXHRcdFx0XHRcdFx0XHR2YXIgYTEgPSBhKFsxLDBdLCBbKGN1cnJwLngtY3BwLngpL3J4LChjdXJycC55LWNwcC55KS9yeV0pO1xyXG5cdFx0XHRcdFx0XHRcdC8vIGFuZ2xlIGRlbHRhXHJcblx0XHRcdFx0XHRcdFx0dmFyIHUgPSBbKGN1cnJwLngtY3BwLngpL3J4LChjdXJycC55LWNwcC55KS9yeV07XHJcblx0XHRcdFx0XHRcdFx0dmFyIHYgPSBbKC1jdXJycC54LWNwcC54KS9yeCwoLWN1cnJwLnktY3BwLnkpL3J5XTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgYWQgPSBhKHUsIHYpO1xyXG5cdFx0XHRcdFx0XHRcdGlmIChyKHUsdikgPD0gLTEpIGFkID0gTWF0aC5QSTtcclxuXHRcdFx0XHRcdFx0XHRpZiAocih1LHYpID49IDEpIGFkID0gMDtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gZm9yIG1hcmtlcnNcclxuXHRcdFx0XHRcdFx0XHR2YXIgZGlyID0gMSAtIHN3ZWVwRmxhZyA/IDEuMCA6IC0xLjA7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGFoID0gYTEgKyBkaXIgKiAoYWQgLyAyLjApO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBoYWxmV2F5ID0gbmV3IHN2Zy5Qb2ludChcclxuXHRcdFx0XHRcdFx0XHRcdGNlbnRwLnggKyByeCAqIE1hdGguY29zKGFoKSxcclxuXHRcdFx0XHRcdFx0XHRcdGNlbnRwLnkgKyByeSAqIE1hdGguc2luKGFoKVxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdFx0cHAuYWRkTWFya2VyQW5nbGUoaGFsZldheSwgYWggLSBkaXIgKiBNYXRoLlBJIC8gMik7XHJcblx0XHRcdFx0XHRcdFx0cHAuYWRkTWFya2VyQW5nbGUoY3AsIGFoIC0gZGlyICogTWF0aC5QSSk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGJiLmFkZFBvaW50KGNwLngsIGNwLnkpOyAvLyBUT0RPOiB0aGlzIGlzIHRvbyBuYWl2ZSwgbWFrZSBpdCBiZXR0ZXJcclxuXHRcdFx0XHRcdFx0XHRpZiAoY3R4ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciByID0gcnggPiByeSA/IHJ4IDogcnk7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgc3ggPSByeCA+IHJ5ID8gMSA6IHJ4IC8gcnk7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgc3kgPSByeCA+IHJ5ID8gcnkgLyByeCA6IDE7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZShjZW50cC54LCBjZW50cC55KTtcclxuXHRcdFx0XHRcdFx0XHRcdGN0eC5yb3RhdGUoeEF4aXNSb3RhdGlvbik7XHJcblx0XHRcdFx0XHRcdFx0XHRjdHguc2NhbGUoc3gsIHN5KTtcclxuXHRcdFx0XHRcdFx0XHRcdGN0eC5hcmMoMCwgMCwgciwgYTEsIGExICsgYWQsIDEgLSBzd2VlcEZsYWcpO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3R4LnNjYWxlKDEvc3gsIDEvc3kpO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3R4LnJvdGF0ZSgteEF4aXNSb3RhdGlvbik7XHJcblx0XHRcdFx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKC1jZW50cC54LCAtY2VudHAueSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnWic6XHJcblx0XHRcdFx0XHRjYXNlICd6JzpcclxuXHRcdFx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSBjdHguY2xvc2VQYXRoKCk7XHJcblx0XHRcdFx0XHRcdHBwLmN1cnJlbnQgPSBwcC5zdGFydDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBiYjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5nZXRNYXJrZXJzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIHBvaW50cyA9IHRoaXMuUGF0aFBhcnNlci5nZXRNYXJrZXJQb2ludHMoKTtcclxuXHRcdFx0XHR2YXIgYW5nbGVzID0gdGhpcy5QYXRoUGFyc2VyLmdldE1hcmtlckFuZ2xlcygpO1xyXG5cclxuXHRcdFx0XHR2YXIgbWFya2VycyA9IFtdO1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTxwb2ludHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdG1hcmtlcnMucHVzaChbcG9pbnRzW2ldLCBhbmdsZXNbaV1dKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIG1hcmtlcnM7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LnBhdGgucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBwYXR0ZXJuIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LnBhdHRlcm4gPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmNyZWF0ZVBhdHRlcm4gPSBmdW5jdGlvbihjdHgsIGVsZW1lbnQpIHtcclxuXHRcdFx0XHR2YXIgd2lkdGggPSB0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS50b1BpeGVscygneCcsIHRydWUpO1xyXG5cdFx0XHRcdHZhciBoZWlnaHQgPSB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knLCB0cnVlKTtcclxuXHJcblx0XHRcdFx0Ly8gcmVuZGVyIG1lIHVzaW5nIGEgdGVtcG9yYXJ5IHN2ZyBlbGVtZW50XHJcblx0XHRcdFx0dmFyIHRlbXBTdmcgPSBuZXcgc3ZnLkVsZW1lbnQuc3ZnKCk7XHJcblx0XHRcdFx0dGVtcFN2Zy5hdHRyaWJ1dGVzWyd2aWV3Qm94J10gPSBuZXcgc3ZnLlByb3BlcnR5KCd2aWV3Qm94JywgdGhpcy5hdHRyaWJ1dGUoJ3ZpZXdCb3gnKS52YWx1ZSk7XHJcblx0XHRcdFx0dGVtcFN2Zy5hdHRyaWJ1dGVzWyd3aWR0aCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnd2lkdGgnLCB3aWR0aCArICdweCcpO1xyXG5cdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1snaGVpZ2h0J10gPSBuZXcgc3ZnLlByb3BlcnR5KCdoZWlnaHQnLCBoZWlnaHQgKyAncHgnKTtcclxuXHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3RyYW5zZm9ybSddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgndHJhbnNmb3JtJywgdGhpcy5hdHRyaWJ1dGUoJ3BhdHRlcm5UcmFuc2Zvcm0nKS52YWx1ZSk7XHJcblx0XHRcdFx0dGVtcFN2Zy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcblxyXG5cdFx0XHRcdHZhciBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcblx0XHRcdFx0Yy53aWR0aCA9IHdpZHRoO1xyXG5cdFx0XHRcdGMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cdFx0XHRcdHZhciBjY3R4ID0gYy5nZXRDb250ZXh0KCcyZCcpO1xyXG5cdFx0XHRcdGlmICh0aGlzLmF0dHJpYnV0ZSgneCcpLmhhc1ZhbHVlKCkgJiYgdGhpcy5hdHRyaWJ1dGUoJ3knKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHRjY3R4LnRyYW5zbGF0ZSh0aGlzLmF0dHJpYnV0ZSgneCcpLnRvUGl4ZWxzKCd4JywgdHJ1ZSksIHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knLCB0cnVlKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIHJlbmRlciAzeDMgZ3JpZCBzbyB3aGVuIHdlIHRyYW5zZm9ybSB0aGVyZSdzIG5vIHdoaXRlIHNwYWNlIG9uIGVkZ2VzXHJcblx0XHRcdFx0Zm9yICh2YXIgeD0tMTsgeDw9MTsgeCsrKSB7XHJcblx0XHRcdFx0XHRmb3IgKHZhciB5PS0xOyB5PD0xOyB5KyspIHtcclxuXHRcdFx0XHRcdFx0Y2N0eC5zYXZlKCk7XHJcblx0XHRcdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1sneCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgneCcsIHggKiBjLndpZHRoKTtcclxuXHRcdFx0XHRcdFx0dGVtcFN2Zy5hdHRyaWJ1dGVzWyd5J10gPSBuZXcgc3ZnLlByb3BlcnR5KCd5JywgeSAqIGMuaGVpZ2h0KTtcclxuXHRcdFx0XHRcdFx0dGVtcFN2Zy5yZW5kZXIoY2N0eCk7XHJcblx0XHRcdFx0XHRcdGNjdHgucmVzdG9yZSgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKGMsICdyZXBlYXQnKTtcclxuXHRcdFx0XHRyZXR1cm4gcGF0dGVybjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQucGF0dGVybi5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gbWFya2VyIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50Lm1hcmtlciA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMuYmFzZVJlbmRlciA9IHRoaXMucmVuZGVyO1xyXG5cdFx0XHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKGN0eCwgcG9pbnQsIGFuZ2xlKSB7XHJcblx0XHRcdFx0Y3R4LnRyYW5zbGF0ZShwb2ludC54LCBwb2ludC55KTtcclxuXHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ29yaWVudCcpLnZhbHVlT3JEZWZhdWx0KCdhdXRvJykgPT0gJ2F1dG8nKSBjdHgucm90YXRlKGFuZ2xlKTtcclxuXHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ21hcmtlclVuaXRzJykudmFsdWVPckRlZmF1bHQoJ3N0cm9rZVdpZHRoJykgPT0gJ3N0cm9rZVdpZHRoJykgY3R4LnNjYWxlKGN0eC5saW5lV2lkdGgsIGN0eC5saW5lV2lkdGgpO1xyXG5cdFx0XHRcdGN0eC5zYXZlKCk7XHJcblxyXG5cdFx0XHRcdC8vIHJlbmRlciBtZSB1c2luZyBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudFxyXG5cdFx0XHRcdHZhciB0ZW1wU3ZnID0gbmV3IHN2Zy5FbGVtZW50LnN2ZygpO1xyXG5cdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1sndmlld0JveCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgndmlld0JveCcsIHRoaXMuYXR0cmlidXRlKCd2aWV3Qm94JykudmFsdWUpO1xyXG5cdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1sncmVmWCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgncmVmWCcsIHRoaXMuYXR0cmlidXRlKCdyZWZYJykudmFsdWUpO1xyXG5cdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1sncmVmWSddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgncmVmWScsIHRoaXMuYXR0cmlidXRlKCdyZWZZJykudmFsdWUpO1xyXG5cdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1snd2lkdGgnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3dpZHRoJywgdGhpcy5hdHRyaWJ1dGUoJ21hcmtlcldpZHRoJykudmFsdWUpO1xyXG5cdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1snaGVpZ2h0J10gPSBuZXcgc3ZnLlByb3BlcnR5KCdoZWlnaHQnLCB0aGlzLmF0dHJpYnV0ZSgnbWFya2VySGVpZ2h0JykudmFsdWUpO1xyXG5cdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1snZmlsbCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnZmlsbCcsIHRoaXMuYXR0cmlidXRlKCdmaWxsJykudmFsdWVPckRlZmF1bHQoJ2JsYWNrJykpO1xyXG5cdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1snc3Ryb2tlJ10gPSBuZXcgc3ZnLlByb3BlcnR5KCdzdHJva2UnLCB0aGlzLmF0dHJpYnV0ZSgnc3Ryb2tlJykudmFsdWVPckRlZmF1bHQoJ25vbmUnKSk7XHJcblx0XHRcdFx0dGVtcFN2Zy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcblx0XHRcdFx0dGVtcFN2Zy5yZW5kZXIoY3R4KTtcclxuXHJcblx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ21hcmtlclVuaXRzJykudmFsdWVPckRlZmF1bHQoJ3N0cm9rZVdpZHRoJykgPT0gJ3N0cm9rZVdpZHRoJykgY3R4LnNjYWxlKDEvY3R4LmxpbmVXaWR0aCwgMS9jdHgubGluZVdpZHRoKTtcclxuXHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ29yaWVudCcpLnZhbHVlT3JEZWZhdWx0KCdhdXRvJykgPT0gJ2F1dG8nKSBjdHgucm90YXRlKC1hbmdsZSk7XHJcblx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSgtcG9pbnQueCwgLXBvaW50LnkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5tYXJrZXIucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIGRlZmluaXRpb25zIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LmRlZnMgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdC8vIE5PT1BcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuZGVmcy5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gYmFzZSBmb3IgZ3JhZGllbnRzXHJcblx0XHRzdmcuRWxlbWVudC5HcmFkaWVudEJhc2UgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLnN0b3BzID0gW107XHJcblx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcclxuXHRcdFx0XHRpZiAoY2hpbGQudHlwZSA9PSAnc3RvcCcpIHRoaXMuc3RvcHMucHVzaChjaGlsZCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZ2V0R3JhZGllbnQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHQvLyBPVkVSUklERSBNRSFcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0dGhpcy5ncmFkaWVudFVuaXRzID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZSgnZ3JhZGllbnRVbml0cycpLnZhbHVlT3JEZWZhdWx0KCdvYmplY3RCb3VuZGluZ0JveCcpO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQgPSBbJ2dyYWRpZW50VW5pdHMnXTtcclxuXHRcdFx0XHJcblx0XHRcdHRoaXMuaW5oZXJpdFN0b3BDb250YWluZXIgPSBmdW5jdGlvbiAoc3RvcHNDb250YWluZXIpIHtcclxuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8dGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgYXR0cmlidXRlVG9Jbmhlcml0ID0gdGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0W2ldO1xyXG5cdFx0XHRcdFx0aWYgKCF0aGlzLmF0dHJpYnV0ZShhdHRyaWJ1dGVUb0luaGVyaXQpLmhhc1ZhbHVlKCkgJiYgc3RvcHNDb250YWluZXIuYXR0cmlidXRlKGF0dHJpYnV0ZVRvSW5oZXJpdCkuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmF0dHJpYnV0ZShhdHRyaWJ1dGVUb0luaGVyaXQsIHRydWUpLnZhbHVlID0gc3RvcHNDb250YWluZXIuYXR0cmlidXRlKGF0dHJpYnV0ZVRvSW5oZXJpdCkudmFsdWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmNyZWF0ZUdyYWRpZW50ID0gZnVuY3Rpb24oY3R4LCBlbGVtZW50LCBwYXJlbnRPcGFjaXR5UHJvcCkge1xyXG5cdFx0XHRcdHZhciBzdG9wc0NvbnRhaW5lciA9IHRoaXM7XHJcblx0XHRcdFx0aWYgKHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdHN0b3BzQ29udGFpbmVyID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xyXG5cdFx0XHRcdFx0dGhpcy5pbmhlcml0U3RvcENvbnRhaW5lcihzdG9wc0NvbnRhaW5lcik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgYWRkUGFyZW50T3BhY2l0eSA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG5cdFx0XHRcdFx0aWYgKHBhcmVudE9wYWNpdHlQcm9wLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHAgPSBuZXcgc3ZnLlByb3BlcnR5KCdjb2xvcicsIGNvbG9yKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHAuYWRkT3BhY2l0eShwYXJlbnRPcGFjaXR5UHJvcCkudmFsdWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gY29sb3I7XHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0dmFyIGcgPSB0aGlzLmdldEdyYWRpZW50KGN0eCwgZWxlbWVudCk7XHJcblx0XHRcdFx0aWYgKGcgPT0gbnVsbCkgcmV0dXJuIGFkZFBhcmVudE9wYWNpdHkoc3RvcHNDb250YWluZXIuc3RvcHNbc3RvcHNDb250YWluZXIuc3RvcHMubGVuZ3RoIC0gMV0uY29sb3IpO1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTxzdG9wc0NvbnRhaW5lci5zdG9wcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0Zy5hZGRDb2xvclN0b3Aoc3RvcHNDb250YWluZXIuc3RvcHNbaV0ub2Zmc2V0LCBhZGRQYXJlbnRPcGFjaXR5KHN0b3BzQ29udGFpbmVyLnN0b3BzW2ldLmNvbG9yKSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ2dyYWRpZW50VHJhbnNmb3JtJykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0Ly8gcmVuZGVyIGFzIHRyYW5zZm9ybWVkIHBhdHRlcm4gb24gdGVtcG9yYXJ5IGNhbnZhc1xyXG5cdFx0XHRcdFx0dmFyIHJvb3RWaWV3ID0gc3ZnLlZpZXdQb3J0LnZpZXdQb3J0c1swXTtcclxuXHJcblx0XHRcdFx0XHR2YXIgcmVjdCA9IG5ldyBzdmcuRWxlbWVudC5yZWN0KCk7XHJcblx0XHRcdFx0XHRyZWN0LmF0dHJpYnV0ZXNbJ3gnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3gnLCAtc3ZnLk1BWF9WSVJUVUFMX1BJWEVMUy8zLjApO1xyXG5cdFx0XHRcdFx0cmVjdC5hdHRyaWJ1dGVzWyd5J10gPSBuZXcgc3ZnLlByb3BlcnR5KCd5JywgLXN2Zy5NQVhfVklSVFVBTF9QSVhFTFMvMy4wKTtcclxuXHRcdFx0XHRcdHJlY3QuYXR0cmlidXRlc1snd2lkdGgnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3dpZHRoJywgc3ZnLk1BWF9WSVJUVUFMX1BJWEVMUyk7XHJcblx0XHRcdFx0XHRyZWN0LmF0dHJpYnV0ZXNbJ2hlaWdodCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnaGVpZ2h0Jywgc3ZnLk1BWF9WSVJUVUFMX1BJWEVMUyk7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGdyb3VwID0gbmV3IHN2Zy5FbGVtZW50LmcoKTtcclxuXHRcdFx0XHRcdGdyb3VwLmF0dHJpYnV0ZXNbJ3RyYW5zZm9ybSddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgndHJhbnNmb3JtJywgdGhpcy5hdHRyaWJ1dGUoJ2dyYWRpZW50VHJhbnNmb3JtJykudmFsdWUpO1xyXG5cdFx0XHRcdFx0Z3JvdXAuY2hpbGRyZW4gPSBbIHJlY3QgXTtcclxuXHJcblx0XHRcdFx0XHR2YXIgdGVtcFN2ZyA9IG5ldyBzdmcuRWxlbWVudC5zdmcoKTtcclxuXHRcdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1sneCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgneCcsIDApO1xyXG5cdFx0XHRcdFx0dGVtcFN2Zy5hdHRyaWJ1dGVzWyd5J10gPSBuZXcgc3ZnLlByb3BlcnR5KCd5JywgMCk7XHJcblx0XHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3dpZHRoJ10gPSBuZXcgc3ZnLlByb3BlcnR5KCd3aWR0aCcsIHJvb3RWaWV3LndpZHRoKTtcclxuXHRcdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1snaGVpZ2h0J10gPSBuZXcgc3ZnLlByb3BlcnR5KCdoZWlnaHQnLCByb290Vmlldy5oZWlnaHQpO1xyXG5cdFx0XHRcdFx0dGVtcFN2Zy5jaGlsZHJlbiA9IFsgZ3JvdXAgXTtcclxuXHJcblx0XHRcdFx0XHR2YXIgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG5cdFx0XHRcdFx0Yy53aWR0aCA9IHJvb3RWaWV3LndpZHRoO1xyXG5cdFx0XHRcdFx0Yy5oZWlnaHQgPSByb290Vmlldy5oZWlnaHQ7XHJcblx0XHRcdFx0XHR2YXIgdGVtcEN0eCA9IGMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHRcdFx0XHRcdHRlbXBDdHguZmlsbFN0eWxlID0gZztcclxuXHRcdFx0XHRcdHRlbXBTdmcucmVuZGVyKHRlbXBDdHgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRlbXBDdHguY3JlYXRlUGF0dGVybihjLCAnbm8tcmVwZWF0Jyk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gZztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuR3JhZGllbnRCYXNlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBsaW5lYXIgZ3JhZGllbnQgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQubGluZWFyR3JhZGllbnQgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkdyYWRpZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cdFx0XHRcclxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LnB1c2goJ3gxJyk7XHJcblx0XHRcdHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5wdXNoKCd5MScpO1xyXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQucHVzaCgneDInKTtcclxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LnB1c2goJ3kyJyk7XHJcblxyXG5cdFx0XHR0aGlzLmdldEdyYWRpZW50ID0gZnVuY3Rpb24oY3R4LCBlbGVtZW50KSB7XHJcblx0XHRcdFx0dmFyIGJiID0gdGhpcy5ncmFkaWVudFVuaXRzKCkgPT0gJ29iamVjdEJvdW5kaW5nQm94JyA/IGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goKSA6IG51bGw7XHJcblxyXG5cdFx0XHRcdGlmICghdGhpcy5hdHRyaWJ1dGUoJ3gxJykuaGFzVmFsdWUoKVxyXG5cdFx0XHRcdCAmJiAhdGhpcy5hdHRyaWJ1dGUoJ3kxJykuaGFzVmFsdWUoKVxyXG5cdFx0XHRcdCAmJiAhdGhpcy5hdHRyaWJ1dGUoJ3gyJykuaGFzVmFsdWUoKVxyXG5cdFx0XHRcdCAmJiAhdGhpcy5hdHRyaWJ1dGUoJ3kyJykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUoJ3gxJywgdHJ1ZSkudmFsdWUgPSAwO1xyXG5cdFx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUoJ3kxJywgdHJ1ZSkudmFsdWUgPSAwO1xyXG5cdFx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUoJ3gyJywgdHJ1ZSkudmFsdWUgPSAxO1xyXG5cdFx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUoJ3kyJywgdHJ1ZSkudmFsdWUgPSAwO1xyXG5cdFx0XHRcdCB9XHJcblxyXG5cdFx0XHRcdHZhciB4MSA9ICh0aGlzLmdyYWRpZW50VW5pdHMoKSA9PSAnb2JqZWN0Qm91bmRpbmdCb3gnXHJcblx0XHRcdFx0XHQ/IGJiLngoKSArIGJiLndpZHRoKCkgKiB0aGlzLmF0dHJpYnV0ZSgneDEnKS5udW1WYWx1ZSgpXHJcblx0XHRcdFx0XHQ6IHRoaXMuYXR0cmlidXRlKCd4MScpLnRvUGl4ZWxzKCd4JykpO1xyXG5cdFx0XHRcdHZhciB5MSA9ICh0aGlzLmdyYWRpZW50VW5pdHMoKSA9PSAnb2JqZWN0Qm91bmRpbmdCb3gnXHJcblx0XHRcdFx0XHQ/IGJiLnkoKSArIGJiLmhlaWdodCgpICogdGhpcy5hdHRyaWJ1dGUoJ3kxJykubnVtVmFsdWUoKVxyXG5cdFx0XHRcdFx0OiB0aGlzLmF0dHJpYnV0ZSgneTEnKS50b1BpeGVscygneScpKTtcclxuXHRcdFx0XHR2YXIgeDIgPSAodGhpcy5ncmFkaWVudFVuaXRzKCkgPT0gJ29iamVjdEJvdW5kaW5nQm94J1xyXG5cdFx0XHRcdFx0PyBiYi54KCkgKyBiYi53aWR0aCgpICogdGhpcy5hdHRyaWJ1dGUoJ3gyJykubnVtVmFsdWUoKVxyXG5cdFx0XHRcdFx0OiB0aGlzLmF0dHJpYnV0ZSgneDInKS50b1BpeGVscygneCcpKTtcclxuXHRcdFx0XHR2YXIgeTIgPSAodGhpcy5ncmFkaWVudFVuaXRzKCkgPT0gJ29iamVjdEJvdW5kaW5nQm94J1xyXG5cdFx0XHRcdFx0PyBiYi55KCkgKyBiYi5oZWlnaHQoKSAqIHRoaXMuYXR0cmlidXRlKCd5MicpLm51bVZhbHVlKClcclxuXHRcdFx0XHRcdDogdGhpcy5hdHRyaWJ1dGUoJ3kyJykudG9QaXhlbHMoJ3knKSk7XHJcblxyXG5cdFx0XHRcdGlmICh4MSA9PSB4MiAmJiB5MSA9PSB5MikgcmV0dXJuIG51bGw7XHJcblx0XHRcdFx0cmV0dXJuIGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4MSwgeTEsIHgyLCB5Mik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmxpbmVhckdyYWRpZW50LnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5HcmFkaWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gcmFkaWFsIGdyYWRpZW50IGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LnJhZGlhbEdyYWRpZW50ID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5HcmFkaWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHRcdFx0XHJcblx0XHRcdHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5wdXNoKCdjeCcpO1xyXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQucHVzaCgnY3knKTtcclxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LnB1c2goJ3InKTtcclxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LnB1c2goJ2Z4Jyk7XHJcblx0XHRcdHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5wdXNoKCdmeScpO1xyXG5cclxuXHRcdFx0dGhpcy5nZXRHcmFkaWVudCA9IGZ1bmN0aW9uKGN0eCwgZWxlbWVudCkge1xyXG5cdFx0XHRcdHZhciBiYiA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goKTtcclxuXHJcblx0XHRcdFx0aWYgKCF0aGlzLmF0dHJpYnV0ZSgnY3gnKS5oYXNWYWx1ZSgpKSB0aGlzLmF0dHJpYnV0ZSgnY3gnLCB0cnVlKS52YWx1ZSA9ICc1MCUnO1xyXG5cdFx0XHRcdGlmICghdGhpcy5hdHRyaWJ1dGUoJ2N5JykuaGFzVmFsdWUoKSkgdGhpcy5hdHRyaWJ1dGUoJ2N5JywgdHJ1ZSkudmFsdWUgPSAnNTAlJztcclxuXHRcdFx0XHRpZiAoIXRoaXMuYXR0cmlidXRlKCdyJykuaGFzVmFsdWUoKSkgdGhpcy5hdHRyaWJ1dGUoJ3InLCB0cnVlKS52YWx1ZSA9ICc1MCUnO1xyXG5cclxuXHRcdFx0XHR2YXIgY3ggPSAodGhpcy5ncmFkaWVudFVuaXRzKCkgPT0gJ29iamVjdEJvdW5kaW5nQm94J1xyXG5cdFx0XHRcdFx0PyBiYi54KCkgKyBiYi53aWR0aCgpICogdGhpcy5hdHRyaWJ1dGUoJ2N4JykubnVtVmFsdWUoKVxyXG5cdFx0XHRcdFx0OiB0aGlzLmF0dHJpYnV0ZSgnY3gnKS50b1BpeGVscygneCcpKTtcclxuXHRcdFx0XHR2YXIgY3kgPSAodGhpcy5ncmFkaWVudFVuaXRzKCkgPT0gJ29iamVjdEJvdW5kaW5nQm94J1xyXG5cdFx0XHRcdFx0PyBiYi55KCkgKyBiYi5oZWlnaHQoKSAqIHRoaXMuYXR0cmlidXRlKCdjeScpLm51bVZhbHVlKClcclxuXHRcdFx0XHRcdDogdGhpcy5hdHRyaWJ1dGUoJ2N5JykudG9QaXhlbHMoJ3knKSk7XHJcblxyXG5cdFx0XHRcdHZhciBmeCA9IGN4O1xyXG5cdFx0XHRcdHZhciBmeSA9IGN5O1xyXG5cdFx0XHRcdGlmICh0aGlzLmF0dHJpYnV0ZSgnZngnKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHRmeCA9ICh0aGlzLmdyYWRpZW50VW5pdHMoKSA9PSAnb2JqZWN0Qm91bmRpbmdCb3gnXHJcblx0XHRcdFx0XHQ/IGJiLngoKSArIGJiLndpZHRoKCkgKiB0aGlzLmF0dHJpYnV0ZSgnZngnKS5udW1WYWx1ZSgpXHJcblx0XHRcdFx0XHQ6IHRoaXMuYXR0cmlidXRlKCdmeCcpLnRvUGl4ZWxzKCd4JykpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ2Z5JykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0ZnkgPSAodGhpcy5ncmFkaWVudFVuaXRzKCkgPT0gJ29iamVjdEJvdW5kaW5nQm94J1xyXG5cdFx0XHRcdFx0PyBiYi55KCkgKyBiYi5oZWlnaHQoKSAqIHRoaXMuYXR0cmlidXRlKCdmeScpLm51bVZhbHVlKClcclxuXHRcdFx0XHRcdDogdGhpcy5hdHRyaWJ1dGUoJ2Z5JykudG9QaXhlbHMoJ3knKSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgciA9ICh0aGlzLmdyYWRpZW50VW5pdHMoKSA9PSAnb2JqZWN0Qm91bmRpbmdCb3gnXHJcblx0XHRcdFx0XHQ/IChiYi53aWR0aCgpICsgYmIuaGVpZ2h0KCkpIC8gMi4wICogdGhpcy5hdHRyaWJ1dGUoJ3InKS5udW1WYWx1ZSgpXHJcblx0XHRcdFx0XHQ6IHRoaXMuYXR0cmlidXRlKCdyJykudG9QaXhlbHMoKSk7XHJcblxyXG5cdFx0XHRcdHJldHVybiBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoZngsIGZ5LCAwLCBjeCwgY3ksIHIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5yYWRpYWxHcmFkaWVudC5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuR3JhZGllbnRCYXNlO1xyXG5cclxuXHRcdC8vIGdyYWRpZW50IHN0b3AgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQuc3RvcCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMub2Zmc2V0ID0gdGhpcy5hdHRyaWJ1dGUoJ29mZnNldCcpLm51bVZhbHVlKCk7XHJcblx0XHRcdGlmICh0aGlzLm9mZnNldCA8IDApIHRoaXMub2Zmc2V0ID0gMDtcclxuXHRcdFx0aWYgKHRoaXMub2Zmc2V0ID4gMSkgdGhpcy5vZmZzZXQgPSAxO1xyXG5cclxuXHRcdFx0dmFyIHN0b3BDb2xvciA9IHRoaXMuc3R5bGUoJ3N0b3AtY29sb3InLCB0cnVlKTtcclxuXHRcdFx0aWYgKHN0b3BDb2xvci52YWx1ZSA9PT0gJycpIHN0b3BDb2xvci52YWx1ZSA9ICcjMDAwJztcclxuXHRcdFx0aWYgKHRoaXMuc3R5bGUoJ3N0b3Atb3BhY2l0eScpLmhhc1ZhbHVlKCkpIHN0b3BDb2xvciA9IHN0b3BDb2xvci5hZGRPcGFjaXR5KHRoaXMuc3R5bGUoJ3N0b3Atb3BhY2l0eScpKTtcclxuXHRcdFx0dGhpcy5jb2xvciA9IHN0b3BDb2xvci52YWx1ZTtcclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LnN0b3AucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIGFuaW1hdGlvbiBiYXNlIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LkFuaW1hdGVCYXNlID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0c3ZnLkFuaW1hdGlvbnMucHVzaCh0aGlzKTtcclxuXHJcblx0XHRcdHRoaXMuZHVyYXRpb24gPSAwLjA7XHJcblx0XHRcdHRoaXMuYmVnaW4gPSB0aGlzLmF0dHJpYnV0ZSgnYmVnaW4nKS50b01pbGxpc2Vjb25kcygpO1xyXG5cdFx0XHR0aGlzLm1heER1cmF0aW9uID0gdGhpcy5iZWdpbiArIHRoaXMuYXR0cmlidXRlKCdkdXInKS50b01pbGxpc2Vjb25kcygpO1xyXG5cclxuXHRcdFx0dGhpcy5nZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciBhdHRyaWJ1dGVUeXBlID0gdGhpcy5hdHRyaWJ1dGUoJ2F0dHJpYnV0ZVR5cGUnKS52YWx1ZTtcclxuXHRcdFx0XHR2YXIgYXR0cmlidXRlTmFtZSA9IHRoaXMuYXR0cmlidXRlKCdhdHRyaWJ1dGVOYW1lJykudmFsdWU7XHJcblxyXG5cdFx0XHRcdGlmIChhdHRyaWJ1dGVUeXBlID09ICdDU1MnKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnQuc3R5bGUoYXR0cmlidXRlTmFtZSwgdHJ1ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB0aGlzLnBhcmVudC5hdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgdHJ1ZSk7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHR0aGlzLmluaXRpYWxWYWx1ZSA9IG51bGw7XHJcblx0XHRcdHRoaXMuaW5pdGlhbFVuaXRzID0gJyc7XHJcblx0XHRcdHRoaXMucmVtb3ZlZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0dGhpcy5jYWxjVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHQvLyBPVkVSUklERSBNRSFcclxuXHRcdFx0XHRyZXR1cm4gJyc7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMudXBkYXRlID0gZnVuY3Rpb24oZGVsdGEpIHtcclxuXHRcdFx0XHQvLyBzZXQgaW5pdGlhbCB2YWx1ZVxyXG5cdFx0XHRcdGlmICh0aGlzLmluaXRpYWxWYWx1ZSA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHR0aGlzLmluaXRpYWxWYWx1ZSA9IHRoaXMuZ2V0UHJvcGVydHkoKS52YWx1ZTtcclxuXHRcdFx0XHRcdHRoaXMuaW5pdGlhbFVuaXRzID0gdGhpcy5nZXRQcm9wZXJ0eSgpLmdldFVuaXRzKCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBpZiB3ZSdyZSBwYXN0IHRoZSBlbmQgdGltZVxyXG5cdFx0XHRcdGlmICh0aGlzLmR1cmF0aW9uID4gdGhpcy5tYXhEdXJhdGlvbikge1xyXG5cdFx0XHRcdFx0Ly8gbG9vcCBmb3IgaW5kZWZpbml0ZWx5IHJlcGVhdGluZyBhbmltYXRpb25zXHJcblx0XHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ3JlcGVhdENvdW50JykudmFsdWUgPT0gJ2luZGVmaW5pdGUnXHJcblx0XHRcdFx0XHQgfHwgdGhpcy5hdHRyaWJ1dGUoJ3JlcGVhdER1cicpLnZhbHVlID09ICdpbmRlZmluaXRlJykge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmR1cmF0aW9uID0gMC4wXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIGlmICh0aGlzLmF0dHJpYnV0ZSgnZmlsbCcpLnZhbHVlT3JEZWZhdWx0KCdyZW1vdmUnKSA9PSAnZnJlZXplJyAmJiAhdGhpcy5mcm96ZW4pIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5mcm96ZW4gPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnBhcmVudC5hbmltYXRpb25Gcm96ZW4gPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnBhcmVudC5hbmltYXRpb25Gcm96ZW5WYWx1ZSA9IHRoaXMuZ2V0UHJvcGVydHkoKS52YWx1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2UgaWYgKHRoaXMuYXR0cmlidXRlKCdmaWxsJykudmFsdWVPckRlZmF1bHQoJ3JlbW92ZScpID09ICdyZW1vdmUnICYmICF0aGlzLnJlbW92ZWQpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5yZW1vdmVkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0dGhpcy5nZXRQcm9wZXJ0eSgpLnZhbHVlID0gdGhpcy5wYXJlbnQuYW5pbWF0aW9uRnJvemVuID8gdGhpcy5wYXJlbnQuYW5pbWF0aW9uRnJvemVuVmFsdWUgOiB0aGlzLmluaXRpYWxWYWx1ZTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMuZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uICsgZGVsdGE7XHJcblxyXG5cdFx0XHRcdC8vIGlmIHdlJ3JlIHBhc3QgdGhlIGJlZ2luIHRpbWVcclxuXHRcdFx0XHR2YXIgdXBkYXRlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdGlmICh0aGlzLmJlZ2luIDwgdGhpcy5kdXJhdGlvbikge1xyXG5cdFx0XHRcdFx0dmFyIG5ld1ZhbHVlID0gdGhpcy5jYWxjVmFsdWUoKTsgLy8gdHdlZW5cclxuXHJcblx0XHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ3R5cGUnKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHRcdC8vIGZvciB0cmFuc2Zvcm0sIGV0Yy5cclxuXHRcdFx0XHRcdFx0dmFyIHR5cGUgPSB0aGlzLmF0dHJpYnV0ZSgndHlwZScpLnZhbHVlO1xyXG5cdFx0XHRcdFx0XHRuZXdWYWx1ZSA9IHR5cGUgKyAnKCcgKyBuZXdWYWx1ZSArICcpJztcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0aGlzLmdldFByb3BlcnR5KCkudmFsdWUgPSBuZXdWYWx1ZTtcclxuXHRcdFx0XHRcdHVwZGF0ZWQgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHVwZGF0ZWQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZnJvbSA9IHRoaXMuYXR0cmlidXRlKCdmcm9tJyk7XHJcblx0XHRcdHRoaXMudG8gPSB0aGlzLmF0dHJpYnV0ZSgndG8nKTtcclxuXHRcdFx0dGhpcy52YWx1ZXMgPSB0aGlzLmF0dHJpYnV0ZSgndmFsdWVzJyk7XHJcblx0XHRcdGlmICh0aGlzLnZhbHVlcy5oYXNWYWx1ZSgpKSB0aGlzLnZhbHVlcy52YWx1ZSA9IHRoaXMudmFsdWVzLnZhbHVlLnNwbGl0KCc7Jyk7XHJcblxyXG5cdFx0XHQvLyBmcmFjdGlvbiBvZiBkdXJhdGlvbiB3ZSd2ZSBjb3ZlcmVkXHJcblx0XHRcdHRoaXMucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgcmV0ID0geyBwcm9ncmVzczogKHRoaXMuZHVyYXRpb24gLSB0aGlzLmJlZ2luKSAvICh0aGlzLm1heER1cmF0aW9uIC0gdGhpcy5iZWdpbikgfTtcclxuXHRcdFx0XHRpZiAodGhpcy52YWx1ZXMuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0dmFyIHAgPSByZXQucHJvZ3Jlc3MgKiAodGhpcy52YWx1ZXMudmFsdWUubGVuZ3RoIC0gMSk7XHJcblx0XHRcdFx0XHR2YXIgbGIgPSBNYXRoLmZsb29yKHApLCB1YiA9IE1hdGguY2VpbChwKTtcclxuXHRcdFx0XHRcdHJldC5mcm9tID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnZnJvbScsIHBhcnNlRmxvYXQodGhpcy52YWx1ZXMudmFsdWVbbGJdKSk7XHJcblx0XHRcdFx0XHRyZXQudG8gPSBuZXcgc3ZnLlByb3BlcnR5KCd0bycsIHBhcnNlRmxvYXQodGhpcy52YWx1ZXMudmFsdWVbdWJdKSk7XHJcblx0XHRcdFx0XHRyZXQucHJvZ3Jlc3MgPSAocCAtIGxiKSAvICh1YiAtIGxiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRyZXQuZnJvbSA9IHRoaXMuZnJvbTtcclxuXHRcdFx0XHRcdHJldC50byA9IHRoaXMudG87XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiByZXQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LkFuaW1hdGVCYXNlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBhbmltYXRlIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LmFuaW1hdGUgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkFuaW1hdGVCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmNhbGNWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciBwID0gdGhpcy5wcm9ncmVzcygpO1xyXG5cclxuXHRcdFx0XHQvLyB0d2VlbiB2YWx1ZSBsaW5lYXJseVxyXG5cdFx0XHRcdHZhciBuZXdWYWx1ZSA9IHAuZnJvbS5udW1WYWx1ZSgpICsgKHAudG8ubnVtVmFsdWUoKSAtIHAuZnJvbS5udW1WYWx1ZSgpKSAqIHAucHJvZ3Jlc3M7XHJcblx0XHRcdFx0cmV0dXJuIG5ld1ZhbHVlICsgdGhpcy5pbml0aWFsVW5pdHM7XHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5hbmltYXRlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5BbmltYXRlQmFzZTtcclxuXHJcblx0XHQvLyBhbmltYXRlIGNvbG9yIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LmFuaW1hdGVDb2xvciA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuQW5pbWF0ZUJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMuY2FsY1ZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIHAgPSB0aGlzLnByb2dyZXNzKCk7XHJcblx0XHRcdFx0dmFyIGZyb20gPSBuZXcgUkdCQ29sb3IocC5mcm9tLnZhbHVlKTtcclxuXHRcdFx0XHR2YXIgdG8gPSBuZXcgUkdCQ29sb3IocC50by52YWx1ZSk7XHJcblxyXG5cdFx0XHRcdGlmIChmcm9tLm9rICYmIHRvLm9rKSB7XHJcblx0XHRcdFx0XHQvLyB0d2VlbiBjb2xvciBsaW5lYXJseVxyXG5cdFx0XHRcdFx0dmFyIHIgPSBmcm9tLnIgKyAodG8uciAtIGZyb20ucikgKiBwLnByb2dyZXNzO1xyXG5cdFx0XHRcdFx0dmFyIGcgPSBmcm9tLmcgKyAodG8uZyAtIGZyb20uZykgKiBwLnByb2dyZXNzO1xyXG5cdFx0XHRcdFx0dmFyIGIgPSBmcm9tLmIgKyAodG8uYiAtIGZyb20uYikgKiBwLnByb2dyZXNzO1xyXG5cdFx0XHRcdFx0cmV0dXJuICdyZ2IoJytwYXJzZUludChyLDEwKSsnLCcrcGFyc2VJbnQoZywxMCkrJywnK3BhcnNlSW50KGIsMTApKycpJztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlKCdmcm9tJykudmFsdWU7XHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5hbmltYXRlQ29sb3IucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkFuaW1hdGVCYXNlO1xyXG5cclxuXHRcdC8vIGFuaW1hdGUgdHJhbnNmb3JtIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LmFuaW1hdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkFuaW1hdGVCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmNhbGNWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciBwID0gdGhpcy5wcm9ncmVzcygpO1xyXG5cclxuXHRcdFx0XHQvLyB0d2VlbiB2YWx1ZSBsaW5lYXJseVxyXG5cdFx0XHRcdHZhciBmcm9tID0gc3ZnLlRvTnVtYmVyQXJyYXkocC5mcm9tLnZhbHVlKTtcclxuXHRcdFx0XHR2YXIgdG8gPSBzdmcuVG9OdW1iZXJBcnJheShwLnRvLnZhbHVlKTtcclxuXHRcdFx0XHR2YXIgbmV3VmFsdWUgPSAnJztcclxuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8ZnJvbS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0bmV3VmFsdWUgKz0gZnJvbVtpXSArICh0b1tpXSAtIGZyb21baV0pICogcC5wcm9ncmVzcyArICcgJztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIG5ld1ZhbHVlO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuYW5pbWF0ZVRyYW5zZm9ybS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuYW5pbWF0ZTtcclxuXHJcblx0XHQvLyBmb250IGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LmZvbnQgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmhvcml6QWR2WCA9IHRoaXMuYXR0cmlidXRlKCdob3Jpei1hZHYteCcpLm51bVZhbHVlKCk7XHJcblxyXG5cdFx0XHR0aGlzLmlzUlRMID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuaXNBcmFiaWMgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5mb250RmFjZSA9IG51bGw7XHJcblx0XHRcdHRoaXMubWlzc2luZ0dseXBoID0gbnVsbDtcclxuXHRcdFx0dGhpcy5nbHlwaHMgPSBbXTtcclxuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xyXG5cdFx0XHRcdGlmIChjaGlsZC50eXBlID09ICdmb250LWZhY2UnKSB7XHJcblx0XHRcdFx0XHR0aGlzLmZvbnRGYWNlID0gY2hpbGQ7XHJcblx0XHRcdFx0XHRpZiAoY2hpbGQuc3R5bGUoJ2ZvbnQtZmFtaWx5JykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0XHRzdmcuRGVmaW5pdGlvbnNbY2hpbGQuc3R5bGUoJ2ZvbnQtZmFtaWx5JykudmFsdWVdID0gdGhpcztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAoY2hpbGQudHlwZSA9PSAnbWlzc2luZy1nbHlwaCcpIHRoaXMubWlzc2luZ0dseXBoID0gY2hpbGQ7XHJcblx0XHRcdFx0ZWxzZSBpZiAoY2hpbGQudHlwZSA9PSAnZ2x5cGgnKSB7XHJcblx0XHRcdFx0XHRpZiAoY2hpbGQuYXJhYmljRm9ybSAhPSAnJykge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmlzUlRMID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0dGhpcy5pc0FyYWJpYyA9IHRydWU7XHJcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgdGhpcy5nbHlwaHNbY2hpbGQudW5pY29kZV0gPT0gJ3VuZGVmaW5lZCcpIHRoaXMuZ2x5cGhzW2NoaWxkLnVuaWNvZGVdID0gW107XHJcblx0XHRcdFx0XHRcdHRoaXMuZ2x5cGhzW2NoaWxkLnVuaWNvZGVdW2NoaWxkLmFyYWJpY0Zvcm1dID0gY2hpbGQ7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5nbHlwaHNbY2hpbGQudW5pY29kZV0gPSBjaGlsZDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmZvbnQucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIGZvbnQtZmFjZSBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5mb250ZmFjZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMuYXNjZW50ID0gdGhpcy5hdHRyaWJ1dGUoJ2FzY2VudCcpLnZhbHVlO1xyXG5cdFx0XHR0aGlzLmRlc2NlbnQgPSB0aGlzLmF0dHJpYnV0ZSgnZGVzY2VudCcpLnZhbHVlO1xyXG5cdFx0XHR0aGlzLnVuaXRzUGVyRW0gPSB0aGlzLmF0dHJpYnV0ZSgndW5pdHMtcGVyLWVtJykubnVtVmFsdWUoKTtcclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmZvbnRmYWNlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBtaXNzaW5nLWdseXBoIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50Lm1pc3NpbmdnbHlwaCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQucGF0aDtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5ob3JpekFkdlggPSAwO1xyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQubWlzc2luZ2dseXBoLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5wYXRoO1xyXG5cclxuXHRcdC8vIGdseXBoIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LmdseXBoID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5wYXRoO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmhvcml6QWR2WCA9IHRoaXMuYXR0cmlidXRlKCdob3Jpei1hZHYteCcpLm51bVZhbHVlKCk7XHJcblx0XHRcdHRoaXMudW5pY29kZSA9IHRoaXMuYXR0cmlidXRlKCd1bmljb2RlJykudmFsdWU7XHJcblx0XHRcdHRoaXMuYXJhYmljRm9ybSA9IHRoaXMuYXR0cmlidXRlKCdhcmFiaWMtZm9ybScpLnZhbHVlO1xyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuZ2x5cGgucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LnBhdGg7XHJcblxyXG5cdFx0Ly8gdGV4dCBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC50ZXh0ID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmNhcHR1cmVUZXh0Tm9kZXMgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmJhc2VTZXRDb250ZXh0ID0gdGhpcy5zZXRDb250ZXh0O1xyXG5cdFx0XHR0aGlzLnNldENvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHR0aGlzLmJhc2VTZXRDb250ZXh0KGN0eCk7XHJcblxyXG5cdFx0XHRcdHZhciB0ZXh0QmFzZWxpbmUgPSB0aGlzLnN0eWxlKCdkb21pbmFudC1iYXNlbGluZScpLnRvVGV4dEJhc2VsaW5lKCk7XHJcblx0XHRcdFx0aWYgKHRleHRCYXNlbGluZSA9PSBudWxsKSB0ZXh0QmFzZWxpbmUgPSB0aGlzLnN0eWxlKCdhbGlnbm1lbnQtYmFzZWxpbmUnKS50b1RleHRCYXNlbGluZSgpO1xyXG5cdFx0XHRcdGlmICh0ZXh0QmFzZWxpbmUgIT0gbnVsbCkgY3R4LnRleHRCYXNlbGluZSA9IHRleHRCYXNlbGluZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHR2YXIgeCA9IHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnKTtcclxuXHRcdFx0XHR2YXIgeSA9IHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHR2YXIgZm9udFNpemUgPSB0aGlzLnBhcmVudC5zdHlsZSgnZm9udC1zaXplJykubnVtVmFsdWVPckRlZmF1bHQoc3ZnLkZvbnQuUGFyc2Uoc3ZnLmN0eC5mb250KS5mb250U2l6ZSk7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBzdmcuQm91bmRpbmdCb3goeCwgeSAtIGZvbnRTaXplLCB4ICsgTWF0aC5mbG9vcihmb250U2l6ZSAqIDIuMCAvIDMuMCkgKiB0aGlzLmNoaWxkcmVuWzBdLmdldFRleHQoKS5sZW5ndGgsIHkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0dGhpcy54ID0gdGhpcy5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcpO1xyXG5cdFx0XHRcdHRoaXMueSA9IHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ2R4JykuaGFzVmFsdWUoKSkgdGhpcy54ICs9IHRoaXMuYXR0cmlidXRlKCdkeCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdkeScpLmhhc1ZhbHVlKCkpIHRoaXMueSArPSB0aGlzLmF0dHJpYnV0ZSgnZHknKS50b1BpeGVscygneScpO1xyXG5cdFx0XHRcdHRoaXMueCArPSB0aGlzLmdldEFuY2hvckRlbHRhKGN0eCwgdGhpcywgMCk7XHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHRoaXMucmVuZGVyQ2hpbGQoY3R4LCB0aGlzLCB0aGlzLCBpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZ2V0QW5jaG9yRGVsdGEgPSBmdW5jdGlvbiAoY3R4LCBwYXJlbnQsIHN0YXJ0SSkge1xyXG5cdFx0XHRcdHZhciB0ZXh0QW5jaG9yID0gdGhpcy5zdHlsZSgndGV4dC1hbmNob3InKS52YWx1ZU9yRGVmYXVsdCgnc3RhcnQnKTtcclxuXHRcdFx0XHRpZiAodGV4dEFuY2hvciAhPSAnc3RhcnQnKSB7XHJcblx0XHRcdFx0XHR2YXIgd2lkdGggPSAwO1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgaT1zdGFydEk7IGk8cGFyZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdHZhciBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbltpXTtcclxuXHRcdFx0XHRcdFx0aWYgKGkgPiBzdGFydEkgJiYgY2hpbGQuYXR0cmlidXRlKCd4JykuaGFzVmFsdWUoKSkgYnJlYWs7IC8vIG5ldyBncm91cFxyXG5cdFx0XHRcdFx0XHR3aWR0aCArPSBjaGlsZC5tZWFzdXJlVGV4dFJlY3Vyc2l2ZShjdHgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIC0xICogKHRleHRBbmNob3IgPT0gJ2VuZCcgPyB3aWR0aCA6IHdpZHRoIC8gMi4wKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIDA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMucmVuZGVyQ2hpbGQgPSBmdW5jdGlvbihjdHgsIHRleHRQYXJlbnQsIHBhcmVudCwgaSkge1xyXG5cdFx0XHRcdHZhciBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbltpXTtcclxuXHRcdFx0XHRpZiAoY2hpbGQuYXR0cmlidXRlKCd4JykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0Y2hpbGQueCA9IGNoaWxkLmF0dHJpYnV0ZSgneCcpLnRvUGl4ZWxzKCd4JykgKyB0ZXh0UGFyZW50LmdldEFuY2hvckRlbHRhKGN0eCwgcGFyZW50LCBpKTtcclxuXHRcdFx0XHRcdGlmIChjaGlsZC5hdHRyaWJ1dGUoJ2R4JykuaGFzVmFsdWUoKSkgY2hpbGQueCArPSBjaGlsZC5hdHRyaWJ1dGUoJ2R4JykudG9QaXhlbHMoJ3gnKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRpZiAoY2hpbGQuYXR0cmlidXRlKCdkeCcpLmhhc1ZhbHVlKCkpIHRleHRQYXJlbnQueCArPSBjaGlsZC5hdHRyaWJ1dGUoJ2R4JykudG9QaXhlbHMoJ3gnKTtcclxuXHRcdFx0XHRcdGNoaWxkLnggPSB0ZXh0UGFyZW50Lng7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRleHRQYXJlbnQueCA9IGNoaWxkLnggKyBjaGlsZC5tZWFzdXJlVGV4dChjdHgpO1xyXG5cclxuXHRcdFx0XHRpZiAoY2hpbGQuYXR0cmlidXRlKCd5JykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0Y2hpbGQueSA9IGNoaWxkLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5Jyk7XHJcblx0XHRcdFx0XHRpZiAoY2hpbGQuYXR0cmlidXRlKCdkeScpLmhhc1ZhbHVlKCkpIGNoaWxkLnkgKz0gY2hpbGQuYXR0cmlidXRlKCdkeScpLnRvUGl4ZWxzKCd5Jyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKGNoaWxkLmF0dHJpYnV0ZSgnZHknKS5oYXNWYWx1ZSgpKSB0ZXh0UGFyZW50LnkgKz0gY2hpbGQuYXR0cmlidXRlKCdkeScpLnRvUGl4ZWxzKCd5Jyk7XHJcblx0XHRcdFx0XHRjaGlsZC55ID0gdGV4dFBhcmVudC55O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0ZXh0UGFyZW50LnkgPSBjaGlsZC55O1xyXG5cclxuXHRcdFx0XHRjaGlsZC5yZW5kZXIoY3R4KTtcclxuXHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPGNoaWxkLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR0ZXh0UGFyZW50LnJlbmRlckNoaWxkKGN0eCwgdGV4dFBhcmVudCwgY2hpbGQsIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQudGV4dC5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyB0ZXh0IGJhc2VcclxuXHRcdHN2Zy5FbGVtZW50LlRleHRFbGVtZW50QmFzZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5nZXRHbHlwaCA9IGZ1bmN0aW9uKGZvbnQsIHRleHQsIGkpIHtcclxuXHRcdFx0XHR2YXIgYyA9IHRleHRbaV07XHJcblx0XHRcdFx0dmFyIGdseXBoID0gbnVsbDtcclxuXHRcdFx0XHRpZiAoZm9udC5pc0FyYWJpYykge1xyXG5cdFx0XHRcdFx0dmFyIGFyYWJpY0Zvcm0gPSAnaXNvbGF0ZWQnO1xyXG5cdFx0XHRcdFx0aWYgKChpPT0wIHx8IHRleHRbaS0xXT09JyAnKSAmJiBpPHRleHQubGVuZ3RoLTIgJiYgdGV4dFtpKzFdIT0nICcpIGFyYWJpY0Zvcm0gPSAndGVybWluYWwnO1xyXG5cdFx0XHRcdFx0aWYgKGk+MCAmJiB0ZXh0W2ktMV0hPScgJyAmJiBpPHRleHQubGVuZ3RoLTIgJiYgdGV4dFtpKzFdIT0nICcpIGFyYWJpY0Zvcm0gPSAnbWVkaWFsJztcclxuXHRcdFx0XHRcdGlmIChpPjAgJiYgdGV4dFtpLTFdIT0nICcgJiYgKGkgPT0gdGV4dC5sZW5ndGgtMSB8fCB0ZXh0W2krMV09PScgJykpIGFyYWJpY0Zvcm0gPSAnaW5pdGlhbCc7XHJcblx0XHRcdFx0XHRpZiAodHlwZW9mIGZvbnQuZ2x5cGhzW2NdICE9ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0XHRcdGdseXBoID0gZm9udC5nbHlwaHNbY11bYXJhYmljRm9ybV07XHJcblx0XHRcdFx0XHRcdGlmIChnbHlwaCA9PSBudWxsICYmIGZvbnQuZ2x5cGhzW2NdLnR5cGUgPT0gJ2dseXBoJykgZ2x5cGggPSBmb250LmdseXBoc1tjXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRnbHlwaCA9IGZvbnQuZ2x5cGhzW2NdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoZ2x5cGggPT0gbnVsbCkgZ2x5cGggPSBmb250Lm1pc3NpbmdHbHlwaDtcclxuXHRcdFx0XHRyZXR1cm4gZ2x5cGg7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMucmVuZGVyQ2hpbGRyZW4gPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHR2YXIgY3VzdG9tRm9udCA9IHRoaXMucGFyZW50LnN0eWxlKCdmb250LWZhbWlseScpLmdldERlZmluaXRpb24oKTtcclxuXHRcdFx0XHRpZiAoY3VzdG9tRm9udCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHR2YXIgZm9udFNpemUgPSB0aGlzLnBhcmVudC5zdHlsZSgnZm9udC1zaXplJykubnVtVmFsdWVPckRlZmF1bHQoc3ZnLkZvbnQuUGFyc2Uoc3ZnLmN0eC5mb250KS5mb250U2l6ZSk7XHJcblx0XHRcdFx0XHR2YXIgZm9udFN0eWxlID0gdGhpcy5wYXJlbnQuc3R5bGUoJ2ZvbnQtc3R5bGUnKS52YWx1ZU9yRGVmYXVsdChzdmcuRm9udC5QYXJzZShzdmcuY3R4LmZvbnQpLmZvbnRTdHlsZSk7XHJcblx0XHRcdFx0XHR2YXIgdGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xyXG5cdFx0XHRcdFx0aWYgKGN1c3RvbUZvbnQuaXNSVEwpIHRleHQgPSB0ZXh0LnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xyXG5cclxuXHRcdFx0XHRcdHZhciBkeCA9IHN2Zy5Ub051bWJlckFycmF5KHRoaXMucGFyZW50LmF0dHJpYnV0ZSgnZHgnKS52YWx1ZSk7XHJcblx0XHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8dGV4dC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHR2YXIgZ2x5cGggPSB0aGlzLmdldEdseXBoKGN1c3RvbUZvbnQsIHRleHQsIGkpO1xyXG5cdFx0XHRcdFx0XHR2YXIgc2NhbGUgPSBmb250U2l6ZSAvIGN1c3RvbUZvbnQuZm9udEZhY2UudW5pdHNQZXJFbTtcclxuXHRcdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSh0aGlzLngsIHRoaXMueSk7XHJcblx0XHRcdFx0XHRcdGN0eC5zY2FsZShzY2FsZSwgLXNjYWxlKTtcclxuXHRcdFx0XHRcdFx0dmFyIGx3ID0gY3R4LmxpbmVXaWR0aDtcclxuXHRcdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IGN0eC5saW5lV2lkdGggKiBjdXN0b21Gb250LmZvbnRGYWNlLnVuaXRzUGVyRW0gLyBmb250U2l6ZTtcclxuXHRcdFx0XHRcdFx0aWYgKGZvbnRTdHlsZSA9PSAnaXRhbGljJykgY3R4LnRyYW5zZm9ybSgxLCAwLCAuNCwgMSwgMCwgMCk7XHJcblx0XHRcdFx0XHRcdGdseXBoLnJlbmRlcihjdHgpO1xyXG5cdFx0XHRcdFx0XHRpZiAoZm9udFN0eWxlID09ICdpdGFsaWMnKSBjdHgudHJhbnNmb3JtKDEsIDAsIC0uNCwgMSwgMCwgMCk7XHJcblx0XHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSBsdztcclxuXHRcdFx0XHRcdFx0Y3R4LnNjYWxlKDEvc2NhbGUsIC0xL3NjYWxlKTtcclxuXHRcdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSgtdGhpcy54LCAtdGhpcy55KTtcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMueCArPSBmb250U2l6ZSAqIChnbHlwaC5ob3JpekFkdlggfHwgY3VzdG9tRm9udC5ob3JpekFkdlgpIC8gY3VzdG9tRm9udC5mb250RmFjZS51bml0c1BlckVtO1xyXG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIGR4W2ldICE9ICd1bmRlZmluZWQnICYmICFpc05hTihkeFtpXSkpIHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnggKz0gZHhbaV07XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjdHguZmlsbFN0eWxlICE9ICcnKSBjdHguZmlsbFRleHQoc3ZnLmNvbXByZXNzU3BhY2VzKHRoaXMuZ2V0VGV4dCgpKSwgdGhpcy54LCB0aGlzLnkpO1xyXG5cdFx0XHRcdGlmIChjdHguc3Ryb2tlU3R5bGUgIT0gJycpIGN0eC5zdHJva2VUZXh0KHN2Zy5jb21wcmVzc1NwYWNlcyh0aGlzLmdldFRleHQoKSksIHRoaXMueCwgdGhpcy55KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly8gT1ZFUlJJREUgTUVcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5tZWFzdXJlVGV4dFJlY3Vyc2l2ZSA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdHZhciB3aWR0aCA9IHRoaXMubWVhc3VyZVRleHQoY3R4KTtcclxuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0d2lkdGggKz0gdGhpcy5jaGlsZHJlbltpXS5tZWFzdXJlVGV4dFJlY3Vyc2l2ZShjdHgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gd2lkdGg7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubWVhc3VyZVRleHQgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHR2YXIgY3VzdG9tRm9udCA9IHRoaXMucGFyZW50LnN0eWxlKCdmb250LWZhbWlseScpLmdldERlZmluaXRpb24oKTtcclxuXHRcdFx0XHRpZiAoY3VzdG9tRm9udCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHR2YXIgZm9udFNpemUgPSB0aGlzLnBhcmVudC5zdHlsZSgnZm9udC1zaXplJykubnVtVmFsdWVPckRlZmF1bHQoc3ZnLkZvbnQuUGFyc2Uoc3ZnLmN0eC5mb250KS5mb250U2l6ZSk7XHJcblx0XHRcdFx0XHR2YXIgbWVhc3VyZSA9IDA7XHJcblx0XHRcdFx0XHR2YXIgdGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xyXG5cdFx0XHRcdFx0aWYgKGN1c3RvbUZvbnQuaXNSVEwpIHRleHQgPSB0ZXh0LnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xyXG5cdFx0XHRcdFx0dmFyIGR4ID0gc3ZnLlRvTnVtYmVyQXJyYXkodGhpcy5wYXJlbnQuYXR0cmlidXRlKCdkeCcpLnZhbHVlKTtcclxuXHRcdFx0XHRcdGZvciAodmFyIGk9MDsgaTx0ZXh0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdHZhciBnbHlwaCA9IHRoaXMuZ2V0R2x5cGgoY3VzdG9tRm9udCwgdGV4dCwgaSk7XHJcblx0XHRcdFx0XHRcdG1lYXN1cmUgKz0gKGdseXBoLmhvcml6QWR2WCB8fCBjdXN0b21Gb250Lmhvcml6QWR2WCkgKiBmb250U2l6ZSAvIGN1c3RvbUZvbnQuZm9udEZhY2UudW5pdHNQZXJFbTtcclxuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBkeFtpXSAhPSAndW5kZWZpbmVkJyAmJiAhaXNOYU4oZHhbaV0pKSB7XHJcblx0XHRcdFx0XHRcdFx0bWVhc3VyZSArPSBkeFtpXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIG1lYXN1cmU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgdGV4dFRvTWVhc3VyZSA9IHN2Zy5jb21wcmVzc1NwYWNlcyh0aGlzLmdldFRleHQoKSk7XHJcblx0XHRcdFx0aWYgKCFjdHgubWVhc3VyZVRleHQpIHJldHVybiB0ZXh0VG9NZWFzdXJlLmxlbmd0aCAqIDEwO1xyXG5cclxuXHRcdFx0XHRjdHguc2F2ZSgpO1xyXG5cdFx0XHRcdHRoaXMuc2V0Q29udGV4dChjdHgpO1xyXG5cdFx0XHRcdHZhciB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0ZXh0VG9NZWFzdXJlKS53aWR0aDtcclxuXHRcdFx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdFx0XHRcdHJldHVybiB3aWR0aDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuVGV4dEVsZW1lbnRCYXNlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIHRzcGFuXHJcblx0XHRzdmcuRWxlbWVudC50c3BhbiA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5jYXB0dXJlVGV4dE5vZGVzID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuVGV4dEVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLnRleHQgPSBzdmcuY29tcHJlc3NTcGFjZXMobm9kZS52YWx1ZSB8fCBub2RlLnRleHQgfHwgbm9kZS50ZXh0Q29udGVudCB8fCAnJyk7XHJcblx0XHRcdHRoaXMuZ2V0VGV4dCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdC8vIGlmIHRoaXMgbm9kZSBoYXMgY2hpbGRyZW4sIHRoZW4gdGhleSBvd24gdGhlIHRleHRcclxuXHRcdFx0XHRpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7IHJldHVybiAnJzsgfVxyXG5cdFx0XHRcdHJldHVybiB0aGlzLnRleHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LnRzcGFuLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5UZXh0RWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gdHJlZlxyXG5cdFx0c3ZnLkVsZW1lbnQudHJlZiA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuVGV4dEVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmdldFRleHQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcclxuXHRcdFx0XHRpZiAoZWxlbWVudCAhPSBudWxsKSByZXR1cm4gZWxlbWVudC5jaGlsZHJlblswXS5nZXRUZXh0KCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LnRyZWYucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlRleHRFbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBhIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LmEgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlRleHRFbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5oYXNUZXh0ID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDA7XHJcblx0XHRcdGZvciAodmFyIGk9MDsgaTxub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZiAobm9kZS5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlICE9IDMpIHRoaXMuaGFzVGV4dCA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB0aGlzIG1pZ2h0IGNvbnRhaW4gdGV4dFxyXG5cdFx0XHR0aGlzLnRleHQgPSB0aGlzLmhhc1RleHQgPyBub2RlLmNoaWxkTm9kZXNbMF0udmFsdWUgOiAnJztcclxuXHRcdFx0dGhpcy5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMudGV4dDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5iYXNlUmVuZGVyQ2hpbGRyZW4gPSB0aGlzLnJlbmRlckNoaWxkcmVuO1xyXG5cdFx0XHR0aGlzLnJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0aWYgKHRoaXMuaGFzVGV4dCkge1xyXG5cdFx0XHRcdFx0Ly8gcmVuZGVyIGFzIHRleHQgZWxlbWVudFxyXG5cdFx0XHRcdFx0dGhpcy5iYXNlUmVuZGVyQ2hpbGRyZW4oY3R4KTtcclxuXHRcdFx0XHRcdHZhciBmb250U2l6ZSA9IG5ldyBzdmcuUHJvcGVydHkoJ2ZvbnRTaXplJywgc3ZnLkZvbnQuUGFyc2Uoc3ZnLmN0eC5mb250KS5mb250U2l6ZSk7XHJcblx0XHRcdFx0XHRzdmcuTW91c2UuY2hlY2tCb3VuZGluZ0JveCh0aGlzLCBuZXcgc3ZnLkJvdW5kaW5nQm94KHRoaXMueCwgdGhpcy55IC0gZm9udFNpemUudG9QaXhlbHMoJ3knKSwgdGhpcy54ICsgdGhpcy5tZWFzdXJlVGV4dChjdHgpLCB0aGlzLnkpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0XHQvLyByZW5kZXIgYXMgdGVtcG9yYXJ5IGdyb3VwXHJcblx0XHRcdFx0XHR2YXIgZyA9IG5ldyBzdmcuRWxlbWVudC5nKCk7XHJcblx0XHRcdFx0XHRnLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuXHRcdFx0XHRcdGcucGFyZW50ID0gdGhpcztcclxuXHRcdFx0XHRcdGcucmVuZGVyKGN0eCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR3aW5kb3cub3Blbih0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS52YWx1ZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMub25tb3VzZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRzdmcuY3R4LmNhbnZhcy5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmEucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlRleHRFbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBpbWFnZSBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5pbWFnZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dmFyIGhyZWYgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS52YWx1ZTtcclxuXHRcdFx0aWYgKGhyZWYgPT0gJycpIHsgcmV0dXJuOyB9XHJcblx0XHRcdHZhciBpc1N2ZyA9IGhyZWYubWF0Y2goL1xcLnN2ZyQvKVxyXG5cclxuXHRcdFx0c3ZnLkltYWdlcy5wdXNoKHRoaXMpO1xyXG5cdFx0XHR0aGlzLmxvYWRlZCA9IGZhbHNlO1xyXG5cdFx0XHRpZiAoIWlzU3ZnKSB7XHJcblx0XHRcdFx0dGhpcy5pbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHRcdFx0XHRpZiAoc3ZnLm9wdHNbJ3VzZUNPUlMnXSA9PSB0cnVlKSB7IHRoaXMuaW1nLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7IH1cclxuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHRcdFx0dGhpcy5pbWcub25sb2FkID0gZnVuY3Rpb24oKSB7IHNlbGYubG9hZGVkID0gdHJ1ZTsgfVxyXG5cdFx0XHRcdHRoaXMuaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHsgc3ZnLmxvZygnRVJST1I6IGltYWdlIFwiJyArIGhyZWYgKyAnXCIgbm90IGZvdW5kJyk7IHNlbGYubG9hZGVkID0gdHJ1ZTsgfVxyXG5cdFx0XHRcdHRoaXMuaW1nLnNyYyA9IGhyZWY7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5pbWcgPSBzdmcuYWpheChocmVmKTtcclxuXHRcdFx0XHR0aGlzLmxvYWRlZCA9IHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMucmVuZGVyQ2hpbGRyZW4gPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHR2YXIgeCA9IHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnKTtcclxuXHRcdFx0XHR2YXIgeSA9IHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKTtcclxuXHJcblx0XHRcdFx0dmFyIHdpZHRoID0gdGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJykudG9QaXhlbHMoJ3gnKTtcclxuXHRcdFx0XHR2YXIgaGVpZ2h0ID0gdGhpcy5hdHRyaWJ1dGUoJ2hlaWdodCcpLnRvUGl4ZWxzKCd5Jyk7XHJcblx0XHRcdFx0aWYgKHdpZHRoID09IDAgfHwgaGVpZ2h0ID09IDApIHJldHVybjtcclxuXHJcblx0XHRcdFx0Y3R4LnNhdmUoKTtcclxuXHRcdFx0XHRpZiAoaXNTdmcpIHtcclxuXHRcdFx0XHRcdGN0eC5kcmF3U3ZnKHRoaXMuaW1nLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKHgsIHkpO1xyXG5cdFx0XHRcdFx0c3ZnLkFzcGVjdFJhdGlvKGN0eCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKS52YWx1ZSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0d2lkdGgsXHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuaW1nLndpZHRoLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRoZWlnaHQsXHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuaW1nLmhlaWdodCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0MCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0MCk7XHJcblx0XHRcdFx0XHRjdHguZHJhd0ltYWdlKHRoaXMuaW1nLCAwLCAwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciB4ID0gdGhpcy5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcpO1xyXG5cdFx0XHRcdHZhciB5ID0gdGhpcy5hdHRyaWJ1dGUoJ3knKS50b1BpeGVscygneScpO1xyXG5cdFx0XHRcdHZhciB3aWR0aCA9IHRoaXMuYXR0cmlidXRlKCd3aWR0aCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0dmFyIGhlaWdodCA9IHRoaXMuYXR0cmlidXRlKCdoZWlnaHQnKS50b1BpeGVscygneScpO1xyXG5cdFx0XHRcdHJldHVybiBuZXcgc3ZnLkJvdW5kaW5nQm94KHgsIHksIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmltYWdlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIGdyb3VwIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LmcgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgYmIgPSBuZXcgc3ZnLkJvdW5kaW5nQm94KCk7XHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdGJiLmFkZEJvdW5kaW5nQm94KHRoaXMuY2hpbGRyZW5baV0uZ2V0Qm91bmRpbmdCb3goKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBiYjtcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmcucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gc3ltYm9sIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LnN5bWJvbCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHQvLyBOTyBSRU5ERVJcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LnN5bWJvbC5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBzdHlsZSBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5zdHlsZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdC8vIHRleHQsIG9yIHNwYWNlcyB0aGVuIENEQVRBXHJcblx0XHRcdHZhciBjc3MgPSAnJ1xyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdCAgY3NzICs9IG5vZGUuY2hpbGROb2Rlc1tpXS5kYXRhO1xyXG5cdFx0XHR9XHJcblx0XHRcdGNzcyA9IGNzcy5yZXBsYWNlKC8oXFwvXFwqKFteKl18W1xcclxcbl18KFxcKisoW14qXFwvXXxbXFxyXFxuXSkpKSpcXCorXFwvKXwoXltcXHNdKlxcL1xcLy4qKS9nbSwgJycpOyAvLyByZW1vdmUgY29tbWVudHNcclxuXHRcdFx0Y3NzID0gc3ZnLmNvbXByZXNzU3BhY2VzKGNzcyk7IC8vIHJlcGxhY2Ugd2hpdGVzcGFjZVxyXG5cdFx0XHR2YXIgY3NzRGVmcyA9IGNzcy5zcGxpdCgnfScpO1xyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8Y3NzRGVmcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmIChzdmcudHJpbShjc3NEZWZzW2ldKSAhPSAnJykge1xyXG5cdFx0XHRcdFx0dmFyIGNzc0RlZiA9IGNzc0RlZnNbaV0uc3BsaXQoJ3snKTtcclxuXHRcdFx0XHRcdHZhciBjc3NDbGFzc2VzID0gY3NzRGVmWzBdLnNwbGl0KCcsJyk7XHJcblx0XHRcdFx0XHR2YXIgY3NzUHJvcHMgPSBjc3NEZWZbMV0uc3BsaXQoJzsnKTtcclxuXHRcdFx0XHRcdGZvciAodmFyIGo9MDsgajxjc3NDbGFzc2VzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0XHRcdHZhciBjc3NDbGFzcyA9IHN2Zy50cmltKGNzc0NsYXNzZXNbal0pO1xyXG5cdFx0XHRcdFx0XHRpZiAoY3NzQ2xhc3MgIT0gJycpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgcHJvcHMgPSBzdmcuU3R5bGVzW2Nzc0NsYXNzXSB8fCB7fTtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrPTA7IGs8Y3NzUHJvcHMubGVuZ3RoOyBrKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBwcm9wID0gY3NzUHJvcHNba10uaW5kZXhPZignOicpO1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIG5hbWUgPSBjc3NQcm9wc1trXS5zdWJzdHIoMCwgcHJvcCk7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSBjc3NQcm9wc1trXS5zdWJzdHIocHJvcCArIDEsIGNzc1Byb3BzW2tdLmxlbmd0aCAtIHByb3ApO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKG5hbWUgIT0gbnVsbCAmJiB2YWx1ZSAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHByb3BzW3N2Zy50cmltKG5hbWUpXSA9IG5ldyBzdmcuUHJvcGVydHkoc3ZnLnRyaW0obmFtZSksIHN2Zy50cmltKHZhbHVlKSk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdHN2Zy5TdHlsZXNbY3NzQ2xhc3NdID0gcHJvcHM7XHJcblx0XHRcdFx0XHRcdFx0c3ZnLlN0eWxlc1NwZWNpZmljaXR5W2Nzc0NsYXNzXSA9IGdldFNlbGVjdG9yU3BlY2lmaWNpdHkoY3NzQ2xhc3MpO1xyXG5cdFx0XHRcdFx0XHRcdGlmIChjc3NDbGFzcyA9PSAnQGZvbnQtZmFjZScpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBmb250RmFtaWx5ID0gcHJvcHNbJ2ZvbnQtZmFtaWx5J10udmFsdWUucmVwbGFjZSgvXCIvZywnJyk7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgc3JjcyA9IHByb3BzWydzcmMnXS52YWx1ZS5zcGxpdCgnLCcpO1xyXG5cdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgcz0wOyBzPHNyY3MubGVuZ3RoOyBzKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHNyY3Nbc10uaW5kZXhPZignZm9ybWF0KFwic3ZnXCIpJykgPiAwKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHVybFN0YXJ0ID0gc3Jjc1tzXS5pbmRleE9mKCd1cmwnKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgdXJsRW5kID0gc3Jjc1tzXS5pbmRleE9mKCcpJywgdXJsU3RhcnQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciB1cmwgPSBzcmNzW3NdLnN1YnN0cih1cmxTdGFydCArIDUsIHVybEVuZCAtIHVybFN0YXJ0IC0gNik7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIGRvYyA9IHN2Zy5wYXJzZVhtbChzdmcuYWpheCh1cmwpKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgZm9udHMgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ZvbnQnKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmb3IgKHZhciBmPTA7IGY8Zm9udHMubGVuZ3RoOyBmKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBmb250ID0gc3ZnLkNyZWF0ZUVsZW1lbnQoZm9udHNbZl0pO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3ZnLkRlZmluaXRpb25zW2ZvbnRGYW1pbHldID0gZm9udDtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LnN0eWxlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyB1c2UgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQudXNlID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmJhc2VTZXRDb250ZXh0ID0gdGhpcy5zZXRDb250ZXh0O1xyXG5cdFx0XHR0aGlzLnNldENvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHR0aGlzLmJhc2VTZXRDb250ZXh0KGN0eCk7XHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCd4JykuaGFzVmFsdWUoKSkgY3R4LnRyYW5zbGF0ZSh0aGlzLmF0dHJpYnV0ZSgneCcpLnRvUGl4ZWxzKCd4JyksIDApO1xyXG5cdFx0XHRcdGlmICh0aGlzLmF0dHJpYnV0ZSgneScpLmhhc1ZhbHVlKCkpIGN0eC50cmFuc2xhdGUoMCwgdGhpcy5hdHRyaWJ1dGUoJ3knKS50b1BpeGVscygneScpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XHJcblxyXG5cdFx0XHR0aGlzLnBhdGggPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHRpZiAoZWxlbWVudCAhPSBudWxsKSBlbGVtZW50LnBhdGgoY3R4KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmIChlbGVtZW50ICE9IG51bGwpIHJldHVybiBlbGVtZW50LmdldEJvdW5kaW5nQm94KCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMucmVuZGVyQ2hpbGRyZW4gPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHRpZiAoZWxlbWVudCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHR2YXIgdGVtcFN2ZyA9IGVsZW1lbnQ7XHJcblx0XHRcdFx0XHRpZiAoZWxlbWVudC50eXBlID09ICdzeW1ib2wnKSB7XHJcblx0XHRcdFx0XHRcdC8vIHJlbmRlciBtZSB1c2luZyBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudCBpbiBzeW1ib2wgY2FzZXMgKGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zdHJ1Y3QuaHRtbCNVc2VFbGVtZW50KVxyXG5cdFx0XHRcdFx0XHR0ZW1wU3ZnID0gbmV3IHN2Zy5FbGVtZW50LnN2ZygpO1xyXG5cdFx0XHRcdFx0XHR0ZW1wU3ZnLnR5cGUgPSAnc3ZnJztcclxuXHRcdFx0XHRcdFx0dGVtcFN2Zy5hdHRyaWJ1dGVzWyd2aWV3Qm94J10gPSBuZXcgc3ZnLlByb3BlcnR5KCd2aWV3Qm94JywgZWxlbWVudC5hdHRyaWJ1dGUoJ3ZpZXdCb3gnKS52YWx1ZSk7XHJcblx0XHRcdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1sncHJlc2VydmVBc3BlY3RSYXRpbyddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgncHJlc2VydmVBc3BlY3RSYXRpbycsIGVsZW1lbnQuYXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJykudmFsdWUpO1xyXG5cdFx0XHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ292ZXJmbG93J10gPSBuZXcgc3ZnLlByb3BlcnR5KCdvdmVyZmxvdycsIGVsZW1lbnQuYXR0cmlidXRlKCdvdmVyZmxvdycpLnZhbHVlKTtcclxuXHRcdFx0XHRcdFx0dGVtcFN2Zy5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAodGVtcFN2Zy50eXBlID09ICdzdmcnKSB7XHJcblx0XHRcdFx0XHRcdC8vIGlmIHN5bWJvbCBvciBzdmcsIGluaGVyaXQgd2lkdGgvaGVpZ2h0IGZyb20gbWVcclxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCd3aWR0aCcpLmhhc1ZhbHVlKCkpIHRlbXBTdmcuYXR0cmlidXRlc1snd2lkdGgnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3dpZHRoJywgdGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJykudmFsdWUpO1xyXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ2hlaWdodCcpLmhhc1ZhbHVlKCkpIHRlbXBTdmcuYXR0cmlidXRlc1snaGVpZ2h0J10gPSBuZXcgc3ZnLlByb3BlcnR5KCdoZWlnaHQnLCB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykudmFsdWUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dmFyIG9sZFBhcmVudCA9IHRlbXBTdmcucGFyZW50O1xyXG5cdFx0XHRcdFx0dGVtcFN2Zy5wYXJlbnQgPSBudWxsO1xyXG5cdFx0XHRcdFx0dGVtcFN2Zy5yZW5kZXIoY3R4KTtcclxuXHRcdFx0XHRcdHRlbXBTdmcucGFyZW50ID0gb2xkUGFyZW50O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQudXNlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIG1hc2sgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQubWFzayA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgsIGVsZW1lbnQpIHtcclxuXHRcdFx0XHQvLyByZW5kZXIgYXMgdGVtcCBzdmdcclxuXHRcdFx0XHR2YXIgeCA9IHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnKTtcclxuXHRcdFx0XHR2YXIgeSA9IHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHR2YXIgd2lkdGggPSB0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS50b1BpeGVscygneCcpO1xyXG5cdFx0XHRcdHZhciBoZWlnaHQgPSB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTtcclxuXHJcblx0XHRcdFx0aWYgKHdpZHRoID09IDAgJiYgaGVpZ2h0ID09IDApIHtcclxuXHRcdFx0XHRcdHZhciBiYiA9IG5ldyBzdmcuQm91bmRpbmdCb3goKTtcclxuXHRcdFx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdGJiLmFkZEJvdW5kaW5nQm94KHRoaXMuY2hpbGRyZW5baV0uZ2V0Qm91bmRpbmdCb3goKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR2YXIgeCA9IE1hdGguZmxvb3IoYmIueDEpO1xyXG5cdFx0XHRcdFx0dmFyIHkgPSBNYXRoLmZsb29yKGJiLnkxKTtcclxuXHRcdFx0XHRcdHZhciB3aWR0aCA9IE1hdGguZmxvb3IoYmIud2lkdGgoKSk7XHJcblx0XHRcdFx0XHR2YXJcdGhlaWdodCA9IE1hdGguZmxvb3IoYmIuaGVpZ2h0KCkpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gdGVtcG9yYXJpbHkgcmVtb3ZlIG1hc2sgdG8gYXZvaWQgcmVjdXJzaW9uXHJcblx0XHRcdFx0dmFyIG1hc2sgPSBlbGVtZW50LmF0dHJpYnV0ZSgnbWFzaycpLnZhbHVlO1xyXG5cdFx0XHRcdGVsZW1lbnQuYXR0cmlidXRlKCdtYXNrJykudmFsdWUgPSAnJztcclxuXHJcblx0XHRcdFx0XHR2YXIgY01hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuXHRcdFx0XHRcdGNNYXNrLndpZHRoID0geCArIHdpZHRoO1xyXG5cdFx0XHRcdFx0Y01hc2suaGVpZ2h0ID0geSArIGhlaWdodDtcclxuXHRcdFx0XHRcdHZhciBtYXNrQ3R4ID0gY01hc2suZ2V0Q29udGV4dCgnMmQnKTtcclxuXHRcdFx0XHRcdHRoaXMucmVuZGVyQ2hpbGRyZW4obWFza0N0eCk7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuXHRcdFx0XHRcdGMud2lkdGggPSB4ICsgd2lkdGg7XHJcblx0XHRcdFx0XHRjLmhlaWdodCA9IHkgKyBoZWlnaHQ7XHJcblx0XHRcdFx0XHR2YXIgdGVtcEN0eCA9IGMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHRcdFx0XHRcdGVsZW1lbnQucmVuZGVyKHRlbXBDdHgpO1xyXG5cdFx0XHRcdFx0dGVtcEN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24taW4nO1xyXG5cdFx0XHRcdFx0dGVtcEN0eC5maWxsU3R5bGUgPSBtYXNrQ3R4LmNyZWF0ZVBhdHRlcm4oY01hc2ssICduby1yZXBlYXQnKTtcclxuXHRcdFx0XHRcdHRlbXBDdHguZmlsbFJlY3QoMCwgMCwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcclxuXHJcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdGVtcEN0eC5jcmVhdGVQYXR0ZXJuKGMsICduby1yZXBlYXQnKTtcclxuXHRcdFx0XHRcdGN0eC5maWxsUmVjdCgwLCAwLCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xyXG5cclxuXHRcdFx0XHQvLyByZWFzc2lnbiBtYXNrXHJcblx0XHRcdFx0ZWxlbWVudC5hdHRyaWJ1dGUoJ21hc2snKS52YWx1ZSA9IG1hc2s7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0Ly8gTk8gUkVOREVSXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50Lm1hc2sucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIGNsaXAgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQuY2xpcFBhdGggPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0dmFyIG9sZEJlZ2luUGF0aCA9IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuYmVnaW5QYXRoO1xyXG5cdFx0XHRcdENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuYmVnaW5QYXRoID0gZnVuY3Rpb24gKCkgeyB9O1xyXG5cclxuXHRcdFx0XHR2YXIgb2xkQ2xvc2VQYXRoID0gQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5jbG9zZVBhdGg7XHJcblx0XHRcdFx0Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5jbG9zZVBhdGggPSBmdW5jdGlvbiAoKSB7IH07XHJcblxyXG5cdFx0XHRcdG9sZEJlZ2luUGF0aC5jYWxsKGN0eCk7XHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XHJcblx0XHRcdFx0XHRpZiAodHlwZW9mIGNoaWxkLnBhdGggIT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHRyYW5zZm9ybSA9IG51bGw7XHJcblx0XHRcdFx0XHRcdGlmIChjaGlsZC5zdHlsZSgndHJhbnNmb3JtJywgZmFsc2UsIHRydWUpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm0gPSBuZXcgc3ZnLlRyYW5zZm9ybShjaGlsZC5zdHlsZSgndHJhbnNmb3JtJywgZmFsc2UsIHRydWUpLnZhbHVlKTtcclxuXHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm0uYXBwbHkoY3R4KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRjaGlsZC5wYXRoKGN0eCk7XHJcblx0XHRcdFx0XHRcdENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuY2xvc2VQYXRoID0gb2xkQ2xvc2VQYXRoO1xyXG5cdFx0XHRcdFx0XHRpZiAodHJhbnNmb3JtKSB7IHRyYW5zZm9ybS51bmFwcGx5KGN0eCk7IH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0b2xkQ2xvc2VQYXRoLmNhbGwoY3R4KTtcclxuXHRcdFx0XHRjdHguY2xpcCgpO1xyXG5cclxuXHRcdFx0XHRDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmJlZ2luUGF0aCA9IG9sZEJlZ2luUGF0aDtcclxuXHRcdFx0XHRDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmNsb3NlUGF0aCA9IG9sZENsb3NlUGF0aDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHQvLyBOTyBSRU5ERVJcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuY2xpcFBhdGgucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIGZpbHRlcnNcclxuXHRcdHN2Zy5FbGVtZW50LmZpbHRlciA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgsIGVsZW1lbnQpIHtcclxuXHRcdFx0XHQvLyByZW5kZXIgYXMgdGVtcCBzdmdcclxuXHRcdFx0XHR2YXIgYmIgPSBlbGVtZW50LmdldEJvdW5kaW5nQm94KCk7XHJcblx0XHRcdFx0dmFyIHggPSBNYXRoLmZsb29yKGJiLngxKTtcclxuXHRcdFx0XHR2YXIgeSA9IE1hdGguZmxvb3IoYmIueTEpO1xyXG5cdFx0XHRcdHZhciB3aWR0aCA9IE1hdGguZmxvb3IoYmIud2lkdGgoKSk7XHJcblx0XHRcdFx0dmFyXHRoZWlnaHQgPSBNYXRoLmZsb29yKGJiLmhlaWdodCgpKTtcclxuXHJcblx0XHRcdFx0Ly8gdGVtcG9yYXJpbHkgcmVtb3ZlIGZpbHRlciB0byBhdm9pZCByZWN1cnNpb25cclxuXHRcdFx0XHR2YXIgZmlsdGVyID0gZWxlbWVudC5zdHlsZSgnZmlsdGVyJykudmFsdWU7XHJcblx0XHRcdFx0ZWxlbWVudC5zdHlsZSgnZmlsdGVyJykudmFsdWUgPSAnJztcclxuXHJcblx0XHRcdFx0dmFyIHB4ID0gMCwgcHkgPSAwO1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgZWZkID0gdGhpcy5jaGlsZHJlbltpXS5leHRyYUZpbHRlckRpc3RhbmNlIHx8IDA7XHJcblx0XHRcdFx0XHRweCA9IE1hdGgubWF4KHB4LCBlZmQpO1xyXG5cdFx0XHRcdFx0cHkgPSBNYXRoLm1heChweSwgZWZkKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcblx0XHRcdFx0Yy53aWR0aCA9IHdpZHRoICsgMipweDtcclxuXHRcdFx0XHRjLmhlaWdodCA9IGhlaWdodCArIDIqcHk7XHJcblx0XHRcdFx0dmFyIHRlbXBDdHggPSBjLmdldENvbnRleHQoJzJkJyk7XHJcblx0XHRcdFx0dGVtcEN0eC50cmFuc2xhdGUoLXggKyBweCwgLXkgKyBweSk7XHJcblx0XHRcdFx0ZWxlbWVudC5yZW5kZXIodGVtcEN0eCk7XHJcblxyXG5cdFx0XHRcdC8vIGFwcGx5IGZpbHRlcnNcclxuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzLmNoaWxkcmVuW2ldLmFwcGx5ID09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5jaGlsZHJlbltpXS5hcHBseSh0ZW1wQ3R4LCAwLCAwLCB3aWR0aCArIDIqcHgsIGhlaWdodCArIDIqcHkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gcmVuZGVyIG9uIG1lXHJcblx0XHRcdFx0Y3R4LmRyYXdJbWFnZShjLCAwLCAwLCB3aWR0aCArIDIqcHgsIGhlaWdodCArIDIqcHksIHggLSBweCwgeSAtIHB5LCB3aWR0aCArIDIqcHgsIGhlaWdodCArIDIqcHkpO1xyXG5cclxuXHRcdFx0XHQvLyByZWFzc2lnbiBmaWx0ZXJcclxuXHRcdFx0XHRlbGVtZW50LnN0eWxlKCdmaWx0ZXInLCB0cnVlKS52YWx1ZSA9IGZpbHRlcjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHQvLyBOTyBSRU5ERVJcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuZmlsdGVyLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHJcblx0XHRzdmcuRWxlbWVudC5mZU1vcnBob2xvZ3kgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcblx0XHRcdFx0Ly8gVE9ETzogaW1wbGVtZW50XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmZlTW9ycGhvbG9neS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0c3ZnLkVsZW1lbnQuZmVDb21wb3NpdGUgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcblx0XHRcdFx0Ly8gVE9ETzogaW1wbGVtZW50XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmZlQ29tcG9zaXRlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHJcblx0XHRzdmcuRWxlbWVudC5mZUNvbG9yTWF0cml4ID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dmFyIG1hdHJpeCA9IHN2Zy5Ub051bWJlckFycmF5KHRoaXMuYXR0cmlidXRlKCd2YWx1ZXMnKS52YWx1ZSk7XHJcblx0XHRcdHN3aXRjaCAodGhpcy5hdHRyaWJ1dGUoJ3R5cGUnKS52YWx1ZU9yRGVmYXVsdCgnbWF0cml4JykpIHsgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2ZpbHRlcnMuaHRtbCNmZUNvbG9yTWF0cml4RWxlbWVudFxyXG5cdFx0XHRcdGNhc2UgJ3NhdHVyYXRlJzpcclxuXHRcdFx0XHRcdHZhciBzID0gbWF0cml4WzBdO1xyXG5cdFx0XHRcdFx0bWF0cml4ID0gWzAuMjEzKzAuNzg3KnMsMC43MTUtMC43MTUqcywwLjA3Mi0wLjA3MipzLDAsMCxcclxuXHRcdFx0XHRcdFx0XHQgIDAuMjEzLTAuMjEzKnMsMC43MTUrMC4yODUqcywwLjA3Mi0wLjA3MipzLDAsMCxcclxuXHRcdFx0XHRcdFx0XHQgIDAuMjEzLTAuMjEzKnMsMC43MTUtMC43MTUqcywwLjA3MiswLjkyOCpzLDAsMCxcclxuXHRcdFx0XHRcdFx0XHQgIDAsMCwwLDEsMCxcclxuXHRcdFx0XHRcdFx0XHQgIDAsMCwwLDAsMV07XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlICdodWVSb3RhdGUnOlxyXG5cdFx0XHRcdFx0dmFyIGEgPSBtYXRyaXhbMF0gKiBNYXRoLlBJIC8gMTgwLjA7XHJcblx0XHRcdFx0XHR2YXIgYyA9IGZ1bmN0aW9uIChtMSxtMixtMykgeyByZXR1cm4gbTEgKyBNYXRoLmNvcyhhKSptMiArIE1hdGguc2luKGEpKm0zOyB9O1xyXG5cdFx0XHRcdFx0bWF0cml4ID0gW2MoMC4yMTMsMC43ODcsLTAuMjEzKSxjKDAuNzE1LC0wLjcxNSwtMC43MTUpLGMoMC4wNzIsLTAuMDcyLDAuOTI4KSwwLDAsXHJcblx0XHRcdFx0XHRcdFx0ICBjKDAuMjEzLC0wLjIxMywwLjE0MyksYygwLjcxNSwwLjI4NSwwLjE0MCksYygwLjA3MiwtMC4wNzIsLTAuMjgzKSwwLDAsXHJcblx0XHRcdFx0XHRcdFx0ICBjKDAuMjEzLC0wLjIxMywtMC43ODcpLGMoMC43MTUsLTAuNzE1LDAuNzE1KSxjKDAuMDcyLDAuOTI4LDAuMDcyKSwwLDAsXHJcblx0XHRcdFx0XHRcdFx0ICAwLDAsMCwxLDAsXHJcblx0XHRcdFx0XHRcdFx0ICAwLDAsMCwwLDFdO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAnbHVtaW5hbmNlVG9BbHBoYSc6XHJcblx0XHRcdFx0XHRtYXRyaXggPSBbMCwwLDAsMCwwLFxyXG5cdFx0XHRcdFx0XHRcdCAgMCwwLDAsMCwwLFxyXG5cdFx0XHRcdFx0XHRcdCAgMCwwLDAsMCwwLFxyXG5cdFx0XHRcdFx0XHRcdCAgMC4yMTI1LDAuNzE1NCwwLjA3MjEsMCwwLFxyXG5cdFx0XHRcdFx0XHRcdCAgMCwwLDAsMCwxXTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBpbUdldChpbWcsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJnYmEpIHtcclxuXHRcdFx0XHRyZXR1cm4gaW1nW3kqd2lkdGgqNCArIHgqNCArIHJnYmFdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBpbVNldChpbWcsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJnYmEsIHZhbCkge1xyXG5cdFx0XHRcdGltZ1t5KndpZHRoKjQgKyB4KjQgKyByZ2JhXSA9IHZhbDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gbShpLCB2KSB7XHJcblx0XHRcdFx0dmFyIG1pID0gbWF0cml4W2ldO1xyXG5cdFx0XHRcdHJldHVybiBtaSAqIChtaSA8IDAgPyB2IC0gMjU1IDogdik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuXHRcdFx0XHQvLyBhc3N1bWluZyB4PT0wICYmIHk9PTAgZm9yIG5vd1xyXG5cdFx0XHRcdHZhciBzcmNEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuXHRcdFx0XHRmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcblx0XHRcdFx0XHRmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcclxuXHRcdFx0XHRcdFx0dmFyIHIgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDApO1xyXG5cdFx0XHRcdFx0XHR2YXIgZyA9IGltR2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMSk7XHJcblx0XHRcdFx0XHRcdHZhciBiID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAyKTtcclxuXHRcdFx0XHRcdFx0dmFyIGEgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDMpO1xyXG5cdFx0XHRcdFx0XHRpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDAsIG0oMCxyKSttKDEsZykrbSgyLGIpK20oMyxhKSttKDQsMSkpO1xyXG5cdFx0XHRcdFx0XHRpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDEsIG0oNSxyKSttKDYsZykrbSg3LGIpK20oOCxhKSttKDksMSkpO1xyXG5cdFx0XHRcdFx0XHRpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDIsIG0oMTAscikrbSgxMSxnKSttKDEyLGIpK20oMTMsYSkrbSgxNCwxKSk7XHJcblx0XHRcdFx0XHRcdGltU2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMywgbSgxNSxyKSttKDE2LGcpK20oMTcsYikrbSgxOCxhKSttKDE5LDEpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuXHRcdFx0XHRjdHgucHV0SW1hZ2VEYXRhKHNyY0RhdGEsIDAsIDApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5mZUNvbG9yTWF0cml4LnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHJcblx0XHRzdmcuRWxlbWVudC5mZUdhdXNzaWFuQmx1ciA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMuYmx1clJhZGl1cyA9IE1hdGguZmxvb3IodGhpcy5hdHRyaWJ1dGUoJ3N0ZERldmlhdGlvbicpLm51bVZhbHVlKCkpO1xyXG5cdFx0XHR0aGlzLmV4dHJhRmlsdGVyRGlzdGFuY2UgPSB0aGlzLmJsdXJSYWRpdXM7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcblx0XHRcdFx0aWYgKHR5cGVvZiBzdGFja0JsdXIuY2FudmFzUkdCQSA9PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdFx0c3ZnLmxvZygnRVJST1I6IFN0YWNrQmx1ci5qcyBtdXN0IGJlIGluY2x1ZGVkIGZvciBibHVyIHRvIHdvcmsnKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIFN0YWNrQmx1ciByZXF1aXJlcyBjYW52YXMgYmUgb24gZG9jdW1lbnRcclxuXHRcdFx0XHRjdHguY2FudmFzLmlkID0gc3ZnLlVuaXF1ZUlkKCk7XHJcblx0XHRcdFx0Y3R4LmNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG5cdFx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY3R4LmNhbnZhcyk7XHJcblx0XHRcdFx0c3RhY2tCbHVyLmNhbnZhc1JHQkEoY3R4LmNhbnZhcy5pZCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgdGhpcy5ibHVyUmFkaXVzKTtcclxuXHRcdFx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGN0eC5jYW52YXMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5mZUdhdXNzaWFuQmx1ci5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gdGl0bGUgZWxlbWVudCwgZG8gbm90aGluZ1xyXG5cdFx0c3ZnLkVsZW1lbnQudGl0bGUgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC50aXRsZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gZGVzYyBlbGVtZW50LCBkbyBub3RoaW5nXHJcblx0XHRzdmcuRWxlbWVudC5kZXNjID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuZGVzYy5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0c3ZnLkVsZW1lbnQuTUlTU0lORyA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0c3ZnLmxvZygnRVJST1I6IEVsZW1lbnQgXFwnJyArIG5vZGUubm9kZU5hbWUgKyAnXFwnIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5NSVNTSU5HLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBlbGVtZW50IGZhY3RvcnlcclxuXHRcdHN2Zy5DcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR2YXIgY2xhc3NOYW1lID0gbm9kZS5ub2RlTmFtZS5yZXBsYWNlKC9eW146XSs6LywnJyk7IC8vIHJlbW92ZSBuYW1lc3BhY2VcclxuXHRcdFx0Y2xhc3NOYW1lID0gY2xhc3NOYW1lLnJlcGxhY2UoL1xcLS9nLCcnKTsgLy8gcmVtb3ZlIGRhc2hlc1xyXG5cdFx0XHR2YXIgZSA9IG51bGw7XHJcblx0XHRcdGlmICh0eXBlb2Ygc3ZnLkVsZW1lbnRbY2xhc3NOYW1lXSAhPSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdGUgPSBuZXcgc3ZnLkVsZW1lbnRbY2xhc3NOYW1lXShub2RlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRlID0gbmV3IHN2Zy5FbGVtZW50Lk1JU1NJTkcobm9kZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGUudHlwZSA9IG5vZGUubm9kZU5hbWU7XHJcblx0XHRcdHJldHVybiBlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGxvYWQgZnJvbSB1cmxcclxuXHRcdHN2Zy5sb2FkID0gZnVuY3Rpb24oY3R4LCB1cmwpIHtcclxuXHRcdFx0c3ZnLmxvYWRYbWwoY3R4LCBzdmcuYWpheCh1cmwpKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBsb2FkIGZyb20geG1sXHJcblx0XHRzdmcubG9hZFhtbCA9IGZ1bmN0aW9uKGN0eCwgeG1sKSB7XHJcblx0XHRcdHN2Zy5sb2FkWG1sRG9jKGN0eCwgc3ZnLnBhcnNlWG1sKHhtbCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHN2Zy5sb2FkWG1sRG9jID0gZnVuY3Rpb24oY3R4LCBkb20pIHtcclxuXHRcdFx0c3ZnLmluaXQoY3R4KTtcclxuXHJcblx0XHRcdHZhciBtYXBYWSA9IGZ1bmN0aW9uKHApIHtcclxuXHRcdFx0XHR2YXIgZSA9IGN0eC5jYW52YXM7XHJcblx0XHRcdFx0d2hpbGUgKGUpIHtcclxuXHRcdFx0XHRcdHAueCAtPSBlLm9mZnNldExlZnQ7XHJcblx0XHRcdFx0XHRwLnkgLT0gZS5vZmZzZXRUb3A7XHJcblx0XHRcdFx0XHRlID0gZS5vZmZzZXRQYXJlbnQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICh3aW5kb3cuc2Nyb2xsWCkgcC54ICs9IHdpbmRvdy5zY3JvbGxYO1xyXG5cdFx0XHRcdGlmICh3aW5kb3cuc2Nyb2xsWSkgcC55ICs9IHdpbmRvdy5zY3JvbGxZO1xyXG5cdFx0XHRcdHJldHVybiBwO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBiaW5kIG1vdXNlXHJcblx0XHRcdGlmIChzdmcub3B0c1snaWdub3JlTW91c2UnXSAhPSB0cnVlKSB7XHJcblx0XHRcdFx0Y3R4LmNhbnZhcy5vbmNsaWNrID0gZnVuY3Rpb24oZSkge1xyXG5cdFx0XHRcdFx0dmFyIHAgPSBtYXBYWShuZXcgc3ZnLlBvaW50KGUgIT0gbnVsbCA/IGUuY2xpZW50WCA6IGV2ZW50LmNsaWVudFgsIGUgIT0gbnVsbCA/IGUuY2xpZW50WSA6IGV2ZW50LmNsaWVudFkpKTtcclxuXHRcdFx0XHRcdHN2Zy5Nb3VzZS5vbmNsaWNrKHAueCwgcC55KTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdGN0eC5jYW52YXMub25tb3VzZW1vdmUgPSBmdW5jdGlvbihlKSB7XHJcblx0XHRcdFx0XHR2YXIgcCA9IG1hcFhZKG5ldyBzdmcuUG9pbnQoZSAhPSBudWxsID8gZS5jbGllbnRYIDogZXZlbnQuY2xpZW50WCwgZSAhPSBudWxsID8gZS5jbGllbnRZIDogZXZlbnQuY2xpZW50WSkpO1xyXG5cdFx0XHRcdFx0c3ZnLk1vdXNlLm9ubW91c2Vtb3ZlKHAueCwgcC55KTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgZSA9IHN2Zy5DcmVhdGVFbGVtZW50KGRvbS5kb2N1bWVudEVsZW1lbnQpO1xyXG5cdFx0XHRlLnJvb3QgPSB0cnVlO1xyXG5cdFx0XHRlLmFkZFN0eWxlc0Zyb21TdHlsZURlZmluaXRpb24oKTtcclxuXHJcblx0XHRcdC8vIHJlbmRlciBsb29wXHJcblx0XHRcdHZhciBpc0ZpcnN0UmVuZGVyID0gdHJ1ZTtcclxuXHRcdFx0dmFyIGRyYXcgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRzdmcuVmlld1BvcnQuQ2xlYXIoKTtcclxuXHRcdFx0XHRpZiAoY3R4LmNhbnZhcy5wYXJlbnROb2RlKSBzdmcuVmlld1BvcnQuU2V0Q3VycmVudChjdHguY2FudmFzLnBhcmVudE5vZGUuY2xpZW50V2lkdGgsIGN0eC5jYW52YXMucGFyZW50Tm9kZS5jbGllbnRIZWlnaHQpO1xyXG5cclxuXHRcdFx0XHRpZiAoc3ZnLm9wdHNbJ2lnbm9yZURpbWVuc2lvbnMnXSAhPSB0cnVlKSB7XHJcblx0XHRcdFx0XHQvLyBzZXQgY2FudmFzIHNpemVcclxuXHRcdFx0XHRcdGlmIChlLnN0eWxlKCd3aWR0aCcpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdFx0Y3R4LmNhbnZhcy53aWR0aCA9IGUuc3R5bGUoJ3dpZHRoJykudG9QaXhlbHMoJ3gnKTtcclxuXHRcdFx0XHRcdFx0Y3R4LmNhbnZhcy5zdHlsZS53aWR0aCA9IGN0eC5jYW52YXMud2lkdGggKyAncHgnO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKGUuc3R5bGUoJ2hlaWdodCcpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdFx0Y3R4LmNhbnZhcy5oZWlnaHQgPSBlLnN0eWxlKCdoZWlnaHQnKS50b1BpeGVscygneScpO1xyXG5cdFx0XHRcdFx0XHRjdHguY2FudmFzLnN0eWxlLmhlaWdodCA9IGN0eC5jYW52YXMuaGVpZ2h0ICsgJ3B4JztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIGNXaWR0aCA9IGN0eC5jYW52YXMuY2xpZW50V2lkdGggfHwgY3R4LmNhbnZhcy53aWR0aDtcclxuXHRcdFx0XHR2YXIgY0hlaWdodCA9IGN0eC5jYW52YXMuY2xpZW50SGVpZ2h0IHx8IGN0eC5jYW52YXMuaGVpZ2h0O1xyXG5cdFx0XHRcdGlmIChzdmcub3B0c1snaWdub3JlRGltZW5zaW9ucyddID09IHRydWUgJiYgZS5zdHlsZSgnd2lkdGgnKS5oYXNWYWx1ZSgpICYmIGUuc3R5bGUoJ2hlaWdodCcpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdGNXaWR0aCA9IGUuc3R5bGUoJ3dpZHRoJykudG9QaXhlbHMoJ3gnKTtcclxuXHRcdFx0XHRcdGNIZWlnaHQgPSBlLnN0eWxlKCdoZWlnaHQnKS50b1BpeGVscygneScpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRzdmcuVmlld1BvcnQuU2V0Q3VycmVudChjV2lkdGgsIGNIZWlnaHQpO1xyXG5cclxuXHRcdFx0XHRpZiAoc3ZnLm9wdHNbJ29mZnNldFgnXSAhPSBudWxsKSBlLmF0dHJpYnV0ZSgneCcsIHRydWUpLnZhbHVlID0gc3ZnLm9wdHNbJ29mZnNldFgnXTtcclxuXHRcdFx0XHRpZiAoc3ZnLm9wdHNbJ29mZnNldFknXSAhPSBudWxsKSBlLmF0dHJpYnV0ZSgneScsIHRydWUpLnZhbHVlID0gc3ZnLm9wdHNbJ29mZnNldFknXTtcclxuXHRcdFx0XHRpZiAoc3ZnLm9wdHNbJ3NjYWxlV2lkdGgnXSAhPSBudWxsIHx8IHN2Zy5vcHRzWydzY2FsZUhlaWdodCddICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdHZhciB4UmF0aW8gPSBudWxsLCB5UmF0aW8gPSBudWxsLCB2aWV3Qm94ID0gc3ZnLlRvTnVtYmVyQXJyYXkoZS5hdHRyaWJ1dGUoJ3ZpZXdCb3gnKS52YWx1ZSk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKHN2Zy5vcHRzWydzY2FsZVdpZHRoJ10gIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRpZiAoZS5hdHRyaWJ1dGUoJ3dpZHRoJykuaGFzVmFsdWUoKSkgeFJhdGlvID0gZS5hdHRyaWJ1dGUoJ3dpZHRoJykudG9QaXhlbHMoJ3gnKSAvIHN2Zy5vcHRzWydzY2FsZVdpZHRoJ107XHJcblx0XHRcdFx0XHRcdGVsc2UgaWYgKCFpc05hTih2aWV3Qm94WzJdKSkgeFJhdGlvID0gdmlld0JveFsyXSAvIHN2Zy5vcHRzWydzY2FsZVdpZHRoJ107XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHN2Zy5vcHRzWydzY2FsZUhlaWdodCddICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0aWYgKGUuYXR0cmlidXRlKCdoZWlnaHQnKS5oYXNWYWx1ZSgpKSB5UmF0aW8gPSBlLmF0dHJpYnV0ZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKSAvIHN2Zy5vcHRzWydzY2FsZUhlaWdodCddO1xyXG5cdFx0XHRcdFx0XHRlbHNlIGlmICghaXNOYU4odmlld0JveFszXSkpIHlSYXRpbyA9IHZpZXdCb3hbM10gLyBzdmcub3B0c1snc2NhbGVIZWlnaHQnXTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoeFJhdGlvID09IG51bGwpIHsgeFJhdGlvID0geVJhdGlvOyB9XHJcblx0XHRcdFx0XHRpZiAoeVJhdGlvID09IG51bGwpIHsgeVJhdGlvID0geFJhdGlvOyB9XHJcblxyXG5cdFx0XHRcdFx0ZS5hdHRyaWJ1dGUoJ3dpZHRoJywgdHJ1ZSkudmFsdWUgPSBzdmcub3B0c1snc2NhbGVXaWR0aCddO1xyXG5cdFx0XHRcdFx0ZS5hdHRyaWJ1dGUoJ2hlaWdodCcsIHRydWUpLnZhbHVlID0gc3ZnLm9wdHNbJ3NjYWxlSGVpZ2h0J107XHJcblx0XHRcdFx0XHRlLnN0eWxlKCd0cmFuc2Zvcm0nLCB0cnVlLCB0cnVlKS52YWx1ZSArPSAnIHNjYWxlKCcrKDEuMC94UmF0aW8pKycsJysoMS4wL3lSYXRpbykrJyknO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gY2xlYXIgYW5kIHJlbmRlclxyXG5cdFx0XHRcdGlmIChzdmcub3B0c1snaWdub3JlQ2xlYXInXSAhPSB0cnVlKSB7XHJcblx0XHRcdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIGNXaWR0aCwgY0hlaWdodCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGUucmVuZGVyKGN0eCk7XHJcblx0XHRcdFx0aWYgKGlzRmlyc3RSZW5kZXIpIHtcclxuXHRcdFx0XHRcdGlzRmlyc3RSZW5kZXIgPSBmYWxzZTtcclxuXHRcdFx0XHRcdGlmICh0eXBlb2Ygc3ZnLm9wdHNbJ3JlbmRlckNhbGxiYWNrJ10gPT0gJ2Z1bmN0aW9uJykgc3ZnLm9wdHNbJ3JlbmRlckNhbGxiYWNrJ10oZG9tKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB3YWl0aW5nRm9ySW1hZ2VzID0gdHJ1ZTtcclxuXHRcdFx0aWYgKHN2Zy5JbWFnZXNMb2FkZWQoKSkge1xyXG5cdFx0XHRcdHdhaXRpbmdGb3JJbWFnZXMgPSBmYWxzZTtcclxuXHRcdFx0XHRkcmF3KCk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3ZnLmludGVydmFsSUQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgbmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRpZiAod2FpdGluZ0ZvckltYWdlcyAmJiBzdmcuSW1hZ2VzTG9hZGVkKCkpIHtcclxuXHRcdFx0XHRcdHdhaXRpbmdGb3JJbWFnZXMgPSBmYWxzZTtcclxuXHRcdFx0XHRcdG5lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gbmVlZCB1cGRhdGUgZnJvbSBtb3VzZSBldmVudHM/XHJcblx0XHRcdFx0aWYgKHN2Zy5vcHRzWydpZ25vcmVNb3VzZSddICE9IHRydWUpIHtcclxuXHRcdFx0XHRcdG5lZWRVcGRhdGUgPSBuZWVkVXBkYXRlIHwgc3ZnLk1vdXNlLmhhc0V2ZW50cygpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gbmVlZCB1cGRhdGUgZnJvbSBhbmltYXRpb25zP1xyXG5cdFx0XHRcdGlmIChzdmcub3B0c1snaWdub3JlQW5pbWF0aW9uJ10gIT0gdHJ1ZSkge1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHN2Zy5BbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdG5lZWRVcGRhdGUgPSBuZWVkVXBkYXRlIHwgc3ZnLkFuaW1hdGlvbnNbaV0udXBkYXRlKDEwMDAgLyBzdmcuRlJBTUVSQVRFKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIG5lZWQgdXBkYXRlIGZyb20gcmVkcmF3P1xyXG5cdFx0XHRcdGlmICh0eXBlb2Ygc3ZnLm9wdHNbJ2ZvcmNlUmVkcmF3J10gPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdFx0aWYgKHN2Zy5vcHRzWydmb3JjZVJlZHJhdyddKCkgPT0gdHJ1ZSkgbmVlZFVwZGF0ZSA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyByZW5kZXIgaWYgbmVlZGVkXHJcblx0XHRcdFx0aWYgKG5lZWRVcGRhdGUpIHtcclxuXHRcdFx0XHRcdGRyYXcoKTtcclxuXHRcdFx0XHRcdHN2Zy5Nb3VzZS5ydW5FdmVudHMoKTsgLy8gcnVuIGFuZCBjbGVhciBvdXIgZXZlbnRzXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LCAxMDAwIC8gc3ZnLkZSQU1FUkFURSk7XHJcblx0XHR9XHJcblxyXG5cdFx0c3ZnLnN0b3AgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0aWYgKHN2Zy5pbnRlcnZhbElEKSB7XHJcblx0XHRcdFx0Y2xlYXJJbnRlcnZhbChzdmcuaW50ZXJ2YWxJRCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRzdmcuTW91c2UgPSBuZXcgKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR0aGlzLmV2ZW50cyA9IFtdO1xyXG5cdFx0XHR0aGlzLmhhc0V2ZW50cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5ldmVudHMubGVuZ3RoICE9IDA7IH1cclxuXHJcblx0XHRcdHRoaXMub25jbGljayA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuXHRcdFx0XHR0aGlzLmV2ZW50cy5wdXNoKHsgdHlwZTogJ29uY2xpY2snLCB4OiB4LCB5OiB5LFxyXG5cdFx0XHRcdFx0cnVuOiBmdW5jdGlvbihlKSB7IGlmIChlLm9uY2xpY2spIGUub25jbGljaygpOyB9XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMub25tb3VzZW1vdmUgPSBmdW5jdGlvbih4LCB5KSB7XHJcblx0XHRcdFx0dGhpcy5ldmVudHMucHVzaCh7IHR5cGU6ICdvbm1vdXNlbW92ZScsIHg6IHgsIHk6IHksXHJcblx0XHRcdFx0XHRydW46IGZ1bmN0aW9uKGUpIHsgaWYgKGUub25tb3VzZW1vdmUpIGUub25tb3VzZW1vdmUoKTsgfVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmV2ZW50RWxlbWVudHMgPSBbXTtcclxuXHJcblx0XHRcdHRoaXMuY2hlY2tQYXRoID0gZnVuY3Rpb24oZWxlbWVudCwgY3R4KSB7XHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuZXZlbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgZSA9IHRoaXMuZXZlbnRzW2ldO1xyXG5cdFx0XHRcdFx0aWYgKGN0eC5pc1BvaW50SW5QYXRoICYmIGN0eC5pc1BvaW50SW5QYXRoKGUueCwgZS55KSkgdGhpcy5ldmVudEVsZW1lbnRzW2ldID0gZWxlbWVudDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuY2hlY2tCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGJiKSB7XHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuZXZlbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgZSA9IHRoaXMuZXZlbnRzW2ldO1xyXG5cdFx0XHRcdFx0aWYgKGJiLmlzUG9pbnRJbkJveChlLngsIGUueSkpIHRoaXMuZXZlbnRFbGVtZW50c1tpXSA9IGVsZW1lbnQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnJ1bkV2ZW50cyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHN2Zy5jdHguY2FudmFzLnN0eWxlLmN1cnNvciA9ICcnO1xyXG5cclxuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8dGhpcy5ldmVudHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHZhciBlID0gdGhpcy5ldmVudHNbaV07XHJcblx0XHRcdFx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZXZlbnRFbGVtZW50c1tpXTtcclxuXHRcdFx0XHRcdHdoaWxlIChlbGVtZW50KSB7XHJcblx0XHRcdFx0XHRcdGUucnVuKGVsZW1lbnQpO1xyXG5cdFx0XHRcdFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQ7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBkb25lIHJ1bm5pbmcsIGNsZWFyXHJcblx0XHRcdFx0dGhpcy5ldmVudHMgPSBbXTtcclxuXHRcdFx0XHR0aGlzLmV2ZW50RWxlbWVudHMgPSBbXTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHN2ZztcclxuXHR9O1xyXG5cblx0aWYgKHR5cGVvZiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgICE9ICd1bmRlZmluZWQnKSB7XHJcblx0XHRDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmRyYXdTdmcgPSBmdW5jdGlvbihzLCBkeCwgZHksIGR3LCBkaCwgb3B0cykge1xyXG5cdFx0XHR2YXIgY09wdHMgPSB7XG5cdFx0XHRcdGlnbm9yZU1vdXNlOiB0cnVlLFxyXG5cdFx0XHRcdGlnbm9yZUFuaW1hdGlvbjogdHJ1ZSxcclxuXHRcdFx0XHRpZ25vcmVEaW1lbnNpb25zOiB0cnVlLFxyXG5cdFx0XHRcdGlnbm9yZUNsZWFyOiB0cnVlLFxyXG5cdFx0XHRcdG9mZnNldFg6IGR4LFxyXG5cdFx0XHRcdG9mZnNldFk6IGR5LFxyXG5cdFx0XHRcdHNjYWxlV2lkdGg6IGR3LFxyXG5cdFx0XHRcdHNjYWxlSGVpZ2h0OiBkaFxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRmb3IodmFyIHByb3AgaW4gb3B0cykge1xyXG5cdFx0XHRcdGlmKG9wdHMuaGFzT3duUHJvcGVydHkocHJvcCkpe1xyXG5cdFx0XHRcdFx0Y09wdHNbcHJvcF0gPSBvcHRzW3Byb3BdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRjYW52Zyh0aGlzLmNhbnZhcywgcywgY09wdHMpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNhbnZnO1xyXG5cclxufSkpO1xyXG4iLCIvKlxuXG5TdGFja0JsdXIgLSBhIGZhc3QgYWxtb3N0IEdhdXNzaWFuIEJsdXIgRm9yIENhbnZhc1xuXG5WZXJzaW9uOiBcdDAuNVxuQXV0aG9yOlx0XHRNYXJpbyBLbGluZ2VtYW5uXG5Db250YWN0OiBcdG1hcmlvQHF1YXNpbW9uZG8uY29tXG5XZWJzaXRlOlx0aHR0cDovL3d3dy5xdWFzaW1vbmRvLmNvbS9TdGFja0JsdXJGb3JDYW52YXNcblR3aXR0ZXI6XHRAcXVhc2ltb25kb1xuXG5JbiBjYXNlIHlvdSBmaW5kIHRoaXMgY2xhc3MgdXNlZnVsIC0gZXNwZWNpYWxseSBpbiBjb21tZXJjaWFsIHByb2plY3RzIC1cbkkgYW0gbm90IHRvdGFsbHkgdW5oYXBweSBmb3IgYSBzbWFsbCBkb25hdGlvbiB0byBteSBQYXlQYWwgYWNjb3VudFxubWFyaW9AcXVhc2ltb25kby5kZVxuXG5PciBzdXBwb3J0IG1lIG9uIGZsYXR0cjogXG5odHRwczovL2ZsYXR0ci5jb20vdGhpbmcvNzI3OTEvU3RhY2tCbHVyLWEtZmFzdC1hbG1vc3QtR2F1c3NpYW4tQmx1ci1FZmZlY3QtZm9yLUNhbnZhc0phdmFzY3JpcHRcblxuQ29weXJpZ2h0IChjKSAyMDEwIE1hcmlvIEtsaW5nZW1hbm5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbm9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG5maWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbnJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbmNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbk5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG5IT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbldIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cblxudmFyIG11bF90YWJsZSA9IFtcbiAgICAgICAgNTEyLDUxMiw0NTYsNTEyLDMyOCw0NTYsMzM1LDUxMiw0MDUsMzI4LDI3MSw0NTYsMzg4LDMzNSwyOTIsNTEyLFxuICAgICAgICA0NTQsNDA1LDM2NCwzMjgsMjk4LDI3MSw0OTYsNDU2LDQyMCwzODgsMzYwLDMzNSwzMTIsMjkyLDI3Myw1MTIsXG4gICAgICAgIDQ4Miw0NTQsNDI4LDQwNSwzODMsMzY0LDM0NSwzMjgsMzEyLDI5OCwyODQsMjcxLDI1OSw0OTYsNDc1LDQ1NixcbiAgICAgICAgNDM3LDQyMCw0MDQsMzg4LDM3NCwzNjAsMzQ3LDMzNSwzMjMsMzEyLDMwMiwyOTIsMjgyLDI3MywyNjUsNTEyLFxuICAgICAgICA0OTcsNDgyLDQ2OCw0NTQsNDQxLDQyOCw0MTcsNDA1LDM5NCwzODMsMzczLDM2NCwzNTQsMzQ1LDMzNywzMjgsXG4gICAgICAgIDMyMCwzMTIsMzA1LDI5OCwyOTEsMjg0LDI3OCwyNzEsMjY1LDI1OSw1MDcsNDk2LDQ4NSw0NzUsNDY1LDQ1NixcbiAgICAgICAgNDQ2LDQzNyw0MjgsNDIwLDQxMiw0MDQsMzk2LDM4OCwzODEsMzc0LDM2NywzNjAsMzU0LDM0NywzNDEsMzM1LFxuICAgICAgICAzMjksMzIzLDMxOCwzMTIsMzA3LDMwMiwyOTcsMjkyLDI4NywyODIsMjc4LDI3MywyNjksMjY1LDI2MSw1MTIsXG4gICAgICAgIDUwNSw0OTcsNDg5LDQ4Miw0NzUsNDY4LDQ2MSw0NTQsNDQ3LDQ0MSw0MzUsNDI4LDQyMiw0MTcsNDExLDQwNSxcbiAgICAgICAgMzk5LDM5NCwzODksMzgzLDM3OCwzNzMsMzY4LDM2NCwzNTksMzU0LDM1MCwzNDUsMzQxLDMzNywzMzIsMzI4LFxuICAgICAgICAzMjQsMzIwLDMxNiwzMTIsMzA5LDMwNSwzMDEsMjk4LDI5NCwyOTEsMjg3LDI4NCwyODEsMjc4LDI3NCwyNzEsXG4gICAgICAgIDI2OCwyNjUsMjYyLDI1OSwyNTcsNTA3LDUwMSw0OTYsNDkxLDQ4NSw0ODAsNDc1LDQ3MCw0NjUsNDYwLDQ1NixcbiAgICAgICAgNDUxLDQ0Niw0NDIsNDM3LDQzMyw0MjgsNDI0LDQyMCw0MTYsNDEyLDQwOCw0MDQsNDAwLDM5NiwzOTIsMzg4LFxuICAgICAgICAzODUsMzgxLDM3NywzNzQsMzcwLDM2NywzNjMsMzYwLDM1NywzNTQsMzUwLDM0NywzNDQsMzQxLDMzOCwzMzUsXG4gICAgICAgIDMzMiwzMjksMzI2LDMyMywzMjAsMzE4LDMxNSwzMTIsMzEwLDMwNywzMDQsMzAyLDI5OSwyOTcsMjk0LDI5MixcbiAgICAgICAgMjg5LDI4NywyODUsMjgyLDI4MCwyNzgsMjc1LDI3MywyNzEsMjY5LDI2NywyNjUsMjYzLDI2MSwyNTldO1xuICAgICAgICBcbiAgIFxudmFyIHNoZ190YWJsZSA9IFtcblx0ICAgICA5LCAxMSwgMTIsIDEzLCAxMywgMTQsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTYsIDE2LCAxNiwgMTYsIDE3LCBcblx0XHQxNywgMTcsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOSwgXG5cdFx0MTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsXG5cdFx0MjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjEsXG5cdFx0MjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsXG5cdFx0MjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIFxuXHRcdDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLFxuXHRcdDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIzLCBcblx0XHQyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMyxcblx0XHQyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMyxcblx0XHQyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgXG5cdFx0MjMsIDIzLCAyMywgMjMsIDIzLCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIFxuXHRcdDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxuXHRcdDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxuXHRcdDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxuXHRcdDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQgXTtcblxuZnVuY3Rpb24gYmx1ciggcGl4ZWxzLCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMgKVxue1xuXHRpZiAoIGlzTmFOKHJhZGl1cykgfHwgcmFkaXVzIDwgMSApIHJldHVybjtcblx0cmFkaXVzIHw9IDA7XG5cblx0dmFyIHgsIHksIGksIHAsIHlwLCB5aSwgeXcsIHJfc3VtLCBnX3N1bSwgYl9zdW0sIGFfc3VtLCBcblx0cl9vdXRfc3VtLCBnX291dF9zdW0sIGJfb3V0X3N1bSwgYV9vdXRfc3VtLFxuXHRyX2luX3N1bSwgZ19pbl9zdW0sIGJfaW5fc3VtLCBhX2luX3N1bSwgXG5cdHByLCBwZywgcGIsIHBhLCByYnM7XG5cdFx0XHRcblx0dmFyIGRpdiA9IHJhZGl1cyArIHJhZGl1cyArIDE7XG5cdHZhciB3NCA9IHdpZHRoIDw8IDI7XG5cdHZhciB3aWR0aE1pbnVzMSAgPSB3aWR0aCAtIDE7XG5cdHZhciBoZWlnaHRNaW51czEgPSBoZWlnaHQgLSAxO1xuXHR2YXIgcmFkaXVzUGx1czEgID0gcmFkaXVzICsgMTtcblx0dmFyIHN1bUZhY3RvciA9IHJhZGl1c1BsdXMxICogKCByYWRpdXNQbHVzMSArIDEgKSAvIDI7XG5cdFxuXHR2YXIgc3RhY2tTdGFydCA9IG5ldyBCbHVyU3RhY2soKTtcblx0dmFyIHN0YWNrID0gc3RhY2tTdGFydDtcblx0Zm9yICggaSA9IDE7IGkgPCBkaXY7IGkrKyApXG5cdHtcblx0XHRzdGFjayA9IHN0YWNrLm5leHQgPSBuZXcgQmx1clN0YWNrKCk7XG5cdFx0aWYgKCBpID09IHJhZGl1c1BsdXMxICkgdmFyIHN0YWNrRW5kID0gc3RhY2s7XG5cdH1cblx0c3RhY2submV4dCA9IHN0YWNrU3RhcnQ7XG5cdHZhciBzdGFja0luID0gbnVsbDtcblx0dmFyIHN0YWNrT3V0ID0gbnVsbDtcblx0XG5cdHl3ID0geWkgPSAwO1xuXHRcblx0dmFyIG11bF9zdW0gPSBtdWxfdGFibGVbcmFkaXVzXTtcblx0dmFyIHNoZ19zdW0gPSBzaGdfdGFibGVbcmFkaXVzXTtcblx0XG5cdGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KysgKVxuXHR7XG5cdFx0cl9pbl9zdW0gPSBnX2luX3N1bSA9IGJfaW5fc3VtID0gYV9pbl9zdW0gPSByX3N1bSA9IGdfc3VtID0gYl9zdW0gPSBhX3N1bSA9IDA7XG5cdFx0XG5cdFx0cl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHByID0gcGl4ZWxzW3lpXSApO1xuXHRcdGdfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwZyA9IHBpeGVsc1t5aSsxXSApO1xuXHRcdGJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwYiA9IHBpeGVsc1t5aSsyXSApO1xuXHRcdGFfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwYSA9IHBpeGVsc1t5aSszXSApO1xuXHRcdFxuXHRcdHJfc3VtICs9IHN1bUZhY3RvciAqIHByO1xuXHRcdGdfc3VtICs9IHN1bUZhY3RvciAqIHBnO1xuXHRcdGJfc3VtICs9IHN1bUZhY3RvciAqIHBiO1xuXHRcdGFfc3VtICs9IHN1bUZhY3RvciAqIHBhO1xuXHRcdFxuXHRcdHN0YWNrID0gc3RhY2tTdGFydDtcblx0XHRcblx0XHRmb3IoIGkgPSAwOyBpIDwgcmFkaXVzUGx1czE7IGkrKyApXG5cdFx0e1xuXHRcdFx0c3RhY2suciA9IHByO1xuXHRcdFx0c3RhY2suZyA9IHBnO1xuXHRcdFx0c3RhY2suYiA9IHBiO1xuXHRcdFx0c3RhY2suYSA9IHBhO1xuXHRcdFx0c3RhY2sgPSBzdGFjay5uZXh0O1xuXHRcdH1cblx0XHRcblx0XHRmb3IoIGkgPSAxOyBpIDwgcmFkaXVzUGx1czE7IGkrKyApXG5cdFx0e1xuXHRcdFx0cCA9IHlpICsgKCggd2lkdGhNaW51czEgPCBpID8gd2lkdGhNaW51czEgOiBpICkgPDwgMiApO1xuXHRcdFx0cl9zdW0gKz0gKCBzdGFjay5yID0gKCBwciA9IHBpeGVsc1twXSkpICogKCByYnMgPSByYWRpdXNQbHVzMSAtIGkgKTtcblx0XHRcdGdfc3VtICs9ICggc3RhY2suZyA9ICggcGcgPSBwaXhlbHNbcCsxXSkpICogcmJzO1xuXHRcdFx0Yl9zdW0gKz0gKCBzdGFjay5iID0gKCBwYiA9IHBpeGVsc1twKzJdKSkgKiByYnM7XG5cdFx0XHRhX3N1bSArPSAoIHN0YWNrLmEgPSAoIHBhID0gcGl4ZWxzW3ArM10pKSAqIHJicztcblx0XHRcdFxuXHRcdFx0cl9pbl9zdW0gKz0gcHI7XG5cdFx0XHRnX2luX3N1bSArPSBwZztcblx0XHRcdGJfaW5fc3VtICs9IHBiO1xuXHRcdFx0YV9pbl9zdW0gKz0gcGE7XG5cdFx0XHRcblx0XHRcdHN0YWNrID0gc3RhY2submV4dDtcblx0XHR9XG5cdFx0XG5cdFx0XG5cdFx0c3RhY2tJbiA9IHN0YWNrU3RhcnQ7XG5cdFx0c3RhY2tPdXQgPSBzdGFja0VuZDtcblx0XHRmb3IgKCB4ID0gMDsgeCA8IHdpZHRoOyB4KysgKVxuXHRcdHtcblx0XHRcdHBpeGVsc1t5aSszXSA9IHBhID0gKGFfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bTtcblx0XHRcdGlmICggcGEgIT0gMCApXG5cdFx0XHR7XG5cdFx0XHRcdHBhID0gMjU1IC8gcGE7XG5cdFx0XHRcdHBpeGVsc1t5aV0gICA9ICgocl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtKSAqIHBhO1xuXHRcdFx0XHRwaXhlbHNbeWkrMV0gPSAoKGdfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcblx0XHRcdFx0cGl4ZWxzW3lpKzJdID0gKChiX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0pICogcGE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwaXhlbHNbeWldID0gcGl4ZWxzW3lpKzFdID0gcGl4ZWxzW3lpKzJdID0gMDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cl9zdW0gLT0gcl9vdXRfc3VtO1xuXHRcdFx0Z19zdW0gLT0gZ19vdXRfc3VtO1xuXHRcdFx0Yl9zdW0gLT0gYl9vdXRfc3VtO1xuXHRcdFx0YV9zdW0gLT0gYV9vdXRfc3VtO1xuXHRcdFx0XG5cdFx0XHRyX291dF9zdW0gLT0gc3RhY2tJbi5yO1xuXHRcdFx0Z19vdXRfc3VtIC09IHN0YWNrSW4uZztcblx0XHRcdGJfb3V0X3N1bSAtPSBzdGFja0luLmI7XG5cdFx0XHRhX291dF9zdW0gLT0gc3RhY2tJbi5hO1xuXHRcdFx0XG5cdFx0XHRwID0gICggeXcgKyAoICggcCA9IHggKyByYWRpdXMgKyAxICkgPCB3aWR0aE1pbnVzMSA/IHAgOiB3aWR0aE1pbnVzMSApICkgPDwgMjtcblx0XHRcdFxuXHRcdFx0cl9pbl9zdW0gKz0gKCBzdGFja0luLnIgPSBwaXhlbHNbcF0pO1xuXHRcdFx0Z19pbl9zdW0gKz0gKCBzdGFja0luLmcgPSBwaXhlbHNbcCsxXSk7XG5cdFx0XHRiX2luX3N1bSArPSAoIHN0YWNrSW4uYiA9IHBpeGVsc1twKzJdKTtcblx0XHRcdGFfaW5fc3VtICs9ICggc3RhY2tJbi5hID0gcGl4ZWxzW3ArM10pO1xuXHRcdFx0XG5cdFx0XHRyX3N1bSArPSByX2luX3N1bTtcblx0XHRcdGdfc3VtICs9IGdfaW5fc3VtO1xuXHRcdFx0Yl9zdW0gKz0gYl9pbl9zdW07XG5cdFx0XHRhX3N1bSArPSBhX2luX3N1bTtcblx0XHRcdFxuXHRcdFx0c3RhY2tJbiA9IHN0YWNrSW4ubmV4dDtcblx0XHRcdFxuXHRcdFx0cl9vdXRfc3VtICs9ICggcHIgPSBzdGFja091dC5yICk7XG5cdFx0XHRnX291dF9zdW0gKz0gKCBwZyA9IHN0YWNrT3V0LmcgKTtcblx0XHRcdGJfb3V0X3N1bSArPSAoIHBiID0gc3RhY2tPdXQuYiApO1xuXHRcdFx0YV9vdXRfc3VtICs9ICggcGEgPSBzdGFja091dC5hICk7XG5cdFx0XHRcblx0XHRcdHJfaW5fc3VtIC09IHByO1xuXHRcdFx0Z19pbl9zdW0gLT0gcGc7XG5cdFx0XHRiX2luX3N1bSAtPSBwYjtcblx0XHRcdGFfaW5fc3VtIC09IHBhO1xuXHRcdFx0XG5cdFx0XHRzdGFja091dCA9IHN0YWNrT3V0Lm5leHQ7XG5cblx0XHRcdHlpICs9IDQ7XG5cdFx0fVxuXHRcdHl3ICs9IHdpZHRoO1xuXHR9XG5cblx0XG5cdGZvciAoIHggPSAwOyB4IDwgd2lkdGg7IHgrKyApXG5cdHtcblx0XHRnX2luX3N1bSA9IGJfaW5fc3VtID0gYV9pbl9zdW0gPSByX2luX3N1bSA9IGdfc3VtID0gYl9zdW0gPSBhX3N1bSA9IHJfc3VtID0gMDtcblx0XHRcblx0XHR5aSA9IHggPDwgMjtcblx0XHRyX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcHIgPSBwaXhlbHNbeWldKTtcblx0XHRnX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGcgPSBwaXhlbHNbeWkrMV0pO1xuXHRcdGJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwYiA9IHBpeGVsc1t5aSsyXSk7XG5cdFx0YV9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBhID0gcGl4ZWxzW3lpKzNdKTtcblx0XHRcblx0XHRyX3N1bSArPSBzdW1GYWN0b3IgKiBwcjtcblx0XHRnX3N1bSArPSBzdW1GYWN0b3IgKiBwZztcblx0XHRiX3N1bSArPSBzdW1GYWN0b3IgKiBwYjtcblx0XHRhX3N1bSArPSBzdW1GYWN0b3IgKiBwYTtcblx0XHRcblx0XHRzdGFjayA9IHN0YWNrU3RhcnQ7XG5cdFx0XG5cdFx0Zm9yKCBpID0gMDsgaSA8IHJhZGl1c1BsdXMxOyBpKysgKVxuXHRcdHtcblx0XHRcdHN0YWNrLnIgPSBwcjtcblx0XHRcdHN0YWNrLmcgPSBwZztcblx0XHRcdHN0YWNrLmIgPSBwYjtcblx0XHRcdHN0YWNrLmEgPSBwYTtcblx0XHRcdHN0YWNrID0gc3RhY2submV4dDtcblx0XHR9XG5cdFx0XG5cdFx0eXAgPSB3aWR0aDtcblx0XHRcblx0XHRmb3IoIGkgPSAxOyBpIDw9IHJhZGl1czsgaSsrIClcblx0XHR7XG5cdFx0XHR5aSA9ICggeXAgKyB4ICkgPDwgMjtcblx0XHRcdFxuXHRcdFx0cl9zdW0gKz0gKCBzdGFjay5yID0gKCBwciA9IHBpeGVsc1t5aV0pKSAqICggcmJzID0gcmFkaXVzUGx1czEgLSBpICk7XG5cdFx0XHRnX3N1bSArPSAoIHN0YWNrLmcgPSAoIHBnID0gcGl4ZWxzW3lpKzFdKSkgKiByYnM7XG5cdFx0XHRiX3N1bSArPSAoIHN0YWNrLmIgPSAoIHBiID0gcGl4ZWxzW3lpKzJdKSkgKiByYnM7XG5cdFx0XHRhX3N1bSArPSAoIHN0YWNrLmEgPSAoIHBhID0gcGl4ZWxzW3lpKzNdKSkgKiByYnM7XG5cdFx0ICAgXG5cdFx0XHRyX2luX3N1bSArPSBwcjtcblx0XHRcdGdfaW5fc3VtICs9IHBnO1xuXHRcdFx0Yl9pbl9zdW0gKz0gcGI7XG5cdFx0XHRhX2luX3N1bSArPSBwYTtcblx0XHRcdFxuXHRcdFx0c3RhY2sgPSBzdGFjay5uZXh0O1xuXHRcdFxuXHRcdFx0aWYoIGkgPCBoZWlnaHRNaW51czEgKVxuXHRcdFx0e1xuXHRcdFx0XHR5cCArPSB3aWR0aDtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0eWkgPSB4O1xuXHRcdHN0YWNrSW4gPSBzdGFja1N0YXJ0O1xuXHRcdHN0YWNrT3V0ID0gc3RhY2tFbmQ7XG5cdFx0Zm9yICggeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKyApXG5cdFx0e1xuXHRcdFx0cCA9IHlpIDw8IDI7XG5cdFx0XHRwaXhlbHNbcCszXSA9IHBhID0gKGFfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bTtcblx0XHRcdGlmICggcGEgPiAwIClcblx0XHRcdHtcblx0XHRcdFx0cGEgPSAyNTUgLyBwYTtcblx0XHRcdFx0cGl4ZWxzW3BdICAgPSAoKHJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSApICogcGE7XG5cdFx0XHRcdHBpeGVsc1twKzFdID0gKChnX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0gKSAqIHBhO1xuXHRcdFx0XHRwaXhlbHNbcCsyXSA9ICgoYl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtICkgKiBwYTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBpeGVsc1twXSA9IHBpeGVsc1twKzFdID0gcGl4ZWxzW3ArMl0gPSAwO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyX3N1bSAtPSByX291dF9zdW07XG5cdFx0XHRnX3N1bSAtPSBnX291dF9zdW07XG5cdFx0XHRiX3N1bSAtPSBiX291dF9zdW07XG5cdFx0XHRhX3N1bSAtPSBhX291dF9zdW07XG5cdFx0ICAgXG5cdFx0XHRyX291dF9zdW0gLT0gc3RhY2tJbi5yO1xuXHRcdFx0Z19vdXRfc3VtIC09IHN0YWNrSW4uZztcblx0XHRcdGJfb3V0X3N1bSAtPSBzdGFja0luLmI7XG5cdFx0XHRhX291dF9zdW0gLT0gc3RhY2tJbi5hO1xuXHRcdFx0XG5cdFx0XHRwID0gKCB4ICsgKCggKCBwID0geSArIHJhZGl1c1BsdXMxKSA8IGhlaWdodE1pbnVzMSA/IHAgOiBoZWlnaHRNaW51czEgKSAqIHdpZHRoICkpIDw8IDI7XG5cdFx0XHRcblx0XHRcdHJfc3VtICs9ICggcl9pbl9zdW0gKz0gKCBzdGFja0luLnIgPSBwaXhlbHNbcF0pKTtcblx0XHRcdGdfc3VtICs9ICggZ19pbl9zdW0gKz0gKCBzdGFja0luLmcgPSBwaXhlbHNbcCsxXSkpO1xuXHRcdFx0Yl9zdW0gKz0gKCBiX2luX3N1bSArPSAoIHN0YWNrSW4uYiA9IHBpeGVsc1twKzJdKSk7XG5cdFx0XHRhX3N1bSArPSAoIGFfaW5fc3VtICs9ICggc3RhY2tJbi5hID0gcGl4ZWxzW3ArM10pKTtcblx0XHQgICBcblx0XHRcdHN0YWNrSW4gPSBzdGFja0luLm5leHQ7XG5cdFx0XHRcblx0XHRcdHJfb3V0X3N1bSArPSAoIHByID0gc3RhY2tPdXQuciApO1xuXHRcdFx0Z19vdXRfc3VtICs9ICggcGcgPSBzdGFja091dC5nICk7XG5cdFx0XHRiX291dF9zdW0gKz0gKCBwYiA9IHN0YWNrT3V0LmIgKTtcblx0XHRcdGFfb3V0X3N1bSArPSAoIHBhID0gc3RhY2tPdXQuYSApO1xuXHRcdFx0XG5cdFx0XHRyX2luX3N1bSAtPSBwcjtcblx0XHRcdGdfaW5fc3VtIC09IHBnO1xuXHRcdFx0Yl9pbl9zdW0gLT0gcGI7XG5cdFx0XHRhX2luX3N1bSAtPSBwYTtcblx0XHRcdFxuXHRcdFx0c3RhY2tPdXQgPSBzdGFja091dC5uZXh0O1xuXHRcdFx0XG5cdFx0XHR5aSArPSB3aWR0aDtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQmx1clN0YWNrKClcbntcblx0dGhpcy5yID0gMDtcblx0dGhpcy5nID0gMDtcblx0dGhpcy5iID0gMDtcblx0dGhpcy5hID0gMDtcblx0dGhpcy5uZXh0ID0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBibHVyOyIsIi8qXG5cdEJhc2VkIG9uIHJnYmNvbG9yLmpzIGJ5IFN0b3lhbiBTdGVmYW5vdiA8c3N0b29AZ21haWwuY29tPlxuXHRodHRwOi8vd3d3LnBocGllZC5jb20vcmdiLWNvbG9yLXBhcnNlci1pbi1qYXZhc2NyaXB0L1xuKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb2xvcl9zdHJpbmcpIHtcbiAgICB0aGlzLm9rID0gZmFsc2U7XG4gICAgdGhpcy5hbHBoYSA9IDEuMDtcblxuICAgIC8vIHN0cmlwIGFueSBsZWFkaW5nICNcbiAgICBpZiAoY29sb3Jfc3RyaW5nLmNoYXJBdCgwKSA9PSAnIycpIHsgLy8gcmVtb3ZlICMgaWYgYW55XG4gICAgICAgIGNvbG9yX3N0cmluZyA9IGNvbG9yX3N0cmluZy5zdWJzdHIoMSw2KTtcbiAgICB9XG5cbiAgICBjb2xvcl9zdHJpbmcgPSBjb2xvcl9zdHJpbmcucmVwbGFjZSgvIC9nLCcnKTtcbiAgICBjb2xvcl9zdHJpbmcgPSBjb2xvcl9zdHJpbmcudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIGJlZm9yZSBnZXR0aW5nIGludG8gcmVnZXhwcywgdHJ5IHNpbXBsZSBtYXRjaGVzXG4gICAgLy8gYW5kIG92ZXJ3cml0ZSB0aGUgaW5wdXRcbiAgICB2YXIgc2ltcGxlX2NvbG9ycyA9IHtcbiAgICAgICAgYWxpY2VibHVlOiAnZjBmOGZmJyxcbiAgICAgICAgYW50aXF1ZXdoaXRlOiAnZmFlYmQ3JyxcbiAgICAgICAgYXF1YTogJzAwZmZmZicsXG4gICAgICAgIGFxdWFtYXJpbmU6ICc3ZmZmZDQnLFxuICAgICAgICBhenVyZTogJ2YwZmZmZicsXG4gICAgICAgIGJlaWdlOiAnZjVmNWRjJyxcbiAgICAgICAgYmlzcXVlOiAnZmZlNGM0JyxcbiAgICAgICAgYmxhY2s6ICcwMDAwMDAnLFxuICAgICAgICBibGFuY2hlZGFsbW9uZDogJ2ZmZWJjZCcsXG4gICAgICAgIGJsdWU6ICcwMDAwZmYnLFxuICAgICAgICBibHVldmlvbGV0OiAnOGEyYmUyJyxcbiAgICAgICAgYnJvd246ICdhNTJhMmEnLFxuICAgICAgICBidXJseXdvb2Q6ICdkZWI4ODcnLFxuICAgICAgICBjYWRldGJsdWU6ICc1ZjllYTAnLFxuICAgICAgICBjaGFydHJldXNlOiAnN2ZmZjAwJyxcbiAgICAgICAgY2hvY29sYXRlOiAnZDI2OTFlJyxcbiAgICAgICAgY29yYWw6ICdmZjdmNTAnLFxuICAgICAgICBjb3JuZmxvd2VyYmx1ZTogJzY0OTVlZCcsXG4gICAgICAgIGNvcm5zaWxrOiAnZmZmOGRjJyxcbiAgICAgICAgY3JpbXNvbjogJ2RjMTQzYycsXG4gICAgICAgIGN5YW46ICcwMGZmZmYnLFxuICAgICAgICBkYXJrYmx1ZTogJzAwMDA4YicsXG4gICAgICAgIGRhcmtjeWFuOiAnMDA4YjhiJyxcbiAgICAgICAgZGFya2dvbGRlbnJvZDogJ2I4ODYwYicsXG4gICAgICAgIGRhcmtncmF5OiAnYTlhOWE5JyxcbiAgICAgICAgZGFya2dyZWVuOiAnMDA2NDAwJyxcbiAgICAgICAgZGFya2toYWtpOiAnYmRiNzZiJyxcbiAgICAgICAgZGFya21hZ2VudGE6ICc4YjAwOGInLFxuICAgICAgICBkYXJrb2xpdmVncmVlbjogJzU1NmIyZicsXG4gICAgICAgIGRhcmtvcmFuZ2U6ICdmZjhjMDAnLFxuICAgICAgICBkYXJrb3JjaGlkOiAnOTkzMmNjJyxcbiAgICAgICAgZGFya3JlZDogJzhiMDAwMCcsXG4gICAgICAgIGRhcmtzYWxtb246ICdlOTk2N2EnLFxuICAgICAgICBkYXJrc2VhZ3JlZW46ICc4ZmJjOGYnLFxuICAgICAgICBkYXJrc2xhdGVibHVlOiAnNDgzZDhiJyxcbiAgICAgICAgZGFya3NsYXRlZ3JheTogJzJmNGY0ZicsXG4gICAgICAgIGRhcmt0dXJxdW9pc2U6ICcwMGNlZDEnLFxuICAgICAgICBkYXJrdmlvbGV0OiAnOTQwMGQzJyxcbiAgICAgICAgZGVlcHBpbms6ICdmZjE0OTMnLFxuICAgICAgICBkZWVwc2t5Ymx1ZTogJzAwYmZmZicsXG4gICAgICAgIGRpbWdyYXk6ICc2OTY5NjknLFxuICAgICAgICBkb2RnZXJibHVlOiAnMWU5MGZmJyxcbiAgICAgICAgZmVsZHNwYXI6ICdkMTkyNzUnLFxuICAgICAgICBmaXJlYnJpY2s6ICdiMjIyMjInLFxuICAgICAgICBmbG9yYWx3aGl0ZTogJ2ZmZmFmMCcsXG4gICAgICAgIGZvcmVzdGdyZWVuOiAnMjI4YjIyJyxcbiAgICAgICAgZnVjaHNpYTogJ2ZmMDBmZicsXG4gICAgICAgIGdhaW5zYm9ybzogJ2RjZGNkYycsXG4gICAgICAgIGdob3N0d2hpdGU6ICdmOGY4ZmYnLFxuICAgICAgICBnb2xkOiAnZmZkNzAwJyxcbiAgICAgICAgZ29sZGVucm9kOiAnZGFhNTIwJyxcbiAgICAgICAgZ3JheTogJzgwODA4MCcsXG4gICAgICAgIGdyZWVuOiAnMDA4MDAwJyxcbiAgICAgICAgZ3JlZW55ZWxsb3c6ICdhZGZmMmYnLFxuICAgICAgICBob25leWRldzogJ2YwZmZmMCcsXG4gICAgICAgIGhvdHBpbms6ICdmZjY5YjQnLFxuICAgICAgICBpbmRpYW5yZWQgOiAnY2Q1YzVjJyxcbiAgICAgICAgaW5kaWdvIDogJzRiMDA4MicsXG4gICAgICAgIGl2b3J5OiAnZmZmZmYwJyxcbiAgICAgICAga2hha2k6ICdmMGU2OGMnLFxuICAgICAgICBsYXZlbmRlcjogJ2U2ZTZmYScsXG4gICAgICAgIGxhdmVuZGVyYmx1c2g6ICdmZmYwZjUnLFxuICAgICAgICBsYXduZ3JlZW46ICc3Y2ZjMDAnLFxuICAgICAgICBsZW1vbmNoaWZmb246ICdmZmZhY2QnLFxuICAgICAgICBsaWdodGJsdWU6ICdhZGQ4ZTYnLFxuICAgICAgICBsaWdodGNvcmFsOiAnZjA4MDgwJyxcbiAgICAgICAgbGlnaHRjeWFuOiAnZTBmZmZmJyxcbiAgICAgICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICdmYWZhZDInLFxuICAgICAgICBsaWdodGdyZXk6ICdkM2QzZDMnLFxuICAgICAgICBsaWdodGdyZWVuOiAnOTBlZTkwJyxcbiAgICAgICAgbGlnaHRwaW5rOiAnZmZiNmMxJyxcbiAgICAgICAgbGlnaHRzYWxtb246ICdmZmEwN2EnLFxuICAgICAgICBsaWdodHNlYWdyZWVuOiAnMjBiMmFhJyxcbiAgICAgICAgbGlnaHRza3libHVlOiAnODdjZWZhJyxcbiAgICAgICAgbGlnaHRzbGF0ZWJsdWU6ICc4NDcwZmYnLFxuICAgICAgICBsaWdodHNsYXRlZ3JheTogJzc3ODg5OScsXG4gICAgICAgIGxpZ2h0c3RlZWxibHVlOiAnYjBjNGRlJyxcbiAgICAgICAgbGlnaHR5ZWxsb3c6ICdmZmZmZTAnLFxuICAgICAgICBsaW1lOiAnMDBmZjAwJyxcbiAgICAgICAgbGltZWdyZWVuOiAnMzJjZDMyJyxcbiAgICAgICAgbGluZW46ICdmYWYwZTYnLFxuICAgICAgICBtYWdlbnRhOiAnZmYwMGZmJyxcbiAgICAgICAgbWFyb29uOiAnODAwMDAwJyxcbiAgICAgICAgbWVkaXVtYXF1YW1hcmluZTogJzY2Y2RhYScsXG4gICAgICAgIG1lZGl1bWJsdWU6ICcwMDAwY2QnLFxuICAgICAgICBtZWRpdW1vcmNoaWQ6ICdiYTU1ZDMnLFxuICAgICAgICBtZWRpdW1wdXJwbGU6ICc5MzcwZDgnLFxuICAgICAgICBtZWRpdW1zZWFncmVlbjogJzNjYjM3MScsXG4gICAgICAgIG1lZGl1bXNsYXRlYmx1ZTogJzdiNjhlZScsXG4gICAgICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAnMDBmYTlhJyxcbiAgICAgICAgbWVkaXVtdHVycXVvaXNlOiAnNDhkMWNjJyxcbiAgICAgICAgbWVkaXVtdmlvbGV0cmVkOiAnYzcxNTg1JyxcbiAgICAgICAgbWlkbmlnaHRibHVlOiAnMTkxOTcwJyxcbiAgICAgICAgbWludGNyZWFtOiAnZjVmZmZhJyxcbiAgICAgICAgbWlzdHlyb3NlOiAnZmZlNGUxJyxcbiAgICAgICAgbW9jY2FzaW46ICdmZmU0YjUnLFxuICAgICAgICBuYXZham93aGl0ZTogJ2ZmZGVhZCcsXG4gICAgICAgIG5hdnk6ICcwMDAwODAnLFxuICAgICAgICBvbGRsYWNlOiAnZmRmNWU2JyxcbiAgICAgICAgb2xpdmU6ICc4MDgwMDAnLFxuICAgICAgICBvbGl2ZWRyYWI6ICc2YjhlMjMnLFxuICAgICAgICBvcmFuZ2U6ICdmZmE1MDAnLFxuICAgICAgICBvcmFuZ2VyZWQ6ICdmZjQ1MDAnLFxuICAgICAgICBvcmNoaWQ6ICdkYTcwZDYnLFxuICAgICAgICBwYWxlZ29sZGVucm9kOiAnZWVlOGFhJyxcbiAgICAgICAgcGFsZWdyZWVuOiAnOThmYjk4JyxcbiAgICAgICAgcGFsZXR1cnF1b2lzZTogJ2FmZWVlZScsXG4gICAgICAgIHBhbGV2aW9sZXRyZWQ6ICdkODcwOTMnLFxuICAgICAgICBwYXBheWF3aGlwOiAnZmZlZmQ1JyxcbiAgICAgICAgcGVhY2hwdWZmOiAnZmZkYWI5JyxcbiAgICAgICAgcGVydTogJ2NkODUzZicsXG4gICAgICAgIHBpbms6ICdmZmMwY2InLFxuICAgICAgICBwbHVtOiAnZGRhMGRkJyxcbiAgICAgICAgcG93ZGVyYmx1ZTogJ2IwZTBlNicsXG4gICAgICAgIHB1cnBsZTogJzgwMDA4MCcsXG4gICAgICAgIHJlZDogJ2ZmMDAwMCcsXG4gICAgICAgIHJvc3licm93bjogJ2JjOGY4ZicsXG4gICAgICAgIHJveWFsYmx1ZTogJzQxNjllMScsXG4gICAgICAgIHNhZGRsZWJyb3duOiAnOGI0NTEzJyxcbiAgICAgICAgc2FsbW9uOiAnZmE4MDcyJyxcbiAgICAgICAgc2FuZHlicm93bjogJ2Y0YTQ2MCcsXG4gICAgICAgIHNlYWdyZWVuOiAnMmU4YjU3JyxcbiAgICAgICAgc2Vhc2hlbGw6ICdmZmY1ZWUnLFxuICAgICAgICBzaWVubmE6ICdhMDUyMmQnLFxuICAgICAgICBzaWx2ZXI6ICdjMGMwYzAnLFxuICAgICAgICBza3libHVlOiAnODdjZWViJyxcbiAgICAgICAgc2xhdGVibHVlOiAnNmE1YWNkJyxcbiAgICAgICAgc2xhdGVncmF5OiAnNzA4MDkwJyxcbiAgICAgICAgc25vdzogJ2ZmZmFmYScsXG4gICAgICAgIHNwcmluZ2dyZWVuOiAnMDBmZjdmJyxcbiAgICAgICAgc3RlZWxibHVlOiAnNDY4MmI0JyxcbiAgICAgICAgdGFuOiAnZDJiNDhjJyxcbiAgICAgICAgdGVhbDogJzAwODA4MCcsXG4gICAgICAgIHRoaXN0bGU6ICdkOGJmZDgnLFxuICAgICAgICB0b21hdG86ICdmZjYzNDcnLFxuICAgICAgICB0dXJxdW9pc2U6ICc0MGUwZDAnLFxuICAgICAgICB2aW9sZXQ6ICdlZTgyZWUnLFxuICAgICAgICB2aW9sZXRyZWQ6ICdkMDIwOTAnLFxuICAgICAgICB3aGVhdDogJ2Y1ZGViMycsXG4gICAgICAgIHdoaXRlOiAnZmZmZmZmJyxcbiAgICAgICAgd2hpdGVzbW9rZTogJ2Y1ZjVmNScsXG4gICAgICAgIHllbGxvdzogJ2ZmZmYwMCcsXG4gICAgICAgIHllbGxvd2dyZWVuOiAnOWFjZDMyJ1xuICAgIH07XG4gICAgY29sb3Jfc3RyaW5nID0gc2ltcGxlX2NvbG9yc1tjb2xvcl9zdHJpbmddIHx8IGNvbG9yX3N0cmluZztcbiAgICAvLyBlbWQgb2Ygc2ltcGxlIHR5cGUtaW4gY29sb3JzXG5cbiAgICAvLyBhcnJheSBvZiBjb2xvciBkZWZpbml0aW9uIG9iamVjdHNcbiAgICB2YXIgY29sb3JfZGVmcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcmU6IC9ecmdiYVxcKChcXGR7MSwzfSksXFxzKihcXGR7MSwzfSksXFxzKihcXGR7MSwzfSksXFxzKigoPzpcXGQ/XFwuKT9cXGQpXFwpJC8sXG4gICAgICAgICAgICBleGFtcGxlOiBbJ3JnYmEoMTIzLCAyMzQsIDQ1LCAwLjgpJywgJ3JnYmEoMjU1LDIzNCwyNDUsMS4wKSddLFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKGJpdHMpe1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbMV0pLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1szXSksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoYml0c1s0XSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByZTogL15yZ2JcXCgoXFxkezEsM30pLFxccyooXFxkezEsM30pLFxccyooXFxkezEsM30pXFwpJC8sXG4gICAgICAgICAgICBleGFtcGxlOiBbJ3JnYigxMjMsIDIzNCwgNDUpJywgJ3JnYigyNTUsMjM0LDI0NSknXSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChiaXRzKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1syXSksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbM10pXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcmU6IC9eKFxcd3syfSkoXFx3ezJ9KShcXHd7Mn0pJC8sXG4gICAgICAgICAgICBleGFtcGxlOiBbJyMwMGZmMDAnLCAnMzM2Njk5J10sXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoYml0cyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1sxXSwgMTYpLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzJdLCAxNiksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbM10sIDE2KVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlOiAvXihcXHd7MX0pKFxcd3sxfSkoXFx3ezF9KSQvLFxuICAgICAgICAgICAgZXhhbXBsZTogWycjZmIwJywgJ2YwZiddLFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKGJpdHMpe1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbMV0gKyBiaXRzWzFdLCAxNiksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbMl0gKyBiaXRzWzJdLCAxNiksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbM10gKyBiaXRzWzNdLCAxNilcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXTtcblxuICAgIC8vIHNlYXJjaCB0aHJvdWdoIHRoZSBkZWZpbml0aW9ucyB0byBmaW5kIGEgbWF0Y2hcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yX2RlZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJlID0gY29sb3JfZGVmc1tpXS5yZTtcbiAgICAgICAgdmFyIHByb2Nlc3NvciA9IGNvbG9yX2RlZnNbaV0ucHJvY2VzcztcbiAgICAgICAgdmFyIGJpdHMgPSByZS5leGVjKGNvbG9yX3N0cmluZyk7XG4gICAgICAgIGlmIChiaXRzKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbHMgPSBwcm9jZXNzb3IoYml0cyk7XG4gICAgICAgICAgICB0aGlzLnIgPSBjaGFubmVsc1swXTtcbiAgICAgICAgICAgIHRoaXMuZyA9IGNoYW5uZWxzWzFdO1xuICAgICAgICAgICAgdGhpcy5iID0gY2hhbm5lbHNbMl07XG4gICAgICAgICAgICBpZiAoY2hhbm5lbHMubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxwaGEgPSBjaGFubmVsc1szXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub2sgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZS9jbGVhbnVwIHZhbHVlc1xuICAgIHRoaXMuciA9ICh0aGlzLnIgPCAwIHx8IGlzTmFOKHRoaXMucikpID8gMCA6ICgodGhpcy5yID4gMjU1KSA/IDI1NSA6IHRoaXMucik7XG4gICAgdGhpcy5nID0gKHRoaXMuZyA8IDAgfHwgaXNOYU4odGhpcy5nKSkgPyAwIDogKCh0aGlzLmcgPiAyNTUpID8gMjU1IDogdGhpcy5nKTtcbiAgICB0aGlzLmIgPSAodGhpcy5iIDwgMCB8fCBpc05hTih0aGlzLmIpKSA/IDAgOiAoKHRoaXMuYiA+IDI1NSkgPyAyNTUgOiB0aGlzLmIpO1xuICAgIHRoaXMuYWxwaGEgPSAodGhpcy5hbHBoYSA8IDApID8gMCA6ICgodGhpcy5hbHBoYSA+IDEuMCB8fCBpc05hTih0aGlzLmFscGhhKSkgPyAxLjAgOiB0aGlzLmFscGhhKTtcblxuICAgIC8vIHNvbWUgZ2V0dGVyc1xuICAgIHRoaXMudG9SR0IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAncmdiKCcgKyB0aGlzLnIgKyAnLCAnICsgdGhpcy5nICsgJywgJyArIHRoaXMuYiArICcpJztcbiAgICB9XG4gICAgdGhpcy50b1JHQkEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAncmdiYSgnICsgdGhpcy5yICsgJywgJyArIHRoaXMuZyArICcsICcgKyB0aGlzLmIgKyAnLCAnICsgdGhpcy5hbHBoYSArICcpJztcbiAgICB9XG4gICAgdGhpcy50b0hleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLnIudG9TdHJpbmcoMTYpO1xuICAgICAgICB2YXIgZyA9IHRoaXMuZy50b1N0cmluZygxNik7XG4gICAgICAgIHZhciBiID0gdGhpcy5iLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKHIubGVuZ3RoID09IDEpIHIgPSAnMCcgKyByO1xuICAgICAgICBpZiAoZy5sZW5ndGggPT0gMSkgZyA9ICcwJyArIGc7XG4gICAgICAgIGlmIChiLmxlbmd0aCA9PSAxKSBiID0gJzAnICsgYjtcbiAgICAgICAgcmV0dXJuICcjJyArIHIgKyBnICsgYjtcbiAgICB9XG5cbiAgICAvLyBoZWxwXG4gICAgdGhpcy5nZXRIZWxwWE1MID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBleGFtcGxlcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAvLyBhZGQgcmVnZXhwc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yX2RlZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBleGFtcGxlID0gY29sb3JfZGVmc1tpXS5leGFtcGxlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBleGFtcGxlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgZXhhbXBsZXNbZXhhbXBsZXMubGVuZ3RoXSA9IGV4YW1wbGVbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIHR5cGUtaW4gY29sb3JzXG4gICAgICAgIGZvciAodmFyIHNjIGluIHNpbXBsZV9jb2xvcnMpIHtcbiAgICAgICAgICAgIGV4YW1wbGVzW2V4YW1wbGVzLmxlbmd0aF0gPSBzYztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4bWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgICAgICB4bWwuc2V0QXR0cmlidXRlKCdpZCcsICdyZ2Jjb2xvci1leGFtcGxlcycpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4YW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0X2l0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICAgICAgICAgIHZhciBsaXN0X2NvbG9yID0gbmV3IFJHQkNvbG9yKGV4YW1wbGVzW2ldKTtcbiAgICAgICAgICAgICAgICB2YXIgZXhhbXBsZV9kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBleGFtcGxlX2Rpdi5zdHlsZS5jc3NUZXh0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJnaW46IDNweDsgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAnYm9yZGVyOiAxcHggc29saWQgYmxhY2s7ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2JhY2tncm91bmQ6JyArIGxpc3RfY29sb3IudG9IZXgoKSArICc7ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2NvbG9yOicgKyBsaXN0X2NvbG9yLnRvSGV4KClcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgZXhhbXBsZV9kaXYuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ3Rlc3QnKSk7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RfaXRlbV92YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxuICAgICAgICAgICAgICAgICAgICAnICcgKyBleGFtcGxlc1tpXSArICcgLT4gJyArIGxpc3RfY29sb3IudG9SR0IoKSArICcgLT4gJyArIGxpc3RfY29sb3IudG9IZXgoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbGlzdF9pdGVtLmFwcGVuZENoaWxkKGV4YW1wbGVfZGl2KTtcbiAgICAgICAgICAgICAgICBsaXN0X2l0ZW0uYXBwZW5kQ2hpbGQobGlzdF9pdGVtX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICB4bWwuYXBwZW5kQ2hpbGQobGlzdF9pdGVtKTtcblxuICAgICAgICAgICAgfSBjYXRjaChlKXt9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHhtbDtcblxuICAgIH1cblxufVxuIiwiLyoqXG5cdFRoZSBtaXNzaW5nIFNWRy50b0RhdGFVUkwgbGlicmFyeSBmb3IgeW91ciBTVkcgZWxlbWVudHMuXG5cblx0VXNhZ2U6IFNWR0VsZW1lbnQudG9EYXRhVVJMKCB0eXBlLCB7IG9wdGlvbnMgfSApXG5cblx0UmV0dXJuczogdGhlIGRhdGEgVVJMLCBleGNlcHQgd2hlbiB1c2luZyBuYXRpdmUgUE5HIHJlbmRlcmVyIChuZWVkcyBjYWxsYmFjaykuXG5cblx0dHlwZVx0TUlNRSB0eXBlIG9mIHRoZSBleHBvcnRlZCBkYXRhLlxuXHRcdFx0RGVmYXVsdDogaW1hZ2Uvc3ZnK3htbC5cblx0XHRcdE11c3Qgc3VwcG9ydDogaW1hZ2UvcG5nLlxuXHRcdFx0QWRkaXRpb25hbDogaW1hZ2UvanBlZy5cblxuXHRvcHRpb25zIGlzIGEgbWFwIG9mIG9wdGlvbnM6IHtcblx0XHRjYWxsYmFjazogZnVuY3Rpb24oZGF0YVVSTClcblx0XHRcdENhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHRoZSBkYXRhIFVSTCBpcyByZWFkeS5cblx0XHRcdFRoaXMgaXMgb25seSBuZWNlc3Nhcnkgd2hlbiB1c2luZyBuYXRpdmUgUE5HIHJlbmRlcmVyLlxuXHRcdFx0RGVmYXVsdDogdW5kZWZpbmVkLlxuXG5cdFx0W3RoZSByZXN0IG9mIHRoZSBvcHRpb25zIG9ubHkgYXBwbHkgd2hlbiB0eXBlPVwiaW1hZ2UvcG5nXCIgb3IgdHlwZT1cImltYWdlL2pwZWdcIl1cblxuXHRcdHJlbmRlcmVyOiBcIm5hdGl2ZVwifFwiY2FudmdcIlxuXHRcdFx0UE5HIHJlbmRlcmVyIHRvIHVzZS4gTmF0aXZlIHJlbmRlcmVywrkgbWlnaHQgY2F1c2UgYSBzZWN1cml0eSBleGNlcHRpb24uXG5cdFx0XHREZWZhdWx0OiBjYW52ZyBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBuYXRpdmUuXG5cblx0XHRrZWVwTm9uU2FmZTogdHJ1ZXxmYWxzZVxuXHRcdFx0RXhwb3J0IG5vbi1zYWZlIChpbWFnZSBhbmQgZm9yZWlnbk9iamVjdCkgZWxlbWVudHMuXG5cdFx0XHRUaGlzIHdpbGwgc2V0IHRoZSBDYW52YXMgb3JpZ2luLWNsZWFuIHByb3BlcnR5IHRvIGZhbHNlLCBpZiB0aGlzIGRhdGEgaXMgdHJhbnNmZXJyZWQgdG8gQ2FudmFzLlxuXHRcdFx0RGVmYXVsdDogZmFsc2UsIHRvIGtlZXAgb3JpZ2luLWNsZWFuIHRydWUuXG5cdFx0XHROT1RFOiBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBhbmQgaXMganVzdCBpZ25vcmVkLlxuXG5cdFx0a2VlcE91dHNpZGVWaWV3cG9ydDogdHJ1ZXxmYWxzZVxuXHRcdFx0RXhwb3J0IGFsbCBkcmF3biBjb250ZW50LCBldmVuIGlmIG5vdCB2aXNpYmxlLlxuXHRcdFx0RGVmYXVsdDogZmFsc2UsIGV4cG9ydCBvbmx5IHZpc2libGUgdmlld3BvcnQsIHNpbWlsYXIgdG8gQ2FudmFzIHRvRGF0YVVSTCgpLlxuXHRcdFx0Tk9URTogb25seSBzdXBwb3J0ZWQgd2l0aCBjYW52ZyByZW5kZXJlci5cblx0fVxuXG5cdFNlZSBvcmlnaW5hbCBwYXBlcsK5IGZvciBtb3JlIGluZm8gb24gU1ZHIHRvIENhbnZhcyBleHBvcnRpbmcuXG5cblx0wrkgaHR0cDovL3N2Z29wZW4ub3JnLzIwMTAvcGFwZXJzLzYyLUZyb21fU1ZHX3RvX0NhbnZhc19hbmRfQmFjay8jc3ZnX3RvX2NhbnZhc1xuKi9cblxuU1ZHRWxlbWVudC5wcm90b3R5cGUudG9EYXRhVVJMID0gZnVuY3Rpb24odHlwZSwgb3B0aW9ucykge1xuXHR2YXIgX3N2ZyA9IHRoaXM7XG5cblx0ZnVuY3Rpb24gZGVidWcocykge1xuXHRcdC8vIFdlIGNvdWxkIGZpbmQgdG8gYSB3YXkgdG8gbWFrZSB0aGlzIGRpc3BsYXkgZGVwZW5kaW5nIG9uIGVudmlyb25tZW50LCBidXRcblx0XHQvLyBmb3Igbm93IEkgdGhpbmsgaXQncyBva2F5IHRvIGp1c3QgZGlzYWJsZS5cblx0XHQvLyBjb25zb2xlLmxvZyhcIlNWRy50b0RhdGFVUkw6XCIsIHMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0U1ZHKCkge1xuXHRcdHZhciBzdmdfeG1sID0gWE1MU2VyaWFsaXplKF9zdmcpO1xuXHRcdHZhciBzdmdfZGF0YXVybCA9IGJhc2U2NGRhdGFVUkxlbmNvZGUoc3ZnX3htbCk7XG5cdFx0ZGVidWcodHlwZSArIFwiIGxlbmd0aDogXCIgKyBzdmdfZGF0YXVybC5sZW5ndGgpO1xuXG5cdFx0Ly8gTk9URSBkb3VibGUgZGF0YSBjYXJyaWVyXG5cdFx0aWYgKG9wdGlvbnMuY2FsbGJhY2spIG9wdGlvbnMuY2FsbGJhY2soc3ZnX2RhdGF1cmwpO1xuXHRcdHJldHVybiBzdmdfZGF0YXVybDtcblx0fVxuXG5cdGZ1bmN0aW9uIFhNTFNlcmlhbGl6ZShzdmcpIHtcblxuXHRcdC8vIHF1aWNrLW4tc2VyaWFsaXplIGFuIFNWRyBkb20sIG5lZWRlZCBmb3IgSUU5IHdoZXJlIHRoZXJlJ3Mgbm8gWE1MU2VyaWFsaXplciBub3IgU1ZHLnhtbFxuXHRcdC8vIHM6IFNWRyBkb20sIHdoaWNoIGlzIHRoZSA8c3ZnPiBlbGVtZW5udFxuXHRcdGZ1bmN0aW9uIFhNTFNlcmlhbGl6ZXJGb3JJRShzKSB7XG5cdFx0XHR2YXIgb3V0ID0gXCJcIjtcblxuXHRcdFx0b3V0ICs9IFwiPFwiICsgcy5ub2RlTmFtZTtcblx0XHRcdGZvciAodmFyIG4gPSAwOyBuIDwgcy5hdHRyaWJ1dGVzLmxlbmd0aDsgbisrKSB7XG5cdFx0XHRcdG91dCArPSBcIiBcIiArIHMuYXR0cmlidXRlc1tuXS5uYW1lICsgXCI9XCIgKyBcIidcIiArIHMuYXR0cmlidXRlc1tuXS52YWx1ZSArIFwiJ1wiO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocy5oYXNDaGlsZE5vZGVzKCkpIHtcblx0XHRcdFx0b3V0ICs9IFwiPlxcblwiO1xuXG5cdFx0XHRcdGZvciAodmFyIG4gPSAwOyBuIDwgcy5jaGlsZE5vZGVzLmxlbmd0aDsgbisrKSB7XG5cdFx0XHRcdFx0b3V0ICs9IFhNTFNlcmlhbGl6ZXJGb3JJRShzLmNoaWxkTm9kZXNbbl0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0b3V0ICs9IFwiPC9cIiArIHMubm9kZU5hbWUgKyBcIj5cIiArIFwiXFxuXCI7XG5cblx0XHRcdH0gZWxzZSBvdXQgKz0gXCIgLz5cXG5cIjtcblxuXHRcdFx0cmV0dXJuIG91dDtcblx0XHR9XG5cblxuXHRcdGlmICh3aW5kb3cuWE1MU2VyaWFsaXplcikge1xuXHRcdFx0ZGVidWcoXCJ1c2luZyBzdGFuZGFyZCBYTUxTZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nXCIpXG5cdFx0XHRyZXR1cm4gKG5ldyBYTUxTZXJpYWxpemVyKCkpLnNlcmlhbGl6ZVRvU3RyaW5nKHN2Zyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlYnVnKFwidXNpbmcgY3VzdG9tIFhNTFNlcmlhbGl6ZXJGb3JJRVwiKVxuXHRcdFx0cmV0dXJuIFhNTFNlcmlhbGl6ZXJGb3JJRShzdmcpO1xuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gYmFzZTY0ZGF0YVVSTGVuY29kZShzKSB7XG5cdFx0dmFyIGI2NCA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxcIjtcblxuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cuYnRvYVxuXHRcdGlmICh3aW5kb3cuYnRvYSkge1xuXHRcdFx0ZGVidWcoXCJ1c2luZyB3aW5kb3cuYnRvYSBmb3IgYmFzZTY0IGVuY29kaW5nXCIpO1xuXHRcdFx0YjY0ICs9IGJ0b2Eocyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlYnVnKFwidXNpbmcgY3VzdG9tIGJhc2U2NCBlbmNvZGVyXCIpO1xuXHRcdFx0YjY0ICs9IEJhc2U2NC5lbmNvZGUocyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGI2NDtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydEltYWdlKHR5cGUpIHtcblx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblx0XHR2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cblx0XHQvLyBUT0RPOiBpZiAob3B0aW9ucy5rZWVwT3V0c2lkZVZpZXdwb3J0KSwgZG8gc29tZSB0cmFuc2xhdGlvbiBtYWdpYz9cblxuXHRcdHZhciBzdmdfaW1nID0gbmV3IEltYWdlKCk7XG5cdFx0dmFyIHN2Z194bWwgPSBYTUxTZXJpYWxpemUoX3N2Zyk7XG5cdFx0c3ZnX2ltZy5zcmMgPSBiYXNlNjRkYXRhVVJMZW5jb2RlKHN2Z194bWwpO1xuXG5cdFx0c3ZnX2ltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0XHRcdGRlYnVnKFwiZXhwb3J0ZWQgaW1hZ2Ugc2l6ZTogXCIgKyBbc3ZnX2ltZy53aWR0aCwgc3ZnX2ltZy5oZWlnaHRdKVxuXHRcdFx0Y2FudmFzLndpZHRoID0gc3ZnX2ltZy53aWR0aDtcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBzdmdfaW1nLmhlaWdodDtcblx0XHRcdGN0eC5kcmF3SW1hZ2Uoc3ZnX2ltZywgMCwgMCk7XG5cblx0XHRcdC8vIFNFQ1VSSVRZX0VSUiBXSUxMIEhBUFBFTiBOT1dcblx0XHRcdHZhciBwbmdfZGF0YXVybCA9IGNhbnZhcy50b0RhdGFVUkwodHlwZSk7XG5cdFx0XHRkZWJ1Zyh0eXBlICsgXCIgbGVuZ3RoOiBcIiArIHBuZ19kYXRhdXJsLmxlbmd0aCk7XG5cblx0XHRcdGlmIChvcHRpb25zLmNhbGxiYWNrKSBvcHRpb25zLmNhbGxiYWNrKCBwbmdfZGF0YXVybCApO1xuXHRcdFx0ZWxzZSBkZWJ1ZyhcIldBUk5JTkc6IG5vIGNhbGxiYWNrIHNldCwgc28gbm90aGluZyBoYXBwZW5zLlwiKTtcblx0XHR9XG5cblx0XHRzdmdfaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdGNvbnNvbGUubG9nKFxuXHRcdFx0XHRcIkNhbid0IGV4cG9ydCEgTWF5YmUgeW91ciBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBcIiArXG5cdFx0XHRcdFwiU1ZHIGluIGltZyBlbGVtZW50IG9yIFNWRyBpbnB1dCBmb3IgQ2FudmFzIGRyYXdJbWFnZT9cXG5cIiArXG5cdFx0XHRcdFwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TVkcjTmF0aXZlX3N1cHBvcnRcIlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyBOT1RFOiB3aWxsIG5vdCByZXR1cm4gYW55dGhpbmdcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydEltYWdlQ2FudmcodHlwZSkge1xuXHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXHRcdHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHR2YXIgc3ZnX3htbCA9IFhNTFNlcmlhbGl6ZShfc3ZnKTtcblxuXHRcdC8vIE5PVEU6IGNhbnZnIGdldHMgdGhlIFNWRyBlbGVtZW50IGRpbWVuc2lvbnMgaW5jb3JyZWN0bHkgaWYgbm90IHNwZWNpZmllZCBhcyBhdHRyaWJ1dGVzXG5cdFx0Ly9kZWJ1ZyhcImRldGVjdGVkIHN2ZyBkaW1lbnNpb25zIFwiICsgW19zdmcuY2xpZW50V2lkdGgsIF9zdmcuY2xpZW50SGVpZ2h0XSlcblx0XHQvL2RlYnVnKFwiY2FudmFzIGRpbWVuc2lvbnMgXCIgKyBbY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0XSlcblxuXHRcdHZhciBrZWVwQkIgPSBvcHRpb25zLmtlZXBPdXRzaWRlVmlld3BvcnQ7XG5cdFx0aWYgKGtlZXBCQikgdmFyIGJiID0gX3N2Zy5nZXRCQm94KCk7XG5cblx0XHQvLyBOT1RFOiB0aGlzIGNhbnZnIGNhbGwgaXMgc3luY2hyb25vdXMgYW5kIGJsb2NrcyAobm8gaXQgZG9lcyBub3QpXG5cdFx0Y2FudmcoY2FudmFzLCBzdmdfeG1sLCB7XG5cdFx0XHRpZ25vcmVNb3VzZTogdHJ1ZSwgaWdub3JlQW5pbWF0aW9uOiB0cnVlLFxuXHRcdFx0b2Zmc2V0WDoga2VlcEJCID8gLWJiLnggOiB1bmRlZmluZWQsXG5cdFx0XHRvZmZzZXRZOiBrZWVwQkIgPyAtYmIueSA6IHVuZGVmaW5lZCxcblx0XHRcdHNjYWxlV2lkdGg6IGtlZXBCQiA/IGJiLndpZHRoK2JiLnggOiB1bmRlZmluZWQsXG5cdFx0XHRzY2FsZUhlaWdodDoga2VlcEJCID8gYmIuaGVpZ2h0K2JiLnkgOiB1bmRlZmluZWQsXG5cdFx0XHRyZW5kZXJDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlYnVnKFwiZXhwb3J0ZWQgaW1hZ2UgZGltZW5zaW9ucyBcIiArIFtjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHRdKTtcblx0XHRcdFx0dmFyIHBuZ19kYXRhdXJsID0gY2FudmFzLnRvRGF0YVVSTCh0eXBlKTtcblx0XHRcdFx0ZGVidWcodHlwZSArIFwiIGxlbmd0aDogXCIgKyBwbmdfZGF0YXVybC5sZW5ndGgpO1xuXG5cdFx0XHRcdGlmIChvcHRpb25zLmNhbGxiYWNrKSBvcHRpb25zLmNhbGxiYWNrKCBwbmdfZGF0YXVybCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gTk9URTogcmV0dXJuIGluIGFkZGl0aW9uIHRvIGNhbGxiYWNrXG5cdFx0cmV0dXJuIGNhbnZhcy50b0RhdGFVUkwodHlwZSk7XG5cdH1cblxuXHQvLyBCRUdJTiBNQUlOXG5cblx0aWYgKCF0eXBlKSB0eXBlID0gXCJpbWFnZS9zdmcreG1sXCI7XG5cdGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuXG5cdGlmIChvcHRpb25zLmtlZXBOb25TYWZlKSBkZWJ1ZyhcIk5PVEU6IGtlZXBOb25TYWZlIGlzIE5PVCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZCFcIik7XG5cdGlmIChvcHRpb25zLmtlZXBPdXRzaWRlVmlld3BvcnQpIGRlYnVnKFwiTk9URToga2VlcE91dHNpZGVWaWV3cG9ydCBpcyBvbmx5IHN1cHBvcnRlZCB3aXRoIGNhbnZnIGV4cG9ydGVyLlwiKTtcblxuXHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRjYXNlIFwiaW1hZ2Uvc3ZnK3htbFwiOlxuXHRcdFx0cmV0dXJuIGV4cG9ydFNWRygpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIFwiaW1hZ2UvcG5nXCI6XG5cdFx0Y2FzZSBcImltYWdlL2pwZWdcIjpcblxuXHRcdFx0aWYgKCFvcHRpb25zLnJlbmRlcmVyKSB7XG5cdFx0XHRcdGlmICh3aW5kb3cuY2FudmcpIG9wdGlvbnMucmVuZGVyZXIgPSBcImNhbnZnXCI7XG5cdFx0XHRcdGVsc2Ugb3B0aW9ucy5yZW5kZXJlcj1cIm5hdGl2ZVwiO1xuXHRcdFx0fVxuXG5cdFx0XHRzd2l0Y2ggKG9wdGlvbnMucmVuZGVyZXIpIHtcblx0XHRcdFx0Y2FzZSBcImNhbnZnXCI6XG5cdFx0XHRcdFx0ZGVidWcoXCJ1c2luZyBjYW52ZyByZW5kZXJlciBmb3IgcG5nIGV4cG9ydFwiKTtcblx0XHRcdFx0XHRyZXR1cm4gZXhwb3J0SW1hZ2VDYW52Zyh0eXBlKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFwibmF0aXZlXCI6XG5cdFx0XHRcdFx0ZGVidWcoXCJ1c2luZyBuYXRpdmUgcmVuZGVyZXIgZm9yIHBuZyBleHBvcnQuIFRISVMgTUlHSFQgRkFJTC5cIik7XG5cdFx0XHRcdFx0cmV0dXJuIGV4cG9ydEltYWdlKHR5cGUpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0ZGVidWcoXCJ1bmtub3duIHBuZyByZW5kZXJlciBnaXZlbiwgZG9pbmcgbm90aW5nIChcIiArIG9wdGlvbnMucmVuZGVyZXIgKyBcIilcIik7XG5cdFx0XHR9XG5cblx0XHRcdGJyZWFrO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGRlYnVnKFwiU29ycnkhIEV4cG9ydGluZyBhcyAnXCIgKyB0eXBlICsgXCInIGlzIG5vdCBzdXBwb3J0ZWQhXCIpXG5cdH1cbn1cbiIsIi8qKlxuICogQSBzZXQgb2YgZnVuY3Rpb25hbCBibG9ja3NcbiAqL1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIF8gPSB1dGlscy5nZXRMb2Rhc2goKTtcbnZhciBtc2cgPSByZXF1aXJlKCcuL2xvY2FsZScpO1xuXG52YXIgQVJJVEhNRVRJQ19USVRMRV9GT05UX1NJWkUgPSAyNTtcblxuZXhwb3J0cy5pbnN0YWxsID0gZnVuY3Rpb24oYmxvY2tseSwgZ2VuZXJhdG9yLCBnZW5zeW0pIHtcbiAgaW5zdGFsbFBsdXMoYmxvY2tseSwgZ2VuZXJhdG9yLCBnZW5zeW0pO1xuICBpbnN0YWxsTWludXMoYmxvY2tseSwgZ2VuZXJhdG9yLCBnZW5zeW0pO1xuICBpbnN0YWxsVGltZXMoYmxvY2tseSwgZ2VuZXJhdG9yLCBnZW5zeW0pO1xuICBpbnN0YWxsRGl2aWRlZEJ5KGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKTtcbiAgaW5zdGFsbEdyZWF0ZXJUaGFuKGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKTtcbiAgaW5zdGFsbExlc3NUaGFuKGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKTtcbiAgaW5zdGFsbE51bWJlckVxdWFscyhibG9ja2x5LCBnZW5lcmF0b3IsIGdlbnN5bSk7XG4gIGluc3RhbGxTdHJpbmdFcXVhbHMoYmxvY2tseSwgZ2VuZXJhdG9yLCBnZW5zeW0pO1xuICBpbnN0YWxsTG9naWNhbEFuZChibG9ja2x5LCBnZW5lcmF0b3IsIGdlbnN5bSk7XG4gIGluc3RhbGxMb2dpY2FsT3IoYmxvY2tseSwgZ2VuZXJhdG9yLCBnZW5zeW0pO1xuICBpbnN0YWxsTG9naWNhbE5vdChibG9ja2x5LCBnZW5lcmF0b3IsIGdlbnN5bSk7XG4gIGluc3RhbGxCb29sZWFuKGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKTtcbiAgaW5zdGFsbE1hdGhOdW1iZXIoYmxvY2tseSwgZ2VuZXJhdG9yLCBnZW5zeW0pO1xuICBpbnN0YWxsU3RyaW5nKGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKTtcbiAgaW5zdGFsbENvbmQoYmxvY2tseSwgZ2VuZXJhdG9yKTtcbiAgaW5zdGFsbFNxcnQoYmxvY2tseSwgZ2VuZXJhdG9yKTtcbiAgaW5zdGFsbFBvdyhibG9ja2x5LCBnZW5lcmF0b3IpO1xuICBpbnN0YWxsU3F1YXJlZChibG9ja2x5LCBnZW5lcmF0b3IpO1xufTtcblxuZnVuY3Rpb24gaW5zdGFsbFBsdXMoYmxvY2tseSwgZ2VuZXJhdG9yLCBnZW5zeW0pIHtcbiAgYmxvY2tseS5CbG9ja3MuZnVuY3Rpb25hbF9wbHVzID0ge1xuXG4gICAgaGVscFVybDogJycsXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICBibG9ja2x5LkZ1bmN0aW9uYWxCbG9ja1V0aWxzLmluaXRUaXRsZWRGdW5jdGlvbmFsQmxvY2sodGhpcywgJysnLCBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLk5VTUJFUiwgW1xuICAgICAgICB7IG5hbWU6ICdBUkcxJywgdHlwZTogYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5OVU1CRVIgfSxcbiAgICAgICAgeyBuYW1lOiAnQVJHMicsIHR5cGU6IGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuTlVNQkVSIH1cbiAgICAgIF0sIHsgdGl0bGVGb250U2l6ZTogQVJJVEhNRVRJQ19USVRMRV9GT05UX1NJWkV9KTtcblxuXG4gICAgfVxuICB9O1xuXG4gIGdlbmVyYXRvci5mdW5jdGlvbmFsX3BsdXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJnMSA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzEnLCBmYWxzZSkgfHwgMDtcbiAgICB2YXIgYXJnMiA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzInLCBmYWxzZSkgfHwgMDtcbiAgICByZXR1cm4gXCIoXCIgKyBhcmcxICsgXCIgKyBcIiArIGFyZzIgKyBcIilcIjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5zdGFsbE1pbnVzKGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKSB7XG4gIGJsb2NrbHkuQmxvY2tzLmZ1bmN0aW9uYWxfbWludXMgPSB7XG4gICAgaGVscFVybDogJycsXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICBibG9ja2x5LkZ1bmN0aW9uYWxCbG9ja1V0aWxzLmluaXRUaXRsZWRGdW5jdGlvbmFsQmxvY2sodGhpcywgJy0nLCBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLk5VTUJFUiwgW1xuICAgICAgICB7IG5hbWU6ICdBUkcxJywgdHlwZTogYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5OVU1CRVIgfSxcbiAgICAgICAgeyBuYW1lOiAnQVJHMicsIHR5cGU6IGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuTlVNQkVSIH1cbiAgICAgIF0sIHsgdGl0bGVGb250U2l6ZTogQVJJVEhNRVRJQ19USVRMRV9GT05UX1NJWkV9KTtcbiAgICB9XG4gIH07XG5cbiAgZ2VuZXJhdG9yLmZ1bmN0aW9uYWxfbWludXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJnMSA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzEnLCBmYWxzZSkgfHwgMDtcbiAgICB2YXIgYXJnMiA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzInLCBmYWxzZSkgfHwgMDtcbiAgICByZXR1cm4gXCIoXCIgKyBhcmcxICsgXCIgLSBcIiArIGFyZzIgKyBcIilcIjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5zdGFsbFRpbWVzKGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKSB7XG4gIGJsb2NrbHkuQmxvY2tzLmZ1bmN0aW9uYWxfdGltZXMgPSB7XG4gICAgaGVscFVybDogJycsXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICBibG9ja2x5LkZ1bmN0aW9uYWxCbG9ja1V0aWxzLmluaXRUaXRsZWRGdW5jdGlvbmFsQmxvY2sodGhpcywgJyonLCBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLk5VTUJFUiwgW1xuICAgICAgICB7IG5hbWU6ICdBUkcxJywgdHlwZTogYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5OVU1CRVIgfSxcbiAgICAgICAgeyBuYW1lOiAnQVJHMicsIHR5cGU6IGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuTlVNQkVSIH1cbiAgICAgIF0sIHsgdGl0bGVGb250U2l6ZTogQVJJVEhNRVRJQ19USVRMRV9GT05UX1NJWkV9KTtcbiAgICB9XG4gIH07XG5cbiAgZ2VuZXJhdG9yLmZ1bmN0aW9uYWxfdGltZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJnMSA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzEnLCBmYWxzZSkgfHwgMDtcbiAgICB2YXIgYXJnMiA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzInLCBmYWxzZSkgfHwgMDtcbiAgICByZXR1cm4gXCIoXCIgKyBhcmcxICsgXCIgKiBcIiArIGFyZzIgKyBcIilcIjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5zdGFsbERpdmlkZWRCeShibG9ja2x5LCBnZW5lcmF0b3IsIGdlbnN5bSkge1xuICBibG9ja2x5LkJsb2Nrcy5mdW5jdGlvbmFsX2RpdmlkZWRieSA9IHtcbiAgICBoZWxwVXJsOiAnJyxcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIGJsb2NrbHkuRnVuY3Rpb25hbEJsb2NrVXRpbHMuaW5pdFRpdGxlZEZ1bmN0aW9uYWxCbG9jayh0aGlzLCAnLycsIGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuTlVNQkVSLCBbXG4gICAgICAgIHsgbmFtZTogJ0FSRzEnLCB0eXBlOiBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLk5VTUJFUiB9LFxuICAgICAgICB7IG5hbWU6ICdBUkcyJywgdHlwZTogYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5OVU1CRVIgfVxuICAgICAgXSwgeyB0aXRsZUZvbnRTaXplOiBBUklUSE1FVElDX1RJVExFX0ZPTlRfU0laRX0pO1xuICAgIH1cbiAgfTtcblxuICBnZW5lcmF0b3IuZnVuY3Rpb25hbF9kaXZpZGVkYnkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJnMSA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzEnLCBmYWxzZSkgfHwgMDtcbiAgICB2YXIgYXJnMiA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzInLCBmYWxzZSkgfHwgMDtcbiAgICByZXR1cm4gXCIoXCIgKyBhcmcxICsgXCIgLyBcIiArIGFyZzIgKyBcIilcIjtcbiAgfTtcbn1cblxuLy8gSW5zdGFsbCBjb21wYXJhdG9yc1xuXG5mdW5jdGlvbiBpbnN0YWxsR3JlYXRlclRoYW4oYmxvY2tseSwgZ2VuZXJhdG9yLCBnZW5zeW0pIHtcbiAgYmxvY2tseS5CbG9ja3MuZnVuY3Rpb25hbF9ncmVhdGVyX3RoYW4gPSB7XG4gICAgaGVscFVybDogJycsXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICBibG9ja2x5LkZ1bmN0aW9uYWxCbG9ja1V0aWxzLmluaXRUaXRsZWRGdW5jdGlvbmFsQmxvY2sodGhpcywgJz4nLCBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLkJPT0xFQU4sIFtcbiAgICAgICAgeyBuYW1lOiAnQVJHMScsIHR5cGU6IGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuTlVNQkVSIH0sXG4gICAgICAgIHsgbmFtZTogJ0FSRzInLCB0eXBlOiBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLk5VTUJFUiB9XG4gICAgICBdKTtcbiAgICB9XG4gIH07XG5cbiAgZ2VuZXJhdG9yLmZ1bmN0aW9uYWxfZ3JlYXRlcl90aGFuID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZzEgPSBCbG9ja2x5LkphdmFTY3JpcHQuc3RhdGVtZW50VG9Db2RlKHRoaXMsICdBUkcxJywgZmFsc2UpIHx8IDA7XG4gICAgdmFyIGFyZzIgPSBCbG9ja2x5LkphdmFTY3JpcHQuc3RhdGVtZW50VG9Db2RlKHRoaXMsICdBUkcyJywgZmFsc2UpIHx8IDA7XG4gICAgcmV0dXJuICcoJyArIGFyZzEgKyBcIiA+IFwiICsgYXJnMiArICcpJztcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5zdGFsbExlc3NUaGFuKGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKSB7XG4gIGJsb2NrbHkuQmxvY2tzLmZ1bmN0aW9uYWxfbGVzc190aGFuID0ge1xuICAgIGhlbHBVcmw6ICcnLFxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgYmxvY2tseS5GdW5jdGlvbmFsQmxvY2tVdGlscy5pbml0VGl0bGVkRnVuY3Rpb25hbEJsb2NrKHRoaXMsICc8JywgYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5CT09MRUFOLCBbXG4gICAgICAgIHsgbmFtZTogJ0FSRzEnLCB0eXBlOiBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLk5VTUJFUiB9LFxuICAgICAgICB7IG5hbWU6ICdBUkcyJywgdHlwZTogYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5OVU1CRVIgfVxuICAgICAgXSk7XG4gICAgfVxuICB9O1xuXG4gIGdlbmVyYXRvci5mdW5jdGlvbmFsX2xlc3NfdGhhbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmcxID0gQmxvY2tseS5KYXZhU2NyaXB0LnN0YXRlbWVudFRvQ29kZSh0aGlzLCAnQVJHMScsIGZhbHNlKSB8fCAwO1xuICAgIHZhciBhcmcyID0gQmxvY2tseS5KYXZhU2NyaXB0LnN0YXRlbWVudFRvQ29kZSh0aGlzLCAnQVJHMicsIGZhbHNlKSB8fCAwO1xuICAgIHJldHVybiAnKCcgKyBhcmcxICsgXCIgPCBcIiArIGFyZzIgKyAnKSc7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxOdW1iZXJFcXVhbHMoYmxvY2tseSwgZ2VuZXJhdG9yLCBnZW5zeW0pIHtcbiAgYmxvY2tseS5CbG9ja3MuZnVuY3Rpb25hbF9udW1iZXJfZXF1YWxzID0ge1xuICAgIGhlbHBVcmw6ICcnLFxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgYmxvY2tseS5GdW5jdGlvbmFsQmxvY2tVdGlscy5pbml0VGl0bGVkRnVuY3Rpb25hbEJsb2NrKHRoaXMsICc9JywgYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5CT09MRUFOLCBbXG4gICAgICAgIHsgbmFtZTogJ0FSRzEnLCB0eXBlOiBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLk5VTUJFUiB9LFxuICAgICAgICB7IG5hbWU6ICdBUkcyJywgdHlwZTogYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5OVU1CRVIgfVxuICAgICAgXSk7XG4gICAgfVxuICB9O1xuXG4gIGdlbmVyYXRvci5mdW5jdGlvbmFsX251bWJlcl9lcXVhbHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJnMSA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzEnLCBmYWxzZSkgfHwgMDtcbiAgICB2YXIgYXJnMiA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzInLCBmYWxzZSkgfHwgMDtcbiAgICByZXR1cm4gJygnICsgYXJnMSArIFwiID09IFwiICsgYXJnMiArICcpJztcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5zdGFsbFN0cmluZ0VxdWFscyhibG9ja2x5LCBnZW5lcmF0b3IsIGdlbnN5bSkge1xuICBibG9ja2x5LkJsb2Nrcy5mdW5jdGlvbmFsX3N0cmluZ19lcXVhbHMgPSB7XG4gICAgaGVscFVybDogJycsXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICBibG9ja2x5LkZ1bmN0aW9uYWxCbG9ja1V0aWxzLmluaXRUaXRsZWRGdW5jdGlvbmFsQmxvY2sodGhpcywgbXNnLnN0cmluZ0VxdWFscygpLCBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLkJPT0xFQU4sIFtcbiAgICAgICAgeyBuYW1lOiAnQVJHMScsIHR5cGU6IGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuU1RSSU5HIH0sXG4gICAgICAgIHsgbmFtZTogJ0FSRzInLCB0eXBlOiBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLlNUUklORyB9XG4gICAgICBdKTtcbiAgICB9XG4gIH07XG5cbiAgZ2VuZXJhdG9yLmZ1bmN0aW9uYWxfc3RyaW5nX2VxdWFscyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmcxID0gQmxvY2tseS5KYXZhU2NyaXB0LnN0YXRlbWVudFRvQ29kZSh0aGlzLCAnQVJHMScsIGZhbHNlKSB8fCAnJztcbiAgICB2YXIgYXJnMiA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzInLCBmYWxzZSkgfHwgJyc7XG4gICAgcmV0dXJuICcoJyArIGFyZzEgKyBcIiA9PSBcIiArIGFyZzIgKyAnKSc7XG4gIH07XG59XG5cbi8vIEluc3RhbGwgYm9vbGVhbiBvcGVyYXRvcnNcblxuZnVuY3Rpb24gaW5zdGFsbExvZ2ljYWxBbmQoYmxvY2tseSwgZ2VuZXJhdG9yLCBnZW5zeW0pIHtcbiAgYmxvY2tseS5CbG9ja3MuZnVuY3Rpb25hbF9sb2dpY2FsX2FuZCA9IHtcbiAgICBoZWxwVXJsOiAnJyxcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIGJsb2NrbHkuRnVuY3Rpb25hbEJsb2NrVXRpbHMuaW5pdFRpdGxlZEZ1bmN0aW9uYWxCbG9jayh0aGlzLCAnYW5kJywgYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5CT09MRUFOLCBbXG4gICAgICAgIHsgbmFtZTogJ0FSRzEnLCB0eXBlOiBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLkJPT0xFQU4gfSxcbiAgICAgICAgeyBuYW1lOiAnQVJHMicsIHR5cGU6IGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuQk9PTEVBTiB9XG4gICAgICBdKTtcbiAgICB9XG4gIH07XG5cbiAgZ2VuZXJhdG9yLmZ1bmN0aW9uYWxfbG9naWNhbF9hbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJnMSA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzEnLCBmYWxzZSkgfHwgMDtcbiAgICB2YXIgYXJnMiA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzInLCBmYWxzZSkgfHwgMDtcbiAgICByZXR1cm4gJygnICsgYXJnMSArIFwiICYmIFwiICsgYXJnMiArICcpJztcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5zdGFsbExvZ2ljYWxPcihibG9ja2x5LCBnZW5lcmF0b3IsIGdlbnN5bSkge1xuICBibG9ja2x5LkJsb2Nrcy5mdW5jdGlvbmFsX2xvZ2ljYWxfb3IgPSB7XG4gICAgaGVscFVybDogJycsXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICBibG9ja2x5LkZ1bmN0aW9uYWxCbG9ja1V0aWxzLmluaXRUaXRsZWRGdW5jdGlvbmFsQmxvY2sodGhpcywgJ29yJywgYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5CT09MRUFOLCBbXG4gICAgICAgIHsgbmFtZTogJ0FSRzEnLCB0eXBlOiBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLkJPT0xFQU4gfSxcbiAgICAgICAgeyBuYW1lOiAnQVJHMicsIHR5cGU6IGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuQk9PTEVBTiB9XG4gICAgICBdKTtcbiAgICB9XG4gIH07XG5cbiAgZ2VuZXJhdG9yLmZ1bmN0aW9uYWxfbG9naWNhbF9vciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmcxID0gQmxvY2tseS5KYXZhU2NyaXB0LnN0YXRlbWVudFRvQ29kZSh0aGlzLCAnQVJHMScsIGZhbHNlKSB8fCAwO1xuICAgIHZhciBhcmcyID0gQmxvY2tseS5KYXZhU2NyaXB0LnN0YXRlbWVudFRvQ29kZSh0aGlzLCAnQVJHMicsIGZhbHNlKSB8fCAwO1xuICAgIHJldHVybiAnKCcgKyBhcmcxICsgXCIgfHwgXCIgKyBhcmcyICsgJyknO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnN0YWxsTG9naWNhbE5vdChibG9ja2x5LCBnZW5lcmF0b3IsIGdlbnN5bSkge1xuICBibG9ja2x5LkJsb2Nrcy5mdW5jdGlvbmFsX2xvZ2ljYWxfbm90ID0ge1xuICAgIGhlbHBVcmw6ICcnLFxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgYmxvY2tseS5GdW5jdGlvbmFsQmxvY2tVdGlscy5pbml0VGl0bGVkRnVuY3Rpb25hbEJsb2NrKHRoaXMsICdub3QnLCBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLkJPT0xFQU4sIFtcbiAgICAgICAgeyBuYW1lOiAnQVJHMScsIHR5cGU6IGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuQk9PTEVBTiB9XG4gICAgICBdKTtcbiAgICB9XG4gIH07XG5cbiAgZ2VuZXJhdG9yLmZ1bmN0aW9uYWxfbG9naWNhbF9ub3QgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJnMSA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzEnLCBmYWxzZSkgfHwgMDtcbiAgICByZXR1cm4gJyEoJyArIGFyZzEgKyAnKSc7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxCb29sZWFuKGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKSB7XG4gIGJsb2NrbHkuQmxvY2tzLmZ1bmN0aW9uYWxfYm9vbGVhbiA9IHtcbiAgICAvLyBCb29sZWFuIHZhbHVlLlxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXRGdW5jdGlvbmFsKHRydWUsIHtcbiAgICAgICAgaGVhZGVySGVpZ2h0OiAwLFxuICAgICAgICByb3dCdWZmZXI6IDNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRIU1YuYXBwbHkodGhpcywgYmxvY2tseS5GdW5jdGlvbmFsVHlwZUNvbG9yc1tibG9ja2x5LkJsb2NrVmFsdWVUeXBlLkJPT0xFQU5dKTtcbiAgICAgIHZhciB2YWx1ZXMgPSBibG9ja2x5LkJsb2Nrcy5mdW5jdGlvbmFsX2Jvb2xlYW4uVkFMVUVTO1xuICAgICAgdGhpcy5hcHBlbmREdW1teUlucHV0KClcbiAgICAgICAgICAuYXBwZW5kVGl0bGUobmV3IGJsb2NrbHkuRmllbGREcm9wZG93bih2YWx1ZXMpLCAnVkFMJylcbiAgICAgICAgICAuc2V0QWxpZ24oQmxvY2tseS5BTElHTl9DRU5UUkUpO1xuICAgICAgdGhpcy5zZXRGdW5jdGlvbmFsT3V0cHV0KHRydWUsIGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuQk9PTEVBTik7XG4gICAgfVxuICB9O1xuXG4gIGJsb2NrbHkuQmxvY2tzLmZ1bmN0aW9uYWxfYm9vbGVhbi5WQUxVRVMgPSBbXG4gICAgICAgIFttc2cuYm9vbGVhblRydWUoKSwgJ3RydWUnXSxcbiAgICAgICAgW21zZy5ib29sZWFuRmFsc2UoKSwgJ2ZhbHNlJ11dO1xuXG4gIGdlbmVyYXRvci5mdW5jdGlvbmFsX2Jvb2xlYW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaXRsZVZhbHVlKCdWQUwnKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5zdGFsbE1hdGhOdW1iZXIoYmxvY2tseSwgZ2VuZXJhdG9yLCBnZW5zeW0pIHtcbiAgYmxvY2tseS5CbG9ja3MuZnVuY3Rpb25hbF9tYXRoX251bWJlciA9IHtcbiAgICAvLyBOdW1lcmljIHZhbHVlLlxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXRGdW5jdGlvbmFsKHRydWUsIHtcbiAgICAgICAgaGVhZGVySGVpZ2h0OiAwLFxuICAgICAgICByb3dCdWZmZXI6IDNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRIU1YuYXBwbHkodGhpcywgYmxvY2tseS5GdW5jdGlvbmFsVHlwZUNvbG9yc1tibG9ja2x5LkJsb2NrVmFsdWVUeXBlLk5VTUJFUl0pO1xuICAgICAgdGhpcy5hcHBlbmREdW1teUlucHV0KClcbiAgICAgICAgICAuYXBwZW5kVGl0bGUobmV3IEJsb2NrbHkuRmllbGRUZXh0SW5wdXQoJzAnLFxuICAgICAgICAgICAgQmxvY2tseS5GaWVsZFRleHRJbnB1dC5udW1iZXJWYWxpZGF0b3IpLCAnTlVNJylcbiAgICAgICAgICAuc2V0QWxpZ24oQmxvY2tseS5BTElHTl9DRU5UUkUpO1xuICAgICAgdGhpcy5zZXRGdW5jdGlvbmFsT3V0cHV0KHRydWUsIGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuTlVNQkVSKTtcbiAgICB9XG4gIH07XG5cbiAgZ2VuZXJhdG9yLmZ1bmN0aW9uYWxfbWF0aF9udW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaXRsZVZhbHVlKCdOVU0nKTtcbiAgfTtcblxuICBibG9ja2x5LkJsb2Nrcy5mdW5jdGlvbmFsX21hdGhfbnVtYmVyX2Ryb3Bkb3duID0ge1xuICAgIC8vIE51bWVyaWMgdmFsdWUuXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldEZ1bmN0aW9uYWwodHJ1ZSwge1xuICAgICAgICBoZWFkZXJIZWlnaHQ6IDAsXG4gICAgICAgIHJvd0J1ZmZlcjogM1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNldEhTVi5hcHBseSh0aGlzLCBibG9ja2x5LkZ1bmN0aW9uYWxUeXBlQ29sb3JzW2Jsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuTlVNQkVSXSk7XG4gICAgICB0aGlzLmFwcGVuZER1bW15SW5wdXQoKVxuICAgICAgICAgIC5hcHBlbmRUaXRsZShuZXcgQmxvY2tseS5GaWVsZERyb3Bkb3duKCksICdOVU0nKVxuICAgICAgICAgIC5zZXRBbGlnbihCbG9ja2x5LkFMSUdOX0NFTlRSRSk7XG4gICAgICB0aGlzLnNldEZ1bmN0aW9uYWxPdXRwdXQodHJ1ZSwgYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5OVU1CRVIpO1xuICAgIH1cbiAgfTtcblxuICBnZW5lcmF0b3IuZnVuY3Rpb25hbF9tYXRoX251bWJlcl9kcm9wZG93biA9IGdlbmVyYXRvci5mdW5jdGlvbmFsX21hdGhfbnVtYmVyO1xufVxuXG5mdW5jdGlvbiBpbnN0YWxsU3RyaW5nKGJsb2NrbHksIGdlbmVyYXRvcikge1xuICBibG9ja2x5LkJsb2Nrcy5mdW5jdGlvbmFsX3N0cmluZyA9IHtcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25hbCh0cnVlLCB7XG4gICAgICAgIGhlYWRlckhlaWdodDogMCxcbiAgICAgICAgcm93QnVmZmVyOiAzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2V0SFNWLmFwcGx5KHRoaXMsIGJsb2NrbHkuRnVuY3Rpb25hbFR5cGVDb2xvcnNbYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5TVFJJTkddKTtcbiAgICAgIHRoaXMuYXBwZW5kRHVtbXlJbnB1dCgpXG4gICAgICAgIC5hcHBlbmRUaXRsZShuZXcgQmxvY2tseS5GaWVsZExhYmVsKCdcIicpKVxuICAgICAgICAuYXBwZW5kVGl0bGUobmV3IEJsb2NrbHkuRmllbGRUZXh0SW5wdXQoJycpLCAnVkFMJylcbiAgICAgICAgLmFwcGVuZFRpdGxlKG5ldyBCbG9ja2x5LkZpZWxkTGFiZWwoJ1wiJykpXG4gICAgICAgIC5zZXRBbGlnbihCbG9ja2x5LkFMSUdOX0NFTlRSRSk7XG4gICAgICB0aGlzLnNldEZ1bmN0aW9uYWxPdXRwdXQodHJ1ZSwgYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5TVFJJTkcpO1xuICAgIH1cbiAgfTtcblxuICBnZW5lcmF0b3IuZnVuY3Rpb25hbF9zdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYmxvY2tseS5KYXZhU2NyaXB0LnF1b3RlXyh0aGlzLmdldFRpdGxlVmFsdWUoJ1ZBTCcpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5zdGFsbFNxcnQoYmxvY2tseSwgZ2VuZXJhdG9yKSB7XG4gIGJsb2NrbHkuQmxvY2tzLmZ1bmN0aW9uYWxfc3FydCA9IHtcbiAgICBoZWxwVXJsOiAnJyxcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIGJsb2NrbHkuRnVuY3Rpb25hbEJsb2NrVXRpbHMuaW5pdFRpdGxlZEZ1bmN0aW9uYWxCbG9jayh0aGlzLCAnc3FydCcsICdOdW1iZXInLCBbXG4gICAgICAgIHsgbmFtZTogJ0FSRzEnLCB0eXBlOiAnTnVtYmVyJyB9XG4gICAgICBdKTtcbiAgICB9XG4gIH07XG5cbiAgZ2VuZXJhdG9yLmZ1bmN0aW9uYWxfc3FydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmcxID0gQmxvY2tseS5KYXZhU2NyaXB0LnN0YXRlbWVudFRvQ29kZSh0aGlzLCAnQVJHMScsIGZhbHNlKSB8fCAwO1xuICAgIHJldHVybiAnTWF0aC5zcXJ0KCcgKyBhcmcxICsgJyknO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnN0YWxsUG93KGJsb2NrbHksIGdlbmVyYXRvcikge1xuICBibG9ja2x5LkJsb2Nrcy5mdW5jdGlvbmFsX3BvdyA9IHtcbiAgICBoZWxwVXJsOiAnJyxcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIGJsb2NrbHkuRnVuY3Rpb25hbEJsb2NrVXRpbHMuaW5pdFRpdGxlZEZ1bmN0aW9uYWxCbG9jayh0aGlzLCAncG93JywgJ051bWJlcicsIFtcbiAgICAgICAgeyBuYW1lOiAnQVJHMScsIHR5cGU6ICdOdW1iZXInIH0sXG4gICAgICAgIHsgbmFtZTogJ0FSRzInLCB0eXBlOiAnTnVtYmVyJyB9XG4gICAgICBdKTtcbiAgICB9XG4gIH07XG5cbiAgZ2VuZXJhdG9yLmZ1bmN0aW9uYWxfcG93ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZzEgPSBCbG9ja2x5LkphdmFTY3JpcHQuc3RhdGVtZW50VG9Db2RlKHRoaXMsICdBUkcxJywgZmFsc2UpIHx8IDA7XG4gICAgdmFyIGFyZzIgPSBCbG9ja2x5LkphdmFTY3JpcHQuc3RhdGVtZW50VG9Db2RlKHRoaXMsICdBUkcyJywgZmFsc2UpIHx8IDA7XG4gICAgcmV0dXJuICdNYXRoLnBvdygnICsgYXJnMSArICcsICcgKyBhcmcyICsgJyknO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnN0YWxsU3F1YXJlZChibG9ja2x5LCBnZW5lcmF0b3IpIHtcbiAgYmxvY2tseS5CbG9ja3MuZnVuY3Rpb25hbF9zcXVhcmVkID0ge1xuICAgIGhlbHBVcmw6ICcnLFxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgYmxvY2tseS5GdW5jdGlvbmFsQmxvY2tVdGlscy5pbml0VGl0bGVkRnVuY3Rpb25hbEJsb2NrKHRoaXMsICdzcXInLCAnTnVtYmVyJywgW1xuICAgICAgICB7IG5hbWU6ICdBUkcxJywgdHlwZTogJ051bWJlcicgfVxuICAgICAgXSk7XG4gICAgfVxuICB9O1xuXG4gIGdlbmVyYXRvci5mdW5jdGlvbmFsX3NxdWFyZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJnMSA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzEnLCBmYWxzZSkgfHwgMDtcbiAgICByZXR1cm4gYXJnMSArICcgKiAnICsgYXJnMTtcbiAgfTtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBjb25kIGJsb2NrLiBudW1QYWlycyByZXByZXNlbnRzIHRoZSBudW1iZXIgb2ZcbiAqIGNvbmRpdGlvbi12YWx1ZSBwYWlycyBiZWZvcmUgdGhlIGRlZmF1bHQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGluc3RhbGxDb25kKGJsb2NrbHksIGdlbmVyYXRvcikge1xuICAvLyBUT0RPKGJyZW50KSAtIHJ0bFxuICB2YXIgdHlwZXMgPSBbQmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5OT05FLCBCbG9ja2x5LkJsb2NrVmFsdWVUeXBlLk5VTUJFUixcbiAgICBCbG9ja2x5LkJsb2NrVmFsdWVUeXBlLlNUUklORywgQmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5JTUFHRSxcbiAgICBCbG9ja2x5LkJsb2NrVmFsdWVUeXBlLkJPT0xFQU5dO1xuXG4gIC8vIEdlbmVyYXRlcyB0aGUgZm9sbG93aW5nIGJsb2NrczpcbiAgLy8gZnVuY3Rpb25hbF9jb25kIChkZXByZWNhdGVkKVxuICAvLyBmdW5jdGlvbmFsX2NvbmRfbnVtYmVyXG4gIC8vIGZ1bmN0aW9uYWxfY29uZF9zdHJpbmdcbiAgLy8gZnVuY3Rpb25hbF9jb25kX2Jvb2xlYW5cbiAgLy8gZnVuY3Rpb25hbF9jb25kX2ltYWdlXG4gIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpbnN0YWxsQ29uZEZvclR5cGUoYmxvY2tseSwgZ2VuZXJhdG9yLCB0eXBlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxDb25kRm9yVHlwZShibG9ja2x5LCBnZW5lcmF0b3IsIHR5cGUpIHtcbiAgdmFyIGJsb2NrTmFtZSA9ICdmdW5jdGlvbmFsX2NvbmQnO1xuICBpZiAodHlwZSAhPT0gQmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5OT05FKSB7XG4gICAgYmxvY2tOYW1lICs9ICdfJyArIHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIGJsb2NrbHkuQmxvY2tzW2Jsb2NrTmFtZV0gPSB7XG4gICAgaGVscFVybDogJycsXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnBhaXJzXyA9IFtdO1xuICAgICAgdGhpcy5zZXRGdW5jdGlvbmFsKHRydWUsIHtcbiAgICAgICAgaGVhZGVySGVpZ2h0OiAzMFxuICAgICAgfSk7XG5cbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBmaXhlZFNpemU6IHsgaGVpZ2h0OiAzNSB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnNldEhTVi5hcHBseSh0aGlzLCBCbG9ja2x5LkZ1bmN0aW9uYWxUeXBlQ29sb3JzW3R5cGVdKTtcblxuICAgICAgdmFyIHBsdXNGaWVsZCA9IG5ldyBCbG9ja2x5LkZpZWxkSWNvbignKycpO1xuICAgICAgQmxvY2tseS5iaW5kRXZlbnRfKHBsdXNGaWVsZC5nZXRSb290RWxlbWVudCgpLCAnbW91c2Vkb3duJyxcbiAgICAgICAgdGhpcywgdGhpcy5hZGRDb25kaXRpb25hbFJvdyk7XG5cbiAgICAgIHRoaXMuYXBwZW5kRHVtbXlJbnB1dCgpXG4gICAgICAgIC5hcHBlbmRUaXRsZShuZXcgQmxvY2tseS5GaWVsZExhYmVsKCdjb25kJywgb3B0aW9ucykpXG4gICAgICAgIC5zZXRBbGlnbihCbG9ja2x5LkFMSUdOX0NFTlRSRSk7XG5cbiAgICAgIHRoaXMuYXBwZW5kRHVtbXlJbnB1dCgnRUxTRScpXG4gICAgICAgIC5hcHBlbmRUaXRsZShuZXcgQmxvY2tseS5GaWVsZExhYmVsKCdlbHNlJywgb3B0aW9ucykpO1xuICAgICAgdmFyIGRlZmF1bHRJbnB1dCA9IHRoaXMuYXBwZW5kRnVuY3Rpb25hbElucHV0KCdERUZBVUxUJylcbiAgICAgICAgLnNldElubGluZSh0cnVlKTtcbiAgICAgIGRlZmF1bHRJbnB1dC5zZXRIU1YuYXBwbHkoZGVmYXVsdElucHV0LCBCbG9ja2x5LkZ1bmN0aW9uYWxUeXBlQ29sb3JzW3R5cGVdKTtcblxuICAgICAgdGhpcy5hcHBlbmREdW1teUlucHV0KCdQTFVTJylcbiAgICAgICAgLmFwcGVuZFRpdGxlKHBsdXNGaWVsZClcbiAgICAgICAgLnNldElubGluZSh0cnVlKTtcblxuICAgICAgdGhpcy5zZXRGdW5jdGlvbmFsT3V0cHV0KHRydWUsIHR5cGUgPT09IEJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuTk9ORSA/XG4gICAgICAgIHVuZGVmaW5lZCA6IHR5cGUpO1xuXG4gICAgICB0aGlzLmFkZENvbmRpdGlvbmFsUm93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhbm90aGVyIGNvbmRpdGlvbi92YWx1ZSBwYWlyIHRvIHRoZSBlbmQuXG4gICAgICovXG4gICAgYWRkQ29uZGl0aW9uYWxSb3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGlkIGlzIGVpdGhlciB0aGUgbGFzdCB2YWx1ZSBwbHVzIDEsIG9yIGlmIHdlIGhhdmUgbm8gdmFsdWVzIHlldCAwXG4gICAgICAvLyB3ZSBjYW4ndCBqdXN0IGhhdmUgcGFpcnNfLmxlbmd0aCwgc2luY2UgdGhlcmUgY291bGQgYmUgZ2Fwc1xuICAgICAgdmFyIGlkID0gdGhpcy5wYWlyc18ubGVuZ3RoID4gMCA/IF8odGhpcy5wYWlyc18pLmxhc3QoKSAqIDEgKyAxIDogMDtcbiAgICAgIHRoaXMucGFpcnNfLnB1c2goaWQpO1xuXG4gICAgICB2YXIgY29uZCA9IHRoaXMuYXBwZW5kRnVuY3Rpb25hbElucHV0KCdDT05EJyArIGlkKTtcbiAgICAgIGNvbmQuc2V0SFNWLmFwcGx5KGNvbmQsIGJsb2NrbHkuRnVuY3Rpb25hbFR5cGVDb2xvcnNbYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5CT09MRUFOXSk7XG4gICAgICBjb25kLnNldENoZWNrKGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuQk9PTEVBTik7XG4gICAgICB0aGlzLm1vdmVJbnB1dEJlZm9yZSgnQ09ORCcgKyBpZCwgJ0VMU0UnKTtcblxuICAgICAgdmFyIGlucHV0ID0gdGhpcy5hcHBlbmRGdW5jdGlvbmFsSW5wdXQoJ1ZBTFVFJyArIGlkKVxuICAgICAgICAuc2V0SW5saW5lKHRydWUpO1xuICAgICAgaW5wdXQuc2V0SFNWLmFwcGx5KGlucHV0LCBCbG9ja2x5LkZ1bmN0aW9uYWxUeXBlQ29sb3JzW3R5cGVdKTtcbiAgICAgIHRoaXMubW92ZUlucHV0QmVmb3JlKCdWQUxVRScgKyBpZCwgJ0VMU0UnKTtcblxuICAgICAgdmFyIG1pbnVzSW5wdXQgPSB0aGlzLmFwcGVuZER1bW15SW5wdXQoJ01JTlVTJyArIGlkKVxuICAgICAgICAuc2V0SW5saW5lKHRydWUpO1xuXG4gICAgICBpZiAodGhpcy5wYWlyc18ubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgbWludXNGaWVsZCA9IG5ldyBCbG9ja2x5LkZpZWxkSWNvbignLScpO1xuICAgICAgICBCbG9ja2x5LmJpbmRFdmVudF8obWludXNGaWVsZC5nZXRSb290RWxlbWVudCgpLCAnbW91c2Vkb3duJyxcbiAgICAgICAgICB0aGlzLCBfLmJpbmQodGhpcy5yZW1vdmVDb25kaXRpb25hbFJvdywgdGhpcywgaWQpKTtcbiAgICAgICAgbWludXNJbnB1dC5hcHBlbmRUaXRsZShtaW51c0ZpZWxkKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tb3ZlSW5wdXRCZWZvcmUoJ01JTlVTJyArIGlkLCAnRUxTRScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGNvbmRpdGlvbi92YWx1ZSBwYWlyIHdpdGggdGhlIGdpdmVuIGlkLiBOby1vcCBpZiBubyByb3cgd2l0aFxuICAgICAqIHRoYXQgaWQuXG4gICAgICovXG4gICAgcmVtb3ZlQ29uZGl0aW9uYWxSb3c6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5wYWlyc18uaW5kZXhPZihpZCk7XG4gICAgICBpZiAoIV8odGhpcy5wYWlyc18pLmNvbnRhaW5zKGlkKSB8fCB0aGlzLnBhaXJzXy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5wYWlyc18uc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgdmFyIGNvbmQgPSB0aGlzLmdldElucHV0KCdDT05EJyArIGlkKTtcbiAgICAgIHZhciBjaGlsZCA9IGNvbmQuY29ubmVjdGlvbi50YXJnZXRCbG9jaygpO1xuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVtb3ZlSW5wdXQoJ0NPTkQnICsgaWQpO1xuXG4gICAgICB2YXIgdmFsID0gdGhpcy5nZXRJbnB1dCgnVkFMVUUnICsgaWQpO1xuICAgICAgY2hpbGQgPSB2YWwuY29ubmVjdGlvbi50YXJnZXRCbG9jaygpO1xuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVtb3ZlSW5wdXQoJ1ZBTFVFJyArIGlkKTtcblxuICAgICAgdGhpcy5yZW1vdmVJbnB1dCgnTUlOVVMnICsgaWQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgcGFpcnMgc28gdGhhdCB3ZSBjYW4gZGVzZXJpYWxpemUgd2l0aCB0aGUgc2FtZSBpZHNcbiAgICAgKi9cbiAgICBtdXRhdGlvblRvRG9tOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBhaXJzXy5sZW5ndGggPD0gMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdtdXRhdGlvbicpO1xuICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgncGFpcnMnLCB0aGlzLnBhaXJzXy5qb2luKCcsJykpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemUgYW5kIGNhdXNlIG91ciBibG9jayB0byBoYXZlIHNhbWUgaWRzXG4gICAgICovXG4gICAgZG9tVG9NdXRhdGlvbjogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIHBhaXJzID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3BhaXJzJyk7XG4gICAgICBpZiAoIXBhaXJzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGFpcnMgPSBwYWlycy5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoaXRlbSwgMTApO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE91ciBwYWlycywgd2hpY2ggYXJlIHVzZWQgdG8gbmFtZSByb3dzLCBhcmUgbm90IG5lY2Vzc2FyaWx5IGNvbnRpZ3VvdXMuXG4gICAgICAvLyBXZSBlbnN1cmUgdGhhdCB3ZSBlbmQgdXAgd2l0aCB0aGUgc2FtZSBzZXQgb2YgcGFpcnMgYnkgYWRkaW5nIGxvdHNcbiAgICAgIC8vIG9mIHJvd3MsIGFuZCB0aGVuIGRlbGV0aW5nIHRoZSB1bm5lZWRlZCBvbmVzIChzaW11bGF0aW5nIHdoYXQgaGFwcGVuZWRcbiAgICAgIC8vIHRvIG9yaWdpbmFsbHkgY3JlYXRlIHRoaXMgYmxvY2spXG4gICAgICB2YXIgbGFzdFJvdyA9IF8ocGFpcnMpLmxhc3QoKTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPD0gbGFzdFJvdzsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRkQ29uZGl0aW9uYWxSb3coKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxhc3RSb3c7IGkrKykge1xuICAgICAgICBpZiAoIV8ocGFpcnMpLmNvbnRhaW5zKGkpKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVDb25kaXRpb25hbFJvdyhpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogLy8gZ2VuZXJhdGVzIGNvZGUgbGlrZTpcbiAgICogZnVuY3Rpb24oKSB7XG4gICAqICAgaWYgKGNvbmQxKSB7IHJldHVybiB2YWx1ZTE7IH1cbiAgICogICBlbHNlIGlmIChjb25kMikge3JldHVybiB2YWx1ZTI7IH1cbiAgICogICAuLi5cbiAgICogICBlbHNlIHsgcmV0dXJuIGRlZmF1bHQ7IH1cbiAgICogfSgpXG4gICAqL1xuICBnZW5lcmF0b3JbYmxvY2tOYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb25kLCB2YWx1ZSwgZGVmYXVsdFZhbHVlO1xuICAgIHZhciBjb2RlID0gJyhmdW5jdGlvbiAoKSB7XFxuICAnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYWlyc18ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBjb2RlICs9ICdlbHNlICc7XG4gICAgICB9XG4gICAgICB2YXIgaWQgPSB0aGlzLnBhaXJzX1tpXTtcbiAgICAgIGNvbmQgPSBCbG9ja2x5LkphdmFTY3JpcHQuc3RhdGVtZW50VG9Db2RlKHRoaXMsICdDT05EJyArIGlkLCBmYWxzZSkgfHxcbiAgICAgICAgICBmYWxzZTtcbiAgICAgIHZhbHVlID0gQmxvY2tseS5KYXZhU2NyaXB0LnN0YXRlbWVudFRvQ29kZSh0aGlzLCAnVkFMVUUnICsgaWQsIGZhbHNlKSB8fFxuICAgICAgICAgICcnO1xuICAgICAgY29kZSArPSAnaWYgKCcgKyBjb25kICsgJykgeyByZXR1cm4gJyArIHZhbHVlICsgJzsgfVxcbiAgJztcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlID0gQmxvY2tseS5KYXZhU2NyaXB0LnN0YXRlbWVudFRvQ29kZSh0aGlzLCAnREVGQVVMVCcsIGZhbHNlKSB8fFxuICAgICAgICAnJztcbiAgICBjb2RlICs9ICdlbHNlIHsgcmV0dXJuICcgKyBkZWZhdWx0VmFsdWUgKyAnOyB9XFxuJztcbiAgICBjb2RlICs9ICd9KSgpJztcbiAgICByZXR1cm4gY29kZTtcbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFByb3RlY3RlZFN0YXRlZnVsRGl2ID0gcmVxdWlyZSgnLi9Qcm90ZWN0ZWRTdGF0ZWZ1bERpdi5qc3gnKTtcbnZhciBTdHVkaW9BcHBXcmFwcGVyID0gcmVxdWlyZSgnLi9TdHVkaW9BcHBXcmFwcGVyLmpzeCcpO1xuXG4vKipcbiAqIFRvcC1sZXZlbCBSZWFjdCB3cmFwcGVyIGZvciBvdXIgc3RhbmRhcmQgYmxvY2tseSBhcHBzLlxuICovXG52YXIgQXBwVmlldyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgcHJvcFR5cGVzOiB7XG4gICAgYXNzZXRVcmw6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgaXNFbWJlZFZpZXc6IFJlYWN0LlByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG4gICAgaXNTaGFyZVZpZXc6IFJlYWN0LlByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG4gICAgcmVuZGVyQ29kZVdvcmtzcGFjZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICByZW5kZXJWaXN1YWxpemF0aW9uQ29sdW1uOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIG9uTW91bnQ6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucHJvcHMub25Nb3VudCgpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8U3R1ZGlvQXBwV3JhcHBlclxuICAgICAgICAgIGFzc2V0VXJsPXt0aGlzLnByb3BzLmFzc2V0VXJsfVxuICAgICAgICAgIGlzRW1iZWRWaWV3PXt0aGlzLnByb3BzLmlzRW1iZWRWaWV3fVxuICAgICAgICAgIGlzU2hhcmVWaWV3PXt0aGlzLnByb3BzLmlzU2hhcmVWaWV3fT5cbiAgICAgICAgPFByb3RlY3RlZFN0YXRlZnVsRGl2XG4gICAgICAgICAgICBpZD1cInZpc3VhbGl6YXRpb25Db2x1bW5cIlxuICAgICAgICAgICAgcmVuZGVyQ29udGVudHM9e3RoaXMucHJvcHMucmVuZGVyVmlzdWFsaXphdGlvbkNvbHVtbn0gLz5cbiAgICAgICAgPFByb3RlY3RlZFN0YXRlZnVsRGl2IGlkPVwidmlzdWFsaXphdGlvblJlc2l6ZUJhclwiIGNsYXNzTmFtZT1cImZhIGZhLWVsbGlwc2lzLXZcIiAvPlxuICAgICAgICA8UHJvdGVjdGVkU3RhdGVmdWxEaXZcbiAgICAgICAgICAgIGlkPVwiY29kZVdvcmtzcGFjZVwiXG4gICAgICAgICAgICByZW5kZXJDb250ZW50cz17dGhpcy5wcm9wcy5yZW5kZXJDb2RlV29ya3NwYWNlfSAvPlxuICAgICAgPC9TdHVkaW9BcHBXcmFwcGVyPlxuICAgICk7XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBBcHBWaWV3O1xuIiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCcnKTsxO1xudmFyIG1zZyA9IHJlcXVpcmUoJy4uL2xvY2FsZScpO1xudmFyIGhpZGVSdW5CdXR0b24gPSBsb2NhbHMuaGlkZVJ1bkJ1dHRvbiB8fCBmYWxzZTtcbjsgYnVmLnB1c2goJ1xcblxcbicpOzY7IHZhciBnYW1lQnV0dG9ucyA9IGZ1bmN0aW9uKCkgezsgYnVmLnB1c2goJzxkaXYgaWQ9XCJnYW1lQnV0dG9uc1wiPlxcbiAgPGJ1dHRvbiBpZD1cInJ1bkJ1dHRvblwiIGNsYXNzPVwibGF1bmNoIGJsb2NrbHlMYXVuY2ggJywgZXNjYXBlKCg3LCAgaGlkZVJ1bkJ1dHRvbiA/ICdpbnZpc2libGUnIDogJycpKSwgJ1wiPlxcbiAgICA8ZGl2PicsIGVzY2FwZSgoOCwgIG1zZy5ydW5Qcm9ncmFtKCkgKSksICc8L2Rpdj5cXG4gICAgPGltZyBzcmM9XCInLCBlc2NhcGUoKDksICBhc3NldFVybCgnbWVkaWEvMXgxLmdpZicpICkpLCAnXCIgY2xhc3M9XCJydW4yNlwiLz5cXG4gIDwvYnV0dG9uPlxcbiAgPGJ1dHRvbiBpZD1cInJlc2V0QnV0dG9uXCIgY2xhc3M9XCJsYXVuY2ggYmxvY2tseUxhdW5jaFwiIHN0eWxlPVwiZGlzcGxheTogbm9uZVwiPlxcbiAgICA8ZGl2PicsIGVzY2FwZSgoMTIsICBtc2cucmVzZXRQcm9ncmFtKCkgKSksICc8L2Rpdj5cXG4gICAgPGltZyBzcmM9XCInLCBlc2NhcGUoKDEzLCAgYXNzZXRVcmwoJ21lZGlhLzF4MS5naWYnKSApKSwgJ1wiIGNsYXNzPVwicmVzZXQyNlwiLz5cXG4gIDwvYnV0dG9uPlxcbiAgJyk7MTU7IGlmIChkYXRhLmNvbnRyb2xzKSB7IDsgYnVmLnB1c2goJ1xcbiAgICAnLCAoMTYsICBkYXRhLmNvbnRyb2xzICksICdcXG4gICcpOzE3OyB9IDsgYnVmLnB1c2goJ1xcbiAgJyk7MTg7IGlmICghZGF0YS5waW5Xb3Jrc3BhY2VUb0JvdHRvbSAmJiBkYXRhLmV4dHJhQ29udHJvbFJvd3MpIHsgOyBidWYucHVzaCgnXFxuICAgICcsICgxOSwgIGRhdGEuZXh0cmFDb250cm9sUm93cyApLCAnXFxuICAnKTsyMDsgfSA7IGJ1Zi5wdXNoKCdcXG48L2Rpdj5cXG4nKTsyMjsgfTs7IGJ1Zi5wdXNoKCdcXG48ZGl2IGlkPVwidmlzdWFsaXphdGlvblwiPlxcbiAgJywgKDI0LCAgZGF0YS52aXN1YWxpemF0aW9uICksICdcXG48L2Rpdj5cXG5cXG4nKTsyNzsgZ2FtZUJ1dHRvbnMoKSA7IGJ1Zi5wdXNoKCdcXG5cXG48ZGl2IGlkPVwiYmVsb3dWaXN1YWxpemF0aW9uXCI+XFxuXFxuICA8ZGl2IGlkPVwiYnViYmxlXCIgY2xhc3M9XCJjbGVhcmZpeFwiPlxcbiAgICA8dGFibGUgaWQ9XCJwcm9tcHQtdGFibGVcIj5cXG4gICAgICA8dHI+XFxuICAgICAgICA8dGQgaWQ9XCJwcm9tcHQtaWNvbi1jZWxsXCIgc3R5bGU9XCJkaXNwbGF5OiBub25lXCI+XFxuICAgICAgICAgIDxpbWcgaWQ9XCJwcm9tcHQtaWNvblwiLz5cXG4gICAgICAgIDwvdGQ+XFxuICAgICAgICA8dGQgaWQ9XCJwcm9tcHQtY2VsbFwiPlxcbiAgICAgICAgICA8cCBpZD1cInByb21wdFwiPlxcbiAgICAgICAgICA8cCBpZD1cInByb21wdDJcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiPlxcbiAgICAgICAgICA8L3A+XFxuICAgICAgICA8L3RkPlxcbiAgICAgIDwvdHI+XFxuICAgIDwvdGFibGU+XFxuICAgICcpOzQ0OyBpZiAoZGF0YS5pbnB1dE91dHB1dFRhYmxlKSB7IDsgYnVmLnB1c2goJ1xcbiAgICAgIDxkaXYgaWQ9XCJpbnB1dC10YWJsZVwiPlxcbiAgICAgICAgPHRhYmxlPlxcbiAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgPHRoPklucHV0PC90aD5cXG4gICAgICAgICAgICA8dGg+T3V0cHV0PC90aD5cXG4gICAgICAgICAgPC90cj5cXG4gICAgICAgICAgJyk7NTE7IGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5pbnB1dE91dHB1dFRhYmxlLmxlbmd0aDsgaSsrKSB7IDsgYnVmLnB1c2goJ1xcbiAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgPHRkPicsICg1MywgIGRhdGEuaW5wdXRPdXRwdXRUYWJsZVtpXVswXSApLCAnPC90ZD5cXG4gICAgICAgICAgICA8dGQ+JywgKDU0LCAgZGF0YS5pbnB1dE91dHB1dFRhYmxlW2ldWzFdICksICc8L3RkPlxcbiAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAnKTs1NjsgfSA7IGJ1Zi5wdXNoKCdcXG4gICAgICAgIDwvdGFibGU+XFxuICAgICAgPC9kaXY+XFxuICAgICcpOzU5OyB9IDsgYnVmLnB1c2goJ1xcbiAgICA8ZGl2IGlkPVwiYW5pLWdpZi1wcmV2aWV3LXdyYXBwZXJcIj5cXG4gICAgICA8ZGl2IGlkPVwiYW5pLWdpZi1wcmV2aWV3XCI+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuJyk7IH0pKCk7XG59IFxucmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG4gIHJldHVybiBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICByZXR1cm4gdChsb2NhbHMsIHJlcXVpcmUoXCJlanNcIikuZmlsdGVycyk7XG4gIH1cbn0oKSk7IiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCcnKTsxO1xudmFyIG1zZyA9IHJlcXVpcmUoJy4uL2xvY2FsZScpO1xuOyBidWYucHVzaCgnXFxuXFxuPGRpdiBpZD1cImNvZGVXb3Jrc3BhY2VXcmFwcGVyXCI+XFxuICA8ZGl2IGlkPVwiaGVhZGVyc1wiIGRpcj1cIicsIGVzY2FwZSgoNiwgIGRhdGEubG9jYWxlRGlyZWN0aW9uICkpLCAnXCI+XFxuICAgIDxkaXYgaWQ9XCJjb2RlTW9kZUhlYWRlcnNcIj5cXG4gICAgICA8ZGl2IGlkPVwidG9vbGJveC1oZWFkZXJcIiBjbGFzcz1cIndvcmtzcGFjZS1oZWFkZXJcIj5cXG4gICAgICAgIDxpIGlkPVwiaGlkZS10b29sYm94LWljb25cIiBzdHlsZT1cImRpc3BsYXk6bm9uZTtcIiBjbGFzcz1cImZhIGZhLWNoZXZyb24tY2lyY2xlLXJpZ2h0XCI+PC9pPlxcbiAgICAgICAgPHNwYW4+JywgZXNjYXBlKCgxMCwgIGRhdGEuZWRpdENvZGUgPyBtc2cudG9vbGJveEhlYWRlckRyb3BsZXQoKSA6IG1zZy50b29sYm94SGVhZGVyKCkgKSksICc8L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBpZD1cInNob3ctdG9vbGJveC1oZWFkZXJcIiBjbGFzcz1cIndvcmtzcGFjZS1oZWFkZXJcIiBzdHlsZT1cImRpc3BsYXk6bm9uZTtcIj5cXG4gICAgICAgIDxpIGlkPVwic2hvdy10b29sYm94LWljb25cIiBjbGFzcz1cImZhIGZhLWNoZXZyb24tY2lyY2xlLXJpZ2h0XCI+PC9pPlxcbiAgICAgICAgPHNwYW4+JywgZXNjYXBlKCgxNCwgIG1zZy5zaG93VG9vbGJveCgpICkpLCAnPC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgaWQ9XCJzaG93LWNvZGUtaGVhZGVyXCIgY2xhc3M9XCJ3b3Jrc3BhY2UtaGVhZGVyIHdvcmtzcGFjZS1oZWFkZXItYnV0dG9uXCI+PHNwYW4+PGltZyBzcmM9XCInLCBlc2NhcGUoKDE2LCAgYXNzZXRVcmwoJ21lZGlhL2FwcGxhYi9ibG9ja3NfZ2x5cGguZ2lmJykgKSksICdcIiBjbGFzcz1cImJsb2Nrcy1nbHlwaFwiIC8+PGkgY2xhc3M9XCJmYSBmYS1jb2RlXCI+PC9pPicsIGVzY2FwZSgoMTYsICBtc2cuc2hvd0NvZGVIZWFkZXIoKSApKSwgJzwvc3Bhbj48L2Rpdj5cXG4gICAgICAnKTsxNzsgaWYgKCFkYXRhLnJlYWRvbmx5V29ya3NwYWNlKSB7IDsgYnVmLnB1c2goJ1xcbiAgICAgICAgPGRpdiBpZD1cImNsZWFyLXB1enpsZS1oZWFkZXJcIiBjbGFzcz1cIndvcmtzcGFjZS1oZWFkZXIgd29ya3NwYWNlLWhlYWRlci1idXR0b25cIj48c3Bhbj48aSBjbGFzcz1cImZhIGZhLXVuZG9cIj48L2k+JywgZXNjYXBlKCgxOCwgIG1zZy5jbGVhclB1enpsZSgpICkpLCAnPC9zcGFuPjwvZGl2PlxcbiAgICAgICcpOzE5OyB9IDsgYnVmLnB1c2goJ1xcbiAgICAgIDxkaXYgaWQ9XCJ2ZXJzaW9ucy1oZWFkZXJcIiBjbGFzcz1cIndvcmtzcGFjZS1oZWFkZXIgd29ya3NwYWNlLWhlYWRlci1idXR0b25cIj48c3Bhbj48aSBjbGFzcz1cImZhIGZhLWNsb2NrLW9cIj48L2k+JywgZXNjYXBlKCgyMCwgIG1zZy5zaG93VmVyc2lvbnNIZWFkZXIoKSApKSwgJzwvc3Bhbj48L2Rpdj5cXG4gICAgICA8ZGl2IGlkPVwid29ya3NwYWNlLWhlYWRlclwiIGNsYXNzPVwid29ya3NwYWNlLWhlYWRlclwiPlxcbiAgICAgICAgPHNwYW4gaWQ9XCJ3b3Jrc3BhY2UtaGVhZGVyLXNwYW5cIj5cXG4gICAgICAgICAgJywgZXNjYXBlKCgyMywgIGRhdGEucmVhZG9ubHlXb3Jrc3BhY2UgPyBtc2cucmVhZG9ubHlXb3Jrc3BhY2VIZWFkZXIoKSA6IG1zZy53b3Jrc3BhY2VIZWFkZXJTaG9ydCgpICkpLCAnXFxuICAgICAgICA8L3NwYW4+XFxuICAgICAgICA8ZGl2IGlkPVwiYmxvY2tDb3VudGVyXCI+XFxuICAgICAgICAgIDxkaXYgaWQ9XCJibG9ja1VzZWRcIiBjbGFzcz0nLCBlc2NhcGUoKDI2LCAgZGF0YS5ibG9ja0NvdW50ZXJDbGFzcyApKSwgJz5cXG4gICAgICAgICAgICAnLCBlc2NhcGUoKDI3LCAgZGF0YS5ibG9ja1VzZWQgKSksICdcXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDxzcGFuPi88L3NwYW4+XFxuICAgICAgICAgIDxzcGFuIGlkPVwiaWRlYWxCbG9ja051bWJlclwiPicsIGVzY2FwZSgoMzAsICBkYXRhLmlkZWFsQmxvY2tOdW1iZXIgKSksICc8L3NwYW4+XFxuICAgICAgICAgIDxzcGFuPiAnLCBlc2NhcGUoKDMxLCAgbXNnLmJsb2NrcygpICkpLCAnPC9zcGFuPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuICAnKTszNjsgaWYgKGRhdGEuZWRpdENvZGUpIHsgOyBidWYucHVzaCgnXFxuICAgIDxkaXYgaWQ9XCJjb2RlVGV4dGJveFwiPjwvZGl2PlxcbiAgJyk7Mzg7IH0gOyBidWYucHVzaCgnXFxuICAnKTszOTsgaWYgKGRhdGEucGluV29ya3NwYWNlVG9Cb3R0b20gJiYgZGF0YS5leHRyYUNvbnRyb2xSb3dzKSB7IDsgYnVmLnB1c2goJ1xcbiAgICAnLCAoNDAsICBkYXRhLmV4dHJhQ29udHJvbFJvd3MgKSwgJ1xcbiAgJyk7NDE7IH0gOyBidWYucHVzaCgnXFxuPC9kaXY+XFxuJyk7NDM7IGlmIChkYXRhLmhhc0Rlc2lnbk1vZGUpIHsgOyBidWYucHVzaCgnXFxuICA8ZGl2IGlkPVwiZGVzaWduV29ya3NwYWNlXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmU7XCI+XFxuPC9kaXY+XFxuJyk7NDY7IH0gOyBidWYucHVzaCgnXFxuJyk7IH0pKCk7XG59IFxucmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG4gIHJldHVybiBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICByZXR1cm4gdChsb2NhbHMsIHJlcXVpcmUoXCJlanNcIikuZmlsdGVycyk7XG4gIH1cbn0oKSk7IiwiLy8gYXZhdGFyOiBBIDEwMjl4NTEgc2V0IG9mIDIxIGF2YXRhciBpbWFnZXMuXG5cbmV4cG9ydHMubG9hZCA9IGZ1bmN0aW9uKGFzc2V0VXJsLCBpZCkge1xuICB2YXIgc2tpblVybCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBpZiAocGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gYXNzZXRVcmwoJ21lZGlhL3NraW5zLycgKyBpZCArICcvJyArIHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNraW4gPSB7XG4gICAgaWQ6IGlkLFxuICAgIGFzc2V0VXJsOiBza2luVXJsLFxuICAgIC8vIEltYWdlc1xuICAgIGF2YXRhcjogc2tpblVybCgnYXZhdGFyLnBuZycpLFxuICAgIGF2YXRhcl8yeDogc2tpblVybCgnYXZhdGFyXzJ4LnBuZycpLFxuICAgIGdvYWw6IHNraW5VcmwoJ2dvYWwucG5nJyksXG4gICAgb2JzdGFjbGU6IHNraW5VcmwoJ29ic3RhY2xlLnBuZycpLFxuICAgIHNtYWxsU3RhdGljQXZhdGFyOiBza2luVXJsKCdzbWFsbF9zdGF0aWNfYXZhdGFyLnBuZycpLFxuICAgIHN0YXRpY0F2YXRhcjogc2tpblVybCgnc3RhdGljX2F2YXRhci5wbmcnKSxcbiAgICB3aW5BdmF0YXI6IHNraW5VcmwoJ3dpbl9hdmF0YXIucG5nJyksXG4gICAgZmFpbHVyZUF2YXRhcjogc2tpblVybCgnZmFpbHVyZV9hdmF0YXIucG5nJyksXG4gICAgZGVjb3JhdGlvbkFuaW1hdGlvbjogc2tpblVybCgnZGVjb3JhdGlvbl9hbmltYXRpb24ucG5nJyksXG4gICAgZGVjb3JhdGlvbkFuaW1hdGlvbl8yeDogc2tpblVybCgnZGVjb3JhdGlvbl9hbmltYXRpb25fMngucG5nJyksXG4gICAgcmVwZWF0SW1hZ2U6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3JlcGVhdC1hcnJvd3MucG5nJyksXG4gICAgbGVmdEFycm93OiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9tb3ZlbGVmdC5wbmcnKSxcbiAgICBkb3duQXJyb3c6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL21vdmVkb3duLnBuZycpLFxuICAgIHVwQXJyb3c6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL21vdmV1cC5wbmcnKSxcbiAgICByaWdodEFycm93OiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9tb3ZlcmlnaHQucG5nJyksXG4gICAgbGVmdEp1bXBBcnJvdzogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvanVtcGxlZnQucG5nJyksXG4gICAgZG93bkp1bXBBcnJvdzogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvanVtcGRvd24ucG5nJyksXG4gICAgdXBKdW1wQXJyb3c6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL2p1bXB1cC5wbmcnKSxcbiAgICByaWdodEp1bXBBcnJvdzogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvanVtcHJpZ2h0LnBuZycpLFxuICAgIG5vcnRoTGluZURyYXc6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL2RyYXctbm9ydGgucG5nJyksXG4gICAgc291dGhMaW5lRHJhdzogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvZHJhdy1zb3V0aC5wbmcnKSxcbiAgICBlYXN0TGluZURyYXc6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL2RyYXctZWFzdC5wbmcnKSxcbiAgICB3ZXN0TGluZURyYXc6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL2RyYXctd2VzdC5wbmcnKSxcbiAgICBzaG9ydExpbmVEcmF3OiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9kcmF3LXNob3J0LnBuZycpLFxuICAgIGxvbmdMaW5lRHJhdzogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvZHJhdy1sb25nLnBuZycpLFxuICAgIHNob3J0TGluZURyYXdSaWdodDogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvZHJhdy1zaG9ydC1yaWdodC5wbmcnKSxcbiAgICBsb25nTGluZURyYXdSaWdodDogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvZHJhdy1sb25nLXJpZ2h0LnBuZycpLFxuICAgIGxvbmdMaW5lOiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9tb3ZlLWxvbmcucG5nJyksXG4gICAgc2hvcnRMaW5lOiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9tb3ZlLXNob3J0LnBuZycpLFxuICAgIHNvdW5kSWNvbjogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvcGxheS1zb3VuZC5wbmcnKSxcbiAgICBjbGlja0ljb246IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3doZW4tY2xpY2staGFuZC5wbmcnKSxcbiAgICBzdGFydEljb246IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3doZW4tcnVuLnBuZycpLFxuICAgIHJ1bkFycm93OiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9ydW4tYXJyb3cucG5nJyksXG4gICAgZW5kSWNvbjogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvZW5kLWljb24ucG5nJyksXG4gICAgc3BlZWRGYXN0OiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9zcGVlZC1mYXN0LnBuZycpLFxuICAgIHNwZWVkTWVkaXVtOiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9zcGVlZC1tZWRpdW0ucG5nJyksXG4gICAgc3BlZWRTbG93OiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9zcGVlZC1zbG93LnBuZycpLFxuICAgIHNjb3JlQ2FyZDogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvaW5jcmVtZW50LXNjb3JlLTc1cGVyY2VudC5wbmcnKSxcbiAgICByYWluYm93TWVudTogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvcmFpbmJvdy1tZW51aWNvbi5wbmcnKSxcbiAgICByb3BlTWVudTogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvcm9wZS1tZW51aWNvbi5wbmcnKSxcbiAgICBzcXVpZ2dseU1lbnU6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3NxdWlnZ2x5LW1lbnVpY29uLnBuZycpLFxuICAgIHN3aXJseU1lbnU6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3N3aXJseWxpbmUtbWVudWljb24ucG5nJyksXG4gICAgcGF0dGVybkRlZmF1bHQ6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL2RlZmF1bHRsaW5lLW1lbnVpY29uLnBuZycpLFxuICAgIHJhaW5ib3dMaW5lOiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9yYWluYm93LnBuZycpLFxuICAgIHJvcGVMaW5lOiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9yb3BlLnBuZycpLFxuICAgIHNxdWlnZ2x5TGluZTogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3F1aWdnbHkucG5nJyksXG4gICAgc3dpcmx5TGluZTogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3dpcmx5bGluZS5wbmcnKSxcbiAgICByYW5kb21QdXJwbGVJY29uOiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9yYW5kb20tcHVycGxlLnBuZycpLFxuXG4gICAgLy8gU291bmRzXG4gICAgc3RhcnRTb3VuZDogW3NraW5VcmwoJ3N0YXJ0Lm1wMycpLCBza2luVXJsKCdzdGFydC5vZ2cnKV0sXG4gICAgd2luU291bmQ6IFtza2luVXJsKCd3aW4ubXAzJyksIHNraW5VcmwoJ3dpbi5vZ2cnKV0sXG4gICAgZmFpbHVyZVNvdW5kOiBbc2tpblVybCgnZmFpbHVyZS5tcDMnKSwgc2tpblVybCgnZmFpbHVyZS5vZ2cnKV0sXG5cbiAgICAvLyBTdGlja2Vyc1xuICAgIHN0aWNrZXJzOiB7XG4gICAgICBlbGVwaGFudDogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3RpY2tlcnMvZWxlcGhhbnQucG5nJyksXG4gICAgICBkcmFnb246IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3N0aWNrZXJzL2RyYWdvbi5wbmcnKSxcbiAgICAgIHRyaWNlcmF0b3BzOiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9zdGlja2Vycy90cmljZXJhdG9wcy5wbmcnKSxcbiAgICAgIG1vbmtleTogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3RpY2tlcnMvbW9ua2V5LnBuZycpLFxuICAgICAgY2F0OiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9zdGlja2Vycy9jYXQucG5nJyksXG4gICAgICB0dXJ0bGU6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3N0aWNrZXJzL3R1cnRsZS5wbmcnKSxcbiAgICAgIGdvYXQ6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3N0aWNrZXJzL2dvYXQucG5nJyksXG4gICAgICB6ZWJyYTogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3RpY2tlcnMvemVicmEucG5nJyksXG4gICAgICBoaXBwbzogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3RpY2tlcnMvaGlwcG8ucG5nJyksXG4gICAgICBidW5ueTogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3RpY2tlcnMvYnVubnkucG5nJyksXG4gICAgICBwZWFjb2NrOiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9zdGlja2Vycy9wZWFjb2NrLnBuZycpLFxuICAgICAgbGxhbWE6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3N0aWNrZXJzL2xsYW1hLnBuZycpLFxuICAgICAgZ2lyYWZmZTogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3RpY2tlcnMvZ2lyYWZmZS5wbmcnKSxcbiAgICAgIG1vdXNlOiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9zdGlja2Vycy9tb3VzZS5wbmcnKSxcbiAgICAgIGJlYXZlcjogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3RpY2tlcnMvYmVhdmVyLnBuZycpLFxuICAgICAgYmF0OiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9zdGlja2Vycy9iYXQucG5nJyksXG4gICAgICBncmFzc2hvcHBlcjogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3RpY2tlcnMvZ3Jhc3Nob3BwZXIucG5nJyksXG4gICAgICBjaGlja2VuOiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9zdGlja2Vycy9jaGlja2VuLnBuZycpLFxuICAgICAgbW9vc2U6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3N0aWNrZXJzL21vb3NlLnBuZycpLFxuICAgICAgb3dsOiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9zdGlja2Vycy9vd2wucG5nJyksXG4gICAgICBwZW5ndWluOiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9zdGlja2Vycy9wZW5ndWluLnBuZycpLFxuICAgICAgbGlvbjogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3RpY2tlcnMvbGlvbi5wbmcnKSxcbiAgICAgIHJvYm90OiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9zdGlja2Vycy9yb2JvdC5wbmcnKSxcbiAgICAgIHJvY2tldDogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3RpY2tlcnMvcm9ja2V0LnBuZycpLFxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2tpbjtcbn07XG4iLCIvKiBnbG9iYWwgRGlhbG9nLCBkYXNoYm9hcmQsIEFwcGxhYiAqL1xuLy8gVE9ETyAoam9zaCkgLSBkb24ndCBwYXNzIGBEaWFsb2dgIGludG8gYGNyZWF0ZU1vZGFsRGlhbG9nYC5cblxudmFyIGFzc2V0TGlzdFN0b3JlID0gcmVxdWlyZSgnLi9hc3NldExpc3RTdG9yZScpO1xudmFyIHNob3dBc3NldE1hbmFnZXIgPSByZXF1aXJlKCcuL3Nob3cnKTtcbnZhciBjb21tb25Nc2cgPSByZXF1aXJlKCcuLi9sb2NhbGUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2Ygb3B0aW9ucyAob3B0aW9uYWxseSBmaWx0ZXJlZCBieSB0eXBlKSBmb3IgY29kZS1tb2RlXG4gKiBhc3NldCBkcm9wZG93bnMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHR5cGVGaWx0ZXIpIHtcbiAgdmFyIG9wdGlvbnMgPSBhc3NldExpc3RTdG9yZS5saXN0KHR5cGVGaWx0ZXIpLm1hcChmdW5jdGlvbiAoYXNzZXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogdXRpbHMucXVvdGUoYXNzZXQuZmlsZW5hbWUpLFxuICAgICAgZGlzcGxheTogdXRpbHMucXVvdGUoYXNzZXQuZmlsZW5hbWUpXG4gICAgfTtcbiAgfSk7XG4gIHZhciBoYW5kbGVDaG9vc2VDbGljayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHNob3dBc3NldE1hbmFnZXIoZnVuY3Rpb24gKGZpbGVuYW1lKSB7XG4gICAgICBjYWxsYmFjayh1dGlscy5xdW90ZShmaWxlbmFtZSkpO1xuICAgIH0sIHR5cGVGaWx0ZXIpO1xuICB9O1xuICBvcHRpb25zLnB1c2goe1xuICAgIHRleHQ6IGNvbW1vbk1zZy5jaG9vc2VQcmVmaXgoKSxcbiAgICBkaXNwbGF5OiAnPHNwYW4gY2xhc3M9XCJjaG9vc2VBc3NldERyb3Bkb3duT3B0aW9uXCI+JyArIGNvbW1vbk1zZy5jaG9vc2VQcmVmaXgoKSArICc8L2E+JyxcbiAgICBjbGljazogaGFuZGxlQ2hvb3NlQ2xpY2tcbiAgfSk7XG4gIHJldHVybiBvcHRpb25zO1xufTtcbiIsInZhciB0aW1lb3V0TGlzdCA9IFtdO1xuXG4vKipcbiAqIGNhbGwgc2V0VGltZW91dCBhbmQgdHJhY2sgdGhlIHJldHVybmVkIGlkXG4gKi9cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uIChmbiwgdGltZSkge1xuICB2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0LmFwcGx5KHdpbmRvdywgYXJndW1lbnRzKTtcbiAgdGltZW91dExpc3QucHVzaCh0aW1lb3V0KTtcbiAgcmV0dXJuIHRpbWVvdXQ7XG59O1xuXG4vKipcbiAqIENsZWFycyBhbGwgdGltZW91dHMgaW4gb3VyIHRpbWVvdXRMaXN0IGFuZCByZXNldHMgdGhlIHRpbWVvdXRMaXN0XG4gKi9cbmV4cG9ydHMuY2xlYXJUaW1lb3V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGltZW91dExpc3QuZm9yRWFjaCh3aW5kb3cuY2xlYXJUaW1lb3V0LCB3aW5kb3cpO1xuICB0aW1lb3V0TGlzdCA9IFtdO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgYSB0aW1lb3V0IGFuZCByZW1vdmVzIHRoZSBpdGVtIGZyb20gdGhlIHRpbWVvdXRMaXN0XG4gKi9cbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKGlkKSB7XG4gIHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpO1xuICAvLyBMaXN0IHJlbW92YWwgcmVxdWlyZXMgSUU5K1xuICB2YXIgaW5kZXggPSB0aW1lb3V0TGlzdC5pbmRleE9mKGlkKTtcbiAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICB0aW1lb3V0TGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59O1xuXG52YXIgaW50ZXJ2YWxMaXN0ID0gW107XG5cbi8qKlxuICogY2FsbCBzZXRJbnRlcnZhbCBhbmQgdHJhY2sgdGhlIHJldHVybmVkIGlkXG4gKi9cbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiAoZm4sIHRpbWUpIHtcbiAgdmFyIGludGVydmFsID0gd2luZG93LnNldEludGVydmFsLmFwcGx5KHdpbmRvdywgYXJndW1lbnRzKTtcbiAgaW50ZXJ2YWxMaXN0LnB1c2goaW50ZXJ2YWwpO1xuICByZXR1cm4gaW50ZXJ2YWw7XG59O1xuXG4vKipcbiAqIENsZWFycyBhbGwgaW50ZXJ2YWwgdGltZW91dHMgaW4gb3VyIGludGVydmFsTGlzdCBhbmQgcmVzZXRzIHRoZSBpbnRlcnZhbExpc3RcbiAqL1xuZXhwb3J0cy5jbGVhckludGVydmFscyA9IGZ1bmN0aW9uICgpIHtcbiAgaW50ZXJ2YWxMaXN0LmZvckVhY2god2luZG93LmNsZWFySW50ZXJ2YWwsIHdpbmRvdyk7XG4gIGludGVydmFsTGlzdCA9IFtdO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgYSB0aW1lb3V0IGFuZCByZW1vdmVzIHRoZSBpdGVtIGZyb20gdGhlIGludGVydmFsTGlzdFxuICovXG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbiAoaWQpIHtcbiAgd2luZG93LmNsZWFySW50ZXJ2YWwoaWQpO1xuICAvLyBMaXN0IHJlbW92YWwgcmVxdWlyZXMgSUU5K1xuICB2YXIgaW5kZXggPSBpbnRlcnZhbExpc3QuaW5kZXhPZihpZCk7XG4gIGlmIChpbmRleCA+IC0xKSB7XG4gICAgaW50ZXJ2YWxMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBMby1EYXNoIDIuNC4yIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIC1vIC4vZGlzdC9sb2Rhc2guanNgXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDEzIFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjUuMiA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTMgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbjsoZnVuY3Rpb24oKSB7XG5cbiAgLyoqIFVzZWQgYXMgYSBzYWZlIHJlZmVyZW5jZSBmb3IgYHVuZGVmaW5lZGAgaW4gcHJlIEVTNSBlbnZpcm9ubWVudHMgKi9cbiAgdmFyIHVuZGVmaW5lZDtcblxuICAvKiogVXNlZCB0byBwb29sIGFycmF5cyBhbmQgb2JqZWN0cyB1c2VkIGludGVybmFsbHkgKi9cbiAgdmFyIGFycmF5UG9vbCA9IFtdLFxuICAgICAgb2JqZWN0UG9vbCA9IFtdO1xuXG4gIC8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMgKi9cbiAgdmFyIGlkQ291bnRlciA9IDA7XG5cbiAgLyoqIFVzZWQgdG8gcHJlZml4IGtleXMgdG8gYXZvaWQgaXNzdWVzIHdpdGggYF9fcHJvdG9fX2AgYW5kIHByb3BlcnRpZXMgb24gYE9iamVjdC5wcm90b3R5cGVgICovXG4gIHZhciBrZXlQcmVmaXggPSArbmV3IERhdGUgKyAnJztcblxuICAvKiogVXNlZCBhcyB0aGUgc2l6ZSB3aGVuIG9wdGltaXphdGlvbnMgYXJlIGVuYWJsZWQgZm9yIGxhcmdlIGFycmF5cyAqL1xuICB2YXIgbGFyZ2VBcnJheVNpemUgPSA3NTtcblxuICAvKiogVXNlZCBhcyB0aGUgbWF4IHNpemUgb2YgdGhlIGBhcnJheVBvb2xgIGFuZCBgb2JqZWN0UG9vbGAgKi9cbiAgdmFyIG1heFBvb2xTaXplID0gNDA7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGFuZCB0ZXN0IHdoaXRlc3BhY2UgKi9cbiAgdmFyIHdoaXRlc3BhY2UgPSAoXG4gICAgLy8gd2hpdGVzcGFjZVxuICAgICcgXFx0XFx4MEJcXGZcXHhBMFxcdWZlZmYnICtcblxuICAgIC8vIGxpbmUgdGVybWluYXRvcnNcbiAgICAnXFxuXFxyXFx1MjAyOFxcdTIwMjknICtcblxuICAgIC8vIHVuaWNvZGUgY2F0ZWdvcnkgXCJac1wiIHNwYWNlIHNlcGFyYXRvcnNcbiAgICAnXFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMCdcbiAgKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlICovXG4gIHZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggRVM2IHRlbXBsYXRlIGRlbGltaXRlcnNcbiAgICogaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtbGl0ZXJhbHMtc3RyaW5nLWxpdGVyYWxzXG4gICAqL1xuICB2YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHJlZ2V4cCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcyAqL1xuICB2YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0ZWQgbmFtZWQgZnVuY3Rpb25zICovXG4gIHZhciByZUZ1bmNOYW1lID0gL15cXHMqZnVuY3Rpb25bIFxcblxcclxcdF0rXFx3LztcblxuICAvKiogVXNlZCB0byBtYXRjaCBcImludGVycG9sYXRlXCIgdGVtcGxhdGUgZGVsaW1pdGVycyAqL1xuICB2YXIgcmVJbnRlcnBvbGF0ZSA9IC88JT0oW1xcc1xcU10rPyklPi9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgd2hpdGVzcGFjZSBhbmQgemVyb3MgdG8gYmUgcmVtb3ZlZCAqL1xuICB2YXIgcmVMZWFkaW5nU3BhY2VzQW5kWmVyb3MgPSBSZWdFeHAoJ15bJyArIHdoaXRlc3BhY2UgKyAnXSowKyg/PS4kKScpO1xuXG4gIC8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycyAqL1xuICB2YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBmdW5jdGlvbnMgY29udGFpbmluZyBhIGB0aGlzYCByZWZlcmVuY2UgKi9cbiAgdmFyIHJlVGhpcyA9IC9cXGJ0aGlzXFxiLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMgKi9cbiAgdmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx0XFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGFzc2lnbiBkZWZhdWx0IGBjb250ZXh0YCBvYmplY3QgcHJvcGVydGllcyAqL1xuICB2YXIgY29udGV4dFByb3BzID0gW1xuICAgICdBcnJheScsICdCb29sZWFuJywgJ0RhdGUnLCAnRnVuY3Rpb24nLCAnTWF0aCcsICdOdW1iZXInLCAnT2JqZWN0JyxcbiAgICAnUmVnRXhwJywgJ1N0cmluZycsICdfJywgJ2F0dGFjaEV2ZW50JywgJ2NsZWFyVGltZW91dCcsICdpc0Zpbml0ZScsICdpc05hTicsXG4gICAgJ3BhcnNlSW50JywgJ3NldFRpbWVvdXQnXG4gIF07XG5cbiAgLyoqIFVzZWQgdG8gbWFrZSB0ZW1wbGF0ZSBzb3VyY2VVUkxzIGVhc2llciB0byBpZGVudGlmeSAqL1xuICB2YXIgdGVtcGxhdGVDb3VudGVyID0gMDtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHNob3J0Y3V0cyAqL1xuICB2YXIgYXJnc0NsYXNzID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgICBhcnJheUNsYXNzID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGJvb2xDbGFzcyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICAgIGRhdGVDbGFzcyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGZ1bmNDbGFzcyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgICBudW1iZXJDbGFzcyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgICAgb2JqZWN0Q2xhc3MgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICAgIHJlZ2V4cENsYXNzID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgICBzdHJpbmdDbGFzcyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IG9iamVjdCBjbGFzc2lmaWNhdGlvbnMgdGhhdCBgXy5jbG9uZWAgc3VwcG9ydHMgKi9cbiAgdmFyIGNsb25lYWJsZUNsYXNzZXMgPSB7fTtcbiAgY2xvbmVhYmxlQ2xhc3Nlc1tmdW5jQ2xhc3NdID0gZmFsc2U7XG4gIGNsb25lYWJsZUNsYXNzZXNbYXJnc0NsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbYXJyYXlDbGFzc10gPVxuICBjbG9uZWFibGVDbGFzc2VzW2Jvb2xDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW2RhdGVDbGFzc10gPVxuICBjbG9uZWFibGVDbGFzc2VzW251bWJlckNsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbb2JqZWN0Q2xhc3NdID1cbiAgY2xvbmVhYmxlQ2xhc3Nlc1tyZWdleHBDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW3N0cmluZ0NsYXNzXSA9IHRydWU7XG5cbiAgLyoqIFVzZWQgYXMgYW4gaW50ZXJuYWwgYF8uZGVib3VuY2VgIG9wdGlvbnMgb2JqZWN0ICovXG4gIHZhciBkZWJvdW5jZU9wdGlvbnMgPSB7XG4gICAgJ2xlYWRpbmcnOiBmYWxzZSxcbiAgICAnbWF4V2FpdCc6IDAsXG4gICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCBhcyB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgYF9fYmluZERhdGFfX2AgKi9cbiAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IGZhbHNlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogbnVsbCxcbiAgICAnd3JpdGFibGUnOiBmYWxzZVxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGRldGVybWluZSBpZiB2YWx1ZXMgYXJlIG9mIHRoZSBsYW5ndWFnZSB0eXBlIE9iamVjdCAqL1xuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgJ2Jvb2xlYW4nOiBmYWxzZSxcbiAgICAnZnVuY3Rpb24nOiB0cnVlLFxuICAgICdvYmplY3QnOiB0cnVlLFxuICAgICdudW1iZXInOiBmYWxzZSxcbiAgICAnc3RyaW5nJzogZmFsc2UsXG4gICAgJ3VuZGVmaW5lZCc6IGZhbHNlXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMgKi9cbiAgdmFyIHN0cmluZ0VzY2FwZXMgPSB7XG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgXCInXCI6IFwiJ1wiLFxuICAgICdcXG4nOiAnbicsXG4gICAgJ1xccic6ICdyJyxcbiAgICAnXFx0JzogJ3QnLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCAqL1xuICB2YXIgcm9vdCA9IChvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cpIHx8IHRoaXM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYCAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYCAqL1xuICB2YXIgZnJlZU1vZHVsZSA9IG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuICAvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgICovXG4gIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzICYmIGZyZWVFeHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUgYW5kIHVzZSBpdCBhcyBgcm9vdGAgKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSBvYmplY3RUeXBlc1t0eXBlb2YgZ2xvYmFsXSAmJiBnbG9iYWw7XG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGJpbmFyeSBzZWFyY2hlc1xuICAgKiBvciBgZnJvbUluZGV4YCBjb25zdHJhaW50cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSBvciBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSAoZnJvbUluZGV4IHx8IDApIC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbnRhaW5zYCBmb3IgY2FjaGUgb2JqZWN0cyB0aGF0IG1pbWljcyB0aGUgcmV0dXJuXG4gICAqIHNpZ25hdHVyZSBvZiBgXy5pbmRleE9mYCBieSByZXR1cm5pbmcgYDBgIGlmIHRoZSB2YWx1ZSBpcyBmb3VuZCwgZWxzZSBgLTFgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGAwYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgY2FjaGUgPSBjYWNoZS5jYWNoZTtcblxuICAgIGlmICh0eXBlID09ICdib29sZWFuJyB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVbdmFsdWVdID8gMCA6IC0xO1xuICAgIH1cbiAgICBpZiAodHlwZSAhPSAnbnVtYmVyJyAmJiB0eXBlICE9ICdzdHJpbmcnKSB7XG4gICAgICB0eXBlID0gJ29iamVjdCc7XG4gICAgfVxuICAgIHZhciBrZXkgPSB0eXBlID09ICdudW1iZXInID8gdmFsdWUgOiBrZXlQcmVmaXggKyB2YWx1ZTtcbiAgICBjYWNoZSA9IChjYWNoZSA9IGNhY2hlW3R5cGVdKSAmJiBjYWNoZVtrZXldO1xuXG4gICAgcmV0dXJuIHR5cGUgPT0gJ29iamVjdCdcbiAgICAgID8gKGNhY2hlICYmIGJhc2VJbmRleE9mKGNhY2hlLCB2YWx1ZSkgPiAtMSA/IDAgOiAtMSlcbiAgICAgIDogKGNhY2hlID8gMCA6IC0xKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgZ2l2ZW4gdmFsdWUgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY2FjaGUgb2JqZWN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhZGQgdG8gdGhlIGNhY2hlLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVQdXNoKHZhbHVlKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZSxcbiAgICAgICAgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICAgIGlmICh0eXBlID09ICdib29sZWFuJyB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBjYWNoZVt2YWx1ZV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSAhPSAnbnVtYmVyJyAmJiB0eXBlICE9ICdzdHJpbmcnKSB7XG4gICAgICAgIHR5cGUgPSAnb2JqZWN0JztcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB0eXBlID09ICdudW1iZXInID8gdmFsdWUgOiBrZXlQcmVmaXggKyB2YWx1ZSxcbiAgICAgICAgICB0eXBlQ2FjaGUgPSBjYWNoZVt0eXBlXSB8fCAoY2FjaGVbdHlwZV0gPSB7fSk7XG5cbiAgICAgIGlmICh0eXBlID09ICdvYmplY3QnKSB7XG4gICAgICAgICh0eXBlQ2FjaGVba2V5XSB8fCAodHlwZUNhY2hlW2tleV0gPSBbXSkpLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZUNhY2hlW2tleV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLm1heGAgYW5kIGBfLm1pbmAgYXMgdGhlIGRlZmF1bHQgY2FsbGJhY2sgd2hlbiBhIGdpdmVuXG4gICAqIGNvbGxlY3Rpb24gaXMgYSBzdHJpbmcgdmFsdWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgY2hhcmFjdGVyIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvZGUgdW5pdCBvZiBnaXZlbiBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyQXRDYWxsYmFjayh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYHNvcnRCeWAgdG8gY29tcGFyZSB0cmFuc2Zvcm1lZCBgY29sbGVjdGlvbmAgZWxlbWVudHMsIHN0YWJsZSBzb3J0aW5nXG4gICAqIHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGNvbXBhcmUgdG8gYGJgLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvbXBhcmUgdG8gYGFgLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBvZiBgMWAgb3IgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcoYSwgYikge1xuICAgIHZhciBhYyA9IGEuY3JpdGVyaWEsXG4gICAgICAgIGJjID0gYi5jcml0ZXJpYSxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYWMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFjW2luZGV4XSxcbiAgICAgICAgICBvdGhlciA9IGJjW2luZGV4XTtcblxuICAgICAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgICAgICBpZiAodmFsdWUgPiBvdGhlciB8fCB0eXBlb2YgdmFsdWUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPCBvdGhlciB8fCB0eXBlb2Ygb3RoZXIgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAgIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHJldHVybiB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgICAvLyBgYWAgYW5kIGBiYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzEyNDdcbiAgICAvL1xuICAgIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gICAgLy8gU2VlIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwXG4gICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjYWNoZSBvYmplY3QgdG8gb3B0aW1pemUgbGluZWFyIHNlYXJjaGVzIG9mIGxhcmdlIGFycmF5cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcmV0dXJucyB7bnVsbHxPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIG9iamVjdCBvciBgbnVsbGAgaWYgY2FjaGluZyBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDYWNoZShhcnJheSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGZpcnN0ID0gYXJyYXlbMF0sXG4gICAgICAgIG1pZCA9IGFycmF5WyhsZW5ndGggLyAyKSB8IDBdLFxuICAgICAgICBsYXN0ID0gYXJyYXlbbGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoZmlyc3QgJiYgdHlwZW9mIGZpcnN0ID09ICdvYmplY3QnICYmXG4gICAgICAgIG1pZCAmJiB0eXBlb2YgbWlkID09ICdvYmplY3QnICYmIGxhc3QgJiYgdHlwZW9mIGxhc3QgPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGNhY2hlID0gZ2V0T2JqZWN0KCk7XG4gICAgY2FjaGVbJ2ZhbHNlJ10gPSBjYWNoZVsnbnVsbCddID0gY2FjaGVbJ3RydWUnXSA9IGNhY2hlWyd1bmRlZmluZWQnXSA9IGZhbHNlO1xuXG4gICAgdmFyIHJlc3VsdCA9IGdldE9iamVjdCgpO1xuICAgIHJlc3VsdC5hcnJheSA9IGFycmF5O1xuICAgIHJlc3VsdC5jYWNoZSA9IGNhY2hlO1xuICAgIHJlc3VsdC5wdXNoID0gY2FjaGVQdXNoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2luZGV4XSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgdGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWRcbiAgICogc3RyaW5nIGxpdGVyYWxzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2ggVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbbWF0Y2hdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gYXJyYXkgZnJvbSB0aGUgYXJyYXkgcG9vbCBvciBjcmVhdGVzIGEgbmV3IG9uZSBpZiB0aGUgcG9vbCBpcyBlbXB0eS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgZnJvbSB0aGUgcG9vbC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEFycmF5KCkge1xuICAgIHJldHVybiBhcnJheVBvb2wucG9wKCkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBvYmplY3QgZnJvbSB0aGUgb2JqZWN0IHBvb2wgb3IgY3JlYXRlcyBhIG5ldyBvbmUgaWYgdGhlIHBvb2wgaXMgZW1wdHkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBvYmplY3QgZnJvbSB0aGUgcG9vbC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldE9iamVjdCgpIHtcbiAgICByZXR1cm4gb2JqZWN0UG9vbC5wb3AoKSB8fCB7XG4gICAgICAnYXJyYXknOiBudWxsLFxuICAgICAgJ2NhY2hlJzogbnVsbCxcbiAgICAgICdjcml0ZXJpYSc6IG51bGwsXG4gICAgICAnZmFsc2UnOiBmYWxzZSxcbiAgICAgICdpbmRleCc6IDAsXG4gICAgICAnbnVsbCc6IGZhbHNlLFxuICAgICAgJ251bWJlcic6IG51bGwsXG4gICAgICAnb2JqZWN0JzogbnVsbCxcbiAgICAgICdwdXNoJzogbnVsbCxcbiAgICAgICdzdHJpbmcnOiBudWxsLFxuICAgICAgJ3RydWUnOiBmYWxzZSxcbiAgICAgICd1bmRlZmluZWQnOiBmYWxzZSxcbiAgICAgICd2YWx1ZSc6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIHRoZSBnaXZlbiBhcnJheSBiYWNrIHRvIHRoZSBhcnJheSBwb29sLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byByZWxlYXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVsZWFzZUFycmF5KGFycmF5KSB7XG4gICAgYXJyYXkubGVuZ3RoID0gMDtcbiAgICBpZiAoYXJyYXlQb29sLmxlbmd0aCA8IG1heFBvb2xTaXplKSB7XG4gICAgICBhcnJheVBvb2wucHVzaChhcnJheSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIHRoZSBnaXZlbiBvYmplY3QgYmFjayB0byB0aGUgb2JqZWN0IHBvb2wuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHJlbGVhc2UuXG4gICAqL1xuICBmdW5jdGlvbiByZWxlYXNlT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBjYWNoZSA9IG9iamVjdC5jYWNoZTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIHJlbGVhc2VPYmplY3QoY2FjaGUpO1xuICAgIH1cbiAgICBvYmplY3QuYXJyYXkgPSBvYmplY3QuY2FjaGUgPSBvYmplY3QuY3JpdGVyaWEgPSBvYmplY3Qub2JqZWN0ID0gb2JqZWN0Lm51bWJlciA9IG9iamVjdC5zdHJpbmcgPSBvYmplY3QudmFsdWUgPSBudWxsO1xuICAgIGlmIChvYmplY3RQb29sLmxlbmd0aCA8IG1heFBvb2xTaXplKSB7XG4gICAgICBvYmplY3RQb29sLnB1c2gob2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2xpY2VzIHRoZSBgY29sbGVjdGlvbmAgZnJvbSB0aGUgYHN0YXJ0YCBpbmRleCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsXG4gICAqIHRoZSBgZW5kYCBpbmRleC5cbiAgICpcbiAgICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGluc3RlYWQgb2YgYEFycmF5I3NsaWNlYCB0byBzdXBwb3J0IG5vZGUgbGlzdHNcbiAgICogaW4gSUUgPCA5IGFuZCB0byBlbnN1cmUgZGVuc2UgYXJyYXlzIGFyZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNsaWNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgaW5kZXguXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gc2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICBzdGFydCB8fCAoc3RhcnQgPSAwKTtcbiAgICBpZiAodHlwZW9mIGVuZCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgZW5kID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gZW5kIC0gc3RhcnQgfHwgMCxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYGxvZGFzaGAgZnVuY3Rpb24gdXNpbmcgdGhlIGdpdmVuIGNvbnRleHQgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PXJvb3RdIFRoZSBjb250ZXh0IG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0KSB7XG4gICAgLy8gQXZvaWQgaXNzdWVzIHdpdGggc29tZSBFUzMgZW52aXJvbm1lbnRzIHRoYXQgYXR0ZW1wdCB0byB1c2UgdmFsdWVzLCBuYW1lZFxuICAgIC8vIGFmdGVyIGJ1aWx0LWluIGNvbnN0cnVjdG9ycyBsaWtlIGBPYmplY3RgLCBmb3IgdGhlIGNyZWF0aW9uIG9mIGxpdGVyYWxzLlxuICAgIC8vIEVTNSBjbGVhcnMgdGhpcyB1cCBieSBzdGF0aW5nIHRoYXQgbGl0ZXJhbHMgbXVzdCB1c2UgYnVpbHQtaW4gY29uc3RydWN0b3JzLlxuICAgIC8vIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDExLjEuNS5cbiAgICBjb250ZXh0ID0gY29udGV4dCA/IF8uZGVmYXVsdHMocm9vdC5PYmplY3QoKSwgY29udGV4dCwgXy5waWNrKHJvb3QsIGNvbnRleHRQcm9wcykpIDogcm9vdDtcblxuICAgIC8qKiBOYXRpdmUgY29uc3RydWN0b3IgcmVmZXJlbmNlcyAqL1xuICAgIHZhciBBcnJheSA9IGNvbnRleHQuQXJyYXksXG4gICAgICAgIEJvb2xlYW4gPSBjb250ZXh0LkJvb2xlYW4sXG4gICAgICAgIERhdGUgPSBjb250ZXh0LkRhdGUsXG4gICAgICAgIEZ1bmN0aW9uID0gY29udGV4dC5GdW5jdGlvbixcbiAgICAgICAgTWF0aCA9IGNvbnRleHQuTWF0aCxcbiAgICAgICAgTnVtYmVyID0gY29udGV4dC5OdW1iZXIsXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHQuT2JqZWN0LFxuICAgICAgICBSZWdFeHAgPSBjb250ZXh0LlJlZ0V4cCxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dC5TdHJpbmcsXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHQuVHlwZUVycm9yO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgYEFycmF5YCBtZXRob2QgcmVmZXJlbmNlcy5cbiAgICAgKlxuICAgICAqIE5vcm1hbGx5IGBBcnJheS5wcm90b3R5cGVgIHdvdWxkIHN1ZmZpY2UsIGhvd2V2ZXIsIHVzaW5nIGFuIGFycmF5IGxpdGVyYWxcbiAgICAgKiBhdm9pZHMgaXNzdWVzIGluIE5hcndoYWwuXG4gICAgICovXG4gICAgdmFyIGFycmF5UmVmID0gW107XG5cbiAgICAvKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzICovXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIGBfYCByZWZlcmVuY2UgaW4gYG5vQ29uZmxpY3RgICovXG4gICAgdmFyIG9sZERhc2ggPSBjb250ZXh0Ll87XG5cbiAgICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBpbnRlcm5hbCBbW0NsYXNzXV0gb2YgdmFsdWVzICovXG4gICAgdmFyIHRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlICovXG4gICAgdmFyIHJlTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgICBTdHJpbmcodG9TdHJpbmcpXG4gICAgICAgIC5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpXG4gICAgICAgIC5yZXBsYWNlKC90b1N0cmluZ3wgZm9yIFteXFxdXSsvZywgJy4qPycpICsgJyQnXG4gICAgKTtcblxuICAgIC8qKiBOYXRpdmUgbWV0aG9kIHNob3J0Y3V0cyAqL1xuICAgIHZhciBjZWlsID0gTWF0aC5jZWlsLFxuICAgICAgICBjbGVhclRpbWVvdXQgPSBjb250ZXh0LmNsZWFyVGltZW91dCxcbiAgICAgICAgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICBmblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgICBnZXRQcm90b3R5cGVPZiA9IGlzTmF0aXZlKGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKSAmJiBnZXRQcm90b3R5cGVPZixcbiAgICAgICAgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgcHVzaCA9IGFycmF5UmVmLnB1c2gsXG4gICAgICAgIHNldFRpbWVvdXQgPSBjb250ZXh0LnNldFRpbWVvdXQsXG4gICAgICAgIHNwbGljZSA9IGFycmF5UmVmLnNwbGljZSxcbiAgICAgICAgdW5zaGlmdCA9IGFycmF5UmVmLnVuc2hpZnQ7XG5cbiAgICAvKiogVXNlZCB0byBzZXQgbWV0YSBkYXRhIG9uIGZ1bmN0aW9ucyAqL1xuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgICAgIC8vIElFIDggb25seSBhY2NlcHRzIERPTSBlbGVtZW50c1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG8gPSB7fSxcbiAgICAgICAgICAgIGZ1bmMgPSBpc05hdGl2ZShmdW5jID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KSAmJiBmdW5jLFxuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYyhvLCBvLCBvKSAmJiBmdW5jO1xuICAgICAgfSBjYXRjaChlKSB7IH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSgpKTtcblxuICAgIC8qIE5hdGl2ZSBtZXRob2Qgc2hvcnRjdXRzIGZvciBtZXRob2RzIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzICovXG4gICAgdmFyIG5hdGl2ZUNyZWF0ZSA9IGlzTmF0aXZlKG5hdGl2ZUNyZWF0ZSA9IE9iamVjdC5jcmVhdGUpICYmIG5hdGl2ZUNyZWF0ZSxcbiAgICAgICAgbmF0aXZlSXNBcnJheSA9IGlzTmF0aXZlKG5hdGl2ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KSAmJiBuYXRpdmVJc0FycmF5LFxuICAgICAgICBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsXG4gICAgICAgIG5hdGl2ZUlzTmFOID0gY29udGV4dC5pc05hTixcbiAgICAgICAgbmF0aXZlS2V5cyA9IGlzTmF0aXZlKG5hdGl2ZUtleXMgPSBPYmplY3Qua2V5cykgJiYgbmF0aXZlS2V5cyxcbiAgICAgICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluLFxuICAgICAgICBuYXRpdmVQYXJzZUludCA9IGNvbnRleHQucGFyc2VJbnQsXG4gICAgICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4gICAgLyoqIFVzZWQgdG8gbG9va3VwIGEgYnVpbHQtaW4gY29uc3RydWN0b3IgYnkgW1tDbGFzc11dICovXG4gICAgdmFyIGN0b3JCeUNsYXNzID0ge307XG4gICAgY3RvckJ5Q2xhc3NbYXJyYXlDbGFzc10gPSBBcnJheTtcbiAgICBjdG9yQnlDbGFzc1tib29sQ2xhc3NdID0gQm9vbGVhbjtcbiAgICBjdG9yQnlDbGFzc1tkYXRlQ2xhc3NdID0gRGF0ZTtcbiAgICBjdG9yQnlDbGFzc1tmdW5jQ2xhc3NdID0gRnVuY3Rpb247XG4gICAgY3RvckJ5Q2xhc3Nbb2JqZWN0Q2xhc3NdID0gT2JqZWN0O1xuICAgIGN0b3JCeUNsYXNzW251bWJlckNsYXNzXSA9IE51bWJlcjtcbiAgICBjdG9yQnlDbGFzc1tyZWdleHBDbGFzc10gPSBSZWdFeHA7XG4gICAgY3RvckJ5Q2xhc3Nbc3RyaW5nQ2xhc3NdID0gU3RyaW5nO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIHRoZSBnaXZlbiB2YWx1ZSB0byBlbmFibGUgaW50dWl0aXZlXG4gICAgICogbWV0aG9kIGNoYWluaW5nLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24gdG8gTG8tRGFzaCBtZXRob2RzLCB3cmFwcGVycyBhbHNvIGhhdmUgdGhlIGZvbGxvd2luZyBgQXJyYXlgIG1ldGhvZHM6XG4gICAgICogYGNvbmNhdGAsIGBqb2luYCwgYHBvcGAsIGBwdXNoYCwgYHJldmVyc2VgLCBgc2hpZnRgLCBgc2xpY2VgLCBgc29ydGAsIGBzcGxpY2VgLFxuICAgICAqIGFuZCBgdW5zaGlmdGBcbiAgICAgKlxuICAgICAqIENoYWluaW5nIGlzIHN1cHBvcnRlZCBpbiBjdXN0b20gYnVpbGRzIGFzIGxvbmcgYXMgdGhlIGB2YWx1ZWAgbWV0aG9kIGlzXG4gICAgICogaW1wbGljaXRseSBvciBleHBsaWNpdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAgICAgKlxuICAgICAqIFRoZSBjaGFpbmFibGUgd3JhcHBlciBmdW5jdGlvbnMgYXJlOlxuICAgICAqIGBhZnRlcmAsIGBhc3NpZ25gLCBgYmluZGAsIGBiaW5kQWxsYCwgYGJpbmRLZXlgLCBgY2hhaW5gLCBgY29tcGFjdGAsXG4gICAgICogYGNvbXBvc2VgLCBgY29uY2F0YCwgYGNvdW50QnlgLCBgY3JlYXRlYCwgYGNyZWF0ZUNhbGxiYWNrYCwgYGN1cnJ5YCxcbiAgICAgKiBgZGVib3VuY2VgLCBgZGVmYXVsdHNgLCBgZGVmZXJgLCBgZGVsYXlgLCBgZGlmZmVyZW5jZWAsIGBmaWx0ZXJgLCBgZmxhdHRlbmAsXG4gICAgICogYGZvckVhY2hgLCBgZm9yRWFjaFJpZ2h0YCwgYGZvckluYCwgYGZvckluUmlnaHRgLCBgZm9yT3duYCwgYGZvck93blJpZ2h0YCxcbiAgICAgKiBgZnVuY3Rpb25zYCwgYGdyb3VwQnlgLCBgaW5kZXhCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnZlcnRgLFxuICAgICAqIGBpbnZva2VgLCBga2V5c2AsIGBtYXBgLCBgbWF4YCwgYG1lbW9pemVgLCBgbWVyZ2VgLCBgbWluYCwgYG9iamVjdGAsIGBvbWl0YCxcbiAgICAgKiBgb25jZWAsIGBwYWlyc2AsIGBwYXJ0aWFsYCwgYHBhcnRpYWxSaWdodGAsIGBwaWNrYCwgYHBsdWNrYCwgYHB1bGxgLCBgcHVzaGAsXG4gICAgICogYHJhbmdlYCwgYHJlamVjdGAsIGByZW1vdmVgLCBgcmVzdGAsIGByZXZlcnNlYCwgYHNodWZmbGVgLCBgc2xpY2VgLCBgc29ydGAsXG4gICAgICogYHNvcnRCeWAsIGBzcGxpY2VgLCBgdGFwYCwgYHRocm90dGxlYCwgYHRpbWVzYCwgYHRvQXJyYXlgLCBgdHJhbnNmb3JtYCxcbiAgICAgKiBgdW5pb25gLCBgdW5pcWAsIGB1bnNoaWZ0YCwgYHVuemlwYCwgYHZhbHVlc2AsIGB3aGVyZWAsIGB3aXRob3V0YCwgYHdyYXBgLFxuICAgICAqIGFuZCBgemlwYFxuICAgICAqXG4gICAgICogVGhlIG5vbi1jaGFpbmFibGUgd3JhcHBlciBmdW5jdGlvbnMgYXJlOlxuICAgICAqIGBjbG9uZWAsIGBjbG9uZURlZXBgLCBgY29udGFpbnNgLCBgZXNjYXBlYCwgYGV2ZXJ5YCwgYGZpbmRgLCBgZmluZEluZGV4YCxcbiAgICAgKiBgZmluZEtleWAsIGBmaW5kTGFzdGAsIGBmaW5kTGFzdEluZGV4YCwgYGZpbmRMYXN0S2V5YCwgYGhhc2AsIGBpZGVudGl0eWAsXG4gICAgICogYGluZGV4T2ZgLCBgaXNBcmd1bWVudHNgLCBgaXNBcnJheWAsIGBpc0Jvb2xlYW5gLCBgaXNEYXRlYCwgYGlzRWxlbWVudGAsXG4gICAgICogYGlzRW1wdHlgLCBgaXNFcXVhbGAsIGBpc0Zpbml0ZWAsIGBpc0Z1bmN0aW9uYCwgYGlzTmFOYCwgYGlzTnVsbGAsIGBpc051bWJlcmAsXG4gICAgICogYGlzT2JqZWN0YCwgYGlzUGxhaW5PYmplY3RgLCBgaXNSZWdFeHBgLCBgaXNTdHJpbmdgLCBgaXNVbmRlZmluZWRgLCBgam9pbmAsXG4gICAgICogYGxhc3RJbmRleE9mYCwgYG1peGluYCwgYG5vQ29uZmxpY3RgLCBgcGFyc2VJbnRgLCBgcG9wYCwgYHJhbmRvbWAsIGByZWR1Y2VgLFxuICAgICAqIGByZWR1Y2VSaWdodGAsIGByZXN1bHRgLCBgc2hpZnRgLCBgc2l6ZWAsIGBzb21lYCwgYHNvcnRlZEluZGV4YCwgYHJ1bkluQ29udGV4dGAsXG4gICAgICogYHRlbXBsYXRlYCwgYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYW5kIGB2YWx1ZWBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGZ1bmN0aW9ucyBgZmlyc3RgIGFuZCBgbGFzdGAgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIHdoZW4gYG5gIGlzXG4gICAgICogcHJvdmlkZWQsIG90aGVyd2lzZSB0aGV5IHJldHVybiB1bndyYXBwZWQgdmFsdWVzLlxuICAgICAqXG4gICAgICogRXhwbGljaXQgY2hhaW5pbmcgY2FuIGJlIGVuYWJsZWQgYnkgdXNpbmcgdGhlIGBfLmNoYWluYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAbmFtZSBfXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyLCAzXSk7XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm5zIGFuIHVud3JhcHBlZCB2YWx1ZVxuICAgICAqIHdyYXBwZWQucmVkdWNlKGZ1bmN0aW9uKHN1bSwgbnVtKSB7XG4gICAgICogICByZXR1cm4gc3VtICsgbnVtO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIC8vIHJldHVybnMgYSB3cmFwcGVkIHZhbHVlXG4gICAgICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gKiBudW07XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzLnZhbHVlKCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2Rhc2godmFsdWUpIHtcbiAgICAgIC8vIGRvbid0IHdyYXAgaWYgYWxyZWFkeSB3cmFwcGVkLCBldmVuIGlmIHdyYXBwZWQgYnkgYSBkaWZmZXJlbnQgYGxvZGFzaGAgY29uc3RydWN0b3JcbiAgICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmICFpc0FycmF5KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnX193cmFwcGVkX18nKSlcbiAgICAgICA/IHZhbHVlXG4gICAgICAgOiBuZXcgbG9kYXNoV3JhcHBlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBmYXN0IHBhdGggZm9yIGNyZWF0aW5nIGBsb2Rhc2hgIHdyYXBwZXIgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hhaW5BbGwgQSBmbGFnIHRvIGVuYWJsZSBjaGFpbmluZyBmb3IgYWxsIG1ldGhvZHNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9kYXNoV3JhcHBlcih2YWx1ZSwgY2hhaW5BbGwpIHtcbiAgICAgIHRoaXMuX19jaGFpbl9fID0gISFjaGFpbkFsbDtcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICB9XG4gICAgLy8gZW5zdXJlIGBuZXcgbG9kYXNoV3JhcHBlcmAgaXMgYW4gaW5zdGFuY2Ugb2YgYGxvZGFzaGBcbiAgICBsb2Rhc2hXcmFwcGVyLnByb3RvdHlwZSA9IGxvZGFzaC5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgdXNlZCB0byBmbGFnIGVudmlyb25tZW50cyBmZWF0dXJlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIHZhciBzdXBwb3J0ID0gbG9kYXNoLnN1cHBvcnQgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiBmdW5jdGlvbnMgY2FuIGJlIGRlY29tcGlsZWQgYnkgYEZ1bmN0aW9uI3RvU3RyaW5nYFxuICAgICAqIChhbGwgYnV0IFBTMyBhbmQgb2xkZXIgT3BlcmEgbW9iaWxlIGJyb3dzZXJzICYgYXZvaWRlZCBpbiBXaW5kb3dzIDggYXBwcykuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgIHN1cHBvcnQuZnVuY0RlY29tcCA9ICFpc05hdGl2ZShjb250ZXh0LldpblJURXJyb3IpICYmIHJlVGhpcy50ZXN0KHJ1bkluQ29udGV4dCk7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgYEZ1bmN0aW9uI25hbWVgIGlzIHN1cHBvcnRlZCAoYWxsIGJ1dCBJRSkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgIHN1cHBvcnQuZnVuY05hbWVzID0gdHlwZW9mIEZ1bmN0aW9uLm5hbWUgPT0gJ3N0cmluZyc7XG5cbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IExvLURhc2ggYXJlIHNpbWlsYXIgdG8gdGhvc2UgaW5cbiAgICAgKiBlbWJlZGRlZCBSdWJ5IChFUkIpLiBDaGFuZ2UgdGhlIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmVcbiAgICAgKiBkZWxpbWl0ZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBiZSBIVE1MLWVzY2FwZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdlc2NhcGUnOiAvPCUtKFtcXHNcXFNdKz8pJT4vZyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBSZWdFeHBcbiAgICAgICAqL1xuICAgICAgJ2V2YWx1YXRlJzogLzwlKFtcXHNcXFNdKz8pJT4vZyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBSZWdFeHBcbiAgICAgICAqL1xuICAgICAgJ2ludGVycG9sYXRlJzogcmVJbnRlcnBvbGF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIHJlZmVyZW5jZSB0aGUgZGF0YSBvYmplY3QgaW4gdGhlIHRlbXBsYXRlIHRleHQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgc3RyaW5nXG4gICAgICAgKi9cbiAgICAgICd2YXJpYWJsZSc6ICcnLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gaW1wb3J0IHZhcmlhYmxlcyBpbnRvIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgICAqL1xuICAgICAgJ2ltcG9ydHMnOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICAnXyc6IGxvZGFzaFxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmJpbmRgIHRoYXQgY3JlYXRlcyB0aGUgYm91bmQgZnVuY3Rpb24gYW5kXG4gICAgICogc2V0cyBpdHMgbWV0YSBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBiaW5kRGF0YSBUaGUgYmluZCBkYXRhIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VCaW5kKGJpbmREYXRhKSB7XG4gICAgICB2YXIgZnVuYyA9IGJpbmREYXRhWzBdLFxuICAgICAgICAgIHBhcnRpYWxBcmdzID0gYmluZERhdGFbMl0sXG4gICAgICAgICAgdGhpc0FyZyA9IGJpbmREYXRhWzRdO1xuXG4gICAgICBmdW5jdGlvbiBib3VuZCgpIHtcbiAgICAgICAgLy8gYEZ1bmN0aW9uI2JpbmRgIHNwZWNcbiAgICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4zLjQuNVxuICAgICAgICBpZiAocGFydGlhbEFyZ3MpIHtcbiAgICAgICAgICAvLyBhdm9pZCBgYXJndW1lbnRzYCBvYmplY3QgZGVvcHRpbWl6YXRpb25zIGJ5IHVzaW5nIGBzbGljZWAgaW5zdGVhZFxuICAgICAgICAgIC8vIG9mIGBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbGAgYW5kIG5vdCBhc3NpZ25pbmcgYGFyZ3VtZW50c2AgdG8gYVxuICAgICAgICAgIC8vIHZhcmlhYmxlIGFzIGEgdGVybmFyeSBleHByZXNzaW9uXG4gICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShwYXJ0aWFsQXJncyk7XG4gICAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yXG4gICAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yXG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAvLyBlbnN1cmUgYG5ldyBib3VuZGAgaXMgYW4gaW5zdGFuY2Ugb2YgYGZ1bmNgXG4gICAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShmdW5jLnByb3RvdHlwZSksXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MgfHwgYXJndW1lbnRzKTtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MgfHwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHNldEJpbmREYXRhKGJvdW5kLCBiaW5kRGF0YSk7XG4gICAgICByZXR1cm4gYm91bmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIHdpdGhvdXQgYXJndW1lbnQganVnZ2xpbmcgb3Igc3VwcG9ydFxuICAgICAqIGZvciBgdGhpc0FyZ2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwPWZhbHNlXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBBc3NvY2lhdGVzIGNsb25lcyB3aXRoIHNvdXJjZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBpbnNwZWN0IFtbQ2xhc3NdXVxuICAgICAgdmFyIGlzT2JqID0gaXNPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKGlzT2JqKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgICAgaWYgKCFjbG9uZWFibGVDbGFzc2VzW2NsYXNzTmFtZV0pIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN0b3IgPSBjdG9yQnlDbGFzc1tjbGFzc05hbWVdO1xuICAgICAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgICAgIGNhc2UgYm9vbENsYXNzOlxuICAgICAgICAgIGNhc2UgZGF0ZUNsYXNzOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjdG9yKCt2YWx1ZSk7XG5cbiAgICAgICAgICBjYXNlIG51bWJlckNsYXNzOlxuICAgICAgICAgIGNhc2Ugc3RyaW5nQ2xhc3M6XG4gICAgICAgICAgICByZXR1cm4gbmV3IGN0b3IodmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSByZWdleHBDbGFzczpcbiAgICAgICAgICAgIHJlc3VsdCA9IGN0b3IodmFsdWUuc291cmNlLCByZUZsYWdzLmV4ZWModmFsdWUpKTtcbiAgICAgICAgICAgIHJlc3VsdC5sYXN0SW5kZXggPSB2YWx1ZS5sYXN0SW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBjb3JyZXNwb25kaW5nIGNsb25lXG4gICAgICAgIHZhciBpbml0ZWRTdGFjayA9ICFzdGFja0E7XG4gICAgICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gZ2V0QXJyYXkoKSk7XG4gICAgICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gZ2V0QXJyYXkoKSk7XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBpc0FyciA/IGN0b3IodmFsdWUubGVuZ3RoKSA6IHt9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGlzQXJyID8gc2xpY2UodmFsdWUpIDogYXNzaWduKHt9LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBhZGQgYXJyYXkgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgXG4gICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdpbmRleCcpKSB7XG4gICAgICAgICAgcmVzdWx0LmluZGV4ID0gdmFsdWUuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdpbnB1dCcpKSB7XG4gICAgICAgICAgcmVzdWx0LmlucHV0ID0gdmFsdWUuaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZm9yIHNoYWxsb3cgY2xvbmVcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICAvLyBhZGQgdGhlIHNvdXJjZSB2YWx1ZSB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgIC8vIGFuZCBhc3NvY2lhdGUgaXQgd2l0aCBpdHMgY2xvbmVcbiAgICAgIHN0YWNrQS5wdXNoKHZhbHVlKTtcbiAgICAgIHN0YWNrQi5wdXNoKHJlc3VsdCk7XG5cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICAgIChpc0FyciA/IGZvckVhY2ggOiBmb3JPd24pKHZhbHVlLCBmdW5jdGlvbihvYmpWYWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gYmFzZUNsb25lKG9ialZhbHVlLCBpc0RlZXAsIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGluaXRlZFN0YWNrKSB7XG4gICAgICAgIHJlbGVhc2VBcnJheShzdGFja0EpO1xuICAgICAgICByZWxlYXNlQXJyYXkoc3RhY2tCKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICAgICAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiBpc09iamVjdChwcm90b3R5cGUpID8gbmF0aXZlQ3JlYXRlKHByb3RvdHlwZSkgOiB7fTtcbiAgICB9XG4gICAgLy8gZmFsbGJhY2sgZm9yIGJyb3dzZXJzIHdpdGhvdXQgYE9iamVjdC5jcmVhdGVgXG4gICAgaWYgKCFuYXRpdmVDcmVhdGUpIHtcbiAgICAgIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIE9iamVjdCgpIHt9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICAgICAgICBpZiAoaXNPYmplY3QocHJvdG90eXBlKSkge1xuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgT2JqZWN0O1xuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQgfHwgY29udGV4dC5PYmplY3QoKTtcbiAgICAgICAgfTtcbiAgICAgIH0oKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlQ2FsbGJhY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY3JlYXRpbmdcbiAgICAgKiBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW2Z1bmM9aWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJnQ291bnRdIFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRoZSBjYWxsYmFjayBhY2NlcHRzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDcmVhdGVDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgLy8gZXhpdCBlYXJseSBmb3Igbm8gYHRoaXNBcmdgIG9yIGFscmVhZHkgYm91bmQgYnkgYEZ1bmN0aW9uI2JpbmRgXG4gICAgICBpZiAodHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgfHwgISgncHJvdG90eXBlJyBpbiBmdW5jKSkge1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH1cbiAgICAgIHZhciBiaW5kRGF0YSA9IGZ1bmMuX19iaW5kRGF0YV9fO1xuICAgICAgaWYgKHR5cGVvZiBiaW5kRGF0YSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoc3VwcG9ydC5mdW5jTmFtZXMpIHtcbiAgICAgICAgICBiaW5kRGF0YSA9ICFmdW5jLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgYmluZERhdGEgPSBiaW5kRGF0YSB8fCAhc3VwcG9ydC5mdW5jRGVjb21wO1xuICAgICAgICBpZiAoIWJpbmREYXRhKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IGZuVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICAgICAgICBpZiAoIXN1cHBvcnQuZnVuY05hbWVzKSB7XG4gICAgICAgICAgICBiaW5kRGF0YSA9ICFyZUZ1bmNOYW1lLnRlc3Qoc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFiaW5kRGF0YSkge1xuICAgICAgICAgICAgLy8gY2hlY2tzIGlmIGBmdW5jYCByZWZlcmVuY2VzIHRoZSBgdGhpc2Aga2V5d29yZCBhbmQgc3RvcmVzIHRoZSByZXN1bHRcbiAgICAgICAgICAgIGJpbmREYXRhID0gcmVUaGlzLnRlc3Qoc291cmNlKTtcbiAgICAgICAgICAgIHNldEJpbmREYXRhKGZ1bmMsIGJpbmREYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgaWYgdGhlcmUgYXJlIG5vIGB0aGlzYCByZWZlcmVuY2VzIG9yIGBmdW5jYCBpcyBib3VuZFxuICAgICAgaWYgKGJpbmREYXRhID09PSBmYWxzZSB8fCAoYmluZERhdGEgIT09IHRydWUgJiYgYmluZERhdGFbMV0gJiAxKSkge1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoYXJnQ291bnQpIHtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYSwgYik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gYmluZChmdW5jLCB0aGlzQXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgY3JlYXRlV3JhcHBlcmAgdGhhdCBjcmVhdGVzIHRoZSB3cmFwcGVyIGFuZFxuICAgICAqIHNldHMgaXRzIG1ldGEgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYmluZERhdGEgVGhlIGJpbmQgZGF0YSBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ3JlYXRlV3JhcHBlcihiaW5kRGF0YSkge1xuICAgICAgdmFyIGZ1bmMgPSBiaW5kRGF0YVswXSxcbiAgICAgICAgICBiaXRtYXNrID0gYmluZERhdGFbMV0sXG4gICAgICAgICAgcGFydGlhbEFyZ3MgPSBiaW5kRGF0YVsyXSxcbiAgICAgICAgICBwYXJ0aWFsUmlnaHRBcmdzID0gYmluZERhdGFbM10sXG4gICAgICAgICAgdGhpc0FyZyA9IGJpbmREYXRhWzRdLFxuICAgICAgICAgIGFyaXR5ID0gYmluZERhdGFbNV07XG5cbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgMSxcbiAgICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgMixcbiAgICAgICAgICBpc0N1cnJ5ID0gYml0bWFzayAmIDQsXG4gICAgICAgICAgaXNDdXJyeUJvdW5kID0gYml0bWFzayAmIDgsXG4gICAgICAgICAga2V5ID0gZnVuYztcblxuICAgICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzO1xuICAgICAgICBpZiAocGFydGlhbEFyZ3MpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IHNsaWNlKHBhcnRpYWxBcmdzKTtcbiAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxSaWdodEFyZ3MgfHwgaXNDdXJyeSkge1xuICAgICAgICAgIGFyZ3MgfHwgKGFyZ3MgPSBzbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgICBpZiAocGFydGlhbFJpZ2h0QXJncykge1xuICAgICAgICAgICAgcHVzaC5hcHBseShhcmdzLCBwYXJ0aWFsUmlnaHRBcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQ3VycnkgJiYgYXJncy5sZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgICAgYml0bWFzayB8PSAxNiAmIH4zMjtcbiAgICAgICAgICAgIHJldHVybiBiYXNlQ3JlYXRlV3JhcHBlcihbZnVuYywgKGlzQ3VycnlCb3VuZCA/IGJpdG1hc2sgOiBiaXRtYXNrICYgfjMpLCBhcmdzLCBudWxsLCB0aGlzQXJnLCBhcml0eV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhcmdzIHx8IChhcmdzID0gYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKGlzQmluZEtleSkge1xuICAgICAgICAgIGZ1bmMgPSB0aGlzQmluZGluZ1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoZnVuYy5wcm90b3R5cGUpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHNldEJpbmREYXRhKGJvdW5kLCBiaW5kRGF0YSk7XG4gICAgICByZXR1cm4gYm91bmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGlmZmVyZW5jZWAgdGhhdCBhY2NlcHRzIGEgc2luZ2xlIGFycmF5XG4gICAgICogb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSBhcnJheSBvZiB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIGlzTGFyZ2UgPSBsZW5ndGggPj0gbGFyZ2VBcnJheVNpemUgJiYgaW5kZXhPZiA9PT0gYmFzZUluZGV4T2YsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IGNyZWF0ZUNhY2hlKHZhbHVlcyk7XG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgIGluZGV4T2YgPSBjYWNoZUluZGV4T2Y7XG4gICAgICAgICAgdmFsdWVzID0gY2FjaGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNMYXJnZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChpbmRleE9mKHZhbHVlcywgdmFsdWUpIDwgMCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgcmVsZWFzZU9iamVjdCh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBvciBgdGhpc0FyZ2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTaGFsbG93PWZhbHNlXSBBIGZsYWcgdG8gcmVzdHJpY3QgZmxhdHRlbmluZyB0byBhIHNpbmdsZSBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdD1mYWxzZV0gQSBmbGFnIHRvIHJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYXJyYXlzIGFuZCBgYXJndW1lbnRzYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzdGFydCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGlzU2hhbGxvdywgaXNTdHJpY3QsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGluZGV4ID0gKGZyb21JbmRleCB8fCAwKSAtIDEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09ICdudW1iZXInXG4gICAgICAgICAgICAmJiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlRmxhdHRlbih2YWx1ZSwgaXNTaGFsbG93LCBpc1N0cmljdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB2YWxJbmRleCA9IC0xLFxuICAgICAgICAgICAgICB2YWxMZW5ndGggPSB2YWx1ZS5sZW5ndGgsXG4gICAgICAgICAgICAgIHJlc0luZGV4ID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgICAgIHJlc3VsdC5sZW5ndGggKz0gdmFsTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgrK3ZhbEluZGV4IDwgdmFsTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZVt2YWxJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCwgd2l0aG91dCBzdXBwb3J0IGZvciBgdGhpc0FyZ2AgYmluZGluZyxcbiAgICAgKiB0aGF0IGFsbG93cyBwYXJ0aWFsIFwiXy53aGVyZVwiIHN0eWxlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IGEgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBiIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpc1doZXJlPWZhbHNlXSBBIGZsYWcgdG8gaW5kaWNhdGUgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYGFgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gVHJhY2tzIHRyYXZlcnNlZCBgYmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKGEsIGIsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgLy8gdXNlZCB0byBpbmRpY2F0ZSB0aGF0IHdoZW4gY29tcGFyaW5nIG9iamVjdHMsIGBhYCBoYXMgYXQgbGVhc3QgdGhlIHByb3BlcnRpZXMgb2YgYGJgXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrKGEsIGIpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZXhpdCBlYXJseSBmb3IgaWRlbnRpY2FsIHZhbHVlc1xuICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgLy8gdHJlYXQgYCswYCB2cy4gYC0wYCBhcyBub3QgZXF1YWxcbiAgICAgICAgcmV0dXJuIGEgIT09IDAgfHwgKDEgLyBhID09IDEgLyBiKTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGEsXG4gICAgICAgICAgb3RoZXJUeXBlID0gdHlwZW9mIGI7XG5cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIHVubGlrZSBwcmltaXRpdmUgdmFsdWVzXG4gICAgICBpZiAoYSA9PT0gYSAmJlxuICAgICAgICAgICEoYSAmJiBvYmplY3RUeXBlc1t0eXBlXSkgJiZcbiAgICAgICAgICAhKGIgJiYgb2JqZWN0VHlwZXNbb3RoZXJUeXBlXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gZXhpdCBlYXJseSBmb3IgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhdm9pZGluZyBFUzMncyBGdW5jdGlvbiNjYWxsIGJlaGF2aW9yXG4gICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjMuNC40XG4gICAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAgIH1cbiAgICAgIC8vIGNvbXBhcmUgW1tDbGFzc11dIG5hbWVzXG4gICAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKSxcbiAgICAgICAgICBvdGhlckNsYXNzID0gdG9TdHJpbmcuY2FsbChiKTtcblxuICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcmdzQ2xhc3MpIHtcbiAgICAgICAgY2xhc3NOYW1lID0gb2JqZWN0Q2xhc3M7XG4gICAgICB9XG4gICAgICBpZiAob3RoZXJDbGFzcyA9PSBhcmdzQ2xhc3MpIHtcbiAgICAgICAgb3RoZXJDbGFzcyA9IG9iamVjdENsYXNzO1xuICAgICAgfVxuICAgICAgaWYgKGNsYXNzTmFtZSAhPSBvdGhlckNsYXNzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGNhc2UgYm9vbENsYXNzOlxuICAgICAgICBjYXNlIGRhdGVDbGFzczpcbiAgICAgICAgICAvLyBjb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWJlcnMsIGRhdGVzIHRvIG1pbGxpc2Vjb25kcyBhbmQgYm9vbGVhbnNcbiAgICAgICAgICAvLyB0byBgMWAgb3IgYDBgIHRyZWF0aW5nIGludmFsaWQgZGF0ZXMgY29lcmNlZCB0byBgTmFOYCBhcyBub3QgZXF1YWxcbiAgICAgICAgICByZXR1cm4gK2EgPT0gK2I7XG5cbiAgICAgICAgY2FzZSBudW1iZXJDbGFzczpcbiAgICAgICAgICAvLyB0cmVhdCBgTmFOYCB2cy4gYE5hTmAgYXMgZXF1YWxcbiAgICAgICAgICByZXR1cm4gKGEgIT0gK2EpXG4gICAgICAgICAgICA/IGIgIT0gK2JcbiAgICAgICAgICAgIC8vIGJ1dCB0cmVhdCBgKzBgIHZzLiBgLTBgIGFzIG5vdCBlcXVhbFxuICAgICAgICAgICAgOiAoYSA9PSAwID8gKDEgLyBhID09IDEgLyBiKSA6IGEgPT0gK2IpO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwQ2xhc3M6XG4gICAgICAgIGNhc2Ugc3RyaW5nQ2xhc3M6XG4gICAgICAgICAgLy8gY29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyAoaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4xMC42LjQpXG4gICAgICAgICAgLy8gdHJlYXQgc3RyaW5nIHByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IGluc3RhbmNlcyBhcyBlcXVhbFxuICAgICAgICAgIHJldHVybiBhID09IFN0cmluZyhiKTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0FyciA9IGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzO1xuICAgICAgaWYgKCFpc0Fycikge1xuICAgICAgICAvLyB1bndyYXAgYW55IGBsb2Rhc2hgIHdyYXBwZWQgdmFsdWVzXG4gICAgICAgIHZhciBhV3JhcHBlZCA9IGhhc093blByb3BlcnR5LmNhbGwoYSwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgICAgICBiV3JhcHBlZCA9IGhhc093blByb3BlcnR5LmNhbGwoYiwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICAgICAgaWYgKGFXcmFwcGVkIHx8IGJXcmFwcGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsKGFXcmFwcGVkID8gYS5fX3dyYXBwZWRfXyA6IGEsIGJXcmFwcGVkID8gYi5fX3dyYXBwZWRfXyA6IGIsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXhpdCBmb3IgZnVuY3Rpb25zIGFuZCBET00gbm9kZXNcbiAgICAgICAgaWYgKGNsYXNzTmFtZSAhPSBvYmplY3RDbGFzcykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBPcGVyYSwgYGFyZ3VtZW50c2Agb2JqZWN0cyBoYXZlIGBBcnJheWAgY29uc3RydWN0b3JzXG4gICAgICAgIHZhciBjdG9yQSA9IGEuY29uc3RydWN0b3IsXG4gICAgICAgICAgICBjdG9yQiA9IGIuY29uc3RydWN0b3I7XG5cbiAgICAgICAgLy8gbm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWxcbiAgICAgICAgaWYgKGN0b3JBICE9IGN0b3JCICYmXG4gICAgICAgICAgICAgICEoaXNGdW5jdGlvbihjdG9yQSkgJiYgY3RvckEgaW5zdGFuY2VvZiBjdG9yQSAmJiBpc0Z1bmN0aW9uKGN0b3JCKSAmJiBjdG9yQiBpbnN0YW5jZW9mIGN0b3JCKSAmJlxuICAgICAgICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gYXNzdW1lIGN5Y2xpYyBzdHJ1Y3R1cmVzIGFyZSBlcXVhbFxuICAgICAgLy8gdGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpYyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjFcbiAgICAgIC8vIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AgKGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMTIuMylcbiAgICAgIHZhciBpbml0ZWRTdGFjayA9ICFzdGFja0E7XG4gICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IGdldEFycmF5KCkpO1xuICAgICAgc3RhY2tCIHx8IChzdGFja0IgPSBnZXRBcnJheSgpKTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IGEpIHtcbiAgICAgICAgICByZXR1cm4gc3RhY2tCW2xlbmd0aF0gPT0gYjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHNpemUgPSAwO1xuICAgICAgcmVzdWx0ID0gdHJ1ZTtcblxuICAgICAgLy8gYWRkIGBhYCBhbmQgYGJgIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0c1xuICAgICAgc3RhY2tBLnB1c2goYSk7XG4gICAgICBzdGFja0IucHVzaChiKTtcblxuICAgICAgLy8gcmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKVxuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIC8vIGNvbXBhcmUgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5XG4gICAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgICBzaXplID0gYi5sZW5ndGg7XG4gICAgICAgIHJlc3VsdCA9IHNpemUgPT0gbGVuZ3RoO1xuXG4gICAgICAgIGlmIChyZXN1bHQgfHwgaXNXaGVyZSkge1xuICAgICAgICAgIC8vIGRlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXNcbiAgICAgICAgICB3aGlsZSAoc2l6ZS0tKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBiW3NpemVdO1xuXG4gICAgICAgICAgICBpZiAoaXNXaGVyZSkge1xuICAgICAgICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgICAgICAgIGlmICgocmVzdWx0ID0gYmFzZUlzRXF1YWwoYVtpbmRleF0sIHZhbHVlLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpKSkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEocmVzdWx0ID0gYmFzZUlzRXF1YWwoYVtzaXplXSwgdmFsdWUsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGRlZXAgY29tcGFyZSBvYmplY3RzIHVzaW5nIGBmb3JJbmAsIGluc3RlYWQgb2YgYGZvck93bmAsIHRvIGF2b2lkIGBPYmplY3Qua2V5c2BcbiAgICAgICAgLy8gd2hpY2gsIGluIHRoaXMgY2FzZSwgaXMgbW9yZSBjb3N0bHlcbiAgICAgICAgZm9ySW4oYiwgZnVuY3Rpb24odmFsdWUsIGtleSwgYikge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleSkpIHtcbiAgICAgICAgICAgIC8vIGNvdW50IHRoZSBudW1iZXIgb2YgcHJvcGVydGllcy5cbiAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICAgIC8vIGRlZXAgY29tcGFyZSBlYWNoIHByb3BlcnR5IHZhbHVlLlxuICAgICAgICAgICAgcmV0dXJuIChyZXN1bHQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGtleSkgJiYgYmFzZUlzRXF1YWwoYVtrZXldLCB2YWx1ZSwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmVzdWx0ICYmICFpc1doZXJlKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGJvdGggb2JqZWN0cyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzXG4gICAgICAgICAgZm9ySW4oYSwgZnVuY3Rpb24odmFsdWUsIGtleSwgYSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYSwga2V5KSkge1xuICAgICAgICAgICAgICAvLyBgc2l6ZWAgd2lsbCBiZSBgLTFgIGlmIGBhYCBoYXMgbW9yZSBwcm9wZXJ0aWVzIHRoYW4gYGJgXG4gICAgICAgICAgICAgIHJldHVybiAocmVzdWx0ID0gLS1zaXplID4gLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja0EucG9wKCk7XG4gICAgICBzdGFja0IucG9wKCk7XG5cbiAgICAgIGlmIChpbml0ZWRTdGFjaykge1xuICAgICAgICByZWxlYXNlQXJyYXkoc3RhY2tBKTtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICAgKiBmb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnaW5nIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBBc3NvY2lhdGVzIHZhbHVlcyB3aXRoIHNvdXJjZSBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBjYWxsYmFjaywgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIChpc0FycmF5KHNvdXJjZSkgPyBmb3JFYWNoIDogZm9yT3duKShzb3VyY2UsIGZ1bmN0aW9uKHNvdXJjZSwga2V5KSB7XG4gICAgICAgIHZhciBmb3VuZCxcbiAgICAgICAgICAgIGlzQXJyLFxuICAgICAgICAgICAgcmVzdWx0ID0gc291cmNlLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICBpZiAoc291cmNlICYmICgoaXNBcnIgPSBpc0FycmF5KHNvdXJjZSkpIHx8IGlzUGxhaW5PYmplY3Qoc291cmNlKSkpIHtcbiAgICAgICAgICAvLyBhdm9pZCBtZXJnaW5nIHByZXZpb3VzbHkgbWVyZ2VkIGN5Y2xpYyBzb3VyY2VzXG4gICAgICAgICAgdmFyIHN0YWNrTGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc3RhY2tMZW5ndGgtLSkge1xuICAgICAgICAgICAgaWYgKChmb3VuZCA9IHN0YWNrQVtzdGFja0xlbmd0aF0gPT0gc291cmNlKSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHN0YWNrQltzdGFja0xlbmd0aF07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICB2YXIgaXNTaGFsbG93O1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKHZhbHVlLCBzb3VyY2UpO1xuICAgICAgICAgICAgICBpZiAoKGlzU2hhbGxvdyA9IHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNTaGFsbG93KSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gaXNBcnJcbiAgICAgICAgICAgICAgICA/IChpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10pXG4gICAgICAgICAgICAgICAgOiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCBgc291cmNlYCBhbmQgYXNzb2NpYXRlZCBgdmFsdWVgIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0c1xuICAgICAgICAgICAgc3RhY2tBLnB1c2goc291cmNlKTtcbiAgICAgICAgICAgIHN0YWNrQi5wdXNoKHZhbHVlKTtcblxuICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICAgICAgICAgIGlmICghaXNTaGFsbG93KSB7XG4gICAgICAgICAgICAgIGJhc2VNZXJnZSh2YWx1ZSwgc291cmNlLCBjYWxsYmFjaywgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKHZhbHVlLCBzb3VyY2UpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgYXJndW1lbnQganVnZ2xpbmcgb3Igc3VwcG9ydFxuICAgICAqIGZvciByZXR1cm5pbmcgZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYSByYW5kb20gbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSYW5kb20obWluLCBtYXgpIHtcbiAgICAgIHJldHVybiBtaW4gKyBmbG9vcihuYXRpdmVSYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU29ydGVkPWZhbHNlXSBBIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCBgYXJyYXlgIGlzIHNvcnRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXNTb3J0ZWQsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgdmFyIGlzTGFyZ2UgPSAhaXNTb3J0ZWQgJiYgbGVuZ3RoID49IGxhcmdlQXJyYXlTaXplICYmIGluZGV4T2YgPT09IGJhc2VJbmRleE9mLFxuICAgICAgICAgIHNlZW4gPSAoY2FsbGJhY2sgfHwgaXNMYXJnZSkgPyBnZXRBcnJheSgpIDogcmVzdWx0O1xuXG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICB2YXIgY2FjaGUgPSBjcmVhdGVDYWNoZShzZWVuKTtcbiAgICAgICAgaW5kZXhPZiA9IGNhY2hlSW5kZXhPZjtcbiAgICAgICAgc2VlbiA9IGNhY2hlO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBjYWxsYmFjayA/IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgYXJyYXkpIDogdmFsdWU7XG5cbiAgICAgICAgaWYgKGlzU29ydGVkXG4gICAgICAgICAgICAgID8gIWluZGV4IHx8IHNlZW5bc2Vlbi5sZW5ndGggLSAxXSAhPT0gY29tcHV0ZWRcbiAgICAgICAgICAgICAgOiBpbmRleE9mKHNlZW4sIGNvbXB1dGVkKSA8IDBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayB8fCBpc0xhcmdlKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgIHJlbGVhc2VBcnJheShzZWVuLmFycmF5KTtcbiAgICAgICAgcmVsZWFzZU9iamVjdChzZWVuKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmVsZWFzZUFycmF5KHNlZW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhZ2dyZWdhdGVzIGEgY29sbGVjdGlvbiwgY3JlYXRpbmcgYW4gb2JqZWN0IGNvbXBvc2VkXG4gICAgICogb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgY29sbGVjdGlvblxuICAgICAqIHRocm91Z2ggYSBjYWxsYmFjay4gVGhlIGdpdmVuIGBzZXR0ZXJgIGZ1bmN0aW9uIHNldHMgdGhlIGtleXMgYW5kIHZhbHVlc1xuICAgICAqIG9mIHRoZSBjb21wb3NlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgc2V0dGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFnZ3JlZ2F0b3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgICBzZXR0ZXIocmVzdWx0LCB2YWx1ZSwgY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSwgY29sbGVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICBzZXR0ZXIocmVzdWx0LCB2YWx1ZSwgY2FsbGJhY2sodmFsdWUsIGtleSwgY29sbGVjdGlvbiksIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgZWl0aGVyIGN1cnJpZXMgb3IgaW52b2tlcyBgZnVuY2BcbiAgICAgKiB3aXRoIGFuIG9wdGlvbmFsIGB0aGlzYCBiaW5kaW5nIGFuZCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byByZWZlcmVuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgbWV0aG9kIGZsYWdzIHRvIGNvbXBvc2UuXG4gICAgICogIFRoZSBiaXRtYXNrIG1heSBiZSBjb21wb3NlZCBvZiB0aGUgZm9sbG93aW5nIGZsYWdzOlxuICAgICAqICAxIC0gYF8uYmluZGBcbiAgICAgKiAgMiAtIGBfLmJpbmRLZXlgXG4gICAgICogIDQgLSBgXy5jdXJyeWBcbiAgICAgKiAgOCAtIGBfLmN1cnJ5YCAoYm91bmQpXG4gICAgICogIDE2IC0gYF8ucGFydGlhbGBcbiAgICAgKiAgMzIgLSBgXy5wYXJ0aWFsUmlnaHRgXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxBcmdzXSBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZVxuICAgICAqICBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsUmlnaHRBcmdzXSBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlXG4gICAgICogIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVdyYXBwZXIoZnVuYywgYml0bWFzaywgcGFydGlhbEFyZ3MsIHBhcnRpYWxSaWdodEFyZ3MsIHRoaXNBcmcsIGFyaXR5KSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIDEsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIDIsXG4gICAgICAgICAgaXNDdXJyeSA9IGJpdG1hc2sgJiA0LFxuICAgICAgICAgIGlzQ3VycnlCb3VuZCA9IGJpdG1hc2sgJiA4LFxuICAgICAgICAgIGlzUGFydGlhbCA9IGJpdG1hc2sgJiAxNixcbiAgICAgICAgICBpc1BhcnRpYWxSaWdodCA9IGJpdG1hc2sgJiAzMjtcblxuICAgICAgaWYgKCFpc0JpbmRLZXkgJiYgIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BhcnRpYWwgJiYgIXBhcnRpYWxBcmdzLmxlbmd0aCkge1xuICAgICAgICBiaXRtYXNrICY9IH4xNjtcbiAgICAgICAgaXNQYXJ0aWFsID0gcGFydGlhbEFyZ3MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BhcnRpYWxSaWdodCAmJiAhcGFydGlhbFJpZ2h0QXJncy5sZW5ndGgpIHtcbiAgICAgICAgYml0bWFzayAmPSB+MzI7XG4gICAgICAgIGlzUGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0QXJncyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGJpbmREYXRhID0gZnVuYyAmJiBmdW5jLl9fYmluZERhdGFfXztcbiAgICAgIGlmIChiaW5kRGF0YSAmJiBiaW5kRGF0YSAhPT0gdHJ1ZSkge1xuICAgICAgICAvLyBjbG9uZSBgYmluZERhdGFgXG4gICAgICAgIGJpbmREYXRhID0gc2xpY2UoYmluZERhdGEpO1xuICAgICAgICBpZiAoYmluZERhdGFbMl0pIHtcbiAgICAgICAgICBiaW5kRGF0YVsyXSA9IHNsaWNlKGJpbmREYXRhWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmluZERhdGFbM10pIHtcbiAgICAgICAgICBiaW5kRGF0YVszXSA9IHNsaWNlKGJpbmREYXRhWzNdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgYHRoaXNCaW5kaW5nYCBpcyBub3QgcHJldmlvdXNseSBib3VuZFxuICAgICAgICBpZiAoaXNCaW5kICYmICEoYmluZERhdGFbMV0gJiAxKSkge1xuICAgICAgICAgIGJpbmREYXRhWzRdID0gdGhpc0FyZztcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgaWYgcHJldmlvdXNseSBib3VuZCBidXQgbm90IGN1cnJlbnRseSAoc3Vic2VxdWVudCBjdXJyaWVkIGZ1bmN0aW9ucylcbiAgICAgICAgaWYgKCFpc0JpbmQgJiYgYmluZERhdGFbMV0gJiAxKSB7XG4gICAgICAgICAgYml0bWFzayB8PSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBjdXJyaWVkIGFyaXR5IGlmIG5vdCB5ZXQgc2V0XG4gICAgICAgIGlmIChpc0N1cnJ5ICYmICEoYmluZERhdGFbMV0gJiA0KSkge1xuICAgICAgICAgIGJpbmREYXRhWzVdID0gYXJpdHk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXBwZW5kIHBhcnRpYWwgbGVmdCBhcmd1bWVudHNcbiAgICAgICAgaWYgKGlzUGFydGlhbCkge1xuICAgICAgICAgIHB1c2guYXBwbHkoYmluZERhdGFbMl0gfHwgKGJpbmREYXRhWzJdID0gW10pLCBwYXJ0aWFsQXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXBwZW5kIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzXG4gICAgICAgIGlmIChpc1BhcnRpYWxSaWdodCkge1xuICAgICAgICAgIHVuc2hpZnQuYXBwbHkoYmluZERhdGFbM10gfHwgKGJpbmREYXRhWzNdID0gW10pLCBwYXJ0aWFsUmlnaHRBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBmbGFnc1xuICAgICAgICBiaW5kRGF0YVsxXSB8PSBiaXRtYXNrO1xuICAgICAgICByZXR1cm4gY3JlYXRlV3JhcHBlci5hcHBseShudWxsLCBiaW5kRGF0YSk7XG4gICAgICB9XG4gICAgICAvLyBmYXN0IHBhdGggZm9yIGBfLmJpbmRgXG4gICAgICB2YXIgY3JlYXRlciA9IChiaXRtYXNrID09IDEgfHwgYml0bWFzayA9PT0gMTcpID8gYmFzZUJpbmQgOiBiYXNlQ3JlYXRlV3JhcHBlcjtcbiAgICAgIHJldHVybiBjcmVhdGVyKFtmdW5jLCBiaXRtYXNrLCBwYXJ0aWFsQXJncywgcGFydGlhbFJpZ2h0QXJncywgdGhpc0FyZywgYXJpdHldKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBlc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2ggVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGVIdG1sQ2hhcihtYXRjaCkge1xuICAgICAgcmV0dXJuIGh0bWxFc2NhcGVzW21hdGNoXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBcImluZGV4T2ZcIiBmdW5jdGlvbi4gSWYgdGhlIGBfLmluZGV4T2ZgIG1ldGhvZCBpc1xuICAgICAqIGN1c3RvbWl6ZWQsIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zXG4gICAgICogdGhlIGBiYXNlSW5kZXhPZmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgXCJpbmRleE9mXCIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXhPZigpIHtcbiAgICAgIHZhciByZXN1bHQgPSAocmVzdWx0ID0gbG9kYXNoLmluZGV4T2YpID09PSBpbmRleE9mID8gYmFzZUluZGV4T2YgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nICYmIHJlTmF0aXZlLnRlc3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYHRoaXNgIGJpbmRpbmcgZGF0YSBvbiBhIGdpdmVuIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBzZXQgZGF0YSBvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSBUaGUgZGF0YSBhcnJheSB0byBzZXQuXG4gICAgICovXG4gICAgdmFyIHNldEJpbmREYXRhID0gIWRlZmluZVByb3BlcnR5ID8gbm9vcCA6IGZ1bmN0aW9uKGZ1bmMsIHZhbHVlKSB7XG4gICAgICBkZXNjcmlwdG9yLnZhbHVlID0gdmFsdWU7XG4gICAgICBkZWZpbmVQcm9wZXJ0eShmdW5jLCAnX19iaW5kRGF0YV9fJywgZGVzY3JpcHRvcik7XG4gICAgICBkZXNjcmlwdG9yLnZhbHVlID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgaXNQbGFpbk9iamVjdGAgd2hpY2ggY2hlY2tzIGlmIGEgZ2l2ZW4gdmFsdWVcbiAgICAgKiBpcyBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IsIGFzc3VtaW5nIG9iamVjdHMgY3JlYXRlZFxuICAgICAqIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvciBoYXZlIG5vIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYW5kIHRoYXRcbiAgICAgKiB0aGVyZSBhcmUgbm8gYE9iamVjdC5wcm90b3R5cGVgIGV4dGVuc2lvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hpbUlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIHZhciBjdG9yLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgLy8gYXZvaWQgbm9uIE9iamVjdCBvYmplY3RzLCBgYXJndW1lbnRzYCBvYmplY3RzLCBhbmQgRE9NIGVsZW1lbnRzXG4gICAgICBpZiAoISh2YWx1ZSAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBvYmplY3RDbGFzcykgfHxcbiAgICAgICAgICAoY3RvciA9IHZhbHVlLmNvbnN0cnVjdG9yLCBpc0Z1bmN0aW9uKGN0b3IpICYmICEoY3RvciBpbnN0YW5jZW9mIGN0b3IpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBJbiBtb3N0IGVudmlyb25tZW50cyBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcyBhcmUgaXRlcmF0ZWQgYmVmb3JlXG4gICAgICAvLyBpdHMgaW5oZXJpdGVkIHByb3BlcnRpZXMuIElmIHRoZSBsYXN0IGl0ZXJhdGVkIHByb3BlcnR5IGlzIGFuIG9iamVjdCdzXG4gICAgICAvLyBvd24gcHJvcGVydHkgdGhlbiB0aGVyZSBhcmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgIGZvckluKHZhbHVlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCcgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGB1bmVzY2FwZWAgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaCBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZUh0bWxDaGFyKG1hdGNoKSB7XG4gICAgICByZXR1cm4gaHRtbFVuZXNjYXBlc1ttYXRjaF07XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogKGZ1bmN0aW9uKCkgeyByZXR1cm4gXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpOyB9KSgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgICAgIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogKGZ1bmN0aW9uKCkgeyByZXR1cm4gXy5pc0FycmF5KGFyZ3VtZW50cyk7IH0pKCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgICAgICB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzIHx8IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBPYmplY3Qua2V5c2Agd2hpY2ggcHJvZHVjZXMgYW4gYXJyYXkgb2YgdGhlXG4gICAgICogZ2l2ZW4gb2JqZWN0J3Mgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIHZhciBzaGltS2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIGluZGV4LCBpdGVyYWJsZSA9IG9iamVjdCwgcmVzdWx0ID0gW107XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgaWYgKCEob2JqZWN0VHlwZXNbdHlwZW9mIG9iamVjdF0pKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICBmb3IgKGluZGV4IGluIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoaXRlcmFibGUsIGluZGV4KSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGNvbXBvc2VkIG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5rZXlzKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgICAqIC8vID0+IFsnb25lJywgJ3R3bycsICd0aHJlZSddIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIHZhciBrZXlzID0gIW5hdGl2ZUtleXMgPyBzaGltS2V5cyA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXM6XG4gICAgICpcbiAgICAgKiBUaG91Z2ggdGhlIGA+YCBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZSBgPmAgYW5kIGAvYFxuICAgICAqIGRvbid0IHJlcXVpcmUgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmcgdW5sZXNzIHRoZXkncmUgcGFydFxuICAgICAqIG9mIGEgdGFnIG9yIGFuIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgKiBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcyAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIilcbiAgICAgKi9cbiAgICB2YXIgaHRtbEVzY2FwZXMgPSB7XG4gICAgICAnJic6ICcmYW1wOycsXG4gICAgICAnPCc6ICcmbHQ7JyxcbiAgICAgICc+JzogJyZndDsnLFxuICAgICAgJ1wiJzogJyZxdW90OycsXG4gICAgICBcIidcIjogJyYjMzk7J1xuICAgIH07XG5cbiAgICAvKiogVXNlZCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycyAqL1xuICAgIHZhciBodG1sVW5lc2NhcGVzID0gaW52ZXJ0KGh0bWxFc2NhcGVzKTtcblxuICAgIC8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycyAqL1xuICAgIHZhciByZUVzY2FwZWRIdG1sID0gUmVnRXhwKCcoJyArIGtleXMoaHRtbFVuZXNjYXBlcykuam9pbignfCcpICsgJyknLCAnZycpLFxuICAgICAgICByZVVuZXNjYXBlZEh0bWwgPSBSZWdFeHAoJ1snICsga2V5cyhodG1sRXNjYXBlcykuam9pbignJykgKyAnXScsICdnJyk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIG9iamVjdC4gU3Vic2VxdWVudCBzb3VyY2VzIHdpbGwgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzXG4gICAgICogc291cmNlcy4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlXG4gICAgICogYXNzaWduZWQgdmFsdWVzLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdHdvXG4gICAgICogYXJndW1lbnRzOyAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGFsaWFzIGV4dGVuZFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICduYW1lJzogJ2ZyZWQnIH0sIHsgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICByZXR1cm4gdHlwZW9mIGEgPT0gJ3VuZGVmaW5lZCcgPyBiIDogYTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2Jhcm5leScgfTtcbiAgICAgKiBkZWZhdWx0cyhvYmplY3QsIHsgJ25hbWUnOiAnZnJlZCcsICdlbXBsb3llcic6ICdzbGF0ZScgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduID0gZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIGd1YXJkKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gb2JqZWN0LCByZXN1bHQgPSBpdGVyYWJsZTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBhcmdzSW5kZXggPSAwLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSB0eXBlb2YgZ3VhcmQgPT0gJ251bWJlcicgPyAyIDogYXJncy5sZW5ndGg7XG4gICAgICBpZiAoYXJnc0xlbmd0aCA+IDMgJiYgdHlwZW9mIGFyZ3NbYXJnc0xlbmd0aCAtIDJdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGFyZ3NbLS1hcmdzTGVuZ3RoIC0gMV0sIGFyZ3NbYXJnc0xlbmd0aC0tXSwgMik7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3NMZW5ndGggPiAyICYmIHR5cGVvZiBhcmdzW2FyZ3NMZW5ndGggLSAxXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYXJnc1stLWFyZ3NMZW5ndGhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICBpdGVyYWJsZSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICYmIG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0pIHtcbiAgICAgICAgdmFyIG93bkluZGV4ID0gLTEsXG4gICAgICAgICAgICBvd25Qcm9wcyA9IG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0gJiYga2V5cyhpdGVyYWJsZSksXG4gICAgICAgICAgICBsZW5ndGggPSBvd25Qcm9wcyA/IG93blByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsrb3duSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IG93blByb3BzW293bkluZGV4XTtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gY2FsbGJhY2sgPyBjYWxsYmFjayhyZXN1bHRbaW5kZXhdLCBpdGVyYWJsZVtpbmRleF0pIDogaXRlcmFibGVbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB2YWx1ZWAuIElmIGBpc0RlZXBgIGlzIGB0cnVlYCBuZXN0ZWQgb2JqZWN0cyB3aWxsIGFsc29cbiAgICAgKiBiZSBjbG9uZWQsIG90aGVyd2lzZSB0aGV5IHdpbGwgYmUgYXNzaWduZWQgYnkgcmVmZXJlbmNlLiBJZiBhIGNhbGxiYWNrXG4gICAgICogaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWVzLiBJZiB0aGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgIGNsb25pbmcgd2lsbCBiZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXA9ZmFsc2VdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShjaGFyYWN0ZXJzKTtcbiAgICAgKiBzaGFsbG93WzBdID09PSBjaGFyYWN0ZXJzWzBdO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZShjaGFyYWN0ZXJzLCB0cnVlKTtcbiAgICAgKiBkZWVwWzBdID09PSBjaGFyYWN0ZXJzWzBdO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLm1peGluKHtcbiAgICAgKiAgICdjbG9uZSc6IF8ucGFydGlhbFJpZ2h0KF8uY2xvbmUsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICAgIHJldHVybiBfLmlzRWxlbWVudCh2YWx1ZSkgPyB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAqICAgfSlcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZhciBjbG9uZSA9IF8uY2xvbmUoZG9jdW1lbnQuYm9keSk7XG4gICAgICogY2xvbmUuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHZhbHVlLCBpc0RlZXAsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzIHdpdGhvdXQgdXNpbmcgdGhlaXIgYGluZGV4YFxuICAgICAgLy8gYW5kIGBjb2xsZWN0aW9uYCBhcmd1bWVudHMgZm9yIGBpc0RlZXBgIGFuZCBgY2FsbGJhY2tgXG4gICAgICBpZiAodHlwZW9mIGlzRGVlcCAhPSAnYm9vbGVhbicgJiYgaXNEZWVwICE9IG51bGwpIHtcbiAgICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9IGlzRGVlcDtcbiAgICAgICAgaXNEZWVwID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nICYmIGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWVwIGNsb25lIG9mIGB2YWx1ZWAuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZVxuICAgICAqIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogY2xvbmluZyB3aWxsIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZSBzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobS4gRnVuY3Rpb25zXG4gICAgICogYW5kIERPTSBub2RlcyBhcmUgKipub3QqKiBjbG9uZWQuIFRoZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhbmRcbiAgICAgKiBvYmplY3RzIGNyZWF0ZWQgYnkgY29uc3RydWN0b3JzIG90aGVyIHRoYW4gYE9iamVjdGAgYXJlIGNsb25lZCB0byBwbGFpbiBgT2JqZWN0YCBvYmplY3RzLlxuICAgICAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI2ludGVybmFsLXN0cnVjdHVyZWQtY2xvbmluZy1hbGdvcml0aG0uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKGNoYXJhY3RlcnMpO1xuICAgICAqIGRlZXBbMF0gPT09IGNoYXJhY3RlcnNbMF07XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ25vZGUnOiBlbGVtZW50XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjbG9uZSA9IF8uY2xvbmVEZWVwKHZpZXcsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc0VsZW1lbnQodmFsdWUpID8gdmFsdWUuY2xvbmVOb2RlKHRydWUpIDogdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY2xvbmUubm9kZSA9PSB2aWV3Lm5vZGU7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCB0cnVlLCB0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJyAmJiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGdpdmVuIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgcHJvdmlkZWQgaXRzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGFzc2lnbmVkXG4gICAgICogdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gVGhlIHByb3BlcnRpZXMgdG8gYXNzaWduIHRvIHRoZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gICAgICogICBTaGFwZS5jYWxsKHRoaXMpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIENpcmNsZS5wcm90b3R5cGUgPSBfLmNyZWF0ZShTaGFwZS5wcm90b3R5cGUsIHsgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlIH0pO1xuICAgICAqXG4gICAgICogdmFyIGNpcmNsZSA9IG5ldyBDaXJjbGU7XG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgQ2lyY2xlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIFNoYXBlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXMgPyBhc3NpZ24ocmVzdWx0LCBwcm9wZXJ0aWVzKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gT25jZSBhXG4gICAgICogcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIGRlZmF1bHRzIG9mIHRoZSBzYW1lIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gQWxsb3dzIHdvcmtpbmcgd2l0aCBgXy5yZWR1Y2VgIHdpdGhvdXQgdXNpbmcgaXRzXG4gICAgICogIGBrZXlgIGFuZCBgb2JqZWN0YCBhcmd1bWVudHMgYXMgc291cmNlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2Jhcm5leScgfTtcbiAgICAgKiBfLmRlZmF1bHRzKG9iamVjdCwgeyAnbmFtZSc6ICdmcmVkJywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdlbXBsb3llcic6ICdzbGF0ZScgfVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0cyA9IGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBndWFyZCkge1xuICAgICAgdmFyIGluZGV4LCBpdGVyYWJsZSA9IG9iamVjdCwgcmVzdWx0ID0gaXRlcmFibGU7XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgYXJnc0luZGV4ID0gMCxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gdHlwZW9mIGd1YXJkID09ICdudW1iZXInID8gMiA6IGFyZ3MubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICBpdGVyYWJsZSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICYmIG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0pIHtcbiAgICAgICAgdmFyIG93bkluZGV4ID0gLTEsXG4gICAgICAgICAgICBvd25Qcm9wcyA9IG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0gJiYga2V5cyhpdGVyYWJsZSksXG4gICAgICAgICAgICBsZW5ndGggPSBvd25Qcm9wcyA/IG93blByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsrb3duSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IG93blByb3BzW293bkluZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdFtpbmRleF0gPT0gJ3VuZGVmaW5lZCcpIHJlc3VsdFtpbmRleF0gPSBpdGVyYWJsZVtpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUga2V5IG9mIHRoZVxuICAgICAqIGZpcnN0IGVsZW1lbnQgdGhhdCBwYXNzZXMgdGhlIGNhbGxiYWNrIGNoZWNrLCBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlclxuICAgICAqICBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvXG4gICAgICogIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogeyAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICAnZnJlZCc6IHsgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRLZXkoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kS2V5KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDEgfSk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kS2V5KG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBmb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kS2V5YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG9cbiAgICAgKiAgY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiB7ICAnYWdlJzogMzYsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiB7ICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEtleShjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gcmV0dXJucyBgcGViYmxlc2AsIGFzc3VtaW5nIGBfLmZpbmRLZXlgIHJldHVybnMgYGJhcm5leWBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkoY2hhcmFjdGVycywgeyAnYWdlJzogNDAgfSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0S2V5KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RLZXkob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGZvck93blJpZ2h0KG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCxcbiAgICAgKiBleGVjdXRpbmcgdGhlIGNhbGxiYWNrIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBDYWxsYmFja3MgbWF5IGV4aXRcbiAgICAgKiBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogU2hhcGUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICB0aGlzLnggKz0geDtcbiAgICAgKiAgIHRoaXMueSArPSB5O1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZvckluKG5ldyBTaGFwZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICd4JywgJ3knLCBhbmQgJ21vdmUnIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIHZhciBmb3JJbiA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gY29sbGVjdGlvbiwgcmVzdWx0ID0gaXRlcmFibGU7XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgaWYgKCFvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdKSByZXR1cm4gcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgZm9yIChpbmRleCBpbiBpdGVyYWJsZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayhpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JJbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIFNoYXBlLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgdGhpcy54ICs9IHg7XG4gICAgICogICB0aGlzLnkgKz0geTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5mb3JJblJpZ2h0KG5ldyBTaGFwZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdtb3ZlJywgJ3knLCBhbmQgJ3gnIGFzc3VtaW5nIGBfLmZvckluIGAgbG9ncyAneCcsICd5JywgYW5kICdtb3ZlJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluUmlnaHQob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHBhaXJzID0gW107XG5cbiAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICBwYWlycy5wdXNoKGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBwYWlycy5sZW5ndGg7XG4gICAgICBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHBhaXJzW2xlbmd0aC0tXSwgcGFpcnNbbGVuZ3RoXSwgb2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LCBleGVjdXRpbmcgdGhlIGNhbGxiYWNrXG4gICAgICogZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBrZXksIG9iamVjdCkuIENhbGxiYWNrcyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnlcbiAgICAgKiBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JPd24oeyAnMCc6ICd6ZXJvJywgJzEnOiAnb25lJywgJ2xlbmd0aCc6IDIgfSwgZnVuY3Rpb24obnVtLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnMCcsICcxJywgYW5kICdsZW5ndGgnIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIHZhciBmb3JPd24gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4LCBpdGVyYWJsZSA9IGNvbGxlY3Rpb24sIHJlc3VsdCA9IGl0ZXJhYmxlO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGlmICghb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHZhciBvd25JbmRleCA9IC0xLFxuICAgICAgICAgICAgb3duUHJvcHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdICYmIGtleXMoaXRlcmFibGUpLFxuICAgICAgICAgICAgbGVuZ3RoID0gb3duUHJvcHMgPyBvd25Qcm9wcy5sZW5ndGggOiAwO1xuXG4gICAgICAgIHdoaWxlICgrK293bkluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaW5kZXggPSBvd25Qcm9wc1tvd25JbmRleF07XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvck93bmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvck93blJpZ2h0KHsgJzAnOiAnemVybycsICcxJzogJ29uZScsICdsZW5ndGgnOiAyIH0sIGZ1bmN0aW9uKG51bSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ2xlbmd0aCcsICcxJywgYW5kICcwJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJzAnLCAnMScsIGFuZCAnbGVuZ3RoJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93blJpZ2h0KG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXksIG9iamVjdCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNvcnRlZCBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBvZiBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLFxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkLCBvZiBgb2JqZWN0YCB0aGF0IGhhdmUgZnVuY3Rpb24gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIG1ldGhvZHNcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB0aGF0IGhhdmUgZnVuY3Rpb24gdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhfKTtcbiAgICAgKiAvLyA9PiBbJ2FsbCcsICdhbnknLCAnYmluZCcsICdiaW5kQWxsJywgJ2Nsb25lJywgJ2NvbXBhY3QnLCAnY29tcG9zZScsIC4uLl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0LnNvcnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBuYW1lIGV4aXN0cyBhcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCxcbiAgICAgKiBpbnN0ZWFkIG9mIGFuIGluaGVyaXRlZCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGtleSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmhhcyh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgJ2InKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID8gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgaW52ZXJ0ZWQga2V5cyBhbmQgdmFsdWVzIG9mIHRoZSBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3JlYXRlZCBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0KHsgJ2ZpcnN0JzogJ2ZyZWQnLCAnc2Vjb25kJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6ICdmaXJzdCcsICdiYXJuZXknOiAnc2Vjb25kJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52ZXJ0KG9iamVjdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbb2JqZWN0W2tleV1dID0ga2V5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJvb2xlYW4gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIGJvb2xlYW4gdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4obnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGJvb2xDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGRhdGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIGRhdGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUobmV3IERhdGUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZGF0ZUNsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMSB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBlbXB0eS4gQXJyYXlzLCBzdHJpbmdzLCBvciBgYXJndW1lbnRzYCBvYmplY3RzIHdpdGggYVxuICAgICAqIGxlbmd0aCBvZiBgMGAgYW5kIG9iamVjdHMgd2l0aCBubyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBjb25zaWRlcmVkXG4gICAgICogXCJlbXB0eVwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoJycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICAgIGlmICgoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MgfHwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBhcmdzQ2xhc3MgKSB8fFxuICAgICAgICAgIChjbGFzc05hbWUgPT0gb2JqZWN0Q2xhc3MgJiYgdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBpc0Z1bmN0aW9uKHZhbHVlLnNwbGljZSkpKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZm9yT3duKHZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChyZXN1bHQgPSBmYWxzZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICAgICAqIGVxdWl2YWxlbnQgdG8gZWFjaCBvdGhlci4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkXG4gICAgICogdG8gY29tcGFyZSB2YWx1ZXMuIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgIGNvbXBhcmlzb25zIHdpbGxcbiAgICAgKiBiZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czsgKGEsIGIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IGEgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBiIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIGNvcHkgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiBvYmplY3QgPT0gY29weTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VxdWFsKG9iamVjdCwgY29weSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIHdvcmRzID0gWydoZWxsbycsICdnb29kYnllJ107XG4gICAgICogdmFyIG90aGVyV29yZHMgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbCh3b3Jkcywgb3RoZXJXb3JkcywgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgdmFyIHJlR3JlZXQgPSAvXig/OmhlbGxvfGhpKSQvaSxcbiAgICAgKiAgICAgICBhR3JlZXQgPSBfLmlzU3RyaW5nKGEpICYmIHJlR3JlZXQudGVzdChhKSxcbiAgICAgKiAgICAgICBiR3JlZXQgPSBfLmlzU3RyaW5nKGIpICYmIHJlR3JlZXQudGVzdChiKTtcbiAgICAgKlxuICAgICAqICAgcmV0dXJuIChhR3JlZXQgfHwgYkdyZWV0KSA/IChhR3JlZXQgPT0gYkdyZWV0KSA6IHVuZGVmaW5lZDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbChhLCBiLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsKGEsIGIsIHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nICYmIGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzLCBvciBjYW4gYmUgY29lcmNlZCB0bywgYSBmaW5pdGUgbnVtYmVyLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgbmF0aXZlIGBpc0Zpbml0ZWAgd2hpY2ggd2lsbCByZXR1cm4gdHJ1ZSBmb3JcbiAgICAgKiBib29sZWFucyBhbmQgZW1wdHkgc3RyaW5ncy4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBmaW5pdGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgtMTAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKCcxMCcpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUodHJ1ZSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmluaXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmF0aXZlSXNGaW5pdGUodmFsdWUpICYmICFuYXRpdmVJc05hTihwYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIGxhbmd1YWdlIHR5cGUgb2YgT2JqZWN0LlxuICAgICAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3Qoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSB2YWx1ZSBpcyB0aGUgRUNNQVNjcmlwdCBsYW5ndWFnZSB0eXBlIG9mIE9iamVjdFxuICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3g4XG4gICAgICAvLyBhbmQgYXZvaWQgYSBWOCBidWdcbiAgICAgIC8vIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTFcbiAgICAgIHJldHVybiAhISh2YWx1ZSAmJiBvYmplY3RUeXBlc1t0eXBlb2YgdmFsdWVdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgTmFOYC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgaXMgbm90IHRoZSBzYW1lIGFzIG5hdGl2ZSBgaXNOYU5gIHdoaWNoIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3JcbiAgICAgKiBgdW5kZWZpbmVkYCBhbmQgb3RoZXIgbm9uLW51bWVyaWMgdmFsdWVzLiBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuNC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4oTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgICAgLy8gYE5hTmAgYXMgYSBwcmltaXRpdmUgaXMgdGhlIG9ubHkgdmFsdWUgdGhhdCBpcyBub3QgZXF1YWwgdG8gaXRzZWxmXG4gICAgICAvLyAocGVyZm9ybSB0aGUgW1tDbGFzc11dIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGVycm9ycyB3aXRoIHNvbWUgaG9zdCBvYmplY3RzIGluIElFKVxuICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAhPSArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYG51bGxgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG51bWJlci5cbiAgICAgKlxuICAgICAqIE5vdGU6IGBOYU5gIGlzIGNvbnNpZGVyZWQgYSBudW1iZXIuIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDguNS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoOC40ICogNSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8XG4gICAgICAgIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBudW1iZXJDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBTaGFwZSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGlzUGxhaW5PYmplY3QgPSAhZ2V0UHJvdG90eXBlT2YgPyBzaGltSXNQbGFpbk9iamVjdCA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoISh2YWx1ZSAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBvYmplY3RDbGFzcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mLFxuICAgICAgICAgIG9ialByb3RvID0gaXNOYXRpdmUodmFsdWVPZikgJiYgKG9ialByb3RvID0gZ2V0UHJvdG90eXBlT2YodmFsdWVPZikpICYmIGdldFByb3RvdHlwZU9mKG9ialByb3RvKTtcblxuICAgICAgcmV0dXJuIG9ialByb3RvXG4gICAgICAgID8gKHZhbHVlID09IG9ialByb3RvIHx8IGdldFByb3RvdHlwZU9mKHZhbHVlKSA9PSBvYmpQcm90bylcbiAgICAgICAgOiBzaGltSXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcmVndWxhciBleHByZXNzaW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgvZnJlZC8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSByZWdleHBDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN0cmluZ0NsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWQgYnlcbiAgICAgKiBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhyb3VnaCB0aGUgY2FsbGJhY2suXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHZhbHVlcyBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcFZhbHVlcyh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDN9ICwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gKiAzOyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2LCAnYyc6IDkgfVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSB7XG4gICAgICogICAnZnJlZCc6IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwVmFsdWVzKGNoYXJhY3RlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgZm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBtZXJnZXMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdChzKSwgdGhhdFxuICAgICAqIGRvbid0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgaW50byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXNcbiAgICAgKiB3aWxsIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLiBJZiBhIGNhbGxiYWNrIGlzXG4gICAgICogcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIGFuZCBzb3VyY2UgcHJvcGVydGllcy4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAgbWVyZ2luZyB3aWxsXG4gICAgICogYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM7IChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2luZyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG5hbWVzID0ge1xuICAgICAqICAgJ2NoYXJhY3RlcnMnOiBbXG4gICAgICogICAgIHsgJ25hbWUnOiAnYmFybmV5JyB9LFxuICAgICAqICAgICB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKiAgIF1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGFnZXMgPSB7XG4gICAgICogICAnY2hhcmFjdGVycyc6IFtcbiAgICAgKiAgICAgeyAnYWdlJzogMzYgfSxcbiAgICAgKiAgICAgeyAnYWdlJzogNDAgfVxuICAgICAqICAgXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKG5hbWVzLCBhZ2VzKTtcbiAgICAgKiAvLyA9PiB7ICdjaGFyYWN0ZXJzJzogW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sIHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9XSB9XG4gICAgICpcbiAgICAgKiB2YXIgZm9vZCA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2FwcGxlJ10sXG4gICAgICogICAndmVnZXRhYmxlcyc6IFsnYmVldCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlckZvb2QgPSB7XG4gICAgICogICAnZnJ1aXRzJzogWydiYW5hbmEnXSxcbiAgICAgKiAgICd2ZWdldGFibGVzJzogWydjYXJyb3QnXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKGZvb2QsIG90aGVyRm9vZCwgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgcmV0dXJuIF8uaXNBcnJheShhKSA/IGEuY29uY2F0KGIpIDogdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ZydWl0cyc6IFsnYXBwbGUnLCAnYmFuYW5hJ10sICd2ZWdldGFibGVzJzogWydiZWV0JywgJ2NhcnJvdF0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlKG9iamVjdCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgbGVuZ3RoID0gMjtcblxuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCB3aXRob3V0IHVzaW5nXG4gICAgICAvLyB0aGVpciBgaW5kZXhgIGFuZCBgY29sbGVjdGlvbmAgYXJndW1lbnRzXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMl0gIT0gJ251bWJlcicpIHtcbiAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJnc1tsZW5ndGggLSAyXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhhcmdzWy0tbGVuZ3RoIC0gMV0sIGFyZ3NbbGVuZ3RoLS1dLCAyKTtcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiB0eXBlb2YgYXJnc1tsZW5ndGggLSAxXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYXJnc1stLWxlbmd0aF07XG4gICAgICB9XG4gICAgICB2YXIgc291cmNlcyA9IHNsaWNlKGFyZ3VtZW50cywgMSwgbGVuZ3RoKSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIHN0YWNrQSA9IGdldEFycmF5KCksXG4gICAgICAgICAgc3RhY2tCID0gZ2V0QXJyYXkoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlc1tpbmRleF0sIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICB9XG4gICAgICByZWxlYXNlQXJyYXkoc3RhY2tBKTtcbiAgICAgIHJlbGVhc2VBcnJheShzdGFja0IpO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgb2JqZWN0YCBleGNsdWRpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAqIFByb3BlcnR5IG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzIG9mXG4gICAgICogcHJvcGVydHkgbmFtZXMuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaFxuICAgICAqIHByb3BlcnR5IG9mIGBvYmplY3RgIG9taXR0aW5nIHRoZSBwcm9wZXJ0aWVzIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5XG4gICAgICogZm9yLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258Li4uc3RyaW5nfHN0cmluZ1tdfSBbY2FsbGJhY2tdIFRoZSBwcm9wZXJ0aWVzIHRvIG9taXQgb3IgdGhlXG4gICAgICogIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGhvdXQgdGhlIG9taXR0ZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5vbWl0KHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICpcbiAgICAgKiBfLm9taXQoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9taXQob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IFtdO1xuICAgICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICBwcm9wcy5wdXNoKGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wcyA9IGJhc2VEaWZmZXJlbmNlKHByb3BzLCBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIGZhbHNlLCAxKSk7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgICBpZiAoIWNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHR3byBkaW1lbnNpb25hbCBhcnJheSBvZiBhbiBvYmplY3QncyBrZXktdmFsdWUgcGFpcnMsXG4gICAgICogaS5lLiBgW1trZXkxLCB2YWx1ZTFdLCBba2V5MiwgdmFsdWUyXV1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgbmV3IGFycmF5IG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWlycyh7ICdiYXJuZXknOiAzNiwgJ2ZyZWQnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXV0gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFpcnMob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IFtrZXksIG9iamVjdFtrZXldXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYG9iamVjdGAgY29tcG9zZWQgb2YgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAqIFByb3BlcnR5IG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzIG9mXG4gICAgICogcHJvcGVydHkgbmFtZXMuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaFxuICAgICAqIHByb3BlcnR5IG9mIGBvYmplY3RgIHBpY2tpbmcgdGhlIHByb3BlcnRpZXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXlcbiAgICAgKiBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnwuLi5zdHJpbmd8c3RyaW5nW119IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uIG9yIHByb3BlcnR5IG5hbWVzIHRvIHBpY2ssIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIHByb3BlcnR5XG4gICAgICogIG5hbWVzIG9yIGFycmF5cyBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGljayh7ICduYW1lJzogJ2ZyZWQnLCAnX3VzZXJpZCc6ICdmcmVkMScgfSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKlxuICAgICAqIF8ucGljayh7ICduYW1lJzogJ2ZyZWQnLCAnX3VzZXJpZCc6ICdmcmVkMScgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgcmV0dXJuIGtleS5jaGFyQXQoMCkgIT0gJ18nO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2sob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgcHJvcHMgPSBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIGZhbHNlLCAxKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGlzT2JqZWN0KG9iamVjdCkgPyBwcm9wcy5sZW5ndGggOiAwO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgIHRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYG9iamVjdGAgdG8gYSBuZXdcbiAgICAgKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgb3duXG4gICAgICogZW51bWVyYWJsZSBwcm9wZXJ0aWVzIHRocm91Z2ggYSBjYWxsYmFjaywgd2l0aCBlYWNoIGNhbGxiYWNrIGV4ZWN1dGlvblxuICAgICAqIHBvdGVudGlhbGx5IG11dGF0aW5nIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM7IChhY2N1bXVsYXRvciwgdmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKiBDYWxsYmFja3MgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc3F1YXJlcyA9IF8udHJhbnNmb3JtKFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMF0sIGZ1bmN0aW9uKHJlc3VsdCwgbnVtKSB7XG4gICAgICogICBudW0gKj0gbnVtO1xuICAgICAqICAgaWYgKG51bSAlIDIpIHtcbiAgICAgKiAgICAgcmV0dXJuIHJlc3VsdC5wdXNoKG51bSkgPCAzO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxLCA5LCAyNV1cbiAgICAgKlxuICAgICAqIHZhciBtYXBwZWQgPSBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgZnVuY3Rpb24ocmVzdWx0LCBudW0sIGtleSkge1xuICAgICAqICAgcmVzdWx0W2tleV0gPSBudW0gKiAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYsICdjJzogOSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgY2FsbGJhY2ssIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCk7XG4gICAgICBpZiAoYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgICAgcHJvdG8gPSBjdG9yICYmIGN0b3IucHJvdG90eXBlO1xuXG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBiYXNlQ3JlYXRlKHByb3RvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCA0KTtcbiAgICAgICAgKGlzQXJyID8gZm9yRWFjaCA6IGZvck93bikob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGNvbXBvc2VkIG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IG9iamVjdFtwcm9wc1tpbmRleF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgZnJvbSB0aGUgc3BlY2lmaWVkIGluZGV4ZXMsIG9yIGtleXMsIG9mIHRoZVxuICAgICAqIGBjb2xsZWN0aW9uYC4gSW5kZXhlcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5c1xuICAgICAqIG9mIGluZGV4ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXXxzdHJpbmd8c3RyaW5nW10pfSBbaW5kZXhdIFRoZSBpbmRleGVzIG9mIGBjb2xsZWN0aW9uYFxuICAgICAqICAgdG8gcmV0cmlldmUsIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGluZGV4ZXMgb3IgYXJyYXlzIG9mIGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlXG4gICAgICogIHByb3ZpZGVkIGluZGV4ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYXQoWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSwgWzAsIDIsIDRdKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYycsICdlJ11cbiAgICAgKlxuICAgICAqIF8uYXQoWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ10sIDAsIDIpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdChjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0gYmFzZUZsYXR0ZW4oYXJncywgdHJ1ZSwgZmFsc2UsIDEpLFxuICAgICAgICAgIGxlbmd0aCA9IChhcmdzWzJdICYmIGFyZ3NbMl1bYXJnc1sxXV0gPT09IGNvbGxlY3Rpb24pID8gMSA6IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBjb2xsZWN0aW9uW3Byb3BzW2luZGV4XV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGdpdmVuIHZhbHVlIGlzIHByZXNlbnQgaW4gYSBjb2xsZWN0aW9uIHVzaW5nIHN0cmljdCBlcXVhbGl0eVxuICAgICAqIGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0IGlzIHVzZWQgYXMgdGhlXG4gICAgICogb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBpbmNsdWRlXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gY2hlY2sgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB0YXJnZXRgIGVsZW1lbnQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb250YWlucyhbMSwgMiwgM10sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uY29udGFpbnMoWzEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5jb250YWlucyh7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSwgJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmNvbnRhaW5zKCdwZWJibGVzJywgJ2ViJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KDAsIGxlbmd0aCArIGZyb21JbmRleCkgOiBmcm9tSW5kZXgpIHx8IDA7XG4gICAgICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXN1bHQgPSBpbmRleE9mKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSA+IC0xO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHJlc3VsdCA9IChpc1N0cmluZyhjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24uaW5kZXhPZih0YXJnZXQsIGZyb21JbmRleCkgOiBpbmRleE9mKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSkgPiAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmICgrK2luZGV4ID49IGZyb21JbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuICEocmVzdWx0ID0gdmFsdWUgPT09IHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJvdWdoIHRoZSBjYWxsYmFjay4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVcbiAgICAgKiBvZiBlYWNoIGtleSBpcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgd2FzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjay5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNC4zLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gTWF0aC5mbG9vcihudW0pOyB9KTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNC4zLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5mbG9vcihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiAyLCAnNSc6IDEgfVxuICAgICAqL1xuICAgIHZhciBjb3VudEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldKysgOiByZXN1bHRba2V5XSA9IDEpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBjYWxsYmFjayByZXR1cm5zIHRydWV5IHZhbHVlIGZvciAqKmFsbCoqIGVsZW1lbnRzIG9mXG4gICAgICogYSBjb2xsZWN0aW9uLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGFsbFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3NlZCB0aGUgY2FsbGJhY2sgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmV2ZXJ5KGNoYXJhY3RlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmV2ZXJ5KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmICghKHJlc3VsdCA9ICEhY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiAocmVzdWx0ID0gISFjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gICAgICogdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkgZm9yLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHNlbGVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBwYXNzZWQgdGhlIGNhbGxiYWNrIGNoZWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZXZlbnMgPSBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICUgMiA9PSAwOyB9KTtcbiAgICAgKiAvLyA9PiBbMiwgNCwgNl1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbHRlcihjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maWx0ZXIoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdFxuICAgICAqIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5IGZvci4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBkZXRlY3QsIGZpbmRXaGVyZVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZChjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAxIH0pO1xuICAgICAqIC8vID0+ICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmQoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtICUgMiA9PSAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiwgZXhlY3V0aW5nIHRoZSBjYWxsYmFjayBmb3IgZWFjaFxuICAgICAqIGVsZW1lbnQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLiBDYWxsYmFja3MgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5XG4gICAgICogZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIE5vdGU6IEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIGBsZW5ndGhgIHByb3BlcnR5XG4gICAgICogYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIGBfLmZvckluYCBvciBgXy5mb3JPd25gXG4gICAgICogbWF5IGJlIHVzZWQgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZWFjaFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkuZm9yRWFjaChmdW5jdGlvbihudW0pIHsgY29uc29sZS5sb2cobnVtKTsgfSkuam9pbignLCcpO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCBudW1iZXIgYW5kIHJldHVybnMgJzEsMiwzJ1xuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0sIGZ1bmN0aW9uKG51bSkgeyBjb25zb2xlLmxvZyhudW0pOyB9KTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggbnVtYmVyIGFuZCByZXR1cm5zIHRoZSBvYmplY3QgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZWFjaFJpZ2h0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS5mb3JFYWNoUmlnaHQoZnVuY3Rpb24obnVtKSB7IGNvbnNvbGUubG9nKG51bSk7IH0pLmpvaW4oJywnKTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggbnVtYmVyIGZyb20gcmlnaHQgdG8gbGVmdCBhbmQgcmV0dXJucyAnMywyLDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2soY29sbGVjdGlvbltsZW5ndGhdLCBsZW5ndGgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvcHMgPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAga2V5ID0gcHJvcHMgPyBwcm9wc1stLWxlbmd0aF0gOiAtLWxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY29sbGVjdGlvbltrZXldLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBhIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgY2FsbGJhY2suIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogb2YgZWFjaCBrZXkgaXMgYW4gYXJyYXkgb2YgdGhlIGVsZW1lbnRzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNC4yLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gTWF0aC5mbG9vcihudW0pOyB9KTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzQuMiwgNi4xLCA2LjRdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIHRoaXMuZmxvb3IobnVtKTsgfSwgTWF0aCk7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuNF0gfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ncm91cEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IFsnb25lJywgJ3R3byddLCAnNSc6IFsndGhyZWUnXSB9XG4gICAgICovXG4gICAgdmFyIGdyb3VwQnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpID8gcmVzdWx0W2tleV0gOiByZXN1bHRba2V5XSA9IFtdKS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiB0aGUgY29sbGVjdGlvbiB0aHJvdWdoIHRoZSBnaXZlbiBjYWxsYmFjay4gVGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiB2YWx1ZSBvZiBlYWNoIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIga2V5cyA9IFtcbiAgICAgKiAgIHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LFxuICAgICAqICAgeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmluZGV4Qnkoa2V5cywgJ2RpcicpO1xuICAgICAqIC8vID0+IHsgJ2xlZnQnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ3JpZ2h0JzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmluZGV4Qnkoa2V5cywgZnVuY3Rpb24oa2V5KSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleS5jb2RlKTsgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGtleSkgeyB0aGlzLmZyb21DaGFyQ29kZShrZXkuY29kZSk7IH0sIFN0cmluZyk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqL1xuICAgIHZhciBpbmRleEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgbmFtZWQgYnkgYG1ldGhvZE5hbWVgIG9uIGVhY2ggZWxlbWVudCBpbiB0aGUgYGNvbGxlY3Rpb25gXG4gICAgICogcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuIEFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogd2lsbCBiZSBwcm92aWRlZCB0byBlYWNoIGludm9rZWQgbWV0aG9kLiBJZiBgbWV0aG9kTmFtZWAgaXMgYSBmdW5jdGlvbiBpdFxuICAgICAqIHdpbGwgYmUgaW52b2tlZCBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiB0aGUgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvclxuICAgICAqICB0aGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52b2tlKFtbNSwgMSwgN10sIFszLCAyLCAxXV0sICdzb3J0Jyk7XG4gICAgICogLy8gPT4gW1sxLCA1LCA3XSwgWzEsIDIsIDNdXVxuICAgICAqXG4gICAgICogXy5pbnZva2UoWzEyMywgNDU2XSwgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgJycpO1xuICAgICAqIC8vID0+IFtbJzEnLCAnMicsICczJ10sIFsnNCcsICc1JywgJzYnXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZva2UoY29sbGVjdGlvbiwgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDIpLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNGdW5jID0gdHlwZW9mIG1ldGhvZE5hbWUgPT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiAwKTtcblxuICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSAoaXNGdW5jID8gbWV0aG9kTmFtZSA6IHZhbHVlW21ldGhvZE5hbWVdKS5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgKiB0aHJvdWdoIHRoZSBjYWxsYmFjay4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBjb2xsZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICogMzsgfSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDldXG4gICAgICpcbiAgICAgKiBfLm1hcCh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9LCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAqIDM7IH0pO1xuICAgICAqIC8vID0+IFszLCA2LCA5XSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAoY2hhcmFjdGVycywgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXN1bHRbKytpbmRleF0gPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBhIGNvbGxlY3Rpb24uIElmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5IG9yXG4gICAgICogZmFsc2V5IGAtSW5maW5pdHlgIGlzIHJldHVybmVkLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWRcbiAgICAgKiBmb3IgZWFjaCB2YWx1ZSBpbiB0aGUgY29sbGVjdGlvbiB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZVxuICAgICAqIGlzIHJhbmtlZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1heChbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXgoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7IHJldHVybiBjaHIuYWdlOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWF4KGNoYXJhY3RlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXgoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgICByZXN1bHQgPSBjb21wdXRlZDtcblxuICAgICAgLy8gYWxsb3dzIHdvcmtpbmcgd2l0aCBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgIHdpdGhvdXQgdXNpbmdcbiAgICAgIC8vIHRoZWlyIGBpbmRleGAgYXJndW1lbnQgYXMgYSBjYWxsYmFja1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgJiYgdGhpc0FyZ1tjYWxsYmFja10gPT09IGNvbGxlY3Rpb24pIHtcbiAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrID09IG51bGwgJiYgaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgaWYgKHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gKGNhbGxiYWNrID09IG51bGwgJiYgaXNTdHJpbmcoY29sbGVjdGlvbikpXG4gICAgICAgICAgPyBjaGFyQXRDYWxsYmFja1xuICAgICAgICAgIDogbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICBpZiAoY3VycmVudCA+IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICBjb21wdXRlZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYSBjb2xsZWN0aW9uLiBJZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eSBvclxuICAgICAqIGZhbHNleSBgSW5maW5pdHlgIGlzIHJldHVybmVkLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWRcbiAgICAgKiBmb3IgZWFjaCB2YWx1ZSBpbiB0aGUgY29sbGVjdGlvbiB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZVxuICAgICAqIGlzIHJhbmtlZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1pbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5taW4oY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7IHJldHVybiBjaHIuYWdlOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5taW4oY2hhcmFjdGVycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH07XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBJbmZpbml0eSxcbiAgICAgICAgICByZXN1bHQgPSBjb21wdXRlZDtcblxuICAgICAgLy8gYWxsb3dzIHdvcmtpbmcgd2l0aCBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgIHdpdGhvdXQgdXNpbmdcbiAgICAgIC8vIHRoZWlyIGBpbmRleGAgYXJndW1lbnQgYXMgYSBjYWxsYmFja1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgJiYgdGhpc0FyZ1tjYWxsYmFja10gPT09IGNvbGxlY3Rpb24pIHtcbiAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrID09IG51bGwgJiYgaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gKGNhbGxiYWNrID09IG51bGwgJiYgaXNTdHJpbmcoY29sbGVjdGlvbikpXG4gICAgICAgICAgPyBjaGFyQXRDYWxsYmFja1xuICAgICAgICAgIDogbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICBpZiAoY3VycmVudCA8IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICBjb21wdXRlZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHZhbHVlIG9mIGEgc3BlY2lmaWVkIHByb3BlcnR5IGZyb20gYWxsIGVsZW1lbnRzIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcGx1Y2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnBsdWNrKGNoYXJhY3RlcnMsICduYW1lJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgdmFyIHBsdWNrID0gbWFwO1xuXG4gICAgLyoqXG4gICAgICogUmVkdWNlcyBhIGNvbGxlY3Rpb24gdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgY2FsbGJhY2ssIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGNhbGxiYWNrIGV4ZWN1dGlvbiBjb25zdW1lcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cyBleGVjdXRpb24uIElmXG4gICAgICogYGFjY3VtdWxhdG9yYCBpcyBub3QgcHJvdmlkZWQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGNvbGxlY3Rpb24gd2lsbCBiZVxuICAgICAqIHVzZWQgYXMgdGhlIGluaXRpYWwgYGFjY3VtdWxhdG9yYCB2YWx1ZS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgICAqIGFuZCBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM7IChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZm9sZGwsIGluamVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIEluaXRpYWwgdmFsdWUgb2YgdGhlIGFjY3VtdWxhdG9yLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHN1bSA9IF8ucmVkdWNlKFsxLCAyLCAzXSwgZnVuY3Rpb24oc3VtLCBudW0pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBudW07XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogdmFyIG1hcHBlZCA9IF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCBmdW5jdGlvbihyZXN1bHQsIG51bSwga2V5KSB7XG4gICAgICogICByZXN1bHRba2V5XSA9IG51bSAqIDM7XG4gICAgICogICByZXR1cm4gcmVzdWx0O1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2LCAnYyc6IDkgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBjYWxsYmFjaywgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICAgIGlmICghY29sbGVjdGlvbikgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgICAgdmFyIG5vYWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCA0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChub2FjY3VtKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBjb2xsZWN0aW9uWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBjYWxsYmFjayhhY2N1bXVsYXRvciwgY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gbm9hY2N1bVxuICAgICAgICAgICAgPyAobm9hY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgICAgIDogY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yZWR1Y2VgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZm9sZHJcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBJbml0aWFsIHZhbHVlIG9mIHRoZSBhY2N1bXVsYXRvci5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsaXN0ID0gW1swLCAxXSwgWzIsIDNdLCBbNCwgNV1dO1xuICAgICAqIHZhciBmbGF0ID0gXy5yZWR1Y2VSaWdodChsaXN0LCBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLmNvbmNhdChiKTsgfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA1LCAyLCAzLCAwLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgICAgdmFyIG5vYWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCA0KTtcbiAgICAgIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBub2FjY3VtXG4gICAgICAgICAgPyAobm9hY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgICA6IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmZpbHRlcmAgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZWxlbWVudHMgb2YgYVxuICAgICAqIGNvbGxlY3Rpb24gdGhhdCB0aGUgY2FsbGJhY2sgZG9lcyAqKm5vdCoqIHJldHVybiB0cnVleSBmb3IuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBmYWlsZWQgdGhlIGNhbGxiYWNrIGNoZWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2RkcyA9IF8ucmVqZWN0KFsxLCAyLCAzLCA0LCA1LCA2XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVqZWN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlamVjdChjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWplY3QoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHJldHVybiBmaWx0ZXIoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAhY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIHJhbmRvbSBlbGVtZW50IG9yIGBuYCByYW5kb20gZWxlbWVudHMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbl0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEFsbG93cyB3b3JraW5nIHdpdGggZnVuY3Rpb25zIGxpa2UgYF8ubWFwYFxuICAgICAqICB3aXRob3V0IHVzaW5nIHRoZWlyIGBpbmRleGAgYXJndW1lbnRzIGFzIGBuYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBzYW1wbGUocykgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSwgMik7XG4gICAgICogLy8gPT4gWzMsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiAmJiB0eXBlb2YgY29sbGVjdGlvbi5sZW5ndGggIT0gJ251bWJlcicpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uW2Jhc2VSYW5kb20oMCwgY29sbGVjdGlvbi5sZW5ndGggLSAxKV0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc2h1ZmZsZShjb2xsZWN0aW9uKTtcbiAgICAgIHJlc3VsdC5sZW5ndGggPSBuYXRpdmVNaW4obmF0aXZlTWF4KDAsIG4pLCByZXN1bHQubGVuZ3RoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGUgRmlzaGVyLVlhdGVzXG4gICAgICogc2h1ZmZsZS4gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgc2h1ZmZsZWQgY29sbGVjdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0LCA1LCA2XSk7XG4gICAgICogLy8gPT4gWzQsIDEsIDYsIDMsIDUsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiAwKTtcblxuICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgcmFuZCA9IGJhc2VSYW5kb20oMCwgKytpbmRleCk7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSByZXN1bHRbcmFuZF07XG4gICAgICAgIHJlc3VsdFtyYW5kXSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNpemUgb2YgdGhlIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgYGNvbGxlY3Rpb24ubGVuZ3RoYCBmb3IgYXJyYXlzXG4gICAgICogYW5kIGFycmF5LWxpa2Ugb2JqZWN0cyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGBjb2xsZWN0aW9uLmxlbmd0aGAgb3IgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2l6ZShbMSwgMl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2l6ZSh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiA3XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDoga2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjYWxsYmFjayByZXR1cm5zIGEgdHJ1ZXkgdmFsdWUgZm9yICoqYW55KiogZWxlbWVudCBvZiBhXG4gICAgICogY29sbGVjdGlvbi4gVGhlIGZ1bmN0aW9uIHJldHVybnMgYXMgc29vbiBhcyBpdCBmaW5kcyBhIHBhc3NpbmcgdmFsdWUgYW5kXG4gICAgICogZG9lcyBub3QgaXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgY29sbGVjdGlvbi4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBhbnlcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlZCB0aGUgY2FsbGJhY2sgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb21lKGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb21lKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmICgocmVzdWx0ID0gY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiAhKHJlc3VsdCA9IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gICAgICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGlzIG1ldGhvZFxuICAgICAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHdpbGwgcHJlc2VydmUgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXJcbiAgICAgKiBvZiBlcXVhbCBlbGVtZW50cy4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY29sbGVjdGlvblxuICAgICAqIHdpbGwgYmUgc29ydGVkIGJ5IGVhY2ggcHJvcGVydHkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2Ygc29ydGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gTWF0aC5zaW4obnVtKTsgfSk7XG4gICAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5zaW4obnVtKTsgfSwgTWF0aCk7XG4gICAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMjYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiAzMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKF8uc29ydEJ5KGNoYXJhY3RlcnMsICdhZ2UnKSwgXy52YWx1ZXMpO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDI2XSwgWydmcmVkJywgMzBdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdXVxuICAgICAqXG4gICAgICogLy8gc29ydGluZyBieSBtdWx0aXBsZSBwcm9wZXJ0aWVzXG4gICAgICogXy5tYXAoXy5zb3J0QnkoY2hhcmFjdGVycywgWyduYW1lJywgJ2FnZSddKSwgXy52YWx1ZXMpO1xuICAgICAqIC8vID0gPiBbWydiYXJuZXknLCAyNl0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCAzMF0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0QnkoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzQXJyID0gaXNBcnJheShjYWxsYmFjayksXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheSh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDogMCk7XG5cbiAgICAgIGlmICghaXNBcnIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSByZXN1bHRbKytpbmRleF0gPSBnZXRPYmplY3QoKTtcbiAgICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgICAgb2JqZWN0LmNyaXRlcmlhID0gbWFwKGNhbGxiYWNrLCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIChvYmplY3QuY3JpdGVyaWEgPSBnZXRBcnJheSgpKVswXSA9IGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC5pbmRleCA9IGluZGV4O1xuICAgICAgICBvYmplY3QudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuICAgICAgcmVzdWx0LnNvcnQoY29tcGFyZUFzY2VuZGluZyk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHJlc3VsdFtsZW5ndGhdO1xuICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IG9iamVjdC52YWx1ZTtcbiAgICAgICAgaWYgKCFpc0Fycikge1xuICAgICAgICAgIHJlbGVhc2VBcnJheShvYmplY3QuY3JpdGVyaWEpO1xuICAgICAgICB9XG4gICAgICAgIHJlbGVhc2VPYmplY3Qob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGBjb2xsZWN0aW9uYCB0byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGNvbnZlcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogKGZ1bmN0aW9uKCkgeyByZXR1cm4gXy50b0FycmF5KGFyZ3VtZW50cykuc2xpY2UoMSk7IH0pKDEsIDIsIDMsIDQpO1xuICAgICAqIC8vID0+IFsyLCAzLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQXJyYXkoY29sbGVjdGlvbikge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gJiYgdHlwZW9mIGNvbGxlY3Rpb24ubGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBzbGljZShjb2xsZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gb2YgZWFjaCBlbGVtZW50IGluIGEgYGNvbGxlY3Rpb25gIHRvIHRoZSBnaXZlblxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHMgdGhhdCBoYXZlIGVxdWl2YWxlbnRcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBnaXZlbiBwcm9wZXJ0aWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAncGV0cyc6IFsnaG9wcHknXSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdwZXRzJzogWydiYWJ5IHB1c3MnLCAnZGlubyddIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy53aGVyZShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdwZXRzJzogWydob3BweSddIH1dXG4gICAgICpcbiAgICAgKiBfLndoZXJlKGNoYXJhY3RlcnMsIHsgJ3BldHMnOiBbJ2Rpbm8nXSB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XVxuICAgICAqL1xuICAgIHZhciB3aGVyZSA9IGZpbHRlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxuICAgICAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBhbGwgZmFsc2V5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgdmFsdWVzIG9mIHRoZSBwcm92aWRlZCBhcnJheXMgdXNpbmcgc3RyaWN0XG4gICAgICogZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSBhcnJheXMgb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlKFsxLCAyLCAzLCA0LCA1XSwgWzUsIDIsIDEwXSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlmZmVyZW5jZShhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgdGhhdCBwYXNzZXMgdGhlIGNhbGxiYWNrIGNoZWNrLCBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZEluZGV4KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCAyMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRJbmRleChjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRJbmRleChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEluZGV4KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPiAzMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEluZGV4KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KSkge1xuICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9yIGZpcnN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYSBjYWxsYmFja1xuICAgICAqIGlzIHByb3ZpZGVkIGVsZW1lbnRzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGFyZSByZXR1cm5lZCBhcyBsb25nXG4gICAgICogYXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgaGVhZCwgdGFrZVxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8bnVtYmVyfHN0cmluZ30gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmV0dXJuLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICAgKiAgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIlxuICAgICAqICBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50KHMpIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmlyc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmZpcnN0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmZpcnN0KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtIDwgMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmlyc3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICdzbGF0ZScgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5maXJzdChjaGFyYWN0ZXJzLCB7ICdlbXBsb3llcic6ICdzbGF0ZScgfSksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlyc3QoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gY2FsbGJhY2s7XG4gICAgICAgIGlmIChuID09IG51bGwgfHwgdGhpc0FyZykge1xuICAgICAgICAgIHJldHVybiBhcnJheSA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIDAsIG5hdGl2ZU1pbihuYXRpdmVNYXgoMCwgbiksIGxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGEgbmVzdGVkIGFycmF5ICh0aGUgbmVzdGluZyBjYW4gYmUgdG8gYW55IGRlcHRoKS4gSWYgYGlzU2hhbGxvd2BcbiAgICAgKiBpcyB0cnVleSwgdGhlIGFycmF5IHdpbGwgb25seSBiZSBmbGF0dGVuZWQgYSBzaW5nbGUgbGV2ZWwuIElmIGEgY2FsbGJhY2tcbiAgICAgKiBpcyBwcm92aWRlZCBlYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5IGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBjYWxsYmFjayBiZWZvcmVcbiAgICAgKiBmbGF0dGVuaW5nLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2hhbGxvdz1mYWxzZV0gQSBmbGFnIHRvIHJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYSBzaW5nbGUgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyXSwgWzMsIFtbNF1dXV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XTtcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzJdLCBbMywgW1s0XV1dXSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFtbNF1dXTtcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzAsICdwZXRzJzogWydob3BweSddIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ3BldHMnOiBbJ2JhYnkgcHVzcycsICdkaW5vJ10gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZsYXR0ZW4oY2hhcmFjdGVycywgJ3BldHMnKTtcbiAgICAgKiAvLyA9PiBbJ2hvcHB5JywgJ2JhYnkgcHVzcycsICdkaW5vJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5LCBpc1NoYWxsb3csIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAvLyBqdWdnbGUgYXJndW1lbnRzXG4gICAgICBpZiAodHlwZW9mIGlzU2hhbGxvdyAhPSAnYm9vbGVhbicgJiYgaXNTaGFsbG93ICE9IG51bGwpIHtcbiAgICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9ICh0eXBlb2YgaXNTaGFsbG93ICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2lzU2hhbGxvd10gPT09IGFycmF5KSA/IG51bGwgOiBpc1NoYWxsb3c7XG4gICAgICAgIGlzU2hhbGxvdyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgYXJyYXkgPSBtYXAoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihhcnJheSwgaXNTaGFsbG93KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIHVzaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgdGhlIGFycmF5IGlzIGFscmVhZHkgc29ydGVkXG4gICAgICogcHJvdmlkaW5nIGB0cnVlYCBmb3IgYGZyb21JbmRleGAgd2lsbCBydW4gYSBmYXN0ZXIgYmluYXJ5IHNlYXJjaC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtib29sZWFufG51bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20gb3IgYHRydWVgXG4gICAgICogIHRvIHBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG9uIGEgc29ydGVkIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIsIDMpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMSwgMiwgMiwgMywgM10sIDIsIHRydWUpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heCgwLCBsZW5ndGggKyBmcm9tSW5kZXgpIDogZnJvbUluZGV4IHx8IDApO1xuICAgICAgfSBlbHNlIGlmIChmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2luZGV4XSA9PT0gdmFsdWUgPyBpbmRleCA6IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvciBsYXN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYVxuICAgICAqIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGVsZW1lbnRzIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5IGFyZSBleGNsdWRlZCBmcm9tXG4gICAgICogdGhlIHJlc3VsdCBhcyBsb25nIGFzIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmRcbiAgICAgKiB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxudW1iZXJ8c3RyaW5nfSBbY2FsbGJhY2s9MV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGV4Y2x1ZGUuIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgICAqICBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSA+IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdibG9ja2VkJzogZmFsc2UsICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICduYScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmluaXRpYWwoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmluaXRpYWwoY2hhcmFjdGVycywgeyAnZW1wbG95ZXInOiAnbmEnIH0pLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHdoaWxlIChpbmRleC0tICYmIGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IChjYWxsYmFjayA9PSBudWxsIHx8IHRoaXNBcmcpID8gMSA6IGNhbGxiYWNrIHx8IG47XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIDAsIG5hdGl2ZU1pbihuYXRpdmVNYXgoMCwgbGVuZ3RoIC0gbiksIGxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyBwcmVzZW50IGluIGFsbCBwcm92aWRlZCBhcnJheXMgdXNpbmdcbiAgICAgKiBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheV0gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBzaGFyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbihbMSwgMiwgM10sIFs1LCAyLCAxLCA0XSwgWzIsIDFdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgIGNhY2hlcyA9IGdldEFycmF5KCksXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICB0cnVzdEluZGV4T2YgPSBpbmRleE9mID09PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICBzZWVuID0gZ2V0QXJyYXkoKTtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbYXJnc0luZGV4XTtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkge1xuICAgICAgICAgIGFyZ3MucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgY2FjaGVzLnB1c2godHJ1c3RJbmRleE9mICYmIHZhbHVlLmxlbmd0aCA+PSBsYXJnZUFycmF5U2l6ZSAmJlxuICAgICAgICAgICAgY3JlYXRlQ2FjaGUoYXJnc0luZGV4ID8gYXJnc1thcmdzSW5kZXhdIDogc2VlbikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgYXJyYXkgPSBhcmdzWzBdLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IGNhY2hlc1swXTtcbiAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cbiAgICAgICAgaWYgKChjYWNoZSA/IGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIDogaW5kZXhPZihzZWVuLCB2YWx1ZSkpIDwgMCkge1xuICAgICAgICAgIGFyZ3NJbmRleCA9IGFyZ3NMZW5ndGg7XG4gICAgICAgICAgKGNhY2hlIHx8IHNlZW4pLnB1c2godmFsdWUpO1xuICAgICAgICAgIHdoaWxlICgtLWFyZ3NJbmRleCkge1xuICAgICAgICAgICAgY2FjaGUgPSBjYWNoZXNbYXJnc0luZGV4XTtcbiAgICAgICAgICAgIGlmICgoY2FjaGUgPyBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSA6IGluZGV4T2YoYXJnc1thcmdzSW5kZXhdLCB2YWx1ZSkpIDwgMCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoYXJnc0xlbmd0aC0tKSB7XG4gICAgICAgIGNhY2hlID0gY2FjaGVzW2FyZ3NMZW5ndGhdO1xuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICByZWxlYXNlT2JqZWN0KGNhY2hlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVsZWFzZUFycmF5KGNhY2hlcyk7XG4gICAgICByZWxlYXNlQXJyYXkoc2Vlbik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvciBsYXN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYSBjYWxsYmFjayBpc1xuICAgICAqIHByb3ZpZGVkIGVsZW1lbnRzIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5IGFyZSByZXR1cm5lZCBhcyBsb25nIGFzIHRoZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fG51bWJlcnxzdHJpbmd9IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJldHVybi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yXG4gICAgICogIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50KHMpIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtID4gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5sYXN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5sYXN0KGNoYXJhY3RlcnMsIHsgJ2VtcGxveWVyJzogJ25hJyB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAnZW1wbG95ZXInOiAnbmEnIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKGluZGV4LS0gJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gY2FsbGJhY2s7XG4gICAgICAgIGlmIChuID09IG51bGwgfHwgdGhpc0FyZykge1xuICAgICAgICAgIHJldHVybiBhcnJheSA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIG5hdGl2ZU1heCgwLCBsZW5ndGggLSBuKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIHVzaW5nIHN0cmljdFxuICAgICAqIGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0IGlzIHVzZWRcbiAgICAgKiBhcyB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMiwgMyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgaW5kZXggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KDAsIGluZGV4ICsgZnJvbUluZGV4KSA6IG5hdGl2ZU1pbihmcm9tSW5kZXgsIGluZGV4IC0gMSkpICsgMTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgcHJvdmlkZWQgdmFsdWVzIGZyb20gdGhlIGdpdmVuIGFycmF5IHVzaW5nIHN0cmljdCBlcXVhbGl0eSBmb3JcbiAgICAgKiBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlXSBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDEsIDIsIDNdO1xuICAgICAqIF8ucHVsbChhcnJheSwgMiwgMyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGwoYXJyYXkpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IDAsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgtLSwgMSk7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxuICAgICAqIGBzdGFydGAgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgYGVuZGAuIElmIGBzdGFydGAgaXMgbGVzcyB0aGFuIGBzdG9wYCBhXG4gICAgICogemVyby1sZW5ndGggcmFuZ2UgaXMgY3JlYXRlZCB1bmxlc3MgYSBuZWdhdGl2ZSBgc3RlcGAgaXMgc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgcmFuZ2UgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoNCk7XG4gICAgICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgICAgIHN0ZXAgPSB0eXBlb2Ygc3RlcCA9PSAnbnVtYmVyJyA/IHN0ZXAgOiAoK3N0ZXAgfHwgMSk7XG5cbiAgICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgLy8gdXNlIGBBcnJheShsZW5ndGgpYCBzbyBlbmdpbmVzIGxpa2UgQ2hha3JhIGFuZCBWOCBhdm9pZCBzbG93ZXIgbW9kZXNcbiAgICAgIC8vIGh0dHA6Ly95b3V0dS5iZS9YQXFJcEdVOFpaayN0PTE3bTI1c1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KDAsIGNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHN0YXJ0O1xuICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGFuIGFycmF5IHRoYXQgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkgZm9yXG4gICAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgICAqIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0LCA1LCA2XTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZXZlbnMpO1xuICAgICAqIC8vID0+IFsyLCA0LCA2XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZShhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LS0sIDEpO1xuICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5pbml0aWFsYCB0aGlzIG1ldGhvZCBnZXRzIGFsbCBidXQgdGhlIGZpcnN0IGVsZW1lbnQgb3JcbiAgICAgKiBmaXJzdCBgbmAgZWxlbWVudHMgb2YgYW4gYXJyYXkuIElmIGEgY2FsbGJhY2sgZnVuY3Rpb24gaXMgcHJvdmlkZWQgZWxlbWVudHNcbiAgICAgKiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheSBhcmUgZXhjbHVkZWQgZnJvbSB0aGUgcmVzdWx0IGFzIGxvbmcgYXMgdGhlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyB0cnVleS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBkcm9wLCB0YWlsXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxudW1iZXJ8c3RyaW5nfSBbY2FsbGJhY2s9MV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGV4Y2x1ZGUuIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgICAqICBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJlc3QoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8ucmVzdChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSA8IDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdibG9ja2VkJzogZmFsc2UsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICduYScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8ucmVzdChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVzdChjaGFyYWN0ZXJzLCB7ICdlbXBsb3llcic6ICdzbGF0ZScgfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgJ2VtcGxveWVyJzogJ25hJyB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3QoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IChjYWxsYmFjayA9PSBudWxsIHx8IHRoaXNBcmcpID8gMSA6IG5hdGl2ZU1heCgwLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2ggYSB2YWx1ZVxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGEgZ2l2ZW4gc29ydGVkIGFycmF5IGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBzb3J0XG4gICAgICogb3JkZXIgb2YgdGhlIGFycmF5LiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgZm9yXG4gICAgICogYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZVxuICAgICAqIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFsyMCwgMzAsIDUwXSwgNDApO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29ydGVkSW5kZXgoW3sgJ3gnOiAyMCB9LCB7ICd4JzogMzAgfSwgeyAneCc6IDUwIH1dLCB7ICd4JzogNDAgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiB2YXIgZGljdCA9IHtcbiAgICAgKiAgICd3b3JkVG9OdW1iZXInOiB7ICd0d2VudHknOiAyMCwgJ3RoaXJ0eSc6IDMwLCAnZm91cnR5JzogNDAsICdmaWZ0eSc6IDUwIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbJ3R3ZW50eScsICd0aGlydHknLCAnZmlmdHknXSwgJ2ZvdXJ0eScsIGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgKiAgIHJldHVybiBkaWN0LndvcmRUb051bWJlclt3b3JkXTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFsndHdlbnR5JywgJ3RoaXJ0eScsICdmaWZ0eSddLCAnZm91cnR5JywgZnVuY3Rpb24od29yZCkge1xuICAgICAqICAgcmV0dXJuIHRoaXMud29yZFRvTnVtYmVyW3dvcmRdO1xuICAgICAqIH0sIGRpY3QpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiBsb3c7XG5cbiAgICAgIC8vIGV4cGxpY2l0bHkgcmVmZXJlbmNlIGBpZGVudGl0eWAgZm9yIGJldHRlciBpbmxpbmluZyBpbiBGaXJlZm94XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAxKSA6IGlkZW50aXR5O1xuICAgICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSk7XG5cbiAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDE7XG4gICAgICAgIChjYWxsYmFjayhhcnJheVttaWRdKSA8IHZhbHVlKVxuICAgICAgICAgID8gbG93ID0gbWlkICsgMVxuICAgICAgICAgIDogaGlnaCA9IG1pZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb3c7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgb2YgdGhlIHByb3ZpZGVkIGFycmF5cyB1c2luZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5XSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbihbMSwgMiwgM10sIFs1LCAyLCAxLCA0XSwgWzIsIDFdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNSwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlvbigpIHtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgdmVyc2lvbiBvZiBhbiBhcnJheSB1c2luZyBzdHJpY3QgZXF1YWxpdHlcbiAgICAgKiBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIHRoZSBhcnJheSBpcyBzb3J0ZWQsIHByb3ZpZGluZ1xuICAgICAqIGB0cnVlYCBmb3IgYGlzU29ydGVkYCB3aWxsIHVzZSBhIGZhc3RlciBhbGdvcml0aG0uIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWRcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBpcyBwYXNzZWQgdGhyb3VnaCB0aGUgY2FsbGJhY2sgYmVmb3JlIHVuaXF1ZW5lc3NcbiAgICAgKiBpcyBjb21wdXRlZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyB1bmlxdWVcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTb3J0ZWQ9ZmFsc2VdIEEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IGBhcnJheWAgaXMgc29ydGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcShbMSwgMiwgMSwgMywgMV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAxLCAyLCAyLCAzXSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWydBJywgJ2InLCAnQycsICdhJywgJ0InLCAnYyddLCBmdW5jdGlvbihsZXR0ZXIpIHsgcmV0dXJuIGxldHRlci50b0xvd2VyQ2FzZSgpOyB9KTtcbiAgICAgKiAvLyA9PiBbJ0EnLCAnYicsICdDJ11cbiAgICAgKlxuICAgICAqIF8udW5pcShbMSwgMi41LCAzLCAxLjUsIDIsIDMuNV0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5mbG9vcihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbMSwgMi41LCAzXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy51bmlxKFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxKGFycmF5LCBpc1NvcnRlZCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIC8vIGp1Z2dsZSBhcmd1bWVudHNcbiAgICAgIGlmICh0eXBlb2YgaXNTb3J0ZWQgIT0gJ2Jvb2xlYW4nICYmIGlzU29ydGVkICE9IG51bGwpIHtcbiAgICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9ICh0eXBlb2YgaXNTb3J0ZWQgIT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnICYmIHRoaXNBcmdbaXNTb3J0ZWRdID09PSBhcnJheSkgPyBudWxsIDogaXNTb3J0ZWQ7XG4gICAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIHByb3ZpZGVkIHZhbHVlcyB1c2luZyBzdHJpY3QgZXF1YWxpdHkgZm9yXG4gICAgICogY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbHRlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZV0gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud2l0aG91dChbMSwgMiwgMSwgMCwgMywgMSwgNF0sIDAsIDEpO1xuICAgICAqIC8vID0+IFsyLCAzLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdpdGhvdXQoYXJyYXkpIHtcbiAgICAgIHJldHVybiBiYXNlRGlmZmVyZW5jZShhcnJheSwgc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBzeW1tZXRyaWMgZGlmZmVyZW5jZSBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzLlxuICAgICAqIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bW1ldHJpY19kaWZmZXJlbmNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheV0gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yKFsxLCAyLCAzXSwgWzUsIDIsIDEsIDRdKTtcbiAgICAgKiAvLyA9PiBbMywgNSwgNF1cbiAgICAgKlxuICAgICAqIF8ueG9yKFsxLCAyLCA1XSwgWzIsIDMsIDVdLCBbMywgNCwgNV0pO1xuICAgICAqIC8vID0+IFsxLCA0LCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHhvcigpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIGlmIChpc0FycmF5KGFycmF5KSB8fCBpc0FyZ3VtZW50cyhhcnJheSkpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0XG4gICAgICAgICAgICA/IGJhc2VVbmlxKGJhc2VEaWZmZXJlbmNlKHJlc3VsdCwgYXJyYXkpLmNvbmNhdChiYXNlRGlmZmVyZW5jZShhcnJheSwgcmVzdWx0KSkpXG4gICAgICAgICAgICA6IGFycmF5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0IHx8IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cywgdGhlIGZpcnN0IG9mIHdoaWNoIGNvbnRhaW5zIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIHRoZSBzZWNvbmQgb2Ygd2hpY2ggY29udGFpbnMgdGhlIHNlY29uZFxuICAgICAqIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyB1bnppcFxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXldIEFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcChbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydmcmVkJywgMzAsIHRydWVdLCBbJ2Jhcm5leScsIDQwLCBmYWxzZV1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwKCkge1xuICAgICAgdmFyIGFycmF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHMgOiBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IG1heChwbHVjayhhcnJheSwgJ2xlbmd0aCcpKSA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gcGx1Y2soYXJyYXksIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgZnJvbSBhcnJheXMgb2YgYGtleXNgIGFuZCBgdmFsdWVzYC4gUHJvdmlkZVxuICAgICAqIGVpdGhlciBhIHNpbmdsZSB0d28gZGltZW5zaW9uYWwgYXJyYXksIGkuZS4gYFtba2V5MSwgdmFsdWUxXSwgW2tleTIsIHZhbHVlMl1dYFxuICAgICAqIG9yIHR3byBhcnJheXMsIG9uZSBvZiBga2V5c2AgYW5kIG9uZSBvZiBjb3JyZXNwb25kaW5nIGB2YWx1ZXNgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIG9iamVjdFxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIFRoZSBhcnJheSBvZiBrZXlzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGdpdmVuIGtleXMgYW5kXG4gICAgICogIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdChbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogMzAsICdiYXJuZXknOiA0MCB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0KGtleXMsIHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0ga2V5cyA/IGtleXMubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgaWYgKCF2YWx1ZXMgJiYgbGVuZ3RoICYmICFpc0FycmF5KGtleXNbMF0pKSB7XG4gICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSkge1xuICAgICAgICAgIHJlc3VsdFtrZXlbMF1dID0ga2V5WzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgYGZ1bmNgLCB3aXRoICB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kXG4gICAgICogYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCBvbmx5IGFmdGVyIGJlaW5nIGNhbGxlZCBgbmAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgYmVmb3JlXG4gICAgICogIGBmdW5jYCBpcyBleGVjdXRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F2ZXMgPSBbJ3Byb2ZpbGUnLCAnc2V0dGluZ3MnXTtcbiAgICAgKlxuICAgICAqIHZhciBkb25lID0gXy5hZnRlcihzYXZlcy5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgICAqICAgY29uc29sZS5sb2coJ0RvbmUgc2F2aW5nIScpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHNhdmVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICogICBhc3luY1NhdmUoeyAndHlwZSc6IHR5cGUsICdjb21wbGV0ZSc6IGRvbmUgfSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnRG9uZSBzYXZpbmchJywgYWZ0ZXIgYWxsIHNhdmVzIGhhdmUgY29tcGxldGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWZ0ZXIobiwgZnVuYykge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCBwcmVwZW5kcyBhbnkgYWRkaXRpb25hbCBgYmluZGAgYXJndW1lbnRzIHRvIHRob3NlXG4gICAgICogcHJvdmlkZWQgdG8gdGhlIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBmdW5jdGlvbihncmVldGluZykge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy5uYW1lO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBmdW5jID0gXy5iaW5kKGZ1bmMsIHsgJ25hbWUnOiAnZnJlZCcgfSwgJ2hpJyk7XG4gICAgICogZnVuYygpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmQoZnVuYywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyXG4gICAgICAgID8gY3JlYXRlV3JhcHBlcihmdW5jLCAxNywgc2xpY2UoYXJndW1lbnRzLCAyKSwgbnVsbCwgdGhpc0FyZylcbiAgICAgICAgOiBjcmVhdGVXcmFwcGVyKGZ1bmMsIDEsIG51bGwsIG51bGwsIHRoaXNBcmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJpbmRzIG1ldGhvZHMgb2YgYW4gb2JqZWN0IHRvIHRoZSBvYmplY3QgaXRzZWxmLCBvdmVyd3JpdGluZyB0aGUgZXhpc3RpbmdcbiAgICAgKiBtZXRob2QuIE1ldGhvZCBuYW1lcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5c1xuICAgICAqIG9mIG1ldGhvZCBuYW1lcy4gSWYgbm8gbWV0aG9kIG5hbWVzIGFyZSBwcm92aWRlZCBhbGwgdGhlIGZ1bmN0aW9uIHByb3BlcnRpZXNcbiAgICAgKiBvZiBgb2JqZWN0YCB3aWxsIGJlIGJvdW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiaW5kIGFuZCBhc3NpZ24gdGhlIGJvdW5kIG1ldGhvZHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi5zdHJpbmd9IFttZXRob2ROYW1lXSBUaGUgb2JqZWN0IG1ldGhvZCBuYW1lcyB0b1xuICAgICAqICBiaW5kLCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBtZXRob2QgbmFtZXMgb3IgYXJyYXlzIG9mIG1ldGhvZCBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgICdvbkNsaWNrJzogZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKCdjbGlja2VkICcgKyB0aGlzLmxhYmVsKTsgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmJpbmRBbGwodmlldyk7XG4gICAgICogalF1ZXJ5KCcjZG9jcycpLm9uKCdjbGljaycsIHZpZXcub25DbGljayk7XG4gICAgICogLy8gPT4gbG9ncyAnY2xpY2tlZCBkb2NzJywgd2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kQWxsKG9iamVjdCkge1xuICAgICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIGZhbHNlLCAxKSA6IGZ1bmN0aW9ucyhvYmplY3QpLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZnVuY3MubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gZnVuY3NbaW5kZXhdO1xuICAgICAgICBvYmplY3Rba2V5XSA9IGNyZWF0ZVdyYXBwZXIob2JqZWN0W2tleV0sIDEsIG51bGwsIG51bGwsIG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBvYmplY3Rba2V5XWBcbiAgICAgKiBhbmQgcHJlcGVuZHMgYW55IGFkZGl0aW9uYWwgYGJpbmRLZXlgIGFyZ3VtZW50cyB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYm91bmRcbiAgICAgKiBmdW5jdGlvbi4gVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0b1xuICAgICAqIHJlZmVyZW5jZSBtZXRob2RzIHRoYXQgd2lsbCBiZSByZWRlZmluZWQgb3IgZG9uJ3QgeWV0IGV4aXN0LlxuICAgICAqIFNlZSBodHRwOi8vbWljaGF1eC5jYS9hcnRpY2xlcy9sYXp5LWZ1bmN0aW9uLWRlZmluaXRpb24tcGF0dGVybi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdGhlIG1ldGhvZCBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ25hbWUnOiAnZnJlZCcsXG4gICAgICogICAnZ3JlZXQnOiBmdW5jdGlvbihncmVldGluZykge1xuICAgICAqICAgICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLm5hbWU7XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgJ2hpJyk7XG4gICAgICogZnVuYygpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqXG4gICAgICogb2JqZWN0LmdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICd5YSAnICsgdGhpcy5uYW1lICsgJyEnO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBmdW5jKCk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZEtleShvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyXG4gICAgICAgID8gY3JlYXRlV3JhcHBlcihrZXksIDE5LCBzbGljZShhcmd1bWVudHMsIDIpLCBudWxsLCBvYmplY3QpXG4gICAgICAgIDogY3JlYXRlV3JhcHBlcihrZXksIDMsIG51bGwsIG51bGwsIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbnMsXG4gICAgICogd2hlcmUgZWFjaCBmdW5jdGlvbiBjb25zdW1lcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gICAgICogRm9yIGV4YW1wbGUsIGNvbXBvc2luZyB0aGUgZnVuY3Rpb25zIGBmKClgLCBgZygpYCwgYW5kIGBoKClgIHByb2R1Y2VzIGBmKGcoaCgpKSlgLlxuICAgICAqIEVhY2ggZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNvbXBvc2VkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IFtmdW5jXSBGdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHJlYWxOYW1lTWFwID0ge1xuICAgICAqICAgJ3BlYmJsZXMnOiAncGVuZWxvcGUnXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBmb3JtYXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICogICBuYW1lID0gcmVhbE5hbWVNYXBbbmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBuYW1lO1xuICAgICAqICAgcmV0dXJuIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBncmVldCA9IGZ1bmN0aW9uKGZvcm1hdHRlZCkge1xuICAgICAqICAgcmV0dXJuICdIaXlhICcgKyBmb3JtYXR0ZWQgKyAnISc7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciB3ZWxjb21lID0gXy5jb21wb3NlKGdyZWV0LCBmb3JtYXQpO1xuICAgICAqIHdlbGNvbWUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnSGl5YSBQZW5lbG9wZSEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgICAgIHZhciBmdW5jcyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBsZW5ndGggPSBmdW5jcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuY3NbbGVuZ3RoXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgbGVuZ3RoID0gZnVuY3MubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3MgPSBbZnVuY3NbbGVuZ3RoXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB3aGljaCBhY2NlcHRzIG9uZSBvciBtb3JlIGFyZ3VtZW50cyBvZiBgZnVuY2AgdGhhdCB3aGVuXG4gICAgICogaW52b2tlZCBlaXRoZXIgZXhlY3V0ZXMgYGZ1bmNgIHJldHVybmluZyBpdHMgcmVzdWx0LCBpZiBhbGwgYGZ1bmNgIGFyZ3VtZW50c1xuICAgICAqIGhhdmUgYmVlbiBwcm92aWRlZCwgb3IgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmUgb3IgbW9yZSBvZiB0aGVcbiAgICAgKiByZW1haW5pbmcgYGZ1bmNgIGFyZ3VtZW50cywgYW5kIHNvIG9uLiBUaGUgYXJpdHkgb2YgYGZ1bmNgIGNhbiBiZSBzcGVjaWZpZWRcbiAgICAgKiBpZiBgZnVuYy5sZW5ndGhgIGlzIG5vdCBzdWZmaWNpZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGEgKyBiICsgYyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEpKDIpKDMpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMikoMyk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHkpIHtcbiAgICAgIGFyaXR5ID0gdHlwZW9mIGFyaXR5ID09ICdudW1iZXInID8gYXJpdHkgOiAoK2FyaXR5IHx8IGZ1bmMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIDQsIG51bGwsIG51bGwsIG51bGwsIGFyaXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGRlbGF5IHRoZSBleGVjdXRpb24gb2YgYGZ1bmNgIHVudGlsIGFmdGVyXG4gICAgICogYHdhaXRgIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSBpdCB3YXMgaW52b2tlZC5cbiAgICAgKiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvIGluZGljYXRlIHRoYXQgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uXG4gICAgICogdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBTdWJzZXF1ZW50IGNhbGxzXG4gICAgICogdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBjYWxsLlxuICAgICAqXG4gICAgICogTm90ZTogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCBgZnVuY2Agd2lsbCBiZSBjYWxsZWRcbiAgICAgKiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIGlzXG4gICAgICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF0gVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGNhbGxlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eFxuICAgICAqIHZhciBsYXp5TGF5b3V0ID0gXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCk7XG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIGxhenlMYXlvdXQpO1xuICAgICAqXG4gICAgICogLy8gZXhlY3V0ZSBgc2VuZE1haWxgIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHNcbiAgICAgKiBqUXVlcnkoJyNwb3N0Ym94Jykub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gICAgICogICAnbGVhZGluZyc6IHRydWUsXG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gZW5zdXJlIGBiYXRjaExvZ2AgaXMgZXhlY3V0ZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHNcbiAgICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gICAgICogc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHtcbiAgICAgKiAgICdtYXhXYWl0JzogMTAwMFxuICAgICAqIH0sIGZhbHNlKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyxcbiAgICAgICAgICBtYXhUaW1lb3V0SWQsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHN0YW1wLFxuICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgdGltZW91dElkLFxuICAgICAgICAgIHRyYWlsaW5nQ2FsbCxcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMCxcbiAgICAgICAgICBtYXhXYWl0ID0gZmFsc2UsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHdhaXQgPSBuYXRpdmVNYXgoMCwgd2FpdCkgfHwgMDtcbiAgICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgdHJhaWxpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9IG9wdGlvbnMubGVhZGluZztcbiAgICAgICAgbWF4V2FpdCA9ICdtYXhXYWl0JyBpbiBvcHRpb25zICYmIChuYXRpdmVNYXgod2FpdCwgb3B0aW9ucy5tYXhXYWl0KSB8fCAwKTtcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgZGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3coKSAtIHN0YW1wKTtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpc0NhbGxlZCA9IHRyYWlsaW5nQ2FsbDtcbiAgICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gbm93KCk7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIG1heERlbGF5ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRyYWlsaW5nIHx8IChtYXhXYWl0ICE9PSB3YWl0KSkge1xuICAgICAgICAgIGxhc3RDYWxsZWQgPSBub3coKTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3RhbXAgPSBub3coKTtcbiAgICAgICAgdGhpc0FyZyA9IHRoaXM7XG4gICAgICAgIHRyYWlsaW5nQ2FsbCA9IHRyYWlsaW5nICYmICh0aW1lb3V0SWQgfHwgIWxlYWRpbmcpO1xuXG4gICAgICAgIGlmIChtYXhXYWl0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHZhciBsZWFkaW5nQ2FsbCA9IGxlYWRpbmcgJiYgIXRpbWVvdXRJZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW1heFRpbWVvdXRJZCAmJiAhbGVhZGluZykge1xuICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVtYWluaW5nID0gbWF4V2FpdCAtIChzdGFtcCAtIGxhc3RDYWxsZWQpLFxuICAgICAgICAgICAgICBpc0NhbGxlZCA9IHJlbWFpbmluZyA8PSAwO1xuXG4gICAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICAgIG1heFRpbWVvdXRJZCA9IGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgbWF4VGltZW91dElkID0gc2V0VGltZW91dChtYXhEZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxsZWQgJiYgdGltZW91dElkKSB7XG4gICAgICAgICAgdGltZW91dElkID0gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRpbWVvdXRJZCAmJiB3YWl0ICE9PSBtYXhXYWl0KSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcbiAgICAgICAgICBpc0NhbGxlZCA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxsZWQgJiYgIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmVycyBleGVjdXRpbmcgdGhlIGBmdW5jYCBmdW5jdGlvbiB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLlxuICAgICAqIEFkZGl0aW9uYWwgYXJndW1lbnRzIHdpbGwgYmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWZlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24odGV4dCkgeyBjb25zb2xlLmxvZyh0ZXh0KTsgfSwgJ2RlZmVycmVkJyk7XG4gICAgICogLy8gbG9ncyAnZGVmZXJyZWQnIGFmdGVyIG9uZSBvciBtb3JlIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmVyKGZ1bmMpIHtcbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGBmdW5jYCBmdW5jdGlvbiBhZnRlciBgd2FpdGAgbWlsbGlzZWNvbmRzLiBBZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAqIHdpbGwgYmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBleGVjdXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlbGF5KGZ1bmN0aW9uKHRleHQpIHsgY29uc29sZS5sb2codGV4dCk7IH0sIDEwMDAsICdsYXRlcicpO1xuICAgICAqIC8vID0+IGxvZ3MgJ2xhdGVyJyBhZnRlciBvbmUgc2Vjb25kXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVsYXkoZnVuYywgd2FpdCkge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCB3YWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICAgICAqIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0XG4gICAgICogYmFzZWQgb24gdGhlIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZVxuICAgICAqIGZpcnN0IGFyZ3VtZW50IHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBjYWNoZSBrZXkuXG4gICAgICogVGhlIGBmdW5jYCBpcyBleGVjdXRlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICogVGhlIHJlc3VsdCBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBBIGZ1bmN0aW9uIHVzZWQgdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemluZyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZpYm9uYWNjaSA9IF8ubWVtb2l6ZShmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiA8IDIgPyBuIDogZmlib25hY2NpKG4gLSAxKSArIGZpYm9uYWNjaShuIC0gMik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBmaWJvbmFjY2koOSlcbiAgICAgKiAvLyA9PiAzNFxuICAgICAqXG4gICAgICogdmFyIGRhdGEgPSB7XG4gICAgICogICAnZnJlZCc6IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIC8vIG1vZGlmeWluZyB0aGUgcmVzdWx0IGNhY2hlXG4gICAgICogdmFyIGdldCA9IF8ubWVtb2l6ZShmdW5jdGlvbihuYW1lKSB7IHJldHVybiBkYXRhW25hbWVdOyB9LCBfLmlkZW50aXR5KTtcbiAgICAgKiBnZXQoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICpcbiAgICAgKiBnZXQuY2FjaGUucGViYmxlcy5uYW1lID0gJ3BlbmVsb3BlJztcbiAgICAgKiBnZXQoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ3BlbmVsb3BlJywgJ2FnZSc6IDEgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IG1lbW9pemVkLmNhY2hlLFxuICAgICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDoga2V5UHJlZml4ICsgYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGNhY2hlLCBrZXkpXG4gICAgICAgICAgPyBjYWNoZVtrZXldXG4gICAgICAgICAgOiAoY2FjaGVba2V5XSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICB9XG4gICAgICBtZW1vaXplZC5jYWNoZSA9IHt9O1xuICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gZXhlY3V0ZSBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzIHRvXG4gICAgICogdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgY2FsbC4gVGhlIGBmdW5jYCBpcyBleGVjdXRlZFxuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIC8vIGBpbml0aWFsaXplYCBleGVjdXRlcyBgY3JlYXRlQXBwbGljYXRpb25gIG9uY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICAgIHZhciByYW4sXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJhbikge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBgZnVuY2AgdmFyaWFibGUgc28gdGhlIGZ1bmN0aW9uIG1heSBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuICAgICAgICBmdW5jID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIGBmdW5jYCB3aXRoIGFueSBhZGRpdGlvbmFsXG4gICAgICogYHBhcnRpYWxgIGFyZ3VtZW50cyBwcmVwZW5kZWQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi4gVGhpc1xuICAgICAqIG1ldGhvZCBpcyBzaW1pbGFyIHRvIGBfLmJpbmRgIGV4Y2VwdCBpdCBkb2VzICoqbm90KiogYWx0ZXIgdGhlIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBuYW1lKSB7IHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7IH07XG4gICAgICogdmFyIGhpID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGknKTtcbiAgICAgKiBoaSgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWwoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgMTYsIHNsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgYHBhcnRpYWxgIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBhcHBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0c0RlZXAgPSBfLnBhcnRpYWxSaWdodChfLm1lcmdlLCBfLmRlZmF1bHRzKTtcbiAgICAgKlxuICAgICAqIHZhciBvcHRpb25zID0ge1xuICAgICAqICAgJ3ZhcmlhYmxlJzogJ2RhdGEnLFxuICAgICAqICAgJ2ltcG9ydHMnOiB7ICdqcSc6ICQgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBkZWZhdWx0c0RlZXAob3B0aW9ucywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcbiAgICAgKlxuICAgICAqIG9wdGlvbnMudmFyaWFibGVcbiAgICAgKiAvLyA9PiAnZGF0YSdcbiAgICAgKlxuICAgICAqIG9wdGlvbnMuaW1wb3J0c1xuICAgICAqIC8vID0+IHsgJ18nOiBfLCAnanEnOiAkIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJ0aWFsUmlnaHQoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgMzIsIG51bGwsIHNsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGV4ZWN1dGVkLCB3aWxsIG9ubHkgY2FsbCB0aGUgYGZ1bmNgIGZ1bmN0aW9uXG4gICAgICogYXQgbW9zdCBvbmNlIHBlciBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvXG4gICAgICogaW5kaWNhdGUgdGhhdCBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2VcbiAgICAgKiBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsXG4gICAgICogcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGNhbGwuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgIGBmdW5jYCB3aWxsIGJlIGNhbGxlZFxuICAgICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgZXhlY3V0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZ1xuICAgICAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApO1xuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCB0aHJvdHRsZWQpO1xuICAgICAqXG4gICAgICogLy8gZXhlY3V0ZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzXG4gICAgICogalF1ZXJ5KCcuaW50ZXJhY3RpdmUnKS5vbignY2xpY2snLCBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwge1xuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgbGVhZGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlT3B0aW9ucy5sZWFkaW5nID0gbGVhZGluZztcbiAgICAgIGRlYm91bmNlT3B0aW9ucy5tYXhXYWl0ID0gd2FpdDtcbiAgICAgIGRlYm91bmNlT3B0aW9ucy50cmFpbGluZyA9IHRyYWlsaW5nO1xuXG4gICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwgZGVib3VuY2VPcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBgdmFsdWVgIHRvIHRoZSB3cmFwcGVyIGZ1bmN0aW9uIGFzIGl0c1xuICAgICAqIGZpcnN0IGFyZ3VtZW50LiBBZGRpdGlvbmFsIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24gYXJlIGFwcGVuZGVkXG4gICAgICogdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIHdyYXBwZXIgZnVuY3Rpb24uIFRoZSB3cmFwcGVyIGlzIGV4ZWN1dGVkIHdpdGhcbiAgICAgKiB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ0ZyZWQsIFdpbG1hLCAmIFBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnPHA+RnJlZCwgV2lsbWEsICZhbXA7IFBlYmJsZXM8L3A+J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXAodmFsdWUsIHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKHdyYXBwZXIsIDE2LCBbdmFsdWVdKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqIHZhciBnZXR0ZXIgPSBfLmNvbnN0YW50KG9iamVjdCk7XG4gICAgICogZ2V0dGVyKCkgPT09IG9iamVjdDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIGNhbGxiYWNrIGJvdW5kIHRvIGFuIG9wdGlvbmFsIGB0aGlzQXJnYC4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHlcbiAgICAgKiBuYW1lIHRoZSBjcmVhdGVkIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LlxuICAgICAqIElmIGBmdW5jYCBpcyBhbiBvYmplY3QgdGhlIGNyZWF0ZWQgY2FsbGJhY2sgd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50c1xuICAgICAqIHRoYXQgY29udGFpbiB0aGUgZXF1aXZhbGVudCBvYmplY3QgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHdpbGwgcmV0dXJuIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdGhlIGNhbGxiYWNrIGFjY2VwdHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gd3JhcCB0byBjcmVhdGUgY3VzdG9tIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBfLmNyZWF0ZUNhbGxiYWNrID0gXy53cmFwKF8uY3JlYXRlQ2FsbGJhY2ssIGZ1bmN0aW9uKGZ1bmMsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICogICB2YXIgbWF0Y2ggPSAvXiguKz8pX18oW2dsXXQpKC4rKSQvLmV4ZWMoY2FsbGJhY2spO1xuICAgICAqICAgcmV0dXJuICFtYXRjaCA/IGZ1bmMoY2FsbGJhY2ssIHRoaXNBcmcpIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICogICAgIHJldHVybiBtYXRjaFsyXSA9PSAnZ3QnID8gb2JqZWN0W21hdGNoWzFdXSA+IG1hdGNoWzNdIDogb2JqZWN0W21hdGNoWzFdXSA8IG1hdGNoWzNdO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKGNoYXJhY3RlcnMsICdhZ2VfX2d0MzgnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGZ1bmM7XG4gICAgICBpZiAoZnVuYyA9PSBudWxsIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gYmFzZUNyZWF0ZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KTtcbiAgICAgIH1cbiAgICAgIC8vIGhhbmRsZSBcIl8ucGx1Y2tcIiBzdHlsZSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICBpZiAodHlwZSAhPSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gcHJvcGVydHkoZnVuYyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKGZ1bmMpLFxuICAgICAgICAgIGtleSA9IHByb3BzWzBdLFxuICAgICAgICAgIGEgPSBmdW5jW2tleV07XG5cbiAgICAgIC8vIGhhbmRsZSBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICBpZiAocHJvcHMubGVuZ3RoID09IDEgJiYgYSA9PT0gYSAmJiAhaXNPYmplY3QoYSkpIHtcbiAgICAgICAgLy8gZmFzdCBwYXRoIHRoZSBjb21tb24gY2FzZSBvZiBwcm92aWRpbmcgYW4gb2JqZWN0IHdpdGggYSBzaW5nbGVcbiAgICAgICAgLy8gcHJvcGVydHkgY29udGFpbmluZyBhIHByaW1pdGl2ZSB2YWx1ZVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgdmFyIGIgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICByZXR1cm4gYSA9PT0gYiAmJiAoYSAhPT0gMCB8fCAoMSAvIGEgPT0gMSAvIGIpKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGlmICghKHJlc3VsdCA9IGJhc2VJc0VxdWFsKG9iamVjdFtwcm9wc1tsZW5ndGhdXSwgZnVuY1twcm9wc1tsZW5ndGhdXSwgbnVsbCwgdHJ1ZSkpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgYCZgLCBgPGAsIGA+YCwgYFwiYCwgYW5kIGAnYCBpbiBgc3RyaW5nYCB0byB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZSgnRnJlZCwgV2lsbWEsICYgUGViYmxlcycpO1xuICAgICAqIC8vID0+ICdGcmVkLCBXaWxtYSwgJmFtcDsgUGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nID09IG51bGwgPyAnJyA6IFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYSBzb3VyY2Ugb2JqZWN0IHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogSWYgYG9iamVjdGAgaXMgYSBmdW5jdGlvbiBtZXRob2RzIHdpbGwgYmUgYWRkZWQgdG8gaXRzIHByb3RvdHlwZSBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBbb2JqZWN0PWxvZGFzaF0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIGZ1bmN0aW9ucyB0byBhZGQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGFpbj10cnVlXSBTcGVjaWZ5IHdoZXRoZXIgdGhlIGZ1bmN0aW9ucyBhZGRlZCBhcmUgY2hhaW5hYmxlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgICAqICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAnY2FwaXRhbGl6ZSc6IGNhcGl0YWxpemUgfSk7XG4gICAgICogXy5jYXBpdGFsaXplKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICpcbiAgICAgKiBfKCdmcmVkJykuY2FwaXRhbGl6ZSgpLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ2NhcGl0YWxpemUnOiBjYXBpdGFsaXplIH0sIHsgJ2NoYWluJzogZmFsc2UgfSk7XG4gICAgICogXygnZnJlZCcpLmNhcGl0YWxpemUoKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgdmFyIGNoYWluID0gdHJ1ZSxcbiAgICAgICAgICBtZXRob2ROYW1lcyA9IHNvdXJjZSAmJiBmdW5jdGlvbnMoc291cmNlKTtcblxuICAgICAgaWYgKCFzb3VyY2UgfHwgKCFvcHRpb25zICYmICFtZXRob2ROYW1lcy5sZW5ndGgpKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGN0b3IgPSBsb2Rhc2hXcmFwcGVyO1xuICAgICAgICBzb3VyY2UgPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdCA9IGxvZGFzaDtcbiAgICAgICAgbWV0aG9kTmFtZXMgPSBmdW5jdGlvbnMoc291cmNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICBjaGFpbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSAmJiAnY2hhaW4nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgY2hhaW4gPSBvcHRpb25zLmNoYWluO1xuICAgICAgfVxuICAgICAgdmFyIGN0b3IgPSBvYmplY3QsXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihjdG9yKTtcblxuICAgICAgZm9yRWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgZnVuYyA9IG9iamVjdFttZXRob2ROYW1lXSA9IHNvdXJjZVttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKGlzRnVuYykge1xuICAgICAgICAgIGN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgICAgICAgYXJncyA9IFt2YWx1ZV07XG5cbiAgICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KG9iamVjdCwgYXJncyk7XG4gICAgICAgICAgICBpZiAoY2hhaW4gfHwgY2hhaW5BbGwpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSByZXN1bHQgJiYgaXNPYmplY3QocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBjdG9yKHJlc3VsdCk7XG4gICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgJ18nIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgIGNvbnRleHQuXyA9IG9sZERhc2g7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIG5vLW9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKiBfLm5vb3Aob2JqZWN0KSA9PT0gdW5kZWZpbmVkO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgLy8gbm8gb3BlcmF0aW9uIHBlcmZvcm1lZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIFVuaXggZXBvY2hcbiAgICAgKiAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHN0YW1wID0gXy5ub3coKTtcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApOyB9KTtcbiAgICAgKiAvLyA9PiBsb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICAgKi9cbiAgICB2YXIgbm93ID0gaXNOYXRpdmUobm93ID0gRGF0ZS5ub3cpICYmIG5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICAgICAqIElmIGByYWRpeGAgaXMgYHVuZGVmaW5lZGAgb3IgYDBgIGEgYHJhZGl4YCBvZiBgMTBgIGlzIHVzZWQgdW5sZXNzIHRoZVxuICAgICAqIGB2YWx1ZWAgaXMgYSBoZXhhZGVjaW1hbCwgaW4gd2hpY2ggY2FzZSBhIGByYWRpeGAgb2YgYDE2YCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBtZXRob2QgYXZvaWRzIGRpZmZlcmVuY2VzIGluIG5hdGl2ZSBFUzMgYW5kIEVTNSBgcGFyc2VJbnRgXG4gICAgICogaW1wbGVtZW50YXRpb25zLiBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI0UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBwYXJzZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl4XSBUaGUgcmFkaXggdXNlZCB0byBpbnRlcnByZXQgdGhlIHZhbHVlIHRvIHBhcnNlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG5ldyBpbnRlZ2VyIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKi9cbiAgICB2YXIgcGFyc2VJbnQgPSBuYXRpdmVQYXJzZUludCh3aGl0ZXNwYWNlICsgJzA4JykgPT0gOCA/IG5hdGl2ZVBhcnNlSW50IDogZnVuY3Rpb24odmFsdWUsIHJhZGl4KSB7XG4gICAgICAvLyBGaXJlZm94IDwgMjEgYW5kIE9wZXJhIDwgMTUgZm9sbG93IHRoZSBFUzMgc3BlY2lmaWVkIGltcGxlbWVudGF0aW9uIG9mIGBwYXJzZUludGBcbiAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludChpc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZS5yZXBsYWNlKHJlTGVhZGluZ1NwYWNlc0FuZFplcm9zLCAnJykgOiB2YWx1ZSwgcmFkaXggfHwgMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBcIl8ucGx1Y2tcIiBzdHlsZSBmdW5jdGlvbiwgd2hpY2ggcmV0dXJucyB0aGUgYGtleWAgdmFsdWUgb2YgYVxuICAgICAqIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXRyaWV2ZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgZ2V0TmFtZSA9IF8ucHJvcGVydHkoJ25hbWUnKTtcbiAgICAgKlxuICAgICAqIF8ubWFwKGNoYXJhY3RlcnMsIGdldE5hbWUpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkoY2hhcmFjdGVycywgZ2V0TmFtZSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHkoa2V5KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgIChpbmNsdXNpdmUpLiBJZiBvbmx5IG9uZVxuICAgICAqIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGEgbnVtYmVyIGJldHdlZW4gYDBgIGFuZCB0aGUgZ2l2ZW4gbnVtYmVyIHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZC4gSWYgYGZsb2F0aW5nYCBpcyB0cnVleSBvciBlaXRoZXIgYG1pbmAgb3IgYG1heGAgYXJlIGZsb2F0cyBhXG4gICAgICogZmxvYXRpbmctcG9pbnQgbnVtYmVyIHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluPTBdIFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zsb2F0aW5nPWZhbHNlXSBTcGVjaWZ5IHJldHVybmluZyBhIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGEgcmFuZG9tIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMCwgNSk7XG4gICAgICogLy8gPT4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUpO1xuICAgICAqIC8vID0+IGFsc28gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUsIHRydWUpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMS4yLCA1LjIpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMS4yIGFuZCA1LjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb20obWluLCBtYXgsIGZsb2F0aW5nKSB7XG4gICAgICB2YXIgbm9NaW4gPSBtaW4gPT0gbnVsbCxcbiAgICAgICAgICBub01heCA9IG1heCA9PSBudWxsO1xuXG4gICAgICBpZiAoZmxvYXRpbmcgPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG1pbiA9PSAnYm9vbGVhbicgJiYgbm9NYXgpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IG1pbjtcbiAgICAgICAgICBtaW4gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFub01heCAmJiB0eXBlb2YgbWF4ID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gbWF4O1xuICAgICAgICAgIG5vTWF4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vTWluICYmIG5vTWF4KSB7XG4gICAgICAgIG1heCA9IDE7XG4gICAgICB9XG4gICAgICBtaW4gPSArbWluIHx8IDA7XG4gICAgICBpZiAobm9NYXgpIHtcbiAgICAgICAgbWF4ID0gbWluO1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4ID0gK21heCB8fCAwO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nIHx8IG1pbiAlIDEgfHwgbWF4ICUgMSkge1xuICAgICAgICB2YXIgcmFuZCA9IG5hdGl2ZVJhbmRvbSgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlTWluKG1pbiArIChyYW5kICogKG1heCAtIG1pbiArIHBhcnNlRmxvYXQoJzFlLScgKyAoKHJhbmQgKycnKS5sZW5ndGggLSAxKSkpKSwgbWF4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmFuZG9tKG1pbiwgbWF4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgdmFsdWUgb2YgcHJvcGVydHkgYGtleWAgb24gYG9iamVjdGAuIElmIGBrZXlgIGlzIGEgZnVuY3Rpb25cbiAgICAgKiBpdCB3aWxsIGJlIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYG9iamVjdGAgYW5kIGl0cyByZXN1bHQgcmV0dXJuZWQsXG4gICAgICogZWxzZSB0aGUgcHJvcGVydHkgdmFsdWUgaXMgcmV0dXJuZWQuIElmIGBvYmplY3RgIGlzIGZhbHNleSB0aGVuIGB1bmRlZmluZWRgXG4gICAgICogaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAnY2hlZXNlJzogJ2NydW1wZXRzJyxcbiAgICAgKiAgICdzdHVmZic6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICByZXR1cm4gJ25vbnNlbnNlJztcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnY2hlZXNlJyk7XG4gICAgICogLy8gPT4gJ2NydW1wZXRzJ1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnc3R1ZmYnKTtcbiAgICAgKiAvLyA9PiAnbm9uc2Vuc2UnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdWx0KG9iamVjdCwga2V5KSB7XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgPyBvYmplY3Rba2V5XSgpIDogdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBtaWNyby10ZW1wbGF0aW5nIG1ldGhvZCB0aGF0IGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlc1xuICAgICAqIHdoaXRlc3BhY2UsIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICAgICAqXG4gICAgICogTm90ZTogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkLCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXMgc291cmNlVVJMcyBmb3IgZWFzaWVyXG4gICAgICogZGVidWdnaW5nLiBTZWUgaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWU6XG4gICAgICogaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHNcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZTpcbiAgICAgKiBodHRwOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vc3RhYmxlL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwuaHRtbFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIG9iamVjdCB1c2VkIHRvIHBvcHVsYXRlIHRoZSB0ZXh0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGVdIFRoZSBcImVzY2FwZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXZhbHVhdGVdIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzXSBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGxvY2FsIHZhcmlhYmxlcy5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGVdIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc291cmNlVVJMXSBUaGUgc291cmNlVVJMIG9mIHRoZSB0ZW1wbGF0ZSdzIGNvbXBpbGVkIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZhcmlhYmxlXSBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258c3RyaW5nfSBSZXR1cm5zIGEgY29tcGlsZWQgZnVuY3Rpb24gd2hlbiBubyBgZGF0YWAgb2JqZWN0XG4gICAgICogIGlzIGdpdmVuLCBlbHNlIGl0IHJldHVybnMgdGhlIGludGVycG9sYXRlZCB0ZXh0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSBuYW1lICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAnbmFtZSc6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcImVzY2FwZVwiIGRlbGltaXRlciB0byBlc2NhcGUgSFRNTCBpbiBkYXRhIHByb3BlcnR5IHZhbHVlc1xuICAgICAqIF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nLCB7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gICAgICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGdlbmVyYXRlIEhUTUxcbiAgICAgKiB2YXIgbGlzdCA9ICc8JSBfLmZvckVhY2gocGVvcGxlLCBmdW5jdGlvbihuYW1lKSB7ICU+PGxpPjwlLSBuYW1lICU+PC9saT48JSB9KTsgJT4nO1xuICAgICAqIF8udGVtcGxhdGUobGlzdCwgeyAncGVvcGxlJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIEVTNiBkZWxpbWl0ZXIgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIGRlZmF1bHQgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlclxuICAgICAqIF8udGVtcGxhdGUoJ2hlbGxvICR7IG5hbWUgfScsIHsgJ25hbWUnOiAncGViYmxlcycgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVyc1xuICAgICAqIF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyBuYW1lKTsgJT4hJywgeyAnbmFtZSc6ICdiYXJuZXknIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBiYXJuZXkhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVyc1xuICAgICAqIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICAgKiAgICdpbnRlcnBvbGF0ZSc6IC97eyhbXFxzXFxTXSs/KX19L2dcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy50ZW1wbGF0ZSgnaGVsbG8ge3sgbmFtZSB9fSEnLCB7ICduYW1lJzogJ211c3RhY2hlJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGpRdWVyeVxuICAgICAqIHZhciBsaXN0ID0gJzwlIGpxLmVhY2gocGVvcGxlLCBmdW5jdGlvbihuYW1lKSB7ICU+PGxpPjwlLSBuYW1lICU+PC9saT48JSB9KTsgJT4nO1xuICAgICAqIF8udGVtcGxhdGUobGlzdCwgeyAncGVvcGxlJzogWydmcmVkJywgJ2Jhcm5leSddIH0sIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IG5hbWUgJT4nLCBudWxsLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gICAgICogY29tcGlsZWQoZGF0YSk7XG4gICAgICogLy8gPT4gZmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3RvclxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEubmFtZSAlPiEnLCBudWxsLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAgICAgKiBjb21waWxlZC5zb3VyY2U7XG4gICAgICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAqICAgdmFyIF9fdCwgX19wID0gJycsIF9fZSA9IF8uZXNjYXBlO1xuICAgICAqICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEubmFtZSApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICAgICAqICAgcmV0dXJuIF9fcDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICAgICAqIC8vIGxpbmUgbnVtYmVycyBpbiBlcnJvciBtZXNzYWdlcyBhbmQgYSBzdGFjayB0cmFjZVxuICAgICAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKGN3ZCwgJ2pzdC5qcycpLCAnXFxcbiAgICAgKiAgIHZhciBKU1QgPSB7XFxcbiAgICAgKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAgICAgKiAgIH07XFxcbiAgICAgKiAnKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0ZW1wbGF0ZSh0ZXh0LCBkYXRhLCBvcHRpb25zKSB7XG4gICAgICAvLyBiYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uXG4gICAgICAvLyBodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nL1xuICAgICAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qc1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVFxuICAgICAgdmFyIHNldHRpbmdzID0gbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3M7XG4gICAgICB0ZXh0ID0gU3RyaW5nKHRleHQgfHwgJycpO1xuXG4gICAgICAvLyBhdm9pZCBtaXNzaW5nIGRlcGVuZGVuY2llcyB3aGVuIGBpdGVyYXRvclRlbXBsYXRlYCBpcyBub3QgZGVmaW5lZFxuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRzKHt9LCBvcHRpb25zLCBzZXR0aW5ncyk7XG5cbiAgICAgIHZhciBpbXBvcnRzID0gZGVmYXVsdHMoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cyksXG4gICAgICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNWYWx1ZXMgPSB2YWx1ZXMoaW1wb3J0cyk7XG5cbiAgICAgIHZhciBpc0V2YWx1YXRpbmcsXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXG4gICAgICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gICAgICAvLyBjb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXJcbiAgICAgIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICAgICAsICdnJyk7XG5cbiAgICAgIHRleHQucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAgICAgLy8gZXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW5ub3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzXG4gICAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgICAgIC8vIHJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzXG4gICAgICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcbiAgICAgICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICAgIC8vIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgcmVxdWlyZXMgcmV0dXJuaW5nIHRoZSBgbWF0Y2hgXG4gICAgICAgIC8vIHN0cmluZyBpbiBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pO1xuXG4gICAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgICAvLyBpZiBgdmFyaWFibGVgIGlzIG5vdCBzcGVjaWZpZWQsIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAgICAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluXG4gICAgICB2YXIgdmFyaWFibGUgPSBvcHRpb25zLnZhcmlhYmxlLFxuICAgICAgICAgIGhhc1ZhcmlhYmxlID0gdmFyaWFibGU7XG5cbiAgICAgIGlmICghaGFzVmFyaWFibGUpIHtcbiAgICAgICAgdmFyaWFibGUgPSAnb2JqJztcbiAgICAgICAgc291cmNlID0gJ3dpdGggKCcgKyB2YXJpYWJsZSArICcpIHtcXG4nICsgc291cmNlICsgJ1xcbn1cXG4nO1xuICAgICAgfVxuICAgICAgLy8gY2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzXG4gICAgICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgICAgIC8vIGZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHlcbiAgICAgIHNvdXJjZSA9ICdmdW5jdGlvbignICsgdmFyaWFibGUgKyAnKSB7XFxuJyArXG4gICAgICAgIChoYXNWYXJpYWJsZSA/ICcnIDogdmFyaWFibGUgKyAnIHx8ICgnICsgdmFyaWFibGUgKyAnID0ge30pO1xcbicpICtcbiAgICAgICAgXCJ2YXIgX190LCBfX3AgPSAnJywgX19lID0gXy5lc2NhcGVcIiArXG4gICAgICAgIChpc0V2YWx1YXRpbmdcbiAgICAgICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgICAgIDogJztcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBzb3VyY2UgK1xuICAgICAgICAncmV0dXJuIF9fcFxcbn0nO1xuXG4gICAgICAvLyBVc2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICAvLyBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsXG4gICAgICB2YXIgc291cmNlVVJMID0gJ1xcbi8qXFxuLy8jIHNvdXJjZVVSTD0nICsgKG9wdGlvbnMuc291cmNlVVJMIHx8ICcvbG9kYXNoL3RlbXBsYXRlL3NvdXJjZVsnICsgKHRlbXBsYXRlQ291bnRlcisrKSArICddJykgKyAnXFxuKi8nO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gRnVuY3Rpb24oaW1wb3J0c0tleXMsICdyZXR1cm4gJyArIHNvdXJjZSArIHNvdXJjZVVSTCkuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQoZGF0YSk7XG4gICAgICB9XG4gICAgICAvLyBwcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2QsIGluXG4gICAgICAvLyBzdXBwb3J0ZWQgZW52aXJvbm1lbnRzLCBvciB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3JcbiAgICAgIC8vIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcyBkdXJpbmcgdGhlIGJ1aWxkIHByb2Nlc3NcbiAgICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjYWxsYmFjayBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0c1xuICAgICAqIG9mIGVhY2ggY2FsbGJhY2sgZXhlY3V0aW9uLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCBvbmUgYXJndW1lbnQ7IChpbmRleCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBleGVjdXRlIHRoZSBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggYGNhbGxiYWNrYCBleGVjdXRpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBkaWNlUm9sbHMgPSBfLnRpbWVzKDMsIF8ucGFydGlhbChfLnJhbmRvbSwgMSwgNikpO1xuICAgICAqIC8vID0+IFszLCA2LCA0XVxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBmdW5jdGlvbihuKSB7IG1hZ2UuY2FzdFNwZWxsKG4pOyB9KTtcbiAgICAgKiAvLyA9PiBjYWxscyBgbWFnZS5jYXN0U3BlbGwobilgIHRocmVlIHRpbWVzLCBwYXNzaW5nIGBuYCBvZiBgMGAsIGAxYCwgYW5kIGAyYCByZXNwZWN0aXZlbHlcbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgZnVuY3Rpb24obikgeyB0aGlzLmNhc3Qobik7IH0sIG1hZ2UpO1xuICAgICAqIC8vID0+IGFsc28gY2FsbHMgYG1hZ2UuY2FzdFNwZWxsKG4pYCB0aHJlZSB0aW1lc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWVzKG4sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBuID0gKG4gPSArbikgPiAtMSA/IG4gOiAwO1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgICAgIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAxKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gY2FsbGJhY2soaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy5lc2NhcGVgIHRoaXMgbWV0aG9kIGNvbnZlcnRzIHRoZSBIVE1MIGVudGl0aWVzXG4gICAgICogYCZhbXA7YCwgYCZsdDtgLCBgJmd0O2AsIGAmcXVvdDtgLCBhbmQgYCYjMzk7YCBpbiBgc3RyaW5nYCB0byB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmVzY2FwZSgnRnJlZCwgQmFybmV5ICZhbXA7IFBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCwgQmFybmV5ICYgUGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcgPT0gbnVsbCA/ICcnIDogU3RyaW5nKHN0cmluZykucmVwbGFjZShyZUVzY2FwZWRIdG1sLCB1bmVzY2FwZUh0bWxDaGFyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQuIElmIGBwcmVmaXhgIGlzIHByb3ZpZGVkIHRoZSBJRCB3aWxsIGJlIGFwcGVuZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4XSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAgICAgKiAvLyA9PiAnY29udGFjdF8xMDQnXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCk7XG4gICAgICogLy8gPT4gJzEwNSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICAgICAgcmV0dXJuIFN0cmluZyhwcmVmaXggPT0gbnVsbCA/ICcnIDogcHJlZml4KSArIGlkO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB0aGF0IHdyYXBzIHRoZSBnaXZlbiB2YWx1ZSB3aXRoIGV4cGxpY2l0XG4gICAgICogbWV0aG9kIGNoYWluaW5nIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciB5b3VuZ2VzdCA9IF8uY2hhaW4oY2hhcmFjdGVycylcbiAgICAgKiAgICAgLnNvcnRCeSgnYWdlJylcbiAgICAgKiAgICAgLm1hcChmdW5jdGlvbihjaHIpIHsgcmV0dXJuIGNoci5uYW1lICsgJyBpcyAnICsgY2hyLmFnZTsgfSlcbiAgICAgKiAgICAgLmZpcnN0KClcbiAgICAgKiAgICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMgaXMgMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFpbih2YWx1ZSkge1xuICAgICAgdmFsdWUgPSBuZXcgbG9kYXNoV3JhcHBlcih2YWx1ZSk7XG4gICAgICB2YWx1ZS5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYGludGVyY2VwdG9yYCB3aXRoIHRoZSBgdmFsdWVgIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgdGhlblxuICAgICAqIHJldHVybnMgYHZhbHVlYC4gVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kXG4gICAgICogY2hhaW4gaW4gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpblxuICAgICAqIHRoZSBjaGFpbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDMsIDRdKVxuICAgICAqICAudGFwKGZ1bmN0aW9uKGFycmF5KSB7IGFycmF5LnBvcCgpOyB9KVxuICAgICAqICAucmV2ZXJzZSgpXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRhcCh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGV4cGxpY2l0IG1ldGhvZCBjaGFpbmluZyBvbiB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjaGFpblxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGhvdXQgZXhwbGljaXQgY2hhaW5pbmdcbiAgICAgKiBfKGNoYXJhY3RlcnMpLmZpcnN0KCk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqXG4gICAgICogLy8gd2l0aCBleHBsaWNpdCBjaGFpbmluZ1xuICAgICAqIF8oY2hhcmFjdGVycykuY2hhaW4oKVxuICAgICAqICAgLmZpcnN0KClcbiAgICAgKiAgIC5waWNrKCdhZ2UnKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4geyAnYWdlJzogMzYgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDaGFpbigpIHtcbiAgICAgIHRoaXMuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIHRoZSBgdG9TdHJpbmdgIHJlc3VsdCBvZiB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHRvU3RyaW5nXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcgcmVzdWx0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkudG9TdHJpbmcoKTtcbiAgICAgKiAvLyA9PiAnMSwyLDMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFN0cmluZyh0aGlzLl9fd3JhcHBlZF9fKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHZhbHVlT2ZcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyB2YWx1ZVxuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkudmFsdWVPZigpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJWYWx1ZU9mKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX193cmFwcGVkX187XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBhZGQgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmdcbiAgICBsb2Rhc2guYWZ0ZXIgPSBhZnRlcjtcbiAgICBsb2Rhc2guYXNzaWduID0gYXNzaWduO1xuICAgIGxvZGFzaC5hdCA9IGF0O1xuICAgIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgICBsb2Rhc2guYmluZEFsbCA9IGJpbmRBbGw7XG4gICAgbG9kYXNoLmJpbmRLZXkgPSBiaW5kS2V5O1xuICAgIGxvZGFzaC5jaGFpbiA9IGNoYWluO1xuICAgIGxvZGFzaC5jb21wYWN0ID0gY29tcGFjdDtcbiAgICBsb2Rhc2guY29tcG9zZSA9IGNvbXBvc2U7XG4gICAgbG9kYXNoLmNvbnN0YW50ID0gY29uc3RhbnQ7XG4gICAgbG9kYXNoLmNvdW50QnkgPSBjb3VudEJ5O1xuICAgIGxvZGFzaC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgbG9kYXNoLmNyZWF0ZUNhbGxiYWNrID0gY3JlYXRlQ2FsbGJhY2s7XG4gICAgbG9kYXNoLmN1cnJ5ID0gY3Vycnk7XG4gICAgbG9kYXNoLmRlYm91bmNlID0gZGVib3VuY2U7XG4gICAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgbG9kYXNoLmRlZmVyID0gZGVmZXI7XG4gICAgbG9kYXNoLmRlbGF5ID0gZGVsYXk7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xuICAgIGxvZGFzaC5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgbG9kYXNoLmZsYXR0ZW4gPSBmbGF0dGVuO1xuICAgIGxvZGFzaC5mb3JFYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZm9yRWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5mb3JJbiA9IGZvckluO1xuICAgIGxvZGFzaC5mb3JJblJpZ2h0ID0gZm9ySW5SaWdodDtcbiAgICBsb2Rhc2guZm9yT3duID0gZm9yT3duO1xuICAgIGxvZGFzaC5mb3JPd25SaWdodCA9IGZvck93blJpZ2h0O1xuICAgIGxvZGFzaC5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLmdyb3VwQnkgPSBncm91cEJ5O1xuICAgIGxvZGFzaC5pbmRleEJ5ID0gaW5kZXhCeTtcbiAgICBsb2Rhc2guaW5pdGlhbCA9IGluaXRpYWw7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcbiAgICBsb2Rhc2guaW52ZXJ0ID0gaW52ZXJ0O1xuICAgIGxvZGFzaC5pbnZva2UgPSBpbnZva2U7XG4gICAgbG9kYXNoLmtleXMgPSBrZXlzO1xuICAgIGxvZGFzaC5tYXAgPSBtYXA7XG4gICAgbG9kYXNoLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcbiAgICBsb2Rhc2gubWF4ID0gbWF4O1xuICAgIGxvZGFzaC5tZW1vaXplID0gbWVtb2l6ZTtcbiAgICBsb2Rhc2gubWVyZ2UgPSBtZXJnZTtcbiAgICBsb2Rhc2gubWluID0gbWluO1xuICAgIGxvZGFzaC5vbWl0ID0gb21pdDtcbiAgICBsb2Rhc2gub25jZSA9IG9uY2U7XG4gICAgbG9kYXNoLnBhaXJzID0gcGFpcnM7XG4gICAgbG9kYXNoLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICAgIGxvZGFzaC5wYXJ0aWFsUmlnaHQgPSBwYXJ0aWFsUmlnaHQ7XG4gICAgbG9kYXNoLnBpY2sgPSBwaWNrO1xuICAgIGxvZGFzaC5wbHVjayA9IHBsdWNrO1xuICAgIGxvZGFzaC5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIGxvZGFzaC5wdWxsID0gcHVsbDtcbiAgICBsb2Rhc2gucmFuZ2UgPSByYW5nZTtcbiAgICBsb2Rhc2gucmVqZWN0ID0gcmVqZWN0O1xuICAgIGxvZGFzaC5yZW1vdmUgPSByZW1vdmU7XG4gICAgbG9kYXNoLnJlc3QgPSByZXN0O1xuICAgIGxvZGFzaC5zaHVmZmxlID0gc2h1ZmZsZTtcbiAgICBsb2Rhc2guc29ydEJ5ID0gc29ydEJ5O1xuICAgIGxvZGFzaC50YXAgPSB0YXA7XG4gICAgbG9kYXNoLnRocm90dGxlID0gdGhyb3R0bGU7XG4gICAgbG9kYXNoLnRpbWVzID0gdGltZXM7XG4gICAgbG9kYXNoLnRvQXJyYXkgPSB0b0FycmF5O1xuICAgIGxvZGFzaC50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgbG9kYXNoLnVuaW9uID0gdW5pb247XG4gICAgbG9kYXNoLnVuaXEgPSB1bmlxO1xuICAgIGxvZGFzaC52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgbG9kYXNoLndoZXJlID0gd2hlcmU7XG4gICAgbG9kYXNoLndpdGhvdXQgPSB3aXRob3V0O1xuICAgIGxvZGFzaC53cmFwID0gd3JhcDtcbiAgICBsb2Rhc2gueG9yID0geG9yO1xuICAgIGxvZGFzaC56aXAgPSB6aXA7XG4gICAgbG9kYXNoLnppcE9iamVjdCA9IHppcE9iamVjdDtcblxuICAgIC8vIGFkZCBhbGlhc2VzXG4gICAgbG9kYXNoLmNvbGxlY3QgPSBtYXA7XG4gICAgbG9kYXNoLmRyb3AgPSByZXN0O1xuICAgIGxvZGFzaC5lYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ247XG4gICAgbG9kYXNoLm1ldGhvZHMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLm9iamVjdCA9IHppcE9iamVjdDtcbiAgICBsb2Rhc2guc2VsZWN0ID0gZmlsdGVyO1xuICAgIGxvZGFzaC50YWlsID0gcmVzdDtcbiAgICBsb2Rhc2gudW5pcXVlID0gdW5pcTtcbiAgICBsb2Rhc2gudW56aXAgPSB6aXA7XG5cbiAgICAvLyBhZGQgZnVuY3Rpb25zIHRvIGBsb2Rhc2gucHJvdG90eXBlYFxuICAgIG1peGluKGxvZGFzaCk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIGFkZCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nXG4gICAgbG9kYXNoLmNsb25lID0gY2xvbmU7XG4gICAgbG9kYXNoLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcbiAgICBsb2Rhc2guY29udGFpbnMgPSBjb250YWlucztcbiAgICBsb2Rhc2guZXNjYXBlID0gZXNjYXBlO1xuICAgIGxvZGFzaC5ldmVyeSA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5maW5kID0gZmluZDtcbiAgICBsb2Rhc2guZmluZEluZGV4ID0gZmluZEluZGV4O1xuICAgIGxvZGFzaC5maW5kS2V5ID0gZmluZEtleTtcbiAgICBsb2Rhc2guZmluZExhc3QgPSBmaW5kTGFzdDtcbiAgICBsb2Rhc2guZmluZExhc3RJbmRleCA9IGZpbmRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLmZpbmRMYXN0S2V5ID0gZmluZExhc3RLZXk7XG4gICAgbG9kYXNoLmhhcyA9IGhhcztcbiAgICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICBsb2Rhc2guaW5kZXhPZiA9IGluZGV4T2Y7XG4gICAgbG9kYXNoLmlzQXJndW1lbnRzID0gaXNBcmd1bWVudHM7XG4gICAgbG9kYXNoLmlzQXJyYXkgPSBpc0FycmF5O1xuICAgIGxvZGFzaC5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG4gICAgbG9kYXNoLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICBsb2Rhc2guaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuICAgIGxvZGFzaC5pc0VtcHR5ID0gaXNFbXB0eTtcbiAgICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG4gICAgbG9kYXNoLmlzRmluaXRlID0gaXNGaW5pdGU7XG4gICAgbG9kYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOO1xuICAgIGxvZGFzaC5pc051bGwgPSBpc051bGw7XG4gICAgbG9kYXNoLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4gICAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgbG9kYXNoLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuICAgIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgIGxvZGFzaC5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuICAgIGxvZGFzaC5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICAgIGxvZGFzaC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbiAgICBsb2Rhc2gubm9vcCA9IG5vb3A7XG4gICAgbG9kYXNoLm5vdyA9IG5vdztcbiAgICBsb2Rhc2gucGFyc2VJbnQgPSBwYXJzZUludDtcbiAgICBsb2Rhc2gucmFuZG9tID0gcmFuZG9tO1xuICAgIGxvZGFzaC5yZWR1Y2UgPSByZWR1Y2U7XG4gICAgbG9kYXNoLnJlZHVjZVJpZ2h0ID0gcmVkdWNlUmlnaHQ7XG4gICAgbG9kYXNoLnJlc3VsdCA9IHJlc3VsdDtcbiAgICBsb2Rhc2gucnVuSW5Db250ZXh0ID0gcnVuSW5Db250ZXh0O1xuICAgIGxvZGFzaC5zaXplID0gc2l6ZTtcbiAgICBsb2Rhc2guc29tZSA9IHNvbWU7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4ID0gc29ydGVkSW5kZXg7XG4gICAgbG9kYXNoLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgbG9kYXNoLnVuZXNjYXBlID0gdW5lc2NhcGU7XG4gICAgbG9kYXNoLnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG5cbiAgICAvLyBhZGQgYWxpYXNlc1xuICAgIGxvZGFzaC5hbGwgPSBldmVyeTtcbiAgICBsb2Rhc2guYW55ID0gc29tZTtcbiAgICBsb2Rhc2guZGV0ZWN0ID0gZmluZDtcbiAgICBsb2Rhc2guZmluZFdoZXJlID0gZmluZDtcbiAgICBsb2Rhc2guZm9sZGwgPSByZWR1Y2U7XG4gICAgbG9kYXNoLmZvbGRyID0gcmVkdWNlUmlnaHQ7XG4gICAgbG9kYXNoLmluY2x1ZGUgPSBjb250YWlucztcbiAgICBsb2Rhc2guaW5qZWN0ID0gcmVkdWNlO1xuXG4gICAgbWl4aW4oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0ge31cbiAgICAgIGZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKCFsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgICAgc291cmNlW21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc291cmNlO1xuICAgIH0oKSwgZmFsc2UpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBhZGQgZnVuY3Rpb25zIGNhcGFibGUgb2YgcmV0dXJuaW5nIHdyYXBwZWQgYW5kIHVud3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZ1xuICAgIGxvZGFzaC5maXJzdCA9IGZpcnN0O1xuICAgIGxvZGFzaC5sYXN0ID0gbGFzdDtcbiAgICBsb2Rhc2guc2FtcGxlID0gc2FtcGxlO1xuXG4gICAgLy8gYWRkIGFsaWFzZXNcbiAgICBsb2Rhc2gudGFrZSA9IGZpcnN0O1xuICAgIGxvZGFzaC5oZWFkID0gZmlyc3Q7XG5cbiAgICBmb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgY2FsbGJhY2thYmxlID0gbWV0aG9kTmFtZSAhPT0gJ3NhbXBsZSc7XG4gICAgICBpZiAoIWxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXT0gZnVuY3Rpb24obiwgZ3VhcmQpIHtcbiAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYyh0aGlzLl9fd3JhcHBlZF9fLCBuLCBndWFyZCk7XG5cbiAgICAgICAgICByZXR1cm4gIWNoYWluQWxsICYmIChuID09IG51bGwgfHwgKGd1YXJkICYmICEoY2FsbGJhY2thYmxlICYmIHR5cGVvZiBuID09ICdmdW5jdGlvbicpKSlcbiAgICAgICAgICAgID8gcmVzdWx0XG4gICAgICAgICAgICA6IG5ldyBsb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKi9cbiAgICBsb2Rhc2guVkVSU0lPTiA9ICcyLjQuMic7XG5cbiAgICAvLyBhZGQgXCJDaGFpbmluZ1wiIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlclxuICAgIGxvZGFzaC5wcm90b3R5cGUuY2hhaW4gPSB3cmFwcGVyQ2hhaW47XG4gICAgbG9kYXNoLnByb3RvdHlwZS50b1N0cmluZyA9IHdyYXBwZXJUb1N0cmluZztcbiAgICBsb2Rhc2gucHJvdG90eXBlLnZhbHVlID0gd3JhcHBlclZhbHVlT2Y7XG4gICAgbG9kYXNoLnByb3RvdHlwZS52YWx1ZU9mID0gd3JhcHBlclZhbHVlT2Y7XG5cbiAgICAvLyBhZGQgYEFycmF5YCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlc1xuICAgIGZvckVhY2goWydqb2luJywgJ3BvcCcsICdzaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UmVmW21ldGhvZE5hbWVdO1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcy5fX3dyYXBwZWRfXywgYXJndW1lbnRzKTtcblxuICAgICAgICByZXR1cm4gY2hhaW5BbGxcbiAgICAgICAgICA/IG5ldyBsb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpXG4gICAgICAgICAgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHRoZSBleGlzdGluZyB3cmFwcGVkIHZhbHVlXG4gICAgZm9yRWFjaChbJ3B1c2gnLCAncmV2ZXJzZScsICdzb3J0JywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVJlZlttZXRob2ROYW1lXTtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuYy5hcHBseSh0aGlzLl9fd3JhcHBlZF9fLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBhZGQgYEFycmF5YCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gbmV3IHdyYXBwZWQgdmFsdWVzXG4gICAgZm9yRWFjaChbJ2NvbmNhdCcsICdzbGljZScsICdzcGxpY2UnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVJlZlttZXRob2ROYW1lXTtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBsb2Rhc2hXcmFwcGVyKGZ1bmMuYXBwbHkodGhpcy5fX3dyYXBwZWRfXywgYXJndW1lbnRzKSwgdGhpcy5fX2NoYWluX18pO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBsb2Rhc2g7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBleHBvc2UgTG8tRGFzaFxuICB2YXIgXyA9IHJ1bkluQ29udGV4dCgpO1xuXG4gIC8vIHNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMgbGlrZSByLmpzIGNoZWNrIGZvciBjb25kaXRpb24gcGF0dGVybnMgbGlrZSB0aGUgZm9sbG93aW5nOlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBFeHBvc2UgTG8tRGFzaCB0byB0aGUgZ2xvYmFsIG9iamVjdCBldmVuIHdoZW4gYW4gQU1EIGxvYWRlciBpcyBwcmVzZW50IGluXG4gICAgLy8gY2FzZSBMby1EYXNoIGlzIGxvYWRlZCB3aXRoIGEgUmVxdWlyZUpTIHNoaW0gY29uZmlnLlxuICAgIC8vIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2FwaS5odG1sI2NvbmZpZy1zaGltXG4gICAgcm9vdC5fID0gXztcblxuICAgIC8vIGRlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvLCB0aHJvdWdoIHBhdGggbWFwcGluZywgaXQgY2FuIGJlXG4gICAgLy8gcmVmZXJlbmNlZCBhcyB0aGUgXCJ1bmRlcnNjb3JlXCIgbW9kdWxlXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbiAgLy8gY2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgYW4gYGV4cG9ydHNgIG9iamVjdFxuICBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG4gICAgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTXG4gICAgaWYgKG1vZHVsZUV4cG9ydHMpIHtcbiAgICAgIChmcmVlTW9kdWxlLmV4cG9ydHMgPSBfKS5fID0gXztcbiAgICB9XG4gICAgLy8gaW4gTmFyd2hhbCBvciBSaGlubyAtcmVxdWlyZVxuICAgIGVsc2Uge1xuICAgICAgZnJlZUV4cG9ydHMuXyA9IF87XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGluIGEgYnJvd3NlciBvciBSaGlub1xuICAgIHJvb3QuXyA9IF87XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcIilcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXCIpXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanNcIilcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpXG4gICAgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24oZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoZGF0YSkpXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgaWYgKGNiKVxuICAgIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKHRoaXMuX2ZsdXNoKSlcbiAgICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uKGVyKSB7XG4gICAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fFxuICAgICAgICBycy5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaylcbiAgICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICghdXRpbC5pc051bGwodHMud3JpdGVjaHVuaykgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXCIpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG5mb3JFYWNoKG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKVxuICAgIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufSk7XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKVxuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKVxuICAgIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzLm5leHRUaWNrKHRoaXMuZW5kLmJpbmQodGhpcykpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gb3B0aW9ucy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleClcbiAgICB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0aG91Z2ggdGhleSdyZSBub3RcbiAgLy8gaW5zdGFuY2VvZiBXcml0YWJsZSwgdGhleSdyZSBpbnN0YW5jZW9mIFJlYWRhYmxlLlxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUuIE5vdCByZWFkYWJsZS4nKSk7XG59O1xuXG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIGNiKGVyKTtcbiAgfSk7XG59XG5cbi8vIElmIHdlIGdldCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkLFxuLy8gYW5kIHdlJ3JlIG5vdCBpbiBvYmplY3RNb2RlLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbi8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxuLy8gd2F0ZXJtYXJrcyBkZXRlcm1pbmUgaG93IG1hbnkgb2JqZWN0cyB0byBrZWVwIGluIHRoZSBidWZmZXIsIHJhdGhlciB0aGFuXG4vLyBob3cgbWFueSBieXRlcyBvciBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgaWYgKCF1dGlsLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNTdHJpbmcoY2h1bmspICYmXG4gICAgICAhdXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgdmFyIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKGVuY29kaW5nKSkge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKHV0aWwuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIGVsc2UgaWYgKCFlbmNvZGluZylcbiAgICBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAoIXV0aWwuaXNGdW5jdGlvbihjYikpXG4gICAgY2IgPSBmdW5jdGlvbigpIHt9O1xuXG4gIGlmIChzdGF0ZS5lbmRlZClcbiAgICB3cml0ZUFmdGVyRW5kKHRoaXMsIHN0YXRlLCBjYik7XG4gIGVsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJlxuICAgICAgICAhc3RhdGUuY29ya2VkICYmXG4gICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxuICAgICAgICAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJlxuICAgICAgICBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJlxuICAgICAgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiZcbiAgICAgIHV0aWwuaXNTdHJpbmcoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gIGlmICh1dGlsLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KVxuICAgIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKVxuICAgIHN0YXRlLmJ1ZmZlci5wdXNoKG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSk7XG4gIGVsc2VcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KVxuICAgIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtcbiAgZWxzZVxuICAgIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIGlmIChzeW5jKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgIGNiKGVyKTtcbiAgICB9KTtcbiAgZWxzZSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXIpO1xuICB9XG5cbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpXG4gICAgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7XG4gIGVsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiZcbiAgICAgICAgIXN0YXRlLmNvcmtlZCAmJlxuICAgICAgICAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJlxuICAgICAgICBzdGF0ZS5idWZmZXIubGVuZ3RoKSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZClcbiAgICBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGggPiAxKSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBjYnMgPSBbXTtcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGg7IGMrKylcbiAgICAgIGNicy5wdXNoKHN0YXRlLmJ1ZmZlcltjXS5jYWxsYmFjayk7XG5cbiAgICAvLyBjb3VudCB0aGUgb25lIHdlIGFyZSBhZGRpbmcsIGFzIHdlbGwuXG4gICAgLy8gVE9ETyhpc2FhY3MpIGNsZWFuIHRoaXMgdXBcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgc3RhdGUuYnVmZmVyLCAnJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgICAgY2JzW2ldKGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDbGVhciBidWZmZXJcbiAgICBzdGF0ZS5idWZmZXIgPSBbXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspIHtcbiAgICAgIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcltjXTtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGMrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgc3RhdGUuYnVmZmVyID0gc3RhdGUuYnVmZmVyLnNsaWNlKGMpO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlLmJ1ZmZlci5sZW5ndGggPSAwO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcblxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh1dGlsLmlzRnVuY3Rpb24oY2h1bmspKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHV0aWwuaXNGdW5jdGlvbihlbmNvZGluZykpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykpXG4gICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZClcbiAgICBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgcmV0dXJuIChzdGF0ZS5lbmRpbmcgJiZcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAhc3RhdGUuZmluaXNoZWQgJiZcbiAgICAgICAgICAhc3RhdGUud3JpdGluZyk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHtcbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9IGVsc2VcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZClcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2IpO1xuICAgIGVsc2VcbiAgICAgIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5pZiAoIUVFLmxpc3RlbmVyQ291bnQpIEVFLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyaW5nRGVjb2RlcjtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnID0gcmVxdWlyZSgndXRpbCcpO1xuaWYgKGRlYnVnICYmIGRlYnVnLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWcuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IG9wdGlvbnMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcblxuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpXG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICh1dGlsLmlzU3RyaW5nKGNodW5rKSAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAodXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZClcbiAgICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpXG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAgIGlmICghYWRkVG9Gcm9udClcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxuICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgICAgaWYgKGFkZFRvRnJvbnQpXG4gICAgICAgICAgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpXG4gICAgICAgICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gICAgICB9XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cblxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDEyOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDJcbiAgICBuLS07XG4gICAgZm9yICh2YXIgcCA9IDE7IHAgPCAzMjsgcCA8PD0gMSkgbiB8PSBuID4+IHA7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpXG4gICAgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAoaXNOYU4obikgfHwgdXRpbC5pc051bGwobikpIHtcbiAgICAvLyBvbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApXG4gICAgcmV0dXJuIDA7XG5cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIHRhcmdldCBidWZmZXIgbGV2ZWwsXG4gIC8vIHRoZW4gcmFpc2UgdGhlIHdhdGVyIG1hcmsuICBCdW1wIHVwIHRvIHRoZSBuZXh0IGhpZ2hlc3RcbiAgLy8gcG93ZXIgb2YgMiwgdG8gcHJldmVudCBpbmNyZWFzaW5nIGl0IGV4Y2Vzc2l2ZWx5IGluIHRpbnlcbiAgLy8gYW1vdW50cy5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKVxuICAgIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSByb3VuZFVwVG9OZXh0UG93ZXJPZjIobik7XG5cbiAgLy8gZG9uJ3QgaGF2ZSB0aGF0IG11Y2guICByZXR1cm4gbnVsbCwgdW5sZXNzIHdlJ3ZlIGVuZGVkLlxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xuICAgIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmICghdXRpbC5pc051bWJlcihuKSB8fCBuID4gMClcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgJiZcbiAgICAgIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIGVsc2VcbiAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH1cblxuICBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgaWYgKGRvUmVhZCAmJiAhc3RhdGUucmVhZGluZylcbiAgICBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMClcbiAgICByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7XG4gIGVsc2VcbiAgICByZXQgPSBudWxsO1xuXG4gIGlmICh1dGlsLmlzTnVsbChyZXQpKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfVxuXG4gIHN0YXRlLmxlbmd0aCAtPSBuO1xuXG4gIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLmVuZGVkKVxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKVxuICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuXG4gIGlmICghdXRpbC5pc051bGwocmV0KSlcbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghdXRpbC5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzU3RyaW5nKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO1xuICBlbHNlXG4gICAgc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJlxuICAgICAgICAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKVxuICAgICAgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCkge1xuICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsXG4gICAgICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApXG4gICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG4gIC8vIFRoaXMgaXMgYSBicnV0YWxseSB1Z2x5IGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXJcbiAgLy8gaXMgYXR0YWNoZWQgYmVmb3JlIGFueSB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy5cbiAgaWYgKCFkZXN0Ll9ldmVudHMgfHwgIWRlc3QuX2V2ZW50cy5lcnJvcilcbiAgICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBlbHNlIGlmIChpc0FycmF5KGRlc3QuX2V2ZW50cy5lcnJvcikpXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yLnVuc2hpZnQob25lcnJvcik7XG4gIGVsc2VcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IgPSBbb25lcnJvciwgZGVzdC5fZXZlbnRzLmVycm9yXTtcblxuXG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKVxuICAgICAgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFLmxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcylcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KVxuICAgICAgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdClcbiAgICAgIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpID09PSAtMSlcbiAgICByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaSwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpXG4gICAgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgLy8gSWYgbGlzdGVuaW5nIHRvIGRhdGEsIGFuZCBpdCBoYXMgbm90IGV4cGxpY2l0bHkgYmVlbiBwYXVzZWQsXG4gIC8vIHRoZW4gY2FsbCByZXN1bWUgdG8gc3RhcnQgdGhlIGZsb3cgb2YgZGF0YSBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAoZXYgPT09ICdkYXRhJyAmJiBmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgdGhpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzLnJlYWRhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgICAgICAgICBzZWxmLnJlYWQoMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgICAgdGhpcy5yZWFkKDApO1xuICAgIH1cbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICByZXN1bWVfKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIGRvIHtcbiAgICAgIHZhciBjaHVuayA9IHN0cmVhbS5yZWFkKCk7XG4gICAgfSB3aGlsZSAobnVsbCAhPT0gY2h1bmsgJiYgc3RhdGUuZmxvd2luZyk7XG4gIH1cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKVxuICAgICAgICBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpXG4gICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgIGlmICghY2h1bmsgfHwgIXN0YXRlLm9iamVjdE1vZGUgJiYgIWNodW5rLmxlbmd0aClcbiAgICAgIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh1dGlsLmlzRnVuY3Rpb24oc3RyZWFtW2ldKSAmJiB1dGlsLmlzVW5kZWZpbmVkKHRoaXNbaV0pKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24obWV0aG9kKSB7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgIH19KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICB9KTtcblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24obikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuXG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgdmFyIGxpc3QgPSBzdGF0ZS5idWZmZXI7XG4gIHZhciBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xuICB2YXIgb2JqZWN0TW9kZSA9ICEhc3RhdGUub2JqZWN0TW9kZTtcbiAgdmFyIHJldDtcblxuICAvLyBub3RoaW5nIGluIHRoZSBsaXN0LCBkZWZpbml0ZWx5IGVtcHR5LlxuICBpZiAobGlzdC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICByZXQgPSBudWxsO1xuICBlbHNlIGlmIChvYmplY3RNb2RlKVxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgZWxzZSBpZiAoIW4gfHwgbiA+PSBsZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGFycmF5LlxuICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgcmV0ID0gbGlzdC5qb2luKCcnKTtcbiAgICBlbHNlXG4gICAgICByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgIHJldCA9ICcnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSBuZXcgQnVmZmVyKG4pO1xuXG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbCAmJiBjIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgICB2YXIgY3B5ID0gTWF0aC5taW4obiAtIGMsIGJ1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICAgIHJldCArPSBidWYuc2xpY2UoMCwgY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgYnVmLmxlbmd0aClcbiAgICAgICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmRSZWFkYWJsZSBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gICAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgaXNCdWZmZXJFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nXG4gIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gICAgICAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICBjYXNlICdoZXgnOiBjYXNlICd1dGY4JzogY2FzZSAndXRmLTgnOiBjYXNlICdhc2NpaSc6IGNhc2UgJ2JpbmFyeSc6IGNhc2UgJ2Jhc2U2NCc6IGNhc2UgJ3VjczInOiBjYXNlICd1Y3MtMic6IGNhc2UgJ3V0ZjE2bGUnOiBjYXNlICd1dGYtMTZsZSc6IGNhc2UgJ3Jhdyc6IHJldHVybiB0cnVlO1xuICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgIH1cbiAgICAgfVxuXG5cbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyAmJiAhaXNCdWZmZXJFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLiBDRVNVLTggaXMgaGFuZGxlZCBhcyBwYXJ0IG9mIHRoZSBVVEYtOCBlbmNvZGluZy5cbi8vXG4vLyBAVE9ETyBIYW5kbGluZyBhbGwgZW5jb2RpbmdzIGluc2lkZSBhIHNpbmdsZSBvYmplY3QgbWFrZXMgaXQgdmVyeSBkaWZmaWN1bHRcbi8vIHRvIHJlYXNvbiBhYm91dCB0aGlzIGNvZGUsIHNvIGl0IHNob3VsZCBiZSBzcGxpdCB1cCBpbiB0aGUgZnV0dXJlLlxuLy8gQFRPRE8gVGhlcmUgc2hvdWxkIGJlIGEgdXRmOC1zdHJpY3QgZW5jb2RpbmcgdGhhdCByZWplY3RzIGludmFsaWQgVVRGLTggY29kZVxuLy8gcG9pbnRzIGFzIHVzZWQgYnkgQ0VTVS04LlxudmFyIFN0cmluZ0RlY29kZXIgPSBleHBvcnRzLlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRW5vdWdoIHNwYWNlIHRvIHN0b3JlIGFsbCBieXRlcyBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuIFVURi04IG5lZWRzIDRcbiAgLy8gYnl0ZXMsIGJ1dCBDRVNVLTggbWF5IHJlcXVpcmUgdXAgdG8gNiAoMyBieXRlcyBwZXIgc3Vycm9nYXRlKS5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIC8vIE51bWJlciBvZiBieXRlcyBleHBlY3RlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyTGVuZ3RoID0gMDtcbn07XG5cblxuLy8gd3JpdGUgZGVjb2RlcyB0aGUgZ2l2ZW4gYnVmZmVyIGFuZCByZXR1cm5zIGl0IGFzIEpTIHN0cmluZyB0aGF0IGlzXG4vLyBndWFyYW50ZWVkIHRvIG5vdCBjb250YWluIGFueSBwYXJ0aWFsIG11bHRpLWJ5dGUgY2hhcmFjdGVycy4gQW55IHBhcnRpYWxcbi8vIGNoYXJhY3RlciBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgaXMgYnVmZmVyZWQgdXAsIGFuZCB3aWxsIGJlXG4vLyByZXR1cm5lZCB3aGVuIGNhbGxpbmcgd3JpdGUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzLlxuLy9cbi8vIE5vdGU6IENvbnZlcnRpbmcgYSBCdWZmZXIgY29udGFpbmluZyBhbiBvcnBoYW4gc3Vycm9nYXRlIHRvIGEgU3RyaW5nXG4vLyBjdXJyZW50bHkgd29ya3MsIGJ1dCBjb252ZXJ0aW5nIGEgU3RyaW5nIHRvIGEgQnVmZmVyICh2aWEgYG5ldyBCdWZmZXJgLCBvclxuLy8gQnVmZmVyI3dyaXRlKSB3aWxsIHJlcGxhY2UgaW5jb21wbGV0ZSBzdXJyb2dhdGVzIHdpdGggdGhlIHVuaWNvZGVcbi8vIHJlcGxhY2VtZW50IGNoYXJhY3Rlci4gU2VlIGh0dHBzOi8vY29kZXJldmlldy5jaHJvbWl1bS5vcmcvMTIxMTczMDA5LyAuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBhdmFpbGFibGUgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgIGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBieXRlcyB0byB0aGUgY2hhciBidWZmZXJcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCAwLCBhdmFpbGFibGUpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IGF2YWlsYWJsZTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYnl0ZXMgYmVsb25naW5nIHRvIHRoZSBjdXJyZW50IGNoYXJhY3RlciBmcm9tIHRoZSBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYXZhaWxhYmxlLCBidWZmZXIubGVuZ3RoKTtcblxuICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIHNwbGl0XG4gICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNoYXJTdHI7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGFuZCBzZXQgY2hhckxlbmd0aCAvIGNoYXJSZWNlaXZlZFxuICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcik7XG5cbiAgdmFyIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkLCBlbmQpO1xuICAgIGVuZCAtPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICB0aGlzLmNoYXJMZW5ndGggKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xuICAgIHRoaXMuY2hhckJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgc2l6ZSwgMCwgc2l6ZSk7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCAwLCBzaXplKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cbi8vIGRldGVjdEluY29tcGxldGVDaGFyIGRldGVybWluZXMgaWYgdGhlcmUgaXMgYW4gaW5jb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXIgYXRcbi8vIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gSWYgc28sIGl0IHNldHMgdGhpcy5jaGFyTGVuZ3RoIHRvIHRoZSBieXRlXG4vLyBsZW5ndGggdGhhdCBjaGFyYWN0ZXIsIGFuZCBzZXRzIHRoaXMuY2hhclJlY2VpdmVkIHRvIHRoZSBudW1iZXIgb2YgYnl0ZXNcbi8vIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdGhpcyBjaGFyYWN0ZXIuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMiA6IDA7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDMgOiAwO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5mdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihhcmcpO1xufVxuZXhwb3J0cy5pc0J1ZmZlciA9IGlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59IiwiLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIEJ1ZmZlclxuICpcbiAqIEF1dGhvcjogICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogTGljZW5zZTogIE1JVFxuICpcbiAqIGBucG0gaW5zdGFsbCBpcy1idWZmZXJgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiAhIShvYmogIT0gbnVsbCAmJlxuICAgIChvYmouX2lzQnVmZmVyIHx8IC8vIEZvciBTYWZhcmkgNS03IChtaXNzaW5nIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IpXG4gICAgICAob2JqLmNvbnN0cnVjdG9yICYmXG4gICAgICB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKSlcbiAgICApKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpcy1hcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG52YXIgcm9vdFBhcmVudCA9IHt9XG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gU2FmYXJpIDUtNyBsYWNrcyBzdXBwb3J0IGZvciBjaGFuZ2luZyB0aGUgYE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3JgIHByb3BlcnR5XG4gKiAgICAgb24gb2JqZWN0cy5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIGZ1bmN0aW9uIEJhciAoKSB7fVxuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgYXJyLmNvbnN0cnVjdG9yID0gQmFyXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgYXJyLmNvbnN0cnVjdG9yID09PSBCYXIgJiYgLy8gY29uc3RydWN0b3IgY2FuIGJlIHNldFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChhcmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAvLyBBdm9pZCBnb2luZyB0aHJvdWdoIGFuIEFyZ3VtZW50c0FkYXB0b3JUcmFtcG9saW5lIGluIHRoZSBjb21tb24gY2FzZS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHJldHVybiBuZXcgQnVmZmVyKGFyZywgYXJndW1lbnRzWzFdKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZylcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gMFxuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZFxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLCBhcmcpXG4gIH1cblxuICAvLyBTbGlnaHRseSBsZXNzIGNvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGlzLCBhcmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogJ3V0ZjgnKVxuICB9XG5cbiAgLy8gVW51c3VhbC5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhpcywgYXJnKVxufVxuXG5mdW5jdGlvbiBmcm9tTnVtYmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChsZW5ndGgpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIC8vIEFzc3VtcHRpb246IGJ5dGVMZW5ndGgoKSByZXR1cm4gdmFsdWUgaXMgYWx3YXlzIDwga01heExlbmd0aC5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpKSByZXR1cm4gZnJvbUJ1ZmZlcih0aGF0LCBvYmplY3QpXG5cbiAgaWYgKGlzQXJyYXkob2JqZWN0KSkgcmV0dXJuIGZyb21BcnJheSh0aGF0LCBvYmplY3QpXG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzdGFydCB3aXRoIG51bWJlciwgYnVmZmVyLCBhcnJheSBvciBzdHJpbmcnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAob2JqZWN0LmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gZnJvbVR5cGVkQXJyYXkodGhhdCwgb2JqZWN0KVxuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgb2JqZWN0KVxuICAgIH1cbiAgfVxuXG4gIGlmIChvYmplY3QubGVuZ3RoKSByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmplY3QpXG5cbiAgcmV0dXJuIGZyb21Kc29uT2JqZWN0KHRoYXQsIG9iamVjdClcbn1cblxuZnVuY3Rpb24gZnJvbUJ1ZmZlciAodGhhdCwgYnVmZmVyKSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGJ1ZmZlci5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBidWZmZXIuY29weSh0aGF0LCAwLCAwLCBsZW5ndGgpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8vIER1cGxpY2F0ZSBvZiBmcm9tQXJyYXkoKSB0byBrZWVwIGZyb21BcnJheSgpIG1vbm9tb3JwaGljLlxuZnVuY3Rpb24gZnJvbVR5cGVkQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIC8vIFRydW5jYXRpbmcgdGhlIGVsZW1lbnRzIGlzIHByb2JhYmx5IG5vdCB3aGF0IHBlb3BsZSBleHBlY3QgZnJvbSB0eXBlZFxuICAvLyBhcnJheXMgd2l0aCBCWVRFU19QRVJfRUxFTUVOVCA+IDEgYnV0IGl0J3MgY29tcGF0aWJsZSB3aXRoIHRoZSBiZWhhdmlvclxuICAvLyBvZiB0aGUgb2xkIEJ1ZmZlciBjb25zdHJ1Y3Rvci5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXkpIHtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYXJyYXkuYnl0ZUxlbmd0aFxuICAgIHRoYXQgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkoYXJyYXkpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbVR5cGVkQXJyYXkodGhhdCwgbmV3IFVpbnQ4QXJyYXkoYXJyYXkpKVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEZXNlcmlhbGl6ZSB7IHR5cGU6ICdCdWZmZXInLCBkYXRhOiBbMSwyLDMsLi4uXSB9IGludG8gYSBCdWZmZXIgb2JqZWN0LlxuLy8gUmV0dXJucyBhIHplcm8tbGVuZ3RoIGJ1ZmZlciBmb3IgaW5wdXRzIHRoYXQgZG9uJ3QgY29uZm9ybSB0byB0aGUgc3BlYy5cbmZ1bmN0aW9uIGZyb21Kc29uT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgdmFyIGFycmF5XG4gIHZhciBsZW5ndGggPSAwXG5cbiAgaWYgKG9iamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iamVjdC5kYXRhKSkge1xuICAgIGFycmF5ID0gb2JqZWN0LmRhdGFcbiAgICBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIH1cbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbn1cblxuZnVuY3Rpb24gYWxsb2NhdGUgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gICAgdGhhdC5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgZnJvbVBvb2wgPSBsZW5ndGggIT09IDAgJiYgbGVuZ3RoIDw9IEJ1ZmZlci5wb29sU2l6ZSA+Pj4gMVxuICBpZiAoZnJvbVBvb2wpIHRoYXQucGFyZW50ID0gcm9vdFBhcmVudFxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNsb3dCdWZmZXIpKSByZXR1cm4gbmV3IFNsb3dCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGRlbGV0ZSBidWYucGFyZW50XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIHZhciBpID0gMFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkgYnJlYWtcblxuICAgICsraVxuICB9XG5cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMuJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHN0cmluZyA9ICcnICsgc3RyaW5nXG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAvLyBEZXByZWNhdGVkXG4gICAgICBjYXNlICdyYXcnOlxuICAgICAgY2FzZSAncmF3cyc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG4vLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbkJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0IHwgMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgfCAwXG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcbiAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8PSBzdGFydCkgcmV0dXJuICcnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiAwXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICBieXRlT2Zmc2V0ID4+PSAwXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVybiAtMVxuXG4gIC8vIE5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0LCAwKVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSByZXR1cm4gLTEgLy8gc3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcgYWx3YXlzIGZhaWxzXG4gICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgWyB2YWwgXSwgYnl0ZU9mZnNldClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yICh2YXIgaSA9IDA7IGJ5dGVPZmZzZXQgKyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2J5dGVPZmZzZXQgKyBpXSA9PT0gdmFsW2ZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4XSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbC5sZW5ndGgpIHJldHVybiBieXRlT2Zmc2V0ICsgZm91bmRJbmRleFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuLy8gYGdldGAgaXMgZGVwcmVjYXRlZFxuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgaXMgZGVwcmVjYXRlZFxuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aCB8IDBcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgaWYgKG5ld0J1Zi5sZW5ndGgpIG5ld0J1Zi5wYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRTdGFydClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gdG9BcnJheUJ1ZmZlciAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gX2F1Z21lbnQgKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IHNldCBtZXRob2QgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuZXF1YWxzID0gQlAuZXF1YWxzXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxuICBhcnIuaW5kZXhPZiA9IEJQLmluZGV4T2ZcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludExFID0gQlAucmVhZFVJbnRMRVxuICBhcnIucmVhZFVJbnRCRSA9IEJQLnJlYWRVSW50QkVcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50TEUgPSBCUC5yZWFkSW50TEVcbiAgYXJyLnJlYWRJbnRCRSA9IEJQLnJlYWRJbnRCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnRMRSA9IEJQLndyaXRlVUludExFXG4gIGFyci53cml0ZVVJbnRCRSA9IEJQLndyaXRlVUludEJFXG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnRMRSA9IEJQLndyaXRlSW50TEVcbiAgYXJyLndyaXRlSW50QkUgPSBCUC53cml0ZUludEJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gbGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCB8IDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuIiwiXG4vKipcbiAqIGlzQXJyYXlcbiAqL1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogdG9TdHJpbmdcbiAqL1xuXG52YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gYHZhbGBcbiAqIGlzIGFuIGFycmF5LlxuICpcbiAqIGV4YW1wbGU6XG4gKlxuICogICAgICAgIGlzQXJyYXkoW10pO1xuICogICAgICAgIC8vID4gdHJ1ZVxuICogICAgICAgIGlzQXJyYXkoYXJndW1lbnRzKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKiAgICAgICAgaXNBcnJheSgnJyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICpcbiAqIEBwYXJhbSB7bWl4ZWR9IHZhbFxuICogQHJldHVybiB7Ym9vbH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXkgfHwgZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gISEgdmFsICYmICdbb2JqZWN0IEFycmF5XScgPT0gc3RyLmNhbGwodmFsKTtcbn07XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cdHZhciBQTFVTX1VSTF9TQUZFID0gJy0nLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIX1VSTF9TQUZFID0gJ18nLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUyB8fFxuXHRcdCAgICBjb2RlID09PSBQTFVTX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSCB8fFxuXHRcdCAgICBjb2RlID09PSBTTEFTSF9VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIHZhciBtO1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gMDtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvKiBnbG9iYWwgRGlhbG9nLCBkYXNoYm9hcmQsIEFwcGxhYiAqL1xuLy8gVE9ETyAoam9zaCkgLSBkb24ndCBwYXNzIGBEaWFsb2dgIGludG8gYGNyZWF0ZU1vZGFsRGlhbG9nYC5cblxudmFyIEFzc2V0TWFuYWdlciA9IHJlcXVpcmUoJy4vQXNzZXRNYW5hZ2VyLmpzeCcpO1xudmFyIHN0dWRpb0FwcCA9IHJlcXVpcmUoJy4uL1N0dWRpb0FwcCcpLnNpbmdsZXRvbjtcblxuLyoqXG4gKiBEaXNwbGF5IHRoZSBcIk1hbmFnZSBBc3NldHNcIiBtb2RhbC5cbiAqIEBwYXJhbSBhc3NldENob3NlbiB7RnVuY3Rpb259IENhbGxlZCB3aGVuIHRoZSB1c2VyIGNob29zZXMgYW4gYXNzZXQuIFRoZVxuICogICBcIkNob29zZVwiIGJ1dHRvbiBpbiB0aGUgVUkgb25seSBhcHBlYXJzIGlmIHRoaXMgb3B0aW9uYWwgcGFyYW0gaXMgcHJvdmlkZWQuXG4gKiBAcGFyYW0gdHlwZUZpbHRlciB7U3RyaW5nfSBUaGUgdHlwZSBvZiBhc3NldHMgdG8gc2hvdyBhbmQgYWxsb3cgdG8gYmVcbiAqICAgdXBsb2FkZWQuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXNzZXRDaG9zZW4sIHR5cGVGaWx0ZXIpIHtcbiAgdmFyIGNvZGVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIHNob3dDaG9zZUltYWdlQnV0dG9uID0gYXNzZXRDaG9zZW4gJiYgdHlwZW9mIGFzc2V0Q2hvc2VuID09PSAnZnVuY3Rpb24nO1xuICB2YXIgZGlhbG9nID0gc3R1ZGlvQXBwLmNyZWF0ZU1vZGFsRGlhbG9nKHtcbiAgICBjb250ZW50RGl2OiBjb2RlRGl2LFxuICAgIGRlZmF1bHRCdG5TZWxlY3RvcjogJ2FnYWluLWJ1dHRvbicsXG4gICAgaWQ6ICdtYW5hZ2VBc3NldHNNb2RhbCdcbiAgfSk7XG4gIFJlYWN0RE9NLnJlbmRlcihSZWFjdC5jcmVhdGVFbGVtZW50KEFzc2V0TWFuYWdlciwge1xuICAgIHR5cGVGaWx0ZXI6IHR5cGVGaWx0ZXIsXG4gICAgY2hhbm5lbElkOiBkYXNoYm9hcmQucHJvamVjdC5nZXRDdXJyZW50SWQoKSxcbiAgICB1cGxvYWRzRW5hYmxlZDogIWRhc2hib2FyZC5wcm9qZWN0LmV4Y2VlZHNBYnVzZVRocmVzaG9sZCgpLFxuICAgIGFzc2V0Q2hvc2VuOiBzaG93Q2hvc2VJbWFnZUJ1dHRvbiA/IGZ1bmN0aW9uIChmaWxlV2l0aFBhdGgpIHtcbiAgICAgIGRpYWxvZy5oaWRlKCk7XG4gICAgICBhc3NldENob3NlbihmaWxlV2l0aFBhdGgpO1xuICAgIH0gOiBudWxsXG4gIH0pLCBjb2RlRGl2KTtcblxuICBkaWFsb2cuc2hvdygpO1xufTtcbiIsInZhciBhc3NldHNBcGkgPSByZXF1aXJlKCcuLi9jbGllbnRBcGknKS5hc3NldHM7XG52YXIgQXNzZXRSb3cgPSByZXF1aXJlKCcuL0Fzc2V0Um93LmpzeCcpO1xudmFyIEFzc2V0VXBsb2FkZXIgPSByZXF1aXJlKCcuL0Fzc2V0VXBsb2FkZXIuanN4Jyk7XG52YXIgYXNzZXRMaXN0U3RvcmUgPSByZXF1aXJlKCcuL2Fzc2V0TGlzdFN0b3JlJyk7XG5cbnZhciBlcnJvck1lc3NhZ2VzID0ge1xuICA0MDM6ICdRdW90YSBleGNlZWRlZC4gUGxlYXNlIGRlbGV0ZSBzb21lIGZpbGVzIGFuZCB0cnkgYWdhaW4uJyxcbiAgNDEzOiAnVGhlIGZpbGUgaXMgdG9vIGxhcmdlLicsXG4gIDQxNTogJ1RoaXMgdHlwZSBvZiBmaWxlIGlzIG5vdCBzdXBwb3J0ZWQuJyxcbiAgNTAwOiAnVGhlIHNlcnZlciByZXNwb25kZWQgd2l0aCBhbiBlcnJvci4nLFxuICB1bmtub3duOiAnQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZC4nXG59O1xuXG52YXIgZXJyb3JVcGxvYWREaXNhYmxlZCA9IFwiVGhpcyBwcm9qZWN0IGhhcyBiZWVuIHJlcG9ydGVkIGZvciBhYnVzaXZlIGNvbnRlbnQsIFwiICtcbiAgXCJzbyB1cGxvYWRpbmcgbmV3IGFzc2V0cyBpcyBkaXNhYmxlZC5cIjtcblxuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKHN0YXR1cykge1xuICByZXR1cm4gZXJyb3JNZXNzYWdlc1tzdGF0dXNdIHx8IGVycm9yTWVzc2FnZXMudW5rbm93bjtcbn1cblxuLyoqXG4gKiBBIGNvbXBvbmVudCBmb3IgbWFuYWdpbmcgaG9zdGVkIGFzc2V0cy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIHByb3BUeXBlczoge1xuICAgIGFzc2V0Q2hvc2VuOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICB0eXBlRmlsdGVyOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGNoYW5uZWxJZDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIHVwbG9hZHNFbmFibGVkOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzc2V0czogbnVsbCxcbiAgICAgIHN0YXR1c01lc3NhZ2U6IHRoaXMucHJvcHMudXBsb2Fkc0VuYWJsZWQgPyAnJyA6IGVycm9yVXBsb2FkRGlzYWJsZWRcbiAgICB9O1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE86IFVzZSBEYXZlJ3MgY2xpZW50IGFwaSB3aGVuIGl0J3MgZmluaXNoZWQuXG4gICAgYXNzZXRzQXBpLmFqYXgoJ0dFVCcsICcnLCB0aGlzLm9uQXNzZXRMaXN0UmVjZWl2ZWQsIHRoaXMub25Bc3NldExpc3RGYWlsdXJlKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsbGVkIGFmdGVyIHRoZSBjb21wb25lbnQgbW91bnRzLCB3aGVuIHRoZSBzZXJ2ZXIgcmVzcG9uZHMgd2l0aCB0aGVcbiAgICogY3VycmVudCBsaXN0IG9mIGFzc2V0cy5cbiAgICogQHBhcmFtIHhoclxuICAgKi9cbiAgb25Bc3NldExpc3RSZWNlaXZlZDogZnVuY3Rpb24gKHhocikge1xuICAgIGFzc2V0TGlzdFN0b3JlLnJlc2V0KEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCkpO1xuICAgIHRoaXMuc2V0U3RhdGUoe2Fzc2V0czogYXNzZXRMaXN0U3RvcmUubGlzdCh0aGlzLnByb3BzLnR5cGVGaWx0ZXIpfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGxlZCBhZnRlciB0aGUgY29tcG9uZW50IG1vdW50cywgaWYgdGhlIHNlcnZlciByZXNwb25kcyB3aXRoIGFuIGVycm9yXG4gICAqIHdoZW4gbG9hZGluZyB0aGUgY3VycmVudCBsaXN0IG9mIGFzc2V0cy5cbiAgICogQHBhcmFtIHhoclxuICAgKi9cbiAgb25Bc3NldExpc3RGYWlsdXJlOiBmdW5jdGlvbiAoeGhyKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7c3RhdHVzTWVzc2FnZTogJ0Vycm9yIGxvYWRpbmcgYXNzZXQgbGlzdDogJyArXG4gICAgICBnZXRFcnJvck1lc3NhZ2UoeGhyLnN0YXR1cyl9KTtcbiAgfSxcblxuICBvblVwbG9hZFN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7c3RhdHVzTWVzc2FnZTogJ1VwbG9hZGluZy4uLid9KTtcbiAgfSxcblxuICBvblVwbG9hZERvbmU6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBhc3NldExpc3RTdG9yZS5hZGQocmVzdWx0KTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGFzc2V0czogYXNzZXRMaXN0U3RvcmUubGlzdCh0aGlzLnByb3BzLnR5cGVGaWx0ZXIpLFxuICAgICAgc3RhdHVzTWVzc2FnZTogJ0ZpbGUgXCInICsgcmVzdWx0LmZpbGVuYW1lICsgJ1wiIHN1Y2Nlc3NmdWxseSB1cGxvYWRlZCEnXG4gICAgfSk7XG4gIH0sXG5cbiAgb25VcGxvYWRFcnJvcjogZnVuY3Rpb24gKHN0YXR1cykge1xuICAgIHRoaXMuc2V0U3RhdGUoe3N0YXR1c01lc3NhZ2U6ICdFcnJvciB1cGxvYWRpbmcgZmlsZTogJyArXG4gICAgICBnZXRFcnJvck1lc3NhZ2Uoc3RhdHVzKX0pO1xuICB9LFxuXG4gIGRlbGV0ZUFzc2V0Um93OiBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgYXNzZXRzOiBhc3NldExpc3RTdG9yZS5yZW1vdmUobmFtZSksXG4gICAgICBzdGF0dXNNZXNzYWdlOiAnRmlsZSBcIicgKyBuYW1lICsgJ1wiIHN1Y2Nlc3NmdWxseSBkZWxldGVkISdcbiAgICB9KTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXBsb2FkQnV0dG9uID0gPGRpdj5cbiAgICAgIDxBc3NldFVwbG9hZGVyXG4gICAgICAgIHVwbG9hZHNFbmFibGVkPXt0aGlzLnByb3BzLnVwbG9hZHNFbmFibGVkfVxuICAgICAgICB0eXBlRmlsdGVyPXt0aGlzLnByb3BzLnR5cGVGaWx0ZXJ9XG4gICAgICAgIGNoYW5uZWxJZD17dGhpcy5wcm9wcy5jaGFubmVsSWR9XG4gICAgICAgIG9uVXBsb2FkU3RhcnQ9e3RoaXMub25VcGxvYWRTdGFydH1cbiAgICAgICAgb25VcGxvYWREb25lPXt0aGlzLm9uVXBsb2FkRG9uZX1cbiAgICAgICAgb25VcGxvYWRFcnJvcj17dGhpcy5vblVwbG9hZEVycm9yfS8+XG4gICAgICA8c3BhbiBzdHlsZT17e21hcmdpbjogJzAgMTBweCd9fSBpZD1cIm1hbmFnZS1hc3NldC1zdGF0dXNcIj5cbiAgICAgICAge3RoaXMuc3RhdGUuc3RhdHVzTWVzc2FnZX1cbiAgICAgIDwvc3Bhbj5cbiAgICA8L2Rpdj47XG5cbiAgICB2YXIgYXNzZXRMaXN0O1xuICAgIC8vIElmIGB0aGlzLnN0YXRlLmFzc2V0c2AgaXMgbnVsbCwgdGhlIGFzc2V0IGxpc3QgaXMgc3RpbGwgbG9hZGluZy4gSWYgaXQnc1xuICAgIC8vIGVtcHR5LCB0aGUgYXNzZXQgbGlzdCBoYXMgbG9hZGVkIGFuZCB0aGVyZSBhcmUgbm8gYXNzZXRzIGluIHRoZSBjdXJyZW50XG4gICAgLy8gY2hhbm5lbCAobWF0Y2hpbmcgdGhlIGB0eXBlRmlsdGVyYCwgaWYgb25lIHdhcyBwcm92aWRlZCkuXG4gICAgaWYgKHRoaXMuc3RhdGUuYXNzZXRzID09PSBudWxsKSB7XG4gICAgICBhc3NldExpc3QgPSAoXG4gICAgICAgIDxkaXYgc3R5bGU9e3ttYXJnaW46ICcxZW0gMCcsIHRleHRBbGlnbjogJ2NlbnRlcid9fT5cbiAgICAgICAgICA8aSBjbGFzc05hbWU9XCJmYSBmYS1zcGlubmVyIGZhLXNwaW5cIiBzdHlsZT17e2ZvbnRTaXplOiAnMzJweCd9fT48L2k+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuYXNzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXNzZXRMaXN0ID0gKFxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxkaXYgc3R5bGU9e3ttYXJnaW46ICcxZW0gMCd9fT5cbiAgICAgICAgICAgIFlvdXIgYXNzZXRzIHdpbGwgYXBwZWFyIGhlcmUuIENsaWNrIFwiVXBsb2FkIEZpbGVcIiB0byBhZGQgYSBuZXcgYXNzZXRcbiAgICAgICAgICAgIGZvciB0aGlzIHByb2plY3QuXG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAge3VwbG9hZEJ1dHRvbn1cbiAgICAgICAgPC9kaXY+XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcm93cyA9IHRoaXMuc3RhdGUuYXNzZXRzLm1hcChmdW5jdGlvbiAoYXNzZXQpIHtcbiAgICAgICAgdmFyIGNob29zZSA9IHRoaXMucHJvcHMuYXNzZXRDaG9zZW4gJiYgdGhpcy5wcm9wcy5hc3NldENob3Nlbi5iaW5kKHRoaXMsXG4gICAgICAgICAgICBhc3NldC5maWxlbmFtZSk7XG5cbiAgICAgICAgcmV0dXJuIDxBc3NldFJvd1xuICAgICAgICAgICAga2V5PXthc3NldC5maWxlbmFtZX1cbiAgICAgICAgICAgIG5hbWU9e2Fzc2V0LmZpbGVuYW1lfVxuICAgICAgICAgICAgdHlwZT17YXNzZXQuY2F0ZWdvcnl9XG4gICAgICAgICAgICBzaXplPXthc3NldC5zaXplfVxuICAgICAgICAgICAgb25DaG9vc2U9e2Nob29zZX1cbiAgICAgICAgICAgIG9uRGVsZXRlPXt0aGlzLmRlbGV0ZUFzc2V0Um93LmJpbmQodGhpcywgYXNzZXQuZmlsZW5hbWUpfSAvPjtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgIGFzc2V0TGlzdCA9IChcbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8ZGl2IHN0eWxlPXt7bWF4SGVpZ2h0OiAnMzMwcHgnLCBvdmVyZmxvd1k6ICdzY3JvbGwnLCBtYXJnaW46ICcxZW0gMCcsIHBhZGRpbmdSaWdodDogJzE1cHgnfX0+XG4gICAgICAgICAgICA8dGFibGUgc3R5bGU9e3t3aWR0aDogJzEwMCUnfX0+XG4gICAgICAgICAgICAgIDx0Ym9keT5cbiAgICAgICAgICAgICAgICB7cm93c31cbiAgICAgICAgICAgICAgPC90Ym9keT5cbiAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAge3VwbG9hZEJ1dHRvbn1cbiAgICAgICAgPC9kaXY+XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciB0aXRsZSA9IHRoaXMucHJvcHMuYXNzZXRDaG9zZW4gP1xuICAgICAgICA8cCBjbGFzc05hbWU9XCJkaWFsb2ctdGl0bGVcIj5DaG9vc2UgQXNzZXRzPC9wPiA6XG4gICAgICAgIDxwIGNsYXNzTmFtZT1cImRpYWxvZy10aXRsZVwiPk1hbmFnZSBBc3NldHM8L3A+O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW9kYWwtY29udGVudFwiIHN0eWxlPXt7bWFyZ2luOiAwfX0+XG4gICAgICAgIHt0aXRsZX1cbiAgICAgICAge2Fzc2V0TGlzdH1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn0pO1xuIiwiXG4vKipcbiAqIEEgY29tcG9uZW50IGZvciBtYW5hZ2luZyBob3N0ZWQgYXNzZXRzLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgcHJvcFR5cGVzOiB7XG4gICAgb25VcGxvYWRTdGFydDogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvblVwbG9hZERvbmU6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgY2hhbm5lbElkOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgdHlwZUZpbHRlcjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICB1cGxvYWRzRW5hYmxlZDogUmVhY3QuUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcblxuICAgICQodGhpcy5yZWZzLnVwbG9hZGVyKS5maWxldXBsb2FkKHtcbiAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICB1cmw6ICcvdjMvYXNzZXRzLycgKyBwcm9wcy5jaGFubmVsSWQgKyAnLycsXG4gICAgICAvLyBwcmV2ZW50IGZpbGV1cGxvYWQgZnJvbSByZXBsYWNpbmcgdGhlIGlucHV0IERPTSBlbGVtZW50LCB3aGljaFxuICAgICAgLy8gUmVhY3QgZG9lcyBub3QgbGlrZVxuICAgICAgcmVwbGFjZUZpbGVJbnB1dDogZmFsc2UsXG4gICAgICBhZGQ6IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICAgIHByb3BzLm9uVXBsb2FkU3RhcnQoKTtcbiAgICAgICAgZGF0YS5zdWJtaXQoKTtcbiAgICAgIH0sXG4gICAgICBkb25lOiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICBwcm9wcy5vblVwbG9hZERvbmUoZGF0YS5yZXN1bHQpO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICBwcm9wcy5vblVwbG9hZEVycm9yKGUuc3RhdHVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gKCkge1xuICAgICQodGhpcy5yZWZzLnVwbG9hZGVyKS5maWxldXBsb2FkKCdkZXN0cm95Jyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdlJ3ZlIGhpZGRlbiB0aGUgPGlucHV0IHR5cGU9XCJmaWxlXCIvPiBhbmQgcmVwbGFjZWQgaXQgd2l0aCBhIGJpZyBidXR0b24uXG4gICAqIEZvcndhcmQgY2xpY2tzIG9uIHRoZSBidXR0b24gdG8gdGhlIGhpZGRlbiBmaWxlIGlucHV0LlxuICAgKi9cbiAgZmlsZVVwbG9hZENsaWNrZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlZnMudXBsb2FkZXIuY2xpY2soKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBOT1RFOiBJRTkgd2lsbCBpZ25vcmUgYWNjZXB0LCB3aGljaCBtZWFucyBvbiB0aGlzIGJyb3dzZXIgd2UgY2FuIGVuZFxuICAgIC8vIHVwIHVwbG9hZGluZyBmaWxlcyB0aGF0IGRvbnQgbWF0Y2ggdHlwZUZpbHRlclxuICAgIHJldHVybiAoXG4gICAgICA8c3Bhbj5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgICByZWY9XCJ1cGxvYWRlclwiXG4gICAgICAgICAgICB0eXBlPVwiZmlsZVwiXG4gICAgICAgICAgICBzdHlsZT17e2Rpc3BsYXk6ICdub25lJ319XG4gICAgICAgICAgICBhY2NlcHQ9eyh0aGlzLnByb3BzLnR5cGVGaWx0ZXIgfHwgJyonKSArICcvKid9Lz5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgb25DbGljaz17dGhpcy5maWxlVXBsb2FkQ2xpY2tlZH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInNoYXJlXCJcbiAgICAgICAgICAgIGlkPVwidXBsb2FkLWFzc2V0XCJcbiAgICAgICAgICAgIGRpc2FibGVkPXshdGhpcy5wcm9wcy51cGxvYWRzRW5hYmxlZH0+XG4gICAgICAgICAgPGkgY2xhc3NOYW1lPVwiZmEgZmEtdXBsb2FkXCI+PC9pPlxuICAgICAgICAgICZuYnNwO1VwbG9hZCBGaWxlXG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9zcGFuPlxuICAgICk7XG4gIH1cbn0pO1xuIiwidmFyIGFzc2V0c0FwaSA9IHJlcXVpcmUoJy4uL2NsaWVudEFwaScpLmFzc2V0cztcbnZhciBBc3NldFRodW1ibmFpbCA9IHJlcXVpcmUoJy4vQXNzZXRUaHVtYm5haWwuanN4Jyk7XG5cbi8qKlxuICogQSBzaW5nbGUgcm93IGluIHRoZSBBc3NldE1hbmFnZXIsIGRlc2NyaWJpbmcgb25lIGFzc2V0LlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgcHJvcFR5cGVzOiB7XG4gICAgbmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIHR5cGU6IFJlYWN0LlByb3BUeXBlcy5vbmVPZihbJ2ltYWdlJywgJ2F1ZGlvJywgJ3ZpZGVvJ10pLmlzUmVxdWlyZWQsXG4gICAgc2l6ZTogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBvbkNob29zZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25EZWxldGU6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgfSxcblxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aW9uOiAnbm9ybWFsJyxcbiAgICAgIGFjdGlvblRleHQ6ICcnXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQ29uZmlybSB0aGUgdXNlciBhY3R1YWxseSB3YW50cyB0byBkZWxldGUgdGhpcyBhc3NldC5cbiAgICovXG4gIGNvbmZpcm1EZWxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHthY3Rpb246ICdjb25maXJtaW5nIGRlbGV0ZScsIGFjdGlvblRleHQ6ICcnfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgdXNlciBkaWRuJ3Qgd2FudCB0byBkZWxldGUgdGhpcyBhc3NldC5cbiAgICovXG4gIGNhbmNlbERlbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe2FjdGlvbjogJ25vcm1hbCcsIGFjdGlvblRleHQ6ICcnfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZSB0aGlzIGFzc2V0IGFuZCBub3RpZnkgdGhlIHBhcmVudCB0byByZW1vdmUgdGhpcyByb3cuIElmIHRoZSBkZWxldGVcbiAgICogZmFpbHMsIGZsaXAgYmFjayB0byAnY29uZmlybWluZyBkZWxldGUnIGFuZCBkaXNwbGF5IGEgbWVzc2FnZS5cbiAgICovXG4gIGhhbmRsZURlbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe2FjdGlvbjogJ2RlbGV0aW5nJywgYWN0aW9uVGV4dDogJyd9KTtcblxuICAgIC8vIFRPRE86IFVzZSBEYXZlJ3MgY2xpZW50IGFwaSB3aGVuIGl0J3MgZmluaXNoZWQuXG4gICAgYXNzZXRzQXBpLmFqYXgoJ0RFTEVURScsIHRoaXMucHJvcHMubmFtZSwgdGhpcy5wcm9wcy5vbkRlbGV0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7YWN0aW9uOiAnY29uZmlybWluZyBkZWxldGUnLFxuICAgICAgICAgIGFjdGlvblRleHQ6ICdFcnJvciBkZWxldGluZyBmaWxlLid9KTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBhY3Rpb25zLCBmbGV4O1xuICAgIC8vIGBmbGV4YCBpcyB0aGUgXCJDaG9vc2VcIiBidXR0b24gaW4gZmlsZS1jaG9vc2UgbW9kZSwgb3IgdGhlIGZpbGVzaXplLlxuICAgIGlmICh0aGlzLnByb3BzLm9uQ2hvb3NlKSB7XG4gICAgICBmbGV4ID0gPGJ1dHRvbiBvbkNsaWNrPXt0aGlzLnByb3BzLm9uQ2hvb3NlfT5DaG9vc2U8L2J1dHRvbj47XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzaXplID0gKHRoaXMucHJvcHMuc2l6ZSAvIDEwMDApLnRvRml4ZWQoMik7XG4gICAgICBmbGV4ID0gc2l6ZSArICcga2InO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5zdGF0ZS5hY3Rpb24pIHtcbiAgICAgIGNhc2UgJ25vcm1hbCc6XG4gICAgICAgIHZhciBzcmMgPSBhc3NldHNBcGkuYmFzZVBhdGgodGhpcy5wcm9wcy5uYW1lKTtcbiAgICAgICAgYWN0aW9ucyA9IChcbiAgICAgICAgICA8dGQgd2lkdGg9XCIyNTBcIiBzdHlsZT17e3RleHRBbGlnbjogJ3JpZ2h0J319PlxuICAgICAgICAgICAge2ZsZXh9XG4gICAgICAgICAgICA8YSBocmVmPXtzcmN9XG4gICAgICAgICAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgICAgICAgICAgICBzdHlsZT17e2JhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50J319PlxuICAgICAgICAgICAgICA8YnV0dG9uPjxpIGNsYXNzTmFtZT1cImZhIGZhLWV5ZVwiPjwvaT48L2J1dHRvbj5cbiAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiYnRuLWRhbmdlclwiIG9uQ2xpY2s9e3RoaXMuY29uZmlybURlbGV0ZX0+XG4gICAgICAgICAgICAgIDxpIGNsYXNzTmFtZT1cImZhIGZhLXRyYXNoLW9cIj48L2k+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIHt0aGlzLnN0YXRlLmFjdGlvblRleHR9XG4gICAgICAgICAgPC90ZD5cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjb25maXJtaW5nIGRlbGV0ZSc6XG4gICAgICAgIGFjdGlvbnMgPSAoXG4gICAgICAgICAgPHRkIHdpZHRoPVwiMjUwXCIgc3R5bGU9e3t0ZXh0QWxpZ246ICdyaWdodCd9fT5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiYnRuLWRhbmdlclwiIG9uQ2xpY2s9e3RoaXMuaGFuZGxlRGVsZXRlfT5cbiAgICAgICAgICAgICAgRGVsZXRlIEZpbGVcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXt0aGlzLmNhbmNlbERlbGV0ZX0+Q2FuY2VsPC9idXR0b24+XG4gICAgICAgICAgICB7dGhpcy5zdGF0ZS5hY3Rpb25UZXh0fVxuICAgICAgICAgIDwvdGQ+XG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGVsZXRpbmcnOlxuICAgICAgICBhY3Rpb25zID0gKFxuICAgICAgICAgIDx0ZCB3aWR0aD1cIjI1MFwiIHN0eWxlPXt7dGV4dEFsaWduOiAncmlnaHQnfX0+XG4gICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJmYSBmYS1zcGlubmVyIGZhLXNwaW5cIiBzdHlsZT17e1xuICAgICAgICAgICAgICBmb250U2l6ZTogJzMycHgnLFxuICAgICAgICAgICAgICBtYXJnaW5SaWdodDogJzE1cHgnXG4gICAgICAgICAgICB9fT48L2k+XG4gICAgICAgICAgPC90ZD5cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDx0ciBjbGFzc05hbWU9XCJhc3NldFJvd1wiIG9uRG91YmxlQ2xpY2s9e3RoaXMucHJvcHMub25DaG9vc2V9PlxuICAgICAgICA8QXNzZXRUaHVtYm5haWwgdHlwZT17dGhpcy5wcm9wcy50eXBlfSBuYW1lPXt0aGlzLnByb3BzLm5hbWV9Lz5cbiAgICAgICAgPHRkPnt0aGlzLnByb3BzLm5hbWV9PC90ZD5cbiAgICAgICAge2FjdGlvbnN9XG4gICAgICA8L3RyPlxuICAgICk7XG4gIH1cbn0pO1xuIiwidmFyIGFzc2V0c0FwaSA9IHJlcXVpcmUoJy4uL2NsaWVudEFwaScpLmFzc2V0cztcblxudmFyIGRlZmF1bHRJY29ucyA9IHtcbiAgaW1hZ2U6ICdmYSBmYS1waWN0dXJlLW8nLFxuICBhdWRpbzogJ2ZhIGZhLW11c2ljJyxcbiAgdmlkZW86ICdmYSBmYS12aWRlby1jYW1lcmEnLFxuICB1bmtub3duOiAnZmEgZmEtcXVlc3Rpb24nXG59O1xuXG52YXIgYXNzZXRUaHVtYm5haWxTdHlsZSA9IHtcbiAgd2lkdGg6ICdhdXRvJyxcbiAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgaGVpZ2h0OiAnYXV0bycsXG4gIG1heEhlaWdodDogJzEwMCUnLFxuICBtYXJnaW5Ub3A6ICc1MCUnLFxuICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC01MCUpJyxcbiAgbXNUcmFuc2Zvcm06ICd0cmFuc2xhdGVZKC01MCUpJyxcbiAgV2Via2l0VHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtNTAlKSdcbn07XG5cbnZhciBhc3NldEljb25TdHlsZSA9IHtcbiAgbWFyZ2luOiAnMTVweCAwJyxcbiAgZm9udFNpemU6ICczMnB4J1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIHByb3BUeXBlczoge1xuICAgIG5hbWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICB0eXBlOiBSZWFjdC5Qcm9wVHlwZXMub25lT2YoWydpbWFnZScsICdhdWRpbycsICd2aWRlbyddKS5pc1JlcXVpcmVkLFxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0eXBlID0gdGhpcy5wcm9wcy50eXBlO1xuICAgIHZhciBuYW1lID0gdGhpcy5wcm9wcy5uYW1lO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDx0ZCB3aWR0aD1cIjgwXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYXNzZXRUaHVtYm5haWxcIiBzdHlsZT17e1xuICAgICAgICAgIHdpZHRoOiAnNjBweCcsXG4gICAgICAgICAgaGVpZ2h0OiAnNjBweCcsXG4gICAgICAgICAgbWFyZ2luOiAnMTBweCBhdXRvJyxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAnI2VlZScsXG4gICAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICNjY2MnLFxuICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcidcbiAgICAgICAgfX0+XG4gICAgICAgICAge3R5cGUgPT09ICdpbWFnZScgP1xuICAgICAgICAgICAgIDxpbWcgc3JjPXthc3NldHNBcGkuYmFzZVBhdGgobmFtZSl9IHN0eWxlPXthc3NldFRodW1ibmFpbFN0eWxlfSAvPiA6XG4gICAgICAgICAgICAgPGkgY2xhc3NOYW1lPXtkZWZhdWx0SWNvbnNbdHlwZV0gfHwgZGVmYXVsdEljb25zLnVua25vd259IHN0eWxlPXthc3NldEljb25TdHlsZX0+PC9pPlxuICAgICAgICAgICB9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC90ZD5cbiAgICApO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFJvdGF0ZUNvbnRhaW5lciA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9Sb3RhdGVDb250YWluZXIuanN4Jyk7XG5cbi8qKlxuICogV3JhcHBlciBjb21wb25lbnQgZm9yIGFsbCBDb2RlIFN0dWRpbyBhcHAgdHlwZXMsIHdoaWNoIHByb3ZpZGVzIHJvdGF0ZVxuICogY29udGFpbmVyIGFuZCBjbGVhci1kaXYgYnV0IG90aGVyd2lzZSBqdXN0IHJlbmRlcnMgY2hpbGRyZW4uXG4gKi9cbnZhciBTdHVkaW9BcHBXcmFwcGVyID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBwcm9wVHlwZXM6IHtcbiAgICBhc3NldFVybDogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBpc0VtYmVkVmlldzogUmVhY3QuUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgICBpc1NoYXJlVmlldzogUmVhY3QuUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZFxuICB9LFxuXG4gIHJlcXVpcmVzTGFuZHNjYXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEodGhpcy5wcm9wcy5pc0VtYmVkVmlldyB8fCB0aGlzLnByb3BzLmlzU2hhcmVWaWV3KTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdj5cbiAgICAgICAge3RoaXMucmVxdWlyZXNMYW5kc2NhcGUoKSAmJiA8Um90YXRlQ29udGFpbmVyIGFzc2V0VXJsPXt0aGlzLnByb3BzLmFzc2V0VXJsfSAvPn1cbiAgICAgICAge3RoaXMucHJvcHMuY2hpbGRyZW59XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2xlYXJcIj48L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBTdHVkaW9BcHBXcmFwcGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbXNnID0gcmVxdWlyZSgnLi4vbG9jYWxlJyk7XG5cbi8qKlxuICogXCJSb3RhdGUgeW91ciBkZXZpY2VcIiBvdmVybGF5LlxuICovXG52YXIgUm90YXRlQ29udGFpbmVyID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBwcm9wVHlwZXM6IHtcbiAgICBhc3NldFVybDogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGlkPVwicm90YXRlQ29udGFpbmVyXCIgc3R5bGU9e3RoaXMuZ2V0U3R5bGUoKX0+XG4gICAgICAgIDxkaXYgaWQ9XCJyb3RhdGVUZXh0XCI+XG4gICAgICAgICAgPHA+e21zZy5yb3RhdGVUZXh0KCl9PGJyIC8+e21zZy5vcmllbnRhdGlvbkxvY2soKX08L3A+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfSxcblxuICBnZXRTdHlsZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBiYWNrZ3JvdW5kSW1hZ2U6ICd1cmwoJyArIHRoaXMucHJvcHMuYXNzZXRVcmwoJ21lZGlhL3R1cm5waG9uZV9ob3Jpem9udGFsLnBuZycpICsgJyknXG4gICAgfTtcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZUNvbnRhaW5lcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGRpdiBET00gZWxlbWVudCB0aGF0IHdpbGwgbmV2ZXIgdXBkYXRlIGl0cyBjb250ZW50cyBhbmQgd2lsbCB0aHJvdyBhblxuICogZXhjZXB0aW9uIGlmIGl0IGlzIGV2ZXIgdW5tb3VudGVkLCBlbmZvcmNpbmcgdGhhdCBpdCBtdXN0IGFsd2F5cyBiZSByZW5kZXJlZFxuICogYmVjYXVzZSBpdHMgY29udGVudHMgbWF5IGNvbnRhaW4gc3RhdGUgdGhhdCB0aGUgYXBwbGljYXRpb24gaXMgZGVwZW5kaW5nIG9uLlxuICpcbiAqIFVzZWZ1bCB3aGVuIFJlYWN0IGlzIHdyYXBwaW5nIGV4dGVybmFsIGxpYnJhcmllcyBvciBwYXJ0cyBvZiBvdXIgVUkgdGhhdCBhcmVcbiAqIG5vdCB5ZXQgZHJpdmVuIGJ5IFJlYWN0LlxuICovXG52YXIgUHJvdGVjdGVkU3RhdGVmdWxEaXYgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIHByb3BUeXBlczoge1xuICAgIHJlbmRlckNvbnRlbnRzOiBSZWFjdC5Qcm9wVHlwZXMuZnVuY1xuICB9LFxuXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5yZW5kZXJDb250ZW50cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5yZWZzLnJvb3QuaW5uZXJIVE1MID0gdGhpcy5wcm9wcy5yZW5kZXJDb250ZW50cygpO1xuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVubW91bnRpbmcgYSBQcm90ZWN0ZWRTdGF0ZWZ1bERpdiBpcyBub3QgYWxsb3dlZC5cIik7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDxkaXYgey4uLnRoaXMucHJvcHN9IHJlZj1cInJvb3RcIj48L2Rpdj47XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBQcm90ZWN0ZWRTdGF0ZWZ1bERpdjtcbiIsInZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBfID0gdXRpbHMuZ2V0TG9kYXNoKCk7XG52YXIgcmVxdWlyZWRCbG9ja1V0aWxzID0gcmVxdWlyZSgnLi9yZXF1aXJlZF9ibG9ja191dGlscycpO1xudmFyIHN0dWRpb0FwcCA9IHJlcXVpcmUoJy4vU3R1ZGlvQXBwJykuc2luZ2xldG9uO1xudmFyIGF1dGhvcmVkSGludFV0aWxzID0gcmVxdWlyZSgnLi9hdXRob3JlZEhpbnRVdGlscycpO1xuXG4vLyBUT0RPIChici1wYWlyKSA6IFRoaXMgaXMgdG8gZXhwb3NlIG1ldGhvZHMgd2UgbmVlZCBpbiB0aGUgZ2xvYmFsIG5hbWVzcGFjZVxuLy8gZm9yIHRlc3RpbmcgcHVycG9zZS4gV291bGQgYmUgbmljZSB0byBlbGltaW5hdGUgdGhpcyBldmVudHVhbGx5Llxud2luZG93Ll9fVGVzdEludGVyZmFjZSA9IHtcbiAgbG9hZEJsb2NrczogXy5iaW5kKHN0dWRpb0FwcC5sb2FkQmxvY2tzLCBzdHVkaW9BcHApLFxuICBhcnJhbmdlQmxvY2tQb3NpdGlvbjogXy5iaW5kKHN0dWRpb0FwcC5hcnJhbmdlQmxvY2tQb3NpdGlvbiwgc3R1ZGlvQXBwKSxcbiAgZ2V0RHJvcGxldENvbnRlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF8uYmluZChzdHVkaW9BcHAuZWRpdG9yLmdldFZhbHVlLCBzdHVkaW9BcHAuZWRpdG9yKSgpO1xuICB9LFxuICBnZXREcm9wbGV0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHN0dWRpb0FwcC5lZGl0b3I7XG4gIH0sXG4gIC8vIFNldCB0byB0cnVlIHRvIGlnbm9yZSBvbkJlZm9yZVVubG9hZCBldmVudHNcbiAgaWdub3JlT25CZWZvcmVVbmxvYWQ6IGZhbHNlXG59O1xuXG52YXIgYWRkUmVhZHlMaXN0ZW5lciA9IHJlcXVpcmUoJy4vZG9tJykuYWRkUmVhZHlMaXN0ZW5lcjtcbnZhciBibG9ja3NDb21tb24gPSByZXF1aXJlKCcuL2Jsb2Nrc0NvbW1vbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCwgbGV2ZWxzLCBvcHRpb25zKSB7XG5cbiAgLy8gSWYgYSBsZXZlbElkIGlzIG5vdCBwcm92aWRlZCwgdGhlbiBvcHRpb25zLmxldmVsIGlzIHNwZWNpZmllZCBpbiBmdWxsLlxuICAvLyBPdGhlcndpc2UsIG9wdGlvbnMubGV2ZWwgb3ZlcnJpZGVzIHJlc29sdmVkIGxldmVsIG9uIGEgcGVyLXByb3BlcnR5IGJhc2lzLlxuICBpZiAob3B0aW9ucy5sZXZlbElkKSB7XG4gICAgdmFyIGxldmVsID0gbGV2ZWxzW29wdGlvbnMubGV2ZWxJZF07XG4gICAgb3B0aW9ucy5sZXZlbCA9IG9wdGlvbnMubGV2ZWwgfHwge307XG4gICAgb3B0aW9ucy5sZXZlbC5pZCA9IG9wdGlvbnMubGV2ZWxJZDtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMubGV2ZWwpIHtcbiAgICAgIGxldmVsW3Byb3BdID0gb3B0aW9ucy5sZXZlbFtwcm9wXTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5sZXZlbC5sZXZlbEJ1aWxkZXJSZXF1aXJlZEJsb2Nrcykge1xuICAgICAgbGV2ZWwucmVxdWlyZWRCbG9ja3MgPSByZXF1aXJlZEJsb2NrVXRpbHMubWFrZVRlc3RzRnJvbUJ1aWxkZXJSZXF1aXJlZEJsb2NrcyhcbiAgICAgICAgICBvcHRpb25zLmxldmVsLmxldmVsQnVpbGRlclJlcXVpcmVkQmxvY2tzKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGV2ZWwubGV2ZWxCdWlsZGVyUmVjb21tZW5kZWRCbG9ja3MpIHtcbiAgICAgIGxldmVsLnJlY29tbWVuZGVkQmxvY2tzID0gcmVxdWlyZWRCbG9ja1V0aWxzLm1ha2VUZXN0c0Zyb21CdWlsZGVyUmVxdWlyZWRCbG9ja3MoXG4gICAgICAgICAgb3B0aW9ucy5sZXZlbC5sZXZlbEJ1aWxkZXJSZWNvbW1lbmRlZEJsb2Nrcyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubGV2ZWwuYXV0aG9yZWRIaW50cykge1xuICAgICAgbGV2ZWwuYXV0aG9yZWRIaW50cyA9IGF1dGhvcmVkSGludFV0aWxzLmdlbmVyYXRlQXV0aG9yZWRIaW50cyhvcHRpb25zLmxldmVsLmF1dGhvcmVkSGludHMpO1xuICAgIH1cblxuICAgIG9wdGlvbnMubGV2ZWwgPSBsZXZlbDtcbiAgfVxuXG4gIHN0dWRpb0FwcC5jb25maWd1cmUob3B0aW9ucyk7XG5cbiAgb3B0aW9ucy5za2luID0gb3B0aW9ucy5za2luc01vZHVsZS5sb2FkKHN0dWRpb0FwcC5hc3NldFVybCwgb3B0aW9ucy5za2luSWQpO1xuXG4gIGlmIChzdHVkaW9BcHAuaXNVc2luZ0Jsb2NrbHkoKSkge1xuICAgIHZhciBibG9ja0luc3RhbGxPcHRpb25zID0ge1xuICAgICAgc2tpbjogb3B0aW9ucy5za2luLFxuICAgICAgaXNLMTogb3B0aW9ucy5sZXZlbCAmJiBvcHRpb25zLmxldmVsLmlzSzEsXG4gICAgICBsZXZlbDogb3B0aW9ucy5sZXZlbFxuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5sZXZlbCAmJiBvcHRpb25zLmxldmVsLmVkaXRfYmxvY2tzKSB7XG4gICAgICB1dGlscy53cmFwTnVtYmVyVmFsaWRhdG9yc0ZvckxldmVsQnVpbGRlcigpO1xuICAgIH1cblxuICAgIGJsb2Nrc0NvbW1vbi5pbnN0YWxsKEJsb2NrbHksIGJsb2NrSW5zdGFsbE9wdGlvbnMpO1xuICAgIG9wdGlvbnMuYmxvY2tzTW9kdWxlLmluc3RhbGwoQmxvY2tseSwgYmxvY2tJbnN0YWxsT3B0aW9ucyk7XG4gIH1cblxuICBhZGRSZWFkeUxpc3RlbmVyKGZ1bmN0aW9uKCkge1xuICAgIGlmIChvcHRpb25zLnJlYWRvbmx5KSB7XG4gICAgICBpZiAoYXBwLmluaXRSZWFkb25seSkge1xuICAgICAgICBhcHAuaW5pdFJlYWRvbmx5KG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R1ZGlvQXBwLmluaXRSZWFkb25seShvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXBwLmluaXQob3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5vbkluaXRpYWxpemUpIHtcbiAgICAgICAgb3B0aW9ucy5vbkluaXRpYWxpemUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcbiIsIi8qIGdsb2JhbCBUZXh0ICovXG5cbnZhciB4bWwgPSByZXF1aXJlKCcuL3htbCcpO1xudmFyIGJsb2NrVXRpbHMgPSByZXF1aXJlKCcuL2Jsb2NrX3V0aWxzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbXNnID0gcmVxdWlyZSgnLi9sb2NhbGUnKTtcbnZhciBfID0gdXRpbHMuZ2V0TG9kYXNoKCk7XG5cbi8qKlxuICogQ3JlYXRlIHRoZSB0ZXh0dWFsIFhNTCBmb3IgYSBtYXRoX251bWJlciBibG9jay5cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbnVtYmVyIFRoZSBudW1lcmljIGFtb3VudCwgZXhwcmVzc2VkIGFzIGFcbiAqICAgICBudW1iZXIgb3Igc3RyaW5nLiAgTm9uLW51bWVyaWMgc3RyaW5ncyBtYXkgYWxzbyBiZSBzcGVjaWZpZWQsXG4gKiAgICAgc3VjaCBhcyAnPz8/Jy5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgYSBtYXRoX251bWJlciBibG9jay5cbiAqL1xuZXhwb3J0cy5tYWtlTWF0aE51bWJlciA9IGZ1bmN0aW9uKG51bWJlcikge1xuICByZXR1cm4gJzxibG9jayB0eXBlPVwibWF0aF9udW1iZXJcIj48dGl0bGUgbmFtZT1cIk5VTVwiPicgK1xuICAgIG51bWJlciArICc8L3RpdGxlPjwvYmxvY2s+Jztcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSByZXF1aXJlZCBibG9ja3MgZGljdGlvbmFyeSBmb3IgYSBzaW1wbGUgYmxvY2sgdGhhdCBkb2VzIG5vdFxuICogaGF2ZSBhbnkgcGFyYW1ldGVycyBvciB2YWx1ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gYmxvY2tfdHlwZSBUaGUgYmxvY2sgdHlwZS5cbiAqIEByZXR1cm4ge09iamVjdH0gQSByZXF1aXJlZCBibG9ja3MgZGljdGlvbmFyeSBhYmxlIHRvIGNoZWNrIGZvciBhbmRcbiAqICAgICBnZW5lcmF0ZSB0aGUgc3BlY2lmaWVkIGJsb2NrLlxuICovXG5leHBvcnRzLnNpbXBsZUJsb2NrID0gZnVuY3Rpb24oYmxvY2tfdHlwZSkge1xuICByZXR1cm4ge3Rlc3Q6IGZ1bmN0aW9uKGJsb2NrKSB7cmV0dXJuIGJsb2NrLnR5cGUgPT0gYmxvY2tfdHlwZTsgfSxcbiAgICB0eXBlOiBibG9ja190eXBlfTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSByZXF1aXJlZCBibG9ja3MgZGljdGlvbmFyeSBmb3IgYSByZXBlYXQgbG9vcC4gIFRoaXMgZG9lcyBub3RcbiAqIHRlc3QgZm9yIHRoZSBzcGVjaWZpZWQgcmVwZWF0IGNvdW50IGJ1dCBpbmNsdWRlcyBpdCBpbiB0aGUgc3VnZ2VzdGVkIGJsb2NrLlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBjb3VudCBUaGUgc3VnZ2VzdGVkIHJlcGVhdCBjb3VudC5cbiAqIEByZXR1cm4ge09iamVjdH0gQSByZXF1aXJlZCBibG9ja3MgZGljdGlvbmFyeSBhYmxlIHRvIGNoZWNrIGZvciBhbmRcbiAqICAgICBnZW5lcmF0ZSB0aGUgc3BlY2lmaWVkIGJsb2NrLlxuICovXG5leHBvcnRzLnJlcGVhdCA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIC8vIFRoaXMgY2hlY2tzIGZvciBhIGNvbnRyb2xzX3JlcGVhdCBibG9jayByYXRoZXIgdGhhbiBsb29raW5nIGZvciAnZm9yJyxcbiAgLy8gc2luY2UgdGhlIGxhdHRlciBtYXkgYmUgZ2VuZXJhdGVkIGJ5IFR1cnRsZSAyJ3MgZHJhd19hX3NxdWFyZS5cbiAgcmV0dXJuIHt0ZXN0OiBmdW5jdGlvbihibG9jaykge3JldHVybiBibG9jay50eXBlID09ICdjb250cm9sc19yZXBlYXQnO30sXG4gICAgdHlwZTogJ2NvbnRyb2xzX3JlcGVhdCcsIHRpdGxlczogeydUSU1FUyc6IGNvdW50fX07XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgcmVxdWlyZWQgYmxvY2tzIGRpY3Rpb25hcnkgZm9yIGEgc2ltcGxlIHJlcGVhdCBsb29wLiAgVGhpcyBkb2VzIG5vdFxuICogdGVzdCBmb3IgdGhlIHNwZWNpZmllZCByZXBlYXQgY291bnQgYnV0IGluY2x1ZGVzIGl0IGluIHRoZSBzdWdnZXN0ZWQgYmxvY2suXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGNvdW50IFRoZSBzdWdnZXN0ZWQgcmVwZWF0IGNvdW50LlxuICogQHJldHVybiB7T2JqZWN0fSBBIHJlcXVpcmVkIGJsb2NrcyBkaWN0aW9uYXJ5IGFibGUgdG8gY2hlY2sgZm9yIGFuZFxuICogICAgIGdlbmVyYXRlIHRoZSBzcGVjaWZpZWQgYmxvY2suXG4gKi9cbmV4cG9ydHMucmVwZWF0U2ltcGxlQmxvY2sgPSBmdW5jdGlvbihjb3VudCkge1xuICByZXR1cm4ge3Rlc3Q6IGZ1bmN0aW9uKGJsb2NrKSB7cmV0dXJuIGJsb2NrLnR5cGUgPT0gJ2NvbnRyb2xzX3JlcGVhdF9zaW1wbGlmaWVkJzt9LFxuICAgIHR5cGU6ICdjb250cm9sc19yZXBlYXRfc2ltcGxpZmllZCcsIHRpdGxlczogeydUSU1FUyc6IGNvdW50fX07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgcmVxdWlyZWQgYmxvY2tzIGJ5IGNvbXBhcmluZyBhIGxpc3Qgb2YgYmxvY2tzIHdpdGhcbiAqIGEgbGlzdCBvZiBhcHAgc3BlY2lmaWMgYmxvY2sgdGVzdHMgKGRlZmluZWQgaW4gPGFwcD4vcmVxdWlyZWRCbG9ja3MuanMpXG4gKi9cbmV4cG9ydHMubWFrZVRlc3RzRnJvbUJ1aWxkZXJSZXF1aXJlZEJsb2NrcyA9IGZ1bmN0aW9uIChjdXN0b21SZXF1aXJlZEJsb2Nrcykge1xuICB2YXIgYmxvY2tzWG1sID0geG1sLnBhcnNlRWxlbWVudChjdXN0b21SZXF1aXJlZEJsb2Nrcyk7XG5cbiAgdmFyIHJlcXVpcmVkQmxvY2tzVGVzdHMgPSBbXTtcbiAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChibG9ja3NYbWwuY2hpbGROb2RlcywgZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gICAgLy8gT25seSBsb29rIGF0IGVsZW1lbnQgbm9kZXNcbiAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoY2hpbGROb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpKSB7XG4gICAgICBjYXNlICdwaWNrX29uZSc6XG4gICAgICAgIHJlcXVpcmVkQmxvY2tzVGVzdHMucHVzaCh0ZXN0c0Zyb21QaWNrT25lKGNoaWxkTm9kZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Byb2NlZHVyZXNfZGVmbm9yZXR1cm4nOlxuICAgICAgY2FzZSAncHJvY2VkdXJlc19kZWZyZXR1cm4nOlxuICAgICAgICByZXF1aXJlZEJsb2Nrc1Rlc3RzLnB1c2godGVzdHNGcm9tUHJvY2VkdXJlKGNoaWxkTm9kZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uYWxfZGVmaW5pdGlvbic6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZnVuY3Rpb25hbF9jYWxsJzpcbiAgICAgICAgcmVxdWlyZWRCbG9ja3NUZXN0cy5wdXNoKHRlc3RzRnJvbUZ1bmN0aW9uYWxDYWxsKGNoaWxkTm9kZSwgYmxvY2tzWG1sKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVxdWlyZWRCbG9ja3NUZXN0cy5wdXNoKFt0ZXN0RnJvbUJsb2NrKGNoaWxkTm9kZSldKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXF1aXJlZEJsb2Nrc1Rlc3RzO1xufTtcblxuLyoqXG4gKiBHaXZlbiB4bWwgZm9yIGEgc2luZ2xlIGJsb2NrIGdlbmVyYXRlcyBhIGJsb2NrIHRlc3RcbiAqL1xuZnVuY3Rpb24gdGVzdEZyb21CbG9jayAobm9kZSkge1xuICByZXR1cm4ge1xuICAgIHRlc3Q6IGZ1bmN0aW9uKHVzZXJCbG9jaykge1xuICAgICAgLy8gRW5jb2RlIHVzZXJCbG9jayB3aGlsZSBpZ25vcmluZyBjaGlsZCBzdGF0ZW1lbnRzXG4gICAgICB2YXIgdXNlckVsZW1lbnQgPSBCbG9ja2x5LlhtbC5ibG9ja1RvRG9tKHVzZXJCbG9jaywgdHJ1ZSk7XG4gICAgICByZXR1cm4gZWxlbWVudHNFcXVpdmFsZW50KG5vZGUsIHVzZXJFbGVtZW50KTtcbiAgICB9LFxuICAgIGJsb2NrRGlzcGxheVhNTDogeG1sLnNlcmlhbGl6ZShub2RlKVxuICB9O1xufVxuXG4vKipcbiAqIEdpdmVuIHhtbCBmb3IgYSBwaWNrX29uZSBibG9jaywgZ2VuZXJhdGVzIGEgdGVzdCB0aGF0IGNoZWNrcyB0aGF0IGF0IGxlYXN0XG4gKiBvbmUgb2YgdGhlIGNoaWxkIGJsb2NrcyBpcyB1c2VkLiAgSWYgbm9uZSBhcmUgdXNlZCwgdGhlIGZpcnN0IG9wdGlvbiB3aWxsIGJlXG4gKiBkaXNwbGF5ZWQgYXMgZmVlZGJhY2tcbiAqL1xuZnVuY3Rpb24gdGVzdHNGcm9tUGlja09uZShub2RlKSB7XG4gIHZhciB0ZXN0cyA9IFtdO1xuICAvLyBjaGlsZCBvZiBwaWNrX29uZSBpcyBhIHN0YXRlbWVudCBibG9jay4gIHdlIHdhbnQgZmlyc3QgY2hpbGQgb2YgdGhhdFxuICB2YXIgc3RhdGVtZW50ID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3RhdGVtZW50JylbMF07XG4gIHZhciBibG9jayA9IHN0YXRlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYmxvY2snKVswXTtcbiAgdmFyIG5leHQ7XG4gIGRvIHtcbiAgICAvLyBpZiB3ZSBoYXZlIGEgbmV4dCBibG9jaywgd2Ugd2FudCB0byBnZW5lcmF0ZSBvdXIgdGVzdCB3aXRob3V0IHRoYXRcbiAgICBuZXh0ID0gYmxvY2suZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ25leHQnKVswXTtcbiAgICBpZiAobmV4dCkge1xuICAgICAgYmxvY2sucmVtb3ZlQ2hpbGQobmV4dCk7XG4gICAgfVxuICAgIHRlc3RzLnB1c2godGVzdEZyb21CbG9jayhibG9jaykpO1xuICAgIGlmIChuZXh0KSB7XG4gICAgICBibG9jayA9IG5leHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Jsb2NrJylbMF07XG4gICAgfVxuICB9IHdoaWxlIChuZXh0KTtcbiAgcmV0dXJuIHRlc3RzO1xufVxuXG4vKipcbiAqIEdpdmVuIHhtbCBmb3IgYSBwcm9jZWR1cmUgYmxvY2ssIGdlbmVyYXRlcyB0ZXN0cyB0aGF0IGNoZWNrIGZvciByZXF1aXJlZFxuICogbnVtYmVyIG9mIHBhcmFtcyBub3QgZGVjbGFyZWRcbiAqL1xuZnVuY3Rpb24gdGVzdHNGcm9tUHJvY2VkdXJlKG5vZGUpIHtcbiAgdmFyIHBhcmFtQ291bnQgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ211dGF0aW9uID4gYXJnJykubGVuZ3RoO1xuICB2YXIgZW1wdHlCbG9jayA9IG5vZGUuY2xvbmVOb2RlKHRydWUpO1xuICBlbXB0eUJsb2NrLnJlbW92ZUNoaWxkKGVtcHR5QmxvY2subGFzdENoaWxkKTtcbiAgcmV0dXJuIFt7XG4gICAgLy8gRW5zdXJlIHRoYXQgYWxsIHJlcXVpcmVkIGJsb2NrcyBtYXRjaCBhIGJsb2NrIHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mXG4gICAgLy8gcGFyYW1zLiBUaGVyZSdzIG5vIGd1YXJhbnRlZSB1c2VycyB3aWxsIG5hbWUgdGhlaXIgZnVuY3Rpb24gdGhlIHNhbWUgYXNcbiAgICAvLyB0aGUgcmVxdWlyZWQgYmxvY2ssIHNvIG9ubHkgbWF0Y2ggb24gbnVtYmVyIG9mIHBhcmFtcy5cbiAgICB0ZXN0OiBmdW5jdGlvbih1c2VyQmxvY2spIHtcbiAgICAgIGlmICh1c2VyQmxvY2sudHlwZSA9PT0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSkge1xuICAgICAgICByZXR1cm4gcGFyYW1Db3VudCA9PT0gdXNlckJsb2NrLnBhcmFtZXRlck5hbWVzXy5sZW5ndGg7XG4gICAgICB9XG4gICAgICAvLyBCbG9jayBpc24ndCB0aGUgc2FtZSB0eXBlLCByZXR1cm4gZmFsc2UgdG8ga2VlcCBzZWFyY2hpbmcuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBtZXNzYWdlOiBtc2cuZXJyb3JSZXF1aXJlZFBhcmFtc01pc3NpbmcoKSxcbiAgICBibG9ja0Rpc3BsYXlYTUw6ICc8eG1sPjwveG1sPidcbiAgfV07XG59XG5cbmZ1bmN0aW9uIHRlc3RzRnJvbUZ1bmN0aW9uYWxDYWxsKG5vZGUsIGJsb2Nrc1htbCkge1xuICB2YXIgbmFtZSA9IG5vZGUucXVlcnlTZWxlY3RvcignbXV0YXRpb24nKS5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgdmFyIGFyZ0VsZW1lbnRzID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdhcmcnKTtcbiAgdmFyIHR5cGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB0eXBlcy5wdXNoKGFyZ0VsZW1lbnRzW2ldLmdldEF0dHJpYnV0ZSgndHlwZScpKTtcbiAgfVxuXG4gIHZhciBkZWZpbml0aW9uID0gXy5maW5kKGJsb2Nrc1htbC5jaGlsZE5vZGVzLCBmdW5jdGlvbiAoc2libGluZykge1xuICAgIGlmIChzaWJsaW5nLmdldEF0dHJpYnV0ZSgndHlwZScpICE9PSAnZnVuY3Rpb25hbF9kZWZpbml0aW9uJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbmFtZUVsZW1lbnQgPSBzaWJsaW5nLnF1ZXJ5U2VsZWN0b3IoJ3RpdGxlW25hbWU9XCJOQU1FXCJdJyk7XG4gICAgaWYgKCFuYW1lRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZUVsZW1lbnQudGV4dENvbnRlbnQgPT09IG5hbWU7XG4gIH0pO1xuXG4gIGlmICghZGVmaW5pdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gbWF0Y2hpbmcgZGVmaW5pdGlvbiBmb3IgZnVuY3Rpb25hbF9jYWxsJyk7XG4gIH1cblxuICByZXR1cm4gW3tcbiAgICB0ZXN0OiBmdW5jdGlvbiAodXNlckJsb2NrKSB7XG4gICAgICBpZiAodXNlckJsb2NrLnR5cGUgIT09ICdmdW5jdGlvbmFsX2NhbGwnIHx8XG4gICAgICAgICAgdXNlckJsb2NrLmdldENhbGxOYW1lKCkgIT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHVzZXJUeXBlcyA9IHVzZXJCbG9jay5nZXRQYXJhbVR5cGVzKCk7XG4gICAgICByZXR1cm4gXy5pc0VxdWFsKHVzZXJUeXBlcywgdHlwZXMpO1xuICAgIH0sXG4gICAgYmxvY2tEaXNwbGF5WE1MOiB4bWwuc2VyaWFsaXplKGRlZmluaXRpb24pICsgeG1sLnNlcmlhbGl6ZShub2RlKVxuICB9XTtcblxufVxuXG4vKipcbiAqIENoZWNrcyB0d28gRE9NIGVsZW1lbnRzIHRvIHNlZSB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBlcXVpdmFsZW50XG4gKiBXZSBjb25zaWRlciB0aGVtIGVxdWl2YWxlbnQgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHRhZ05hbWUsIGF0dHJpYnV0ZXMsXG4gKiBhbmQgY2hpbGRyZW5cbiAqL1xuZnVuY3Rpb24gZWxlbWVudHNFcXVpdmFsZW50KGV4cGVjdGVkLCBnaXZlbikge1xuICBpZiAoIShleHBlY3RlZCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgZ2l2ZW4gaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgIC8vIGlmIHdlIGV4cGVjdCA/Pz8sIGFsbG93IG1hdGNoIHdpdGggYW55dGhpbmdcbiAgICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBUZXh0ICYmIGV4cGVjdGVkLnRleHRDb250ZW50ID09PSAnPz8/Jykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBleHBlY3RlZC5pc0VxdWFsTm9kZShnaXZlbik7XG4gIH1cbiAgLy8gTm90IGZ1bGx5IGNsZWFyIHRvIG1lIHdoeSwgYnV0IGJsb2NrVG9Eb20gc2VlbXMgdG8gcmV0dXJuIHVzIGFuIGVsZW1lbnRcbiAgLy8gd2l0aCBhIHRhZ05hbWUgaW4gYWxsIGNhcHNcbiAgaWYgKGV4cGVjdGVkLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gZ2l2ZW4udGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFhdHRyaWJ1dGVzRXF1aXZhbGVudChleHBlY3RlZCwgZ2l2ZW4pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFjaGlsZHJlbkVxdWl2YWxlbnQoZXhwZWN0ZWQsIGdpdmVuKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEEgbGlzdCBvZiBhdHRyaWJ1dGVzIHdlIHdhbnQgdG8gaWdub3JlIHdoZW4gY29tcGFyaW5nIGF0dHJpYnV0ZXMsIGFuZCBhXG4gKiBmdW5jdGlvbiBmb3IgZWFzaWx5IGRldGVybWluaW5nIHdoZXRoZXIgYW4gYXR0cmlidXRlIGlzIGluIHRoZSBsaXN0LlxuICovXG52YXIgaWdub3JhYmxlQXR0cmlidXRlcyA9IFtcbiAgJ2RlbGV0YWJsZScsXG4gICdtb3ZhYmxlJyxcbiAgJ2VkaXRhYmxlJyxcbiAgJ2lubGluZScsXG4gICd1c2VydmlzaWJsZScsXG4gICd1c2VyY3JlYXRlZCcsXG4gICdpZCdcbl07XG5cbmlnbm9yYWJsZUF0dHJpYnV0ZXMuY29udGFpbnMgPSBmdW5jdGlvbiAoYXR0cikge1xuICByZXR1cm4gaWdub3JhYmxlQXR0cmlidXRlcy5pbmRleE9mKGF0dHIubmFtZSkgIT09IC0xO1xufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgYXR0cmlidXRlcyBmb3IgdHdvIGRpZmZlcmVudCBlbGVtZW50cyBhcmUgZXF1aXZhbGVudFxuICovXG5mdW5jdGlvbiBhdHRyaWJ1dGVzRXF1aXZhbGVudChleHBlY3RlZCwgZ2l2ZW4pIHtcbiAgdmFyIGF0dHJpYnV0ZXMxID0gXy5yZWplY3QoZXhwZWN0ZWQuYXR0cmlidXRlcywgaWdub3JhYmxlQXR0cmlidXRlcy5jb250YWlucyk7XG4gIHZhciBhdHRyaWJ1dGVzMiA9IF8ucmVqZWN0KGdpdmVuLmF0dHJpYnV0ZXMsIGlnbm9yYWJsZUF0dHJpYnV0ZXMuY29udGFpbnMpO1xuICBpZiAoYXR0cmlidXRlczEubGVuZ3RoICE9PSBhdHRyaWJ1dGVzMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzMS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhdHRyMSA9IGF0dHJpYnV0ZXMxW2ldO1xuICAgIHZhciBhdHRyMiA9IGF0dHJpYnV0ZXMyW2ldO1xuICAgIGlmIChhdHRyMS5uYW1lICE9PSBhdHRyMi5uYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhdHRyMS52YWx1ZSAhPT0gYXR0cjIudmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGNoaWxkcmVuIG9mIHR3byBkaWZmZXJlbnQgZWxlbWVudHMgYXJlIGVxdWl2YWxlbnRcbiAqL1xuZnVuY3Rpb24gY2hpbGRyZW5FcXVpdmFsZW50KGV4cGVjdGVkLCBnaXZlbikge1xuICB2YXIgY2hpbGRyZW4xID0gZXhwZWN0ZWQuY2hpbGROb2RlcztcbiAgdmFyIGNoaWxkcmVuMiA9IGdpdmVuLmNoaWxkTm9kZXM7XG4gIGlmIChjaGlsZHJlbjEubGVuZ3RoICE9PSBjaGlsZHJlbjIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4xLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFlbGVtZW50c0VxdWl2YWxlbnQoY2hpbGRyZW4xW2ldLCBjaGlsZHJlbjJbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0d28gYmxvY2tzIGFyZSBcImVxdWl2YWxlbnRcIlxuICogQ3VycmVudGx5IG1lYW5zIHRoZWlyIHR5cGUgYW5kIGFsbCBvZiB0aGVpciB0aXRsZXMgbWF0Y2ggZXhhY3RseVxuICogQHBhcmFtIGJsb2NrQVxuICogQHBhcmFtIGJsb2NrQlxuICovXG5leHBvcnRzLmJsb2Nrc01hdGNoID0gZnVuY3Rpb24oYmxvY2tBLCBibG9ja0IpIHtcbiAgdmFyIHR5cGVzTWF0Y2ggPSBibG9ja0EudHlwZSA9PT0gYmxvY2tCLnR5cGU7XG4gIHZhciB0aXRsZXNNYXRjaCA9IGV4cG9ydHMuYmxvY2tUaXRsZXNNYXRjaChibG9ja0EsIGJsb2NrQik7XG4gIHJldHVybiB0eXBlc01hdGNoICYmIHRpdGxlc01hdGNoO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0d28gYmxvY2tzJyB0aXRsZXMsIHJldHVybnMgdHJ1ZSBpZiB0aGV5IGFsbCBtYXRjaFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcGFyYW0gYmxvY2tBXG4gKiBAcGFyYW0gYmxvY2tCXG4gKi9cbmV4cG9ydHMuYmxvY2tUaXRsZXNNYXRjaCA9IGZ1bmN0aW9uKGJsb2NrQSwgYmxvY2tCKSB7XG4gIHZhciBibG9ja0FUaXRsZXMgPSBibG9ja0EuZ2V0VGl0bGVzKCk7XG4gIHZhciBibG9ja0JUaXRsZXMgPSBibG9ja0IuZ2V0VGl0bGVzKCk7XG5cbiAgdmFyIG5hbWVDb21wYXJlID0gZnVuY3Rpb24oYSxiKSB7IHJldHVybiBhLm5hbWUgPCBiLm5hbWU7IH07XG4gIGJsb2NrQVRpdGxlcy5zb3J0KG5hbWVDb21wYXJlKTtcbiAgYmxvY2tCVGl0bGVzLnNvcnQobmFtZUNvbXBhcmUpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tBVGl0bGVzLmxlbmd0aCB8fCBpIDwgYmxvY2tCVGl0bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJsb2NrQVRpdGxlID0gYmxvY2tBVGl0bGVzW2ldO1xuICAgIHZhciBibG9ja0JUaXRsZSA9IGJsb2NrQlRpdGxlc1tpXTtcbiAgICBpZiAoIWJsb2NrQVRpdGxlIHx8ICFibG9ja0JUaXRsZSB8fFxuICAgICAgIXRpdGxlc01hdGNoKGJsb2NrQVRpdGxlLCBibG9ja0JUaXRsZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgdGl0bGVzTWF0Y2ggPSBmdW5jdGlvbih0aXRsZUEsIHRpdGxlQikge1xuICByZXR1cm4gdGl0bGVCLm5hbWUgPT09IHRpdGxlQS5uYW1lICYmXG4gICAgdGl0bGVCLmdldFZhbHVlKCkgPT09IHRpdGxlQS5nZXRWYWx1ZSgpO1xufTtcbiIsIi8qKlxuICogRGVmaW5lcyBibG9ja3MgdXNlZnVsIGluIG11bHRpcGxlIGJsb2NrbHkgYXBwc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjb21tb25Nc2cgPSByZXF1aXJlKCcuL2xvY2FsZScpO1xuXG4vKipcbiAqIEluc3RhbGwgZXh0ZW5zaW9ucyB0byBCbG9ja2x5J3MgbGFuZ3VhZ2UgYW5kIEphdmFTY3JpcHQgZ2VuZXJhdG9yXG4gKiBAcGFyYW0gYmxvY2tseSBpbnN0YW5jZSBvZiBCbG9ja2x5XG4gKi9cbmV4cG9ydHMuaW5zdGFsbCA9IGZ1bmN0aW9uKGJsb2NrbHksIGJsb2NrSW5zdGFsbE9wdGlvbnMpIHtcbiAgdmFyIHNraW4gPSBibG9ja0luc3RhbGxPcHRpb25zLnNraW47XG4gIHZhciBpc0sxID0gYmxvY2tJbnN0YWxsT3B0aW9ucy5pc0sxO1xuXG4gIGluc3RhbGxDb250cm9sc1JlcGVhdFNpbXBsaWZpZWQoYmxvY2tseSwgc2tpbik7XG4gIGluc3RhbGxDb250cm9sc1JlcGVhdERyb3Bkb3duKGJsb2NrbHkpO1xuICBpbnN0YWxsTnVtYmVyRHJvcGRvd24oYmxvY2tseSk7XG4gIGluc3RhbGxQaWNrT25lKGJsb2NrbHkpO1xuICBpbnN0YWxsQ2F0ZWdvcnkoYmxvY2tseSk7XG4gIGluc3RhbGxXaGVuUnVuKGJsb2NrbHksIHNraW4sIGlzSzEpO1xufTtcblxuZnVuY3Rpb24gaW5zdGFsbENvbnRyb2xzUmVwZWF0U2ltcGxpZmllZChibG9ja2x5LCBza2luKSB7XG4gIC8vIFJlLXVzZXMgdGhlIHJlcGVhdCBibG9jayBnZW5lcmF0b3IgZnJvbSBjb3JlXG4gIGJsb2NrbHkuSmF2YVNjcmlwdC5jb250cm9sc19yZXBlYXRfc2ltcGxpZmllZCA9IGJsb2NrbHkuSmF2YVNjcmlwdC5jb250cm9sc19yZXBlYXQ7XG4gIGJsb2NrbHkuSmF2YVNjcmlwdC5jb250cm9sc19yZXBlYXRfc2ltcGxpZmllZF9kcm9wZG93biA9IGJsb2NrbHkuSmF2YVNjcmlwdC5jb250cm9sc19yZXBlYXQ7XG5cbiAgYmxvY2tseS5CbG9ja3MuY29udHJvbHNfcmVwZWF0X3NpbXBsaWZpZWQgPSB7XG4gICAgLy8gUmVwZWF0IG4gdGltZXMgKGludGVybmFsIG51bWJlcikgd2l0aCBzaW1wbGlmaWVkIFVJXG4gICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zZXRIZWxwVXJsKGJsb2NrbHkuTXNnLkNPTlRST0xTX1JFUEVBVF9IRUxQVVJMKTtcbiAgICAgIHRoaXMuc2V0SFNWKDMyMiwgMC45MCwgMC45NSk7XG4gICAgICB0aGlzLmFwcGVuZER1bW15SW5wdXQoKVxuICAgICAgICAuYXBwZW5kVGl0bGUoYmxvY2tseS5Nc2cuQ09OVFJPTFNfUkVQRUFUX1RJVExFX1JFUEVBVClcbiAgICAgICAgLmFwcGVuZFRpdGxlKG5ldyBibG9ja2x5LkZpZWxkVGV4dElucHV0KCcxMCcsIGJsb2NrbHkuRmllbGRUZXh0SW5wdXQubm9ubmVnYXRpdmVJbnRlZ2VyVmFsaWRhdG9yKSwgJ1RJTUVTJyk7XG4gICAgICB0aGlzLmFwcGVuZFN0YXRlbWVudElucHV0KCdETycpXG4gICAgICAgIC5hcHBlbmRUaXRsZShuZXcgYmxvY2tseS5GaWVsZEltYWdlKHNraW4ucmVwZWF0SW1hZ2UpKTtcbiAgICAgIHRoaXMuc2V0UHJldmlvdXNTdGF0ZW1lbnQodHJ1ZSk7XG4gICAgICB0aGlzLnNldE5leHRTdGF0ZW1lbnQodHJ1ZSk7XG4gICAgICB0aGlzLnNldFRvb2x0aXAoYmxvY2tseS5Nc2cuQ09OVFJPTFNfUkVQRUFUX1RPT0xUSVApO1xuICAgIH1cbiAgfTtcblxuICBibG9ja2x5LkJsb2Nrcy5jb250cm9sc19yZXBlYXRfc2ltcGxpZmllZF9kcm9wZG93biA9IHtcbiAgICAvLyBSZXBlYXQgbiB0aW1lcyAoaW50ZXJuYWwgbnVtYmVyKSB3aXRoIHNpbXBsaWZpZWQgVUlcbiAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnNldEhlbHBVcmwoYmxvY2tseS5Nc2cuQ09OVFJPTFNfUkVQRUFUX0hFTFBVUkwpO1xuICAgICAgdGhpcy5zZXRIU1YoMzIyLCAwLjkwLCAwLjk1KTtcbiAgICAgIHRoaXMuYXBwZW5kRHVtbXlJbnB1dCgpXG4gICAgICAgIC5hcHBlbmRUaXRsZShibG9ja2x5Lk1zZy5DT05UUk9MU19SRVBFQVRfVElUTEVfUkVQRUFUKVxuICAgICAgICAuYXBwZW5kVGl0bGUobmV3IGJsb2NrbHkuRmllbGREcm9wZG93bigpLCAnVElNRVMnKTtcbiAgICAgIHRoaXMuYXBwZW5kU3RhdGVtZW50SW5wdXQoJ0RPJylcbiAgICAgICAgLmFwcGVuZFRpdGxlKG5ldyBibG9ja2x5LkZpZWxkSW1hZ2Uoc2tpbi5yZXBlYXRJbWFnZSkpO1xuICAgICAgdGhpcy5zZXRQcmV2aW91c1N0YXRlbWVudCh0cnVlKTtcbiAgICAgIHRoaXMuc2V0TmV4dFN0YXRlbWVudCh0cnVlKTtcbiAgICAgIHRoaXMuc2V0VG9vbHRpcChibG9ja2x5Lk1zZy5DT05UUk9MU19SRVBFQVRfVE9PTFRJUCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnN0YWxsQ29udHJvbHNSZXBlYXREcm9wZG93bihibG9ja2x5KSB7XG4gIGJsb2NrbHkuSmF2YVNjcmlwdC5jb250cm9sc19yZXBlYXRfZHJvcGRvd24gPSBibG9ja2x5LkphdmFTY3JpcHQuY29udHJvbHNfcmVwZWF0O1xuXG4gIGJsb2NrbHkuQmxvY2tzLmNvbnRyb2xzX3JlcGVhdF9kcm9wZG93biA9IHtcbiAgICAvLyBSZXBlYXQgbiB0aW1lcyAoaW50ZXJuYWwgbnVtYmVyKSB3aXRoIGEgY3VzdG9taXphYmxlIGRyb3Bkb3duIG9mICMgY2hvaWNlcy5cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0SGVscFVybChibG9ja2x5Lk1zZy5DT05UUk9MU19SRVBFQVRfSEVMUFVSTCk7XG4gICAgICB0aGlzLnNldEhTVigzMjIsIDAuOTAsIDAuOTUpO1xuICAgICAgdGhpcy5hcHBlbmREdW1teUlucHV0KClcbiAgICAgICAgLmFwcGVuZFRpdGxlKGJsb2NrbHkuTXNnLkNPTlRST0xTX1JFUEVBVF9USVRMRV9SRVBFQVQpXG4gICAgICAgIC5hcHBlbmRUaXRsZShuZXcgYmxvY2tseS5GaWVsZERyb3Bkb3duKCksICdUSU1FUycpXG4gICAgICAgIC5hcHBlbmRUaXRsZShibG9ja2x5Lk1zZy5DT05UUk9MU19SRVBFQVRfVElUTEVfVElNRVMpO1xuICAgICAgdGhpcy5hcHBlbmRTdGF0ZW1lbnRJbnB1dCgnRE8nKVxuICAgICAgICAuYXBwZW5kVGl0bGUoYmxvY2tseS5Nc2cuQ09OVFJPTFNfUkVQRUFUX0lOUFVUX0RPKTtcbiAgICAgIHRoaXMuc2V0UHJldmlvdXNTdGF0ZW1lbnQodHJ1ZSk7XG4gICAgICB0aGlzLnNldE5leHRTdGF0ZW1lbnQodHJ1ZSk7XG4gICAgICB0aGlzLnNldFRvb2x0aXAoYmxvY2tseS5Nc2cuQ09OVFJPTFNfUkVQRUFUX1RPT0xUSVApO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5zdGFsbE51bWJlckRyb3Bkb3duKGJsb2NrbHkpIHtcbiAgYmxvY2tseS5KYXZhU2NyaXB0Lm1hdGhfbnVtYmVyX2Ryb3Bkb3duID0gYmxvY2tseS5KYXZhU2NyaXB0Lm1hdGhfbnVtYmVyO1xuXG4gIGJsb2NrbHkuQmxvY2tzLm1hdGhfbnVtYmVyX2Ryb3Bkb3duID0ge1xuICAgIC8vIE51bWVyaWMgdmFsdWUgd2l0aCBhIGN1c3RvbWl6YWJsZSBkcm9wZG93bi5cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0SGVscFVybChibG9ja2x5Lk1zZy5NQVRIX05VTUJFUl9IRUxQVVJMKTtcbiAgICAgIHRoaXMuc2V0SFNWKDI1OCwgMC4zNSwgMC42Mik7XG4gICAgICB0aGlzLmFwcGVuZER1bW15SW5wdXQoKVxuICAgICAgICAuYXBwZW5kVGl0bGUobmV3IGJsb2NrbHkuRmllbGREcm9wZG93bigpLCAnTlVNJyk7XG4gICAgICB0aGlzLnNldE91dHB1dCh0cnVlLCBCbG9ja2x5LkJsb2NrVmFsdWVUeXBlLk5VTUJFUik7XG4gICAgICB0aGlzLnNldFRvb2x0aXAoYmxvY2tseS5Nc2cuTUFUSF9OVU1CRVJfVE9PTFRJUCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBBIFwiUGljayAxXCIgYmxvY2sgZm9yIGxldmVsIGVkaXRpbmcsIHdoZXJlIHlvdSB3YW50IHRvIHJlcXVpcmUgdGhhdCBvbmUgb2YgYVxuLy8gc2V0IG9mIGJsb2NrcyBpcyB1c2VkLlxuZnVuY3Rpb24gaW5zdGFsbFBpY2tPbmUoYmxvY2tseSkge1xuICBibG9ja2x5LkJsb2Nrcy5waWNrX29uZSA9IHtcbiAgICAvLyBSZXBlYXQgbiB0aW1lcyAoaW50ZXJuYWwgbnVtYmVyKS5cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0SFNWKDMyMiwgMC45MCwgMC45NSk7XG5cbiAgICAgIC8vIE5vdCBsb2NhbGl6ZWQgYXMgdGhpcyBpcyBvbmx5IHVzZWQgYnkgbGV2ZWwgYnVpbGRlcnNcbiAgICAgIHRoaXMuYXBwZW5kRHVtbXlJbnB1dCgpXG4gICAgICAgICAgLmFwcGVuZFRpdGxlKCdQaWNrIG9uZSAoVXNlIG9ubHkgaW4gcmVxdWlyZWQgYmxvY2tzKScpO1xuICAgICAgdGhpcy5hcHBlbmRTdGF0ZW1lbnRJbnB1dCgnUElDSycpO1xuICAgIH1cbiAgfTtcblxuICBibG9ja2x5LkphdmFTY3JpcHQucGlja19vbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdcXG4nO1xuICB9O1xufVxuXG4vLyBBIFwiQ2F0ZWdvcnlcIiBibG9jayBmb3IgbGV2ZWwgZWRpdGluZywgZm9yIGRlbGluZWF0aW5nIGNhdGVnb3J5IGdyb3Vwcy5cbmZ1bmN0aW9uIGluc3RhbGxDYXRlZ29yeShibG9ja2x5KSB7XG4gIGJsb2NrbHkuQmxvY2tzLmNhdGVnb3J5ID0ge1xuICAgIC8vIFJlcGVhdCBuIHRpbWVzIChpbnRlcm5hbCBudW1iZXIpLlxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXRIU1YoMzIyLCAwLjkwLCAwLjk1KTtcbiAgICAgIHRoaXMuc2V0SW5wdXRzSW5saW5lKHRydWUpO1xuXG4gICAgICAvLyBOb3QgbG9jYWxpemVkIGFzIHRoaXMgaXMgb25seSB1c2VkIGJ5IGxldmVsIGJ1aWxkZXJzXG4gICAgICB0aGlzLmFwcGVuZER1bW15SW5wdXQoKVxuICAgICAgICAuYXBwZW5kVGl0bGUoJ0NhdGVnb3J5JylcbiAgICAgICAgLmFwcGVuZFRpdGxlKG5ldyBibG9ja2x5LkZpZWxkVGV4dElucHV0KCdOYW1lJyksICdDQVRFR09SWScpO1xuICAgICAgdGhpcy5zZXRQcmV2aW91c1N0YXRlbWVudChmYWxzZSk7XG4gICAgICB0aGlzLnNldE5leHRTdGF0ZW1lbnQoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBibG9ja2x5LkphdmFTY3JpcHQuY2F0ZWdvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdcXG4nO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnN0YWxsV2hlblJ1bihibG9ja2x5LCBza2luLCBpc0sxKSB7XG4gIGJsb2NrbHkuQmxvY2tzLndoZW5fcnVuID0ge1xuICAgIC8vIEJsb2NrIHRvIGhhbmRsZSBldmVudCB3aGVyZSBtb3VzZSBpcyBjbGlja2VkXG4gICAgaGVscFVybDogJycsXG4gICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zZXRIU1YoMzksIDEuMDAsIDAuOTkpO1xuICAgICAgaWYgKGlzSzEpIHtcbiAgICAgICAgdGhpcy5hcHBlbmREdW1teUlucHV0KClcbiAgICAgICAgICAuYXBwZW5kVGl0bGUoY29tbW9uTXNnLndoZW5SdW4oKSlcbiAgICAgICAgICAuYXBwZW5kVGl0bGUobmV3IGJsb2NrbHkuRmllbGRJbWFnZShza2luLnJ1bkFycm93KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFwcGVuZER1bW15SW5wdXQoKS5hcHBlbmRUaXRsZShjb21tb25Nc2cud2hlblJ1bigpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0UHJldmlvdXNTdGF0ZW1lbnQoZmFsc2UpO1xuICAgICAgdGhpcy5zZXROZXh0U3RhdGVtZW50KHRydWUpO1xuICAgIH0sXG4gICAgc2hvdWxkQmVHcmF5ZWRPdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgYmxvY2tseS5KYXZhU2NyaXB0LndoZW5fcnVuID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEdlbmVyYXRlIEphdmFTY3JpcHQgZm9yIGhhbmRsaW5nIGNsaWNrIGV2ZW50LlxuICAgIHJldHVybiAnXFxuJztcbiAgfTtcbn1cbiIsIi8qIGdsb2JhbCBCbG9ja2x5LCBhY2U6dHJ1ZSwgZHJvcGxldCwgbWFya2VkLCBkYXNoYm9hcmQsIGFkZFRvSG9tZSAqL1xuXG52YXIgYWNlTW9kZSA9IHJlcXVpcmUoJy4vYWNlbW9kZS9tb2RlLWphdmFzY3JpcHRfY29kZW9yZycpO1xudmFyIHBhcnNlWG1sRWxlbWVudCA9IHJlcXVpcmUoJy4veG1sJykucGFyc2VFbGVtZW50O1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGRyb3BsZXRVdGlscyA9IHJlcXVpcmUoJy4vZHJvcGxldFV0aWxzJyk7XG52YXIgXyA9IHV0aWxzLmdldExvZGFzaCgpO1xudmFyIGRvbSA9IHJlcXVpcmUoJy4vZG9tJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMuanMnKTtcbnZhciBtc2cgPSByZXF1aXJlKCcuL2xvY2FsZScpO1xudmFyIGJsb2NrVXRpbHMgPSByZXF1aXJlKCcuL2Jsb2NrX3V0aWxzJyk7XG52YXIgRHJvcGxldFRvb2x0aXBNYW5hZ2VyID0gcmVxdWlyZSgnLi9ibG9ja1Rvb2x0aXBzL0Ryb3BsZXRUb29sdGlwTWFuYWdlcicpO1xudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xudmFyIEZlZWRiYWNrVXRpbHMgPSByZXF1aXJlKCcuL2ZlZWRiYWNrJyk7XG52YXIgVmVyc2lvbkhpc3RvcnkgPSByZXF1aXJlKCcuL3RlbXBsYXRlcy9WZXJzaW9uSGlzdG9yeS5qc3gnKTtcbnZhciBBbGVydCA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL2FsZXJ0LmpzeCcpO1xudmFyIGNvZGVnZW4gPSByZXF1aXJlKCcuL2NvZGVnZW4nKTtcbnZhciBwdXp6bGVSYXRpbmdVdGlscyA9IHJlcXVpcmUoJy4vcHV6emxlUmF0aW5nVXRpbHMnKTtcbnZhciBsb2dUb0Nsb3VkID0gcmVxdWlyZSgnLi9sb2dUb0Nsb3VkJyk7XG52YXIgQXV0aG9yZWRIaW50cyA9IHJlcXVpcmUoJy4vYXV0aG9yZWRIaW50cycpO1xudmFyIEluc3RydWN0aW9ucyA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL0luc3RydWN0aW9ucy5qc3gnKTtcbnZhciBXaXJlZnJhbWVTZW5kVG9QaG9uZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL1dpcmVmcmFtZVNlbmRUb1Bob25lLmpzeCcpO1xudmFyIGFzc2V0c0FwaSA9IHJlcXVpcmUoJy4vY2xpZW50QXBpJykuYXNzZXRzO1xudmFyIGFzc2V0UHJlZml4ID0gcmVxdWlyZSgnLi9hc3NldE1hbmFnZW1lbnQvYXNzZXRQcmVmaXgnKTtcbnZhciBhc3NldExpc3RTdG9yZSA9IHJlcXVpcmUoJy4vYXNzZXRNYW5hZ2VtZW50L2Fzc2V0TGlzdFN0b3JlJyk7XG52YXIgY29weXJpZ2h0U3RyaW5ncztcblxuLyoqXG4qIFRoZSBtaW5pbXVtIHdpZHRoIG9mIGEgcGxheWFibGUgd2hvbGUgYmxvY2tseSBnYW1lLlxuKi9cbnZhciBNSU5fV0lEVEggPSA5MDA7XG52YXIgREVGQVVMVF9NT0JJTEVfTk9fUEFERElOR19TSEFSRV9XSURUSCA9IDMyMDtcbnZhciBNQVhfVklTVUFMSVpBVElPTl9XSURUSCA9IDQwMDtcbnZhciBNSU5fVklTVUFMSVpBVElPTl9XSURUSCA9IDIwMDtcblxudmFyIEVOR0xJU0hfTE9DQUxFID0gJ2VuX3VzJztcblxuLyoqXG4gKiBUcmVhdCBtb2JpbGUgZGV2aWNlcyB3aXRoIHNjcmVlbi53aWR0aCBsZXNzIHRoYW4gdGhlIHZhbHVlIGJlbG93IGFzIHBob25lcy5cbiAqL1xudmFyIE1BWF9QSE9ORV9XSURUSCA9IDUwMDtcblxudmFyIFN0dWRpb0FwcCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5mZWVkYmFja18gPSBuZXcgRmVlZGJhY2tVdGlscyh0aGlzKTtcbiAgdGhpcy5hdXRob3JlZEhpbnRzQ29udHJvbGxlcl8gPSBuZXcgQXV0aG9yZWRIaW50cyh0aGlzKTtcblxuICAvKipcbiAgKiBUaGUgcGFyZW50IGRpcmVjdG9yeSBvZiB0aGUgYXBwcy4gQ29udGFpbnMgY29tbW9uLmpzLlxuICAqL1xuICB0aGlzLkJBU0VfVVJMID0gdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAqIFRoZSBjdXJyZW50IGxvY2FsZSBjb2RlLlxuICAqL1xuICB0aGlzLkxPQ0FMRSA9IEVOR0xJU0hfTE9DQUxFO1xuXG4gIHRoaXMuZW5hYmxlU2hvd0NvZGUgPSB0cnVlO1xuICB0aGlzLmVkaXRDb2RlID0gZmFsc2U7XG4gIHRoaXMudXNpbmdCbG9ja2x5XyA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtBdWRpb1BsYXllcn1cbiAgICovXG4gIHRoaXMuY2RvU291bmRzID0gbnVsbDtcbiAgdGhpcy5EaWFsb2cgPSBudWxsO1xuICAvKipcbiAgICogQHR5cGUgez9Ecm9wbGV0LkVkaXRvcn1cbiAgICovXG4gIHRoaXMuZWRpdG9yID0gbnVsbDtcbiAgLyoqXG4gICAqIEB0eXBlIHs/RHJvcGxldFRvb2x0aXBNYW5hZ2VyfVxuICAgKi9cbiAgdGhpcy5kcm9wbGV0VG9vbHRpcE1hbmFnZXIgPSBudWxsO1xuXG4gIC8vIEB0eXBlIHtzdHJpbmd9IGZvciBhbGwgb2YgdGhlc2VcbiAgdGhpcy5pY29uID0gdW5kZWZpbmVkO1xuICB0aGlzLnNtYWxsSWNvbiA9IHVuZGVmaW5lZDtcbiAgdGhpcy53aW5JY29uID0gdW5kZWZpbmVkO1xuICB0aGlzLmZhaWx1cmVJY29uID0gdW5kZWZpbmVkO1xuXG4gIC8vIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBnZXQgdGhlaXIgbm9uLWRlZmF1bHQgdmFsdWVzIHNldCBieSB0aGUgYXBwbGljYXRpb24uXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gYWxlcnQgdXNlciB0byBlbXB0eSBibG9ja3MsIHNob3J0LWNpcmN1aXRpbmcgYWxsIG90aGVyIHRlc3RzLlxuICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5jaGVja0ZvckVtcHR5QmxvY2tzXyA9IGZhbHNlO1xuXG4gIC8qKlxuICAqIFRoZSBpZGVhbCBudW1iZXIgb2YgYmxvY2tzIHRvIHNvbHZlIHRoaXMgbGV2ZWwuICBVc2VycyBvbmx5IGdldCAyXG4gICogc3RhcnMgaWYgdGhleSB1c2UgbW9yZSB0aGFuIHRoaXMgbnVtYmVyLlxuICAqIEB0eXBlIHtudW1iZXJ9XG4gICovXG4gIHRoaXMuSURFQUxfQkxPQ0tfTlVNID0gdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBUZXN0YWJsZUJsb2NrXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfGZ1bmN0aW9ufSB0ZXN0IC0gQSB0ZXN0IHdoZXRoZXIgdGhlIGJsb2NrIGlzXG4gICAqICAgICAgICAgICBwcmVzZW50LCBlaXRoZXI6XG4gICAqICAgICAgICAgICAtIEEgc3RyaW5nLCBpbiB3aGljaCBjYXNlIHRoZSBzdHJpbmcgaXMgc2VhcmNoZWQgZm9yIGluXG4gICAqICAgICAgICAgICAgIHRoZSBnZW5lcmF0ZWQgY29kZS5cbiAgICogICAgICAgICAgIC0gQSBzaW5nbGUtYXJndW1lbnQgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGVhY2ggdXNlci1hZGRlZFxuICAgKiAgICAgICAgICAgICBibG9jayBpbmRpdmlkdWFsbHkuICBJZiBhbnkgY2FsbCByZXR1cm5zIHRydWUsIHRoZSBibG9ja1xuICAgKiAgICAgICAgICAgICBpcyBkZWVtZWQgcHJlc2VudC4gIFwiVXNlci1hZGRlZFwiIGJsb2NrcyBhcmUgb25lcyB0aGF0IGFyZVxuICAgKiAgICAgICAgICAgICBuZWl0aGVyIGRpc2FibGVkIG9yIHVuZGVsZXRhYmxlLlxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIGJsb2NrIHRvIGJlIHByb2R1Y2VkIGZvclxuICAgKiAgICAgICAgICAgZGlzcGxheSB0byB0aGUgdXNlciBpZiB0aGUgdGVzdCBmYWlsZWQuXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbdGl0bGVzXSAtIEEgZGljdGlvbmFyeSwgd2hlcmUsIGZvciBlYWNoXG4gICAqICAgICAgICAgICBLRVktVkFMVUUgcGFpciwgdGhpcyBpcyBhZGRlZCB0byB0aGUgYmxvY2sgZGVmaW5pdGlvbjpcbiAgICogICAgICAgICAgIDx0aXRsZSBuYW1lPVwiS0VZXCI+VkFMVUU8L3RpdGxlPi5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IFt2YWx1ZV0gLSBBIGRpY3Rpb25hcnksIHdoZXJlLCBmb3IgZWFjaFxuICAgKiAgICAgICAgICAgS0VZLVZBTFVFIHBhaXIsIHRoaXMgaXMgYWRkZWQgdG8gdGhlIGJsb2NrIGRlZmluaXRpb246XG4gICAqICAgICAgICAgICA8dmFsdWUgbmFtZT1cIktFWVwiPlZBTFVFPC92YWx1ZT5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtleHRyYV0gLSBBIHN0cmluZyB0aGF0IHNob3VsZCBiZSBibGFja2VkXG4gICAqICAgICAgICAgICBiZXR3ZWVuIHRoZSBcImJsb2NrXCIgc3RhcnQgYW5kIGVuZCB0YWdzLlxuICAgKi9cblxuICAvKipcbiAgKiBAdHlwZSB7IVRlc3RhYmxlQmxvY2tbXX1cbiAgKi9cbiAgdGhpcy5yZXF1aXJlZEJsb2Nrc18gPSBbXTtcblxuICAvKipcbiAgKiBUaGUgbnVtYmVyIG9mIHJlcXVpcmVkIGJsb2NrcyB0byBnaXZlIGhpbnRzIGFib3V0IGF0IGFueSBvbmUgdGltZS5cbiAgKiBTZXQgdGhpcyB0byBJbmZpbml0eSB0byBzaG93IGFsbC5cbiAgKiBAdHlwZSB7bnVtYmVyfVxuICAqL1xuICB0aGlzLm1heFJlcXVpcmVkQmxvY2tzVG9GbGFnXyA9IDE7XG5cbiAgLyoqXG4gICogQHR5cGUgeyFUZXN0YWJsZUJsb2NrW119XG4gICovXG4gIHRoaXMucmVjb21tZW5kZWRCbG9ja3NfID0gW107XG5cbiAgLyoqXG4gICogVGhlIG51bWJlciBvZiByZWNvbW1lbmRlZCBibG9ja3MgdG8gZ2l2ZSBoaW50cyBhYm91dCBhdCBhbnkgb25lIHRpbWUuXG4gICogU2V0IHRoaXMgdG8gSW5maW5pdHkgdG8gc2hvdyBhbGwuXG4gICogQHR5cGUge251bWJlcn1cbiAgKi9cbiAgdGhpcy5tYXhSZWNvbW1lbmRlZEJsb2Nrc1RvRmxhZ18gPSAxO1xuXG4gIC8qKlxuICAqIFRoZSBudW1iZXIgb2YgYXR0ZW1wdHMgKGhvdyBtYW55IHRpbWVzIHRoZSBydW4gYnV0dG9uIGhhcyBiZWVuIHByZXNzZWQpXG4gICogQHR5cGUgez9udW1iZXJ9XG4gICovXG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xuXG4gIC8qKlxuICAqIFN0b3JlcyB0aGUgdGltZSBhdCBpbml0LiBUaGUgZGVsdGEgdG8gY3VycmVudCB0aW1lIGlzIHVzZWQgZm9yIGxvZ2dpbmdcbiAgKiBhbmQgcmVwb3J0aW5nIHRvIGNhcHR1cmUgaG93IGxvbmcgaXQgdG9vayB0byBhcnJpdmUgYXQgYW4gYXR0ZW1wdC5cbiAgKiBAdHlwZSB7P251bWJlcn1cbiAgKi9cbiAgdGhpcy5pbml0VGltZSA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgKiBFbnVtZXJhdGlvbiBvZiB1c2VyIHByb2dyYW0gZXhlY3V0aW9uIG91dGNvbWVzLlxuICAqL1xuICB0aGlzLlJlc3VsdFR5cGUgPSBjb25zdGFudHMuUmVzdWx0VHlwZTtcblxuICAvKipcbiAgKiBFbnVtZXJhdGlvbiBvZiB0ZXN0IHJlc3VsdHMuXG4gICovXG4gIHRoaXMuVGVzdFJlc3VsdHMgPSBjb25zdGFudHMuVGVzdFJlc3VsdHM7XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIHdlIGRvbid0IHNob3cgYmxvY2tzcGFjZS4gVXNlZCB3aGVuIHZpZXdpbmcgc2hhcmVkIGxldmVsc1xuICAgKi9cbiAgdGhpcy5oaWRlU291cmNlID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIHdlJ3JlIHZpZXdpbmcgYSBzaGFyZWQgbGV2ZWwuXG4gICAqL1xuICB0aGlzLnNoYXJlID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQsIHdlIGNlbnRlciBvdXIgZW1iZWRkZWQgbGV2ZWxzLiBDYW4gYmUgb3ZlcnJpZGVuIGJ5IGFwcHMuXG4gICAqL1xuICB0aGlzLmNlbnRlckVtYmVkZGVkID0gdHJ1ZTtcblxuICAvKipcbiAgICogSWYgc2V0IHRvIHRydWUsIHdlIHVzZSBvdXIgd2lyZWZyYW1lIHNoYXJlIChvciBjaHJvbWVsZXNzIHNoYXJlIG9uIG1vYmlsZSlcbiAgICovXG4gIHRoaXMud2lyZWZyYW1lU2hhcmUgPSBmYWxzZTtcblxuICB0aGlzLm9uQXR0ZW1wdCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5vbkNvbnRpbnVlID0gdW5kZWZpbmVkO1xuICB0aGlzLm9uUmVzZXRQcmVzc2VkID0gdW5kZWZpbmVkO1xuICB0aGlzLmJhY2tUb1ByZXZpb3VzTGV2ZWwgPSB1bmRlZmluZWQ7XG4gIHRoaXMuc2VuZFRvUGhvbmUgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZW5hYmxlU2hvd0Jsb2NrQ291bnQgPSB0cnVlO1xuXG4gIHRoaXMuZGlzYWJsZVNvY2lhbFNoYXJlID0gZmFsc2U7XG4gIHRoaXMubm9QYWRkaW5nID0gZmFsc2U7XG5cbiAgdGhpcy5NSU5fV09SS1NQQUNFX0hFSUdIVCA9IHVuZGVmaW5lZDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFN0dWRpb0FwcDtcblN0dWRpb0FwcC5zaW5nbGV0b24gPSBuZXcgU3R1ZGlvQXBwKCk7XG5cbi8qKlxuICogQ29uZmlndXJlIFN0dWRpb0FwcCBvcHRpb25zXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdGhpcy5CQVNFX1VSTCA9IG9wdGlvbnMuYmFzZVVybDtcbiAgdGhpcy5MT0NBTEUgPSBvcHRpb25zLmxvY2FsZSB8fCB0aGlzLkxPQ0FMRTtcbiAgLy8gTk9URTogZWRpdENvZGUgKHdoaWNoIGN1cnJlbnRseSBpbXBsaWVzIGRyb3BsZXQpIGFuZCB1c2luZ0Jsb2NrbHlfIGFyZVxuICAvLyBjdXJyZW50bHkgbXV0dWFsbHkgZXhjbHVzaXZlLlxuICB0aGlzLmVkaXRDb2RlID0gb3B0aW9ucy5sZXZlbCAmJiBvcHRpb25zLmxldmVsLmVkaXRDb2RlO1xuICB0aGlzLnVzaW5nQmxvY2tseV8gPSAhdGhpcy5lZGl0Q29kZTtcblxuICAvLyBUT0RPIChiYnVjaGFuYW4pIDogUmVwbGFjZSB0aGlzIGVkaXRvcmxlc3MtaGFjayB3aXRoIHNldHRpbmcgYW4gZWRpdG9yIGVudW1cbiAgLy8gb3IgKGV2ZW4gYmV0dGVyKSBpbmplY3QgYW4gYXBwcm9wcmlhdGUgZWRpdG9yLWFkYXB0b3IuXG4gIGlmIChvcHRpb25zLmlzRWRpdG9ybGVzcykge1xuICAgIHRoaXMuZWRpdENvZGUgPSBmYWxzZTtcbiAgICB0aGlzLnVzaW5nQmxvY2tseV8gPSBmYWxzZTtcbiAgfVxuXG4gIHRoaXMuY2RvU291bmRzID0gb3B0aW9ucy5jZG9Tb3VuZHM7XG4gIHRoaXMuRGlhbG9nID0gb3B0aW9ucy5EaWFsb2c7XG5cbiAgLy8gQmluZCBhc3NldFVybCB0byB0aGUgaW5zdGFuY2Ugc28gdGhhdCB3ZSBkb24ndCBuZWVkIHRvIGRlcGVuZCBvbiBjYWxsZXJzXG4gIC8vIGJpbmRpbmcgY29ycmVjdGx5IGFzIHRoZXkgcGFzcyB0aGlzIGZ1bmN0aW9uIGFyb3VuZC5cbiAgdGhpcy5hc3NldFVybCA9IF8uYmluZCh0aGlzLmFzc2V0VXJsXywgdGhpcyk7XG5cbiAgdGhpcy5tYXhWaXN1YWxpemF0aW9uV2lkdGggPSBvcHRpb25zLm1heFZpc3VhbGl6YXRpb25XaWR0aCB8fCBNQVhfVklTVUFMSVpBVElPTl9XSURUSDtcbiAgdGhpcy5taW5WaXN1YWxpemF0aW9uV2lkdGggPSBvcHRpb25zLm1pblZpc3VhbGl6YXRpb25XaWR0aCB8fCBNSU5fVklTVUFMSVpBVElPTl9XSURUSDtcbn07XG5cblN0dWRpb0FwcC5wcm90b3R5cGUuaGFzSW5zdHJ1Y3Rpb25zVG9TaG93ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICByZXR1cm4gISEoY29uZmlnLmxldmVsLmluc3RydWN0aW9ucyB8fCBjb25maWcubGV2ZWwuYW5pR2lmVVJMKTtcbn07XG5cbi8qKlxuICogQ29tbW9uIHN0YXJ0dXAgdGFza3MgZm9yIGFsbCBhcHBzLiBIYXBwZW5zIGFmdGVyIGNvbmZpZ3VyZS5cbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gIGlmICghY29uZmlnKSB7XG4gICAgY29uZmlnID0ge307XG4gIH1cblxuICBjb25maWcuZ2V0Q29kZSA9IHRoaXMuZ2V0Q29kZS5iaW5kKHRoaXMpO1xuICBjb3B5cmlnaHRTdHJpbmdzID0gY29uZmlnLmNvcHlyaWdodFN0cmluZ3M7XG5cbiAgaWYgKGNvbmZpZy5pc0xlZ2FjeVNoYXJlICYmIGNvbmZpZy5oaWRlU291cmNlKSB7XG4gICAgJChcImJvZHlcIikuYWRkQ2xhc3MoXCJsZWdhY3ktc2hhcmUtdmlld1wiKTtcbiAgICBpZiAoZG9tLmlzTW9iaWxlKCkpIHtcbiAgICAgICQoJyNtYWluLWxvZ28nKS5oaWRlKCk7XG4gICAgfVxuICAgIGlmIChkb20uaXNJT1MoKSAmJiAhd2luZG93Lm5hdmlnYXRvci5zdGFuZGFsb25lKSB7XG4gICAgICBhZGRUb0hvbWUuc2hvdyh0cnVlKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnNldENvbmZpZ1ZhbHVlc18oY29uZmlnKTtcblxuICB0aGlzLmNvbmZpZ3VyZURvbShjb25maWcpO1xuXG4gIGlmIChjb25maWcudXNlc0Fzc2V0cykge1xuICAgIGFzc2V0UHJlZml4LmluaXQoY29uZmlnKTtcblxuICAgIC8vIFByZS1wb3B1bGF0ZSBhc3NldCBsaXN0XG4gICAgYXNzZXRzQXBpLmFqYXgoJ0dFVCcsICcnLCBmdW5jdGlvbiAoeGhyKSB7XG4gICAgICBhc3NldExpc3RTdG9yZS5yZXNldChKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpKTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBVbmFibGUgdG8gbG9hZCBhc3NldCBsaXN0XG4gICAgfSk7XG4gIH1cblxuICBpZiAoY29uZmlnLmhpZGVTb3VyY2UpIHtcbiAgICB0aGlzLmhhbmRsZUhpZGVTb3VyY2VfKHtcbiAgICAgIGNvbnRhaW5lcklkOiBjb25maWcuY29udGFpbmVySWQsXG4gICAgICBlbWJlZDogY29uZmlnLmVtYmVkLFxuICAgICAgbGV2ZWw6IGNvbmZpZy5sZXZlbCxcbiAgICAgIGxldmVsX3NvdXJjZV9pZDogY29uZmlnLmxldmVsX3NvdXJjZV9pZCxcbiAgICAgIHBob25lX3NoYXJlX3VybDogY29uZmlnLnNlbmRfdG9fcGhvbmVfdXJsLFxuICAgICAgc2VuZFRvUGhvbmU6IGNvbmZpZy5zZW5kVG9QaG9uZSxcbiAgICAgIHR3aXR0ZXI6IGNvbmZpZy50d2l0dGVyLFxuICAgICAgYXBwOiBjb25maWcuYXBwLFxuICAgICAgaXNMZWdhY3lTaGFyZTogY29uZmlnLmlzTGVnYWN5U2hhcmVcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChjb25maWcuc2hhcmUpIHtcbiAgICB0aGlzLmhhbmRsZVNoYXJpbmdfKHtcbiAgICAgIG1ha2VVcmw6IGNvbmZpZy5tYWtlVXJsLFxuICAgICAgbWFrZVN0cmluZzogY29uZmlnLm1ha2VTdHJpbmcsXG4gICAgICBtYWtlSW1hZ2U6IGNvbmZpZy5tYWtlSW1hZ2UsXG4gICAgICBtYWtlWW91ck93bjogY29uZmlnLm1ha2VZb3VyT3duXG4gICAgfSk7XG4gIH1cblxuICB0aGlzLmF1dGhvcmVkSGludHNDb250cm9sbGVyXy5pbml0KGNvbmZpZy5sZXZlbC5hdXRob3JlZEhpbnRzLCBjb25maWcuc2NyaXB0SWQsIGNvbmZpZy5zZXJ2ZXJMZXZlbElkKTtcbiAgaWYgKGNvbmZpZy5hdXRob3JlZEhpbnRWaWV3UmVxdWVzdHNVcmwpIHtcbiAgICB0aGlzLmF1dGhvcmVkSGludHNDb250cm9sbGVyXy5zdWJtaXRIaW50cyhjb25maWcuYXV0aG9yZWRIaW50Vmlld1JlcXVlc3RzVXJsKTtcbiAgfVxuXG4gIGlmIChjb25maWcucHV6emxlUmF0aW5nc1VybCkge1xuICAgIHB1enpsZVJhdGluZ1V0aWxzLnN1Ym1pdENhY2hlZFB1enpsZVJhdGluZ3MoY29uZmlnLnB1enpsZVJhdGluZ3NVcmwpO1xuICB9XG5cbiAgLy8gUmVjb3JkIHRpbWUgYXQgaW5pdGlhbGl6YXRpb24uXG4gIHRoaXMuaW5pdFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAvLyBGaXhlcyB2aWV3cG9ydCBmb3Igc21hbGwgc2NyZWVucy5cbiAgdmFyIHZpZXdwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwidmlld3BvcnRcIl0nKTtcbiAgaWYgKHZpZXdwb3J0KSB7XG4gICAgdGhpcy5maXhWaWV3cG9ydEZvclNtYWxsU2NyZWVuc18odmlld3BvcnQsIGNvbmZpZyk7XG4gIH1cblxuICB2YXIgc2hvd0NvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2hvdy1jb2RlLWhlYWRlcicpO1xuICBpZiAoc2hvd0NvZGUgJiYgdGhpcy5lbmFibGVTaG93Q29kZSkge1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQoc2hvd0NvZGUsIF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmVkaXRDb2RlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBub25Ecm9wbGV0RXJyb3IgPSBmYWxzZTtcbiAgICAgICAgLy8gYXJlIHdlIHRyeWluZyB0byB0b2dnbGUgZnJvbSBibG9ja3MgdG8gdGV4dCAob3IgdGhlIG9wcG9zaXRlKVxuICAgICAgICB2YXIgZnJvbUJsb2NrcyA9IHRoaXMuZWRpdG9yLmN1cnJlbnRseVVzaW5nQmxvY2tzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZWRpdG9yLnRvZ2dsZUJsb2NrcygpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBub25Ecm9wbGV0RXJyb3IgPSB0cnVlO1xuICAgICAgICAgIHJlc3VsdCA9IHtlcnJvcjogZXJyfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgIGxvZ1RvQ2xvdWQuYWRkUGFnZUFjdGlvbihsb2dUb0Nsb3VkLlBhZ2VBY3Rpb24uRHJvcGxldFRyYW5zaXRpb25FcnJvciwge1xuICAgICAgICAgICAgZHJvcGxldEVycm9yOiAhbm9uRHJvcGxldEVycm9yLFxuICAgICAgICAgICAgZnJvbUJsb2NrczogZnJvbUJsb2Nrc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZmVlZGJhY2tfLnNob3dUb2dnbGVCbG9ja3NFcnJvcih0aGlzLkRpYWxvZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkRyb3BsZXRUb2dnbGVfKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZlZWRiYWNrXy5zaG93R2VuZXJhdGVkQ29kZSh0aGlzLkRpYWxvZywgY29uZmlnLmFwcFN0cmluZ3MpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpKTtcbiAgfVxuXG4gIHZhciBibG9ja0NvdW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Jsb2NrQ291bnRlcicpO1xuICBpZiAoYmxvY2tDb3VudCAmJiAhdGhpcy5lbmFibGVTaG93QmxvY2tDb3VudCkge1xuICAgIGJsb2NrQ291bnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfVxuXG4gIHRoaXMuc2V0SWNvbnNGcm9tU2tpbihjb25maWcuc2tpbik7XG5cbiAgaWYgKGNvbmZpZy5sZXZlbC5pbnN0cnVjdGlvbnNJY29uKSB7XG4gICAgdGhpcy5pY29uID0gY29uZmlnLnNraW5bY29uZmlnLmxldmVsLmluc3RydWN0aW9uc0ljb25dO1xuICAgIHRoaXMud2luSWNvbiA9IGNvbmZpZy5za2luW2NvbmZpZy5sZXZlbC5pbnN0cnVjdGlvbnNJY29uXTtcbiAgfVxuXG4gIGlmIChjb25maWcuc2hvd0luc3RydWN0aW9uc1dyYXBwZXIpIHtcbiAgICBjb25maWcuc2hvd0luc3RydWN0aW9uc1dyYXBwZXIoXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzaG91bGRBdXRvQ2xvc2UgPSAhIWNvbmZpZy5sZXZlbC5hbmlHaWZVUkw7XG4gICAgICB0aGlzLnNob3dJbnN0cnVjdGlvbnNfKGNvbmZpZy5sZXZlbCwgc2hvdWxkQXV0b0Nsb3NlLCBmYWxzZSk7XG4gICAgfSwgdGhpcykpO1xuICB9XG5cbiAgLy8gSW4gZW1iZWQgbW9kZSwgdGhlIGRpc3BsYXkgc2NhbGVzIGRvd24gd2hlbiB0aGUgd2lkdGggb2YgdGhlXG4gIC8vIHZpc3VhbGl6YXRpb25Db2x1bW4gZ29lcyBiZWxvdyB0aGUgbWluIHdpZHRoXG4gIGlmKGNvbmZpZy5lbWJlZCAmJiBjb25maWcuY2VudGVyRW1iZWRkZWQpIHtcbiAgICB2YXIgcmVzaXplZCA9IGZhbHNlO1xuICAgIHZhciByZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2aXpDb2wgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmlzdWFsaXphdGlvbkNvbHVtbicpO1xuICAgICAgdmFyIHdpZHRoID0gdml6Q29sLm9mZnNldFdpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IHZpekNvbC5vZmZzZXRIZWlnaHQ7XG4gICAgICB2YXIgZGlzcGxheVdpZHRoID0gREVGQVVMVF9NT0JJTEVfTk9fUEFERElOR19TSEFSRV9XSURUSDtcbiAgICAgIHZhciBzY2FsZSA9IE1hdGgubWluKHdpZHRoIC8gZGlzcGxheVdpZHRoLCBoZWlnaHQgLyBkaXNwbGF5V2lkdGgpO1xuICAgICAgdmFyIHZpeiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aXN1YWxpemF0aW9uJyk7XG4gICAgICB2aXouc3R5bGVbJ3RyYW5zZm9ybS1vcmlnaW4nXSA9ICdsZWZ0IHRvcCc7XG4gICAgICB2aXouc3R5bGVbJy13ZWJraXQtdHJhbnNmb3JtJ10gPSAnc2NhbGUoJyArIHNjYWxlICsgJyknO1xuICAgICAgdml6LnN0eWxlWydtYXgtaGVpZ2h0J10gPSAoZGlzcGxheVdpZHRoICogc2NhbGUpICsgJ3B4JztcbiAgICAgIHZpei5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgIHZpekNvbC5zdHlsZS53aWR0aCA9ICcnO1xuICAgICAgdml6Q29sLnN0eWxlLm1heFdpZHRoID0gZGlzcGxheVdpZHRoICsgJ3B4JztcbiAgICAgIC8vIE5lZWRzIHRvIHJ1biB0d2ljZSBvbiBpbml0aWFsaXphdGlvblxuICAgICAgaWYoIXJlc2l6ZWQpIHtcbiAgICAgICAgcmVzaXplZCA9IHRydWU7XG4gICAgICAgIHJlc2l6ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgLy8gRGVwZW5kcyBvbiBSZXNpemVTZW5zb3IuanNcbiAgICB2YXIgUmVzaXplU2Vuc29yID0gcmVxdWlyZSgnLi9SZXNpemVTZW5zb3InKTtcbiAgICBSZXNpemVTZW5zb3IoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Zpc3VhbGl6YXRpb25Db2x1bW4nKSwgcmVzaXplKTtcbiAgfVxuXG4gIHZhciBvcmllbnRhdGlvbkhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7ICAvLyBCcm93c2VycyBsaWtlIHRvIG1lc3Mgd2l0aCBzY3JvbGwgb24gcm90YXRlLlxuICB9O1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCBvcmllbnRhdGlvbkhhbmRsZXIpO1xuICBvcmllbnRhdGlvbkhhbmRsZXIoKTtcblxuICBpZiAoY29uZmlnLmxvYWRBdWRpbykge1xuICAgIGNvbmZpZy5sb2FkQXVkaW8oKTtcbiAgfVxuXG4gIHZhciBwcm9tcHREaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJvbXB0Jyk7XG4gIHZhciBwcm9tcHQyRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb21wdDInKTtcbiAgaWYgKGNvbmZpZy5sZXZlbC5pbnN0cnVjdGlvbnMpIHtcbiAgICB2YXIgaW5zdHJ1Y3Rpb25zSHRtbCA9IHRoaXMuc3Vic3RpdHV0ZUluc3RydWN0aW9uSW1hZ2VzKGNvbmZpZy5sZXZlbC5pbnN0cnVjdGlvbnMpO1xuICAgICQocHJvbXB0RGl2KS5odG1sKGluc3RydWN0aW9uc0h0bWwpO1xuICB9XG4gIGlmIChjb25maWcubGV2ZWwuaW5zdHJ1Y3Rpb25zMikge1xuICAgIHZhciBpbnN0cnVjdGlvbnMySHRtbCA9IHRoaXMuc3Vic3RpdHV0ZUluc3RydWN0aW9uSW1hZ2VzKGNvbmZpZy5sZXZlbC5pbnN0cnVjdGlvbnMyKTtcbiAgICAkKHByb21wdDJEaXYpLmh0bWwoaW5zdHJ1Y3Rpb25zMkh0bWwpO1xuICAgICQocHJvbXB0MkRpdikuc2hvdygpO1xuICB9XG5cbiAgaWYgKHRoaXMuaGFzSW5zdHJ1Y3Rpb25zVG9TaG93KGNvbmZpZykpIHtcbiAgICB2YXIgcHJvbXB0SWNvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9tcHQtaWNvbicpO1xuICAgIGlmICh0aGlzLnNtYWxsSWNvbikge1xuICAgICAgcHJvbXB0SWNvbi5zcmMgPSB0aGlzLnNtYWxsSWNvbjtcbiAgICAgICQoJyNwcm9tcHQtaWNvbi1jZWxsJykuc2hvdygpO1xuICAgIH1cblxuICAgIHZhciBidWJibGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnViYmxlJyk7XG5cbiAgICB0aGlzLmF1dGhvcmVkSGludHNDb250cm9sbGVyXy5kaXNwbGF5KHByb21wdEljb24sIGJ1YmJsZSwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zaG93SW5zdHJ1Y3Rpb25zXyhjb25maWcubGV2ZWwsIGZhbHNlLCB0cnVlKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9XG5cbiAgdmFyIGFuaUdpZlByZXZpZXcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYW5pLWdpZi1wcmV2aWV3Jyk7XG4gIGlmIChjb25maWcubGV2ZWwuYW5pR2lmVVJMKSB7XG4gICAgYW5pR2lmUHJldmlldy5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBcInVybCgnXCIgKyBjb25maWcubGV2ZWwuYW5pR2lmVVJMICsgXCInKVwiO1xuICAgIHZhciBwcm9tcHRUYWJsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9tcHQtdGFibGUnKTtcbiAgICBwcm9tcHRUYWJsZS5jbGFzc05hbWUgKz0gXCIgd2l0aC1hbmktZ2lmXCI7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYW5pLWdpZi1wcmV2aWV3LXdyYXBwZXInKTtcbiAgICB3cmFwcGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cblxuICBpZiAodGhpcy5lZGl0Q29kZSkge1xuICAgIHRoaXMuaGFuZGxlRWRpdENvZGVfKGNvbmZpZyk7XG4gIH1cblxuICBpZiAodGhpcy5pc1VzaW5nQmxvY2tseSgpKSB7XG4gICAgdGhpcy5oYW5kbGVVc2luZ0Jsb2NrbHlfKGNvbmZpZyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaGFuZGxlVXNpbmdCbG9ja2x5XyBhbHJlYWR5IGRvZXMgYW4gb25SZXNpemUuIFdlIHN0aWxsIHdhbnQgdGhhdCBnb29kbmVzc1xuICAgIC8vIGlmIHdlJ3JlIG5vdCBibG9ja2x5XG4gICAgdGhpcy5vblJlc2l6ZSgpO1xuICB9XG5cbiAgdmFyIHZpelJlc2l6ZUJhciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aXN1YWxpemF0aW9uUmVzaXplQmFyJyk7XG4gIGlmICh2aXpSZXNpemVCYXIpIHtcbiAgICBkb20uYWRkTW91c2VEb3duVG91Y2hFdmVudCh2aXpSZXNpemVCYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5iaW5kKHRoaXMub25Nb3VzZURvd25WaXpSZXNpemVCYXIsIHRoaXMpKTtcblxuICAgIC8vIENhbid0IHVzZSBkb20uYWRkTW91c2VVcFRvdWNoRXZlbnQoKSBiZWNhdXNlIGl0IHdpbGwgcHJldmVudERlZmF1bHQgb25cbiAgICAvLyBhbGwgdG91Y2hlbmQgZXZlbnRzIG9uIHRoZSBwYWdlLCBicmVha2luZyBjbGljayBldmVudHMuLi5cbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmJpbmQodGhpcy5vbk1vdXNlVXBWaXpSZXNpemVCYXIsIHRoaXMpKTtcbiAgICB2YXIgbW91c2VVcFRvdWNoRXZlbnROYW1lID0gZG9tLmdldFRvdWNoRXZlbnROYW1lKCdtb3VzZXVwJyk7XG4gICAgaWYgKG1vdXNlVXBUb3VjaEV2ZW50TmFtZSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKG1vdXNlVXBUb3VjaEV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmJpbmQodGhpcy5vbk1vdXNlVXBWaXpSZXNpemVCYXIsIHRoaXMpKTtcbiAgICB9XG4gIH1cblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgXy5iaW5kKHRoaXMub25SZXNpemUsIHRoaXMpKTtcblxuICB0aGlzLnJlc2V0KHRydWUpO1xuXG4gIC8vIEFkZCBkaXNwbGF5IG9mIGJsb2NrcyB1c2VkLlxuICB0aGlzLnNldElkZWFsQmxvY2tOdW1iZXJfKCk7XG5cbiAgLy8gVE9ETyAoY3BpcmljaCk6IGltcGxlbWVudCBibG9jayBjb3VudCBmb3IgZHJvcGxldCAoZm9yIG5vdywgYmxvY2tseSBvbmx5KVxuICBpZiAodGhpcy5pc1VzaW5nQmxvY2tseSgpKSB7XG4gICAgQmxvY2tseS5tYWluQmxvY2tTcGFjZUVkaXRvci5hZGRDaGFuZ2VMaXN0ZW5lcihfLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnVwZGF0ZUJsb2NrQ291bnQoKTtcbiAgICB9LCB0aGlzKSk7XG5cbiAgICBpZiAoY29uZmlnLmxldmVsLm9wZW5GdW5jdGlvbkRlZmluaXRpb24pIHtcbiAgICAgIHRoaXMub3BlbkZ1bmN0aW9uRGVmaW5pdGlvbl8oY29uZmlnKTtcbiAgICB9XG4gIH1cblxuICAvLyBCaW5kIGxpc3RlbmVyIHRvICdDbGVhciBQdXp6bGUnIGJ1dHRvblxuICB2YXIgaGlkZUljb24gPSB1dGlscy52YWx1ZU9yKGNvbmZpZy5za2luLmhpZGVJY29uSW5DbGVhclB1enpsZSwgZmFsc2UpO1xuICB2YXIgY2xlYXJQdXp6bGVIZWFkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2xlYXItcHV6emxlLWhlYWRlcicpO1xuICBpZiAoY2xlYXJQdXp6bGVIZWFkZXIpIHtcbiAgICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KGNsZWFyUHV6emxlSGVhZGVyLCAoZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmZlZWRiYWNrXy5zaG93Q2xlYXJQdXp6bGVDb25maXJtYXRpb24odGhpcy5EaWFsb2csIGhpZGVJY29uLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xlYXJQdXp6bGUoY29uZmlnKTtcbiAgICAgIH0pLmJpbmQodGhpcykpO1xuICAgIH0pLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLy8gQmluZCBsaXN0ZW5lciB0byAnVmVyc2lvbiBIaXN0b3J5JyBidXR0b25cbiAgdmFyIHZlcnNpb25zSGVhZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ZlcnNpb25zLWhlYWRlcicpO1xuICBpZiAodmVyc2lvbnNIZWFkZXIpIHtcbiAgICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KHZlcnNpb25zSGVhZGVyLCAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29kZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdmFyIGRpYWxvZyA9IHRoaXMuY3JlYXRlTW9kYWxEaWFsb2coe1xuICAgICAgICBEaWFsb2c6IHRoaXMuRGlhbG9nLFxuICAgICAgICBjb250ZW50RGl2OiBjb2RlRGl2LFxuICAgICAgICBkZWZhdWx0QnRuU2VsZWN0b3I6ICdhZ2Fpbi1idXR0b24nLFxuICAgICAgICBpZDogJ3Nob3dWZXJzaW9uc01vZGFsJ1xuICAgICAgfSk7XG4gICAgICBSZWFjdERPTS5yZW5kZXIoUmVhY3QuY3JlYXRlRWxlbWVudChWZXJzaW9uSGlzdG9yeSwge1xuICAgICAgICBoYW5kbGVDbGVhclB1enpsZTogdGhpcy5oYW5kbGVDbGVhclB1enpsZS5iaW5kKHRoaXMsIGNvbmZpZylcbiAgICAgIH0pLCBjb2RlRGl2KTtcblxuICAgICAgZGlhbG9nLnNob3coKTtcbiAgICB9KS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIGlmICh0aGlzLmlzVXNpbmdCbG9ja2x5KCkgJiYgQmxvY2tseS5jb250cmFjdEVkaXRvcikge1xuICAgIEJsb2NrbHkuY29udHJhY3RFZGl0b3IucmVnaXN0ZXJUZXN0c0ZhaWxlZE9uQ2xvc2VIYW5kbGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZmVlZGJhY2tfLnNob3dTaW1wbGVEaWFsb2codGhpcy5EaWFsb2csIHtcbiAgICAgICAgaGVhZGVyVGV4dDogdW5kZWZpbmVkLFxuICAgICAgICBib2R5VGV4dDogbXNnLmV4YW1wbGVzRmFpbGVkT25DbG9zZSgpLFxuICAgICAgICBjYW5jZWxUZXh0OiBtc2cuaWdub3JlKCksXG4gICAgICAgIGNvbmZpcm1UZXh0OiBtc2cudHJ5QWdhaW4oKSxcbiAgICAgICAgb25Db25maXJtOiBudWxsLFxuICAgICAgICBvbkNhbmNlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIEJsb2NrbHkuY29udHJhY3RFZGl0b3IuaGlkZUlmT3BlbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gcmV0dXJuIHRydWUgdG8gaW5kaWNhdGUgdG8gYmxvY2tseS1jb3JlIHRoYXQgd2UnbGwgb3duIGNsb3NpbmcgdGhlXG4gICAgICAvLyBjb250cmFjdCBlZGl0b3JcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH1cblxuICBpZiAoY29uZmlnLmlzTGVnYWN5U2hhcmUgJiYgY29uZmlnLmhpZGVTb3VyY2UpIHtcbiAgICB0aGlzLnNldHVwTGVnYWN5U2hhcmVWaWV3KCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgcGhvbmUgZnJhbWUgYW5kIGNvbnRhaW5lci4gU2NhbGUgc2hhcmVkIGNvbnRlbnQgKGV2ZXJ5dGhpbmcgY3VycmVudGx5IGluc2lkZSB0aGUgdmlzdWFsaXphdGlvbiBjb2x1bW4pXG4gKiB0byBjb250YWluZXIgd2lkdGgsIGZpdCBjb250YWluZXIgdG8gdGhlIHBob25lIGZyYW1lIGFuZCBhZGQgc2hhcmUgZm9vdGVyLlxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLnNldHVwTGVnYWN5U2hhcmVWaWV3ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB2aXpDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdml6Q29udGFpbmVyLmlkID0gJ3Zpc3VhbGl6YXRpb25Db250YWluZXInO1xuICB2YXIgdml6Q29sdW1uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Zpc3VhbGl6YXRpb25Db2x1bW4nKTtcbiAgaWYgKGRvbS5pc01vYmlsZSgpKSB7XG4gICAgJCh2aXpDb250YWluZXIpLndpZHRoKCQodml6Q29sdW1uKS53aWR0aCgpKTtcbiAgfVxuICAkKHZpekNvbnRhaW5lcikuYXBwZW5kKHZpekNvbHVtbi5jaGlsZHJlbik7XG5cbiAgdmFyIHBob25lRnJhbWVTY3JlZW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcGhvbmVGcmFtZVNjcmVlbi5pZCA9ICdwaG9uZUZyYW1lU2NyZWVuJztcbiAgJChwaG9uZUZyYW1lU2NyZWVuKS5hcHBlbmQodml6Q29udGFpbmVyKTtcbiAgJCh2aXpDb2x1bW4pLmFwcGVuZChwaG9uZUZyYW1lU2NyZWVuKTtcblxuICB0aGlzLnJlbmRlclNoYXJlRm9vdGVyXyhwaG9uZUZyYW1lU2NyZWVuKTtcbiAgaWYgKGRvbS5pc01vYmlsZSkge1xuICAgIC8vIHJlLXNjYWxlIG9uIHJlc2l6ZSBldmVudHMgdG8gYWRqdXN0IHRvIG9yaWVudGF0aW9uIGFuZCBuYXZiYXIgY2hhbmdlc1xuICAgICQod2luZG93KS5yZXNpemUodGhpcy5zY2FsZUxlZ2FjeVNoYXJlKTtcbiAgfVxuICB0aGlzLnNjYWxlTGVnYWN5U2hhcmUoKTtcbn07XG5cblN0dWRpb0FwcC5wcm90b3R5cGUuc2NhbGVMZWdhY3lTaGFyZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdml6Q29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Zpc3VhbGl6YXRpb25Db250YWluZXInKTtcbiAgdmFyIHZpekNvbHVtbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aXN1YWxpemF0aW9uQ29sdW1uJyk7XG4gIHZhciBwaG9uZUZyYW1lU2NyZWVuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bob25lRnJhbWVTY3JlZW4nKTtcbiAgdmFyIHZpeldpZHRoID0gJCh2aXpDb250YWluZXIpLndpZHRoKCk7XG5cbiAgLy8gT24gbW9iaWxlLCBzY2FsZSBwaG9uZSBmcmFtZSB0byBmdWxsIHNjcmVlbiAocG9ydHJhaXQpLiBPdGhlcndpc2UgdXNlIGdpdmVuIGRpbWVuc2lvbnMgZnJvbSBjc3MuXG4gIGlmIChkb20uaXNNb2JpbGUoKSkge1xuICAgIHZhciBzY3JlZW5XaWR0aCA9IE1hdGgubWluKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIHZhciBzY3JlZW5IZWlnaHQgPSBNYXRoLm1heCh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAkKHBob25lRnJhbWVTY3JlZW4pLndpZHRoKHNjcmVlbldpZHRoKTtcbiAgICAkKHBob25lRnJhbWVTY3JlZW4pLmhlaWdodChzY3JlZW5IZWlnaHQpO1xuICAgICQodml6Q29sdW1uKS53aWR0aChzY3JlZW5XaWR0aCk7XG4gIH1cblxuICB2YXIgZnJhbWVXaWR0aCA9ICQocGhvbmVGcmFtZVNjcmVlbikud2lkdGgoKTtcbiAgdmFyIHNjYWxlID0gZnJhbWVXaWR0aCAvIHZpeldpZHRoO1xuICBhcHBseVRyYW5zZm9ybU9yaWdpbih2aXpDb250YWluZXIsICdsZWZ0IHRvcCcpO1xuICBhcHBseVRyYW5zZm9ybVNjYWxlKHZpekNvbnRhaW5lciwgJ3NjYWxlKCcgKyBzY2FsZSArICcpJyk7XG59O1xuXG5TdHVkaW9BcHAucHJvdG90eXBlLnN1YnN0aXR1dGVJbnN0cnVjdGlvbkltYWdlcyA9IGZ1bmN0aW9uKGh0bWxUZXh0KSB7XG4gIGlmIChodG1sVGV4dCkge1xuICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5za2luLmluc3RydWN0aW9uczJJbWFnZVN1YnN0aXR1dGlvbnMpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc2tpbi5pbnN0cnVjdGlvbnMySW1hZ2VTdWJzdGl0dXRpb25zW3Byb3BdO1xuICAgICAgdmFyIHN1YnN0aXR1dGlvbkh0bWwgPSAnPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbnNJbWFnZUNvbnRhaW5lclwiPjxpbWcgc3JjPVwiJyArIHZhbHVlICsgJ1wiIGNsYXNzPVwiaW5zdHJ1Y3Rpb25zSW1hZ2VcIi8+PC9zcGFuPic7XG4gICAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKCdcXFxcWycgKyBwcm9wICsgJ1xcXFxdJywgJ2cnKTtcbiAgICAgIGh0bWxUZXh0ID0gaHRtbFRleHQucmVwbGFjZShyZSwgc3Vic3RpdHV0aW9uSHRtbCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGh0bWxUZXh0O1xufTtcblxuU3R1ZGlvQXBwLnByb3RvdHlwZS5nZXRDb2RlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuZWRpdENvZGUpIHtcbiAgICB0aHJvdyBcImdldENvZGUoKSByZXF1aXJlcyBlZGl0Q29kZVwiO1xuICB9XG4gIGlmICh0aGlzLmhpZGVTb3VyY2UpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydEJsb2Nrc187XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yLmdldFZhbHVlKCk7XG4gIH1cbn07XG5cblN0dWRpb0FwcC5wcm90b3R5cGUuc2V0SWNvbnNGcm9tU2tpbiA9IGZ1bmN0aW9uIChza2luKSB7XG4gIHRoaXMuaWNvbiA9IHNraW4uc3RhdGljQXZhdGFyO1xuICB0aGlzLnNtYWxsSWNvbiA9IHNraW4uc21hbGxTdGF0aWNBdmF0YXI7XG4gIHRoaXMud2luSWNvbiA9IHNraW4ud2luQXZhdGFyO1xuICB0aGlzLmZhaWx1cmVJY29uID0gc2tpbi5mYWlsdXJlQXZhdGFyO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgcHV6emxlIGJhY2sgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG4gKiBTZWFyY2ggYWxpYXNlczogXCJTdGFydCBPdmVyXCIsIHN0YXJ0T3ZlclxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIHNhbWUgY29uZmlnIG9iamVjdCBwYXNzZWQgdG8gc3R1ZGlvQXBwLmluaXQoKS5cbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5oYW5kbGVDbGVhclB1enpsZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgaWYgKHRoaXMuaXNVc2luZ0Jsb2NrbHkoKSkge1xuICAgIGlmIChCbG9ja2x5LmZ1bmN0aW9uRWRpdG9yKSB7XG4gICAgICBCbG9ja2x5LmZ1bmN0aW9uRWRpdG9yLmhpZGVJZk9wZW4oKTtcbiAgICB9XG4gICAgQmxvY2tseS5tYWluQmxvY2tTcGFjZS5jbGVhcigpO1xuICAgIHRoaXMuc2V0U3RhcnRCbG9ja3NfKGNvbmZpZywgZmFsc2UpO1xuICAgIGlmIChjb25maWcubGV2ZWwub3BlbkZ1bmN0aW9uRGVmaW5pdGlvbikge1xuICAgICAgdGhpcy5vcGVuRnVuY3Rpb25EZWZpbml0aW9uXyhjb25maWcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVzZXRWYWx1ZSA9ICcnO1xuICAgIGlmIChjb25maWcubGV2ZWwuc3RhcnRCbG9ja3MpIHtcbiAgICAgIC8vIERvbid0IHBhc3MgQ1JMRiBwYWlycyB0byBkcm9wbGV0IHVudGlsIHRoZXkgZml4IENSIGhhbmRsaW5nOlxuICAgICAgcmVzZXRWYWx1ZSA9IGNvbmZpZy5sZXZlbC5zdGFydEJsb2Nrcy5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpO1xuICAgIH1cbiAgICAvLyBUT0RPIChiYnVjaGFuYW4pOiBUaGlzIGdldFZhbHVlKCkgY2FsbCBpcyBhIHdvcmthcm91bmQgZm9yIGEgRHJvcGxldCBidWcsXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kcm9wbGV0LWVkaXRvci9kcm9wbGV0L2lzc3Vlcy8xMzdcbiAgICAvLyBDYWxsaW5nIGdldFZhbHVlKCkgdXBkYXRlcyB0aGUgY2FjaGVkIGFjZSBlZGl0b3IgdmFsdWUsIHdoaWNoIGNhbiBiZVxuICAgIC8vIG91dC1vZi1kYXRlIGluIGRyb3BsZXQgYW5kIGNhdXNlIGFuIGluY29ycmVjdCBlYXJseS1vdXQuXG4gICAgLy8gUmVtb3ZlIHRoaXMgbGluZSBvbmNlIHRoYXQgYnVnIGlzIGZpeGVkIGFuZCBvdXIgRHJvcGxldCBsaWIgaXMgdXBkYXRlZC5cbiAgICB0aGlzLmVkaXRvci5nZXRWYWx1ZSgpO1xuICAgIHRoaXMuZWRpdG9yLnNldFZhbHVlKHJlc2V0VmFsdWUpO1xuICB9XG4gIGlmIChjb25maWcuYWZ0ZXJDbGVhclB1enpsZSkge1xuICAgIGNvbmZpZy5hZnRlckNsZWFyUHV6emxlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogVFJVRSBpZiB0aGUgY3VycmVudCBhcHAgdXNlcyBibG9ja2x5IChhcyBvcHBvc2VkIHRvIGVkaXRDb2RlIG9yIGFub3RoZXJcbiAqIGVkaXRvcilcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuaXNVc2luZ0Jsb2NrbHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnVzaW5nQmxvY2tseV87XG59O1xuXG4vKipcbiAqXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuaGFuZGxlU2hhcmluZ18gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAvLyAxLiBNb3ZlIHRoZSBidXR0b25zLCAyLiBIaWRlIHRoZSBzbGlkZXIgaW4gdGhlIHNoYXJlIHBhZ2UgZm9yIG1vYmlsZS5cbiAgdmFyIGJlbG93VmlzdWFsaXphdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdiZWxvd1Zpc3VhbGl6YXRpb24nKTtcbiAgaWYgKGRvbS5pc01vYmlsZSgpKSB7XG4gICAgdmFyIHNsaWRlckNlbGwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2xpZGVyLWNlbGwnKTtcbiAgICBpZiAoc2xpZGVyQ2VsbCkge1xuICAgICAgc2xpZGVyQ2VsbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbiAgICBpZiAoYmVsb3dWaXN1YWxpemF0aW9uKSB7XG4gICAgICB2YXIgdmlzdWFsaXphdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aXN1YWxpemF0aW9uJyk7XG4gICAgICBiZWxvd1Zpc3VhbGl6YXRpb24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHZpc3VhbGl6YXRpb24uc3R5bGUubWFyZ2luQm90dG9tID0gJzBweCc7XG4gICAgfVxuICB9XG5cbiAgLy8gU2hvdyBmbGFwcHkgdXBzYWxlIG9uIGRlc2t0b3AgYW5kIG1vYmlsZS4gIFNob3cgbGVhcm4gdXBzYWxlIG9ubHkgb24gZGVza3RvcFxuICB2YXIgdXBTYWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGlmIChvcHRpb25zLm1ha2VZb3VyT3duKSB7XG4gICAgdXBTYWxlLmlubmVySFRNTCA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL21ha2VZb3VyT3duLmh0bWwuZWpzJykoe1xuICAgICAgZGF0YToge1xuICAgICAgICBtYWtlVXJsOiBvcHRpb25zLm1ha2VVcmwsXG4gICAgICAgIG1ha2VTdHJpbmc6IG9wdGlvbnMubWFrZVN0cmluZyxcbiAgICAgICAgbWFrZUltYWdlOiBvcHRpb25zLm1ha2VJbWFnZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0aGlzLm5vUGFkZGluZykge1xuICAgICAgdXBTYWxlLnN0eWxlLm1hcmdpbkxlZnQgPSAnMTBweCc7XG4gICAgfVxuICAgIGJlbG93VmlzdWFsaXphdGlvbi5hcHBlbmRDaGlsZCh1cFNhbGUpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLm1ha2VZb3VyT3duID09PSAndW5kZWZpbmVkJykge1xuICAgIHVwU2FsZS5pbm5lckhUTUwgPSByZXF1aXJlKCcuL3RlbXBsYXRlcy9sZWFybi5odG1sLmVqcycpKHtcbiAgICAgIGFzc2V0VXJsOiB0aGlzLmFzc2V0VXJsXG4gICAgfSk7XG4gICAgYmVsb3dWaXN1YWxpemF0aW9uLmFwcGVuZENoaWxkKHVwU2FsZSk7XG4gIH1cbn07XG5cblN0dWRpb0FwcC5wcm90b3R5cGUucmVuZGVyU2hhcmVGb290ZXJfID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gIHZhciBmb290ZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZm9vdGVyRGl2LnNldEF0dHJpYnV0ZSgnaWQnLCAnZm9vdGVyRGl2Jyk7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChmb290ZXJEaXYpO1xuXG4gIHZhciByZWFjdFByb3BzID0ge1xuICAgIGkxOG5Ecm9wZG93bjogJycsXG4gICAgY29weXJpZ2h0SW5CYXNlOiBmYWxzZSxcbiAgICBjb3B5cmlnaHRTdHJpbmdzOiBjb3B5cmlnaHRTdHJpbmdzLFxuICAgIGJhc2VNb3JlTWVudVN0cmluZzogd2luZG93LmRhc2hib2FyZC5pMThuLnQoJ2Zvb3Rlci5idWlsdF9vbl9jb2RlX3N0dWRpbycpLFxuICAgIGJhc2VTdHlsZToge1xuICAgICAgcGFkZGluZ0xlZnQ6IDAsXG4gICAgICB3aWR0aDogJChcIiN2aXN1YWxpemF0aW9uXCIpLndpZHRoKClcbiAgICB9LFxuICAgIGNsYXNzTmFtZTogJ2RhcmsnLFxuICAgIG1lbnVJdGVtczogW1xuICAgICAge1xuICAgICAgICB0ZXh0OiB3aW5kb3cuZGFzaGJvYXJkLmkxOG4udCgnZm9vdGVyLnRyeV9ob3VyX29mX2NvZGUnKSxcbiAgICAgICAgbGluazogJ2h0dHBzOi8vY29kZS5vcmcvbGVhcm4nLFxuICAgICAgICBuZXdXaW5kb3c6IHRydWVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRleHQ6IHdpbmRvdy5kYXNoYm9hcmQuaTE4bi50KCdmb290ZXIuaG93X2l0X3dvcmtzJyksXG4gICAgICAgIGxpbms6IGxvY2F0aW9uLmhyZWYgKyBcIi9lZGl0XCIsXG4gICAgICAgIG5ld1dpbmRvdzogZmFsc2VcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRleHQ6IHdpbmRvdy5kYXNoYm9hcmQuaTE4bi50KCdmb290ZXIuY29weXJpZ2h0JyksXG4gICAgICAgIGxpbms6ICcjJyxcbiAgICAgICAgY29weXJpZ2h0OiB0cnVlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0ZXh0OiB3aW5kb3cuZGFzaGJvYXJkLmkxOG4udCgnZm9vdGVyLnRvcycpLFxuICAgICAgICBsaW5rOiBcImh0dHBzOi8vY29kZS5vcmcvdG9zXCIsXG4gICAgICAgIG5ld1dpbmRvdzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGV4dDogd2luZG93LmRhc2hib2FyZC5pMThuLnQoJ2Zvb3Rlci5wcml2YWN5JyksXG4gICAgICAgIGxpbms6IFwiaHR0cHM6Ly9jb2RlLm9yZy9wcml2YWN5XCIsXG4gICAgICAgIG5ld1dpbmRvdzogdHJ1ZVxuICAgICAgfVxuICAgIF0sXG4gICAgcGhvbmVGb290ZXI6IHRydWVcbiAgfTtcblxuICBSZWFjdERPTS5yZW5kZXIoUmVhY3QuY3JlYXRlRWxlbWVudCh3aW5kb3cuZGFzaGJvYXJkLlNtYWxsRm9vdGVyLCByZWFjdFByb3BzKSxcbiAgICBmb290ZXJEaXYpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHVybCBvZiBwYXRoIGFwcGVuZGVkIHRvIEJBU0VfVVJMXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuYXNzZXRVcmxfID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHRoaXMuQkFTRV9VUkwgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3R1ZGlvQXBwIEJBU0VfVVJMIGhhcyBub3QgYmVlbiBzZXQuICcgK1xuICAgICAgJ0NhbGwgY29uZmlndXJlKCkgZmlyc3QnKTtcbiAgfVxuICByZXR1cm4gdGhpcy5CQVNFX1VSTCArIHBhdGg7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBwbGF5aW5nIGZpZWxkIHRvIHRoZSBzdGFydCBwb3NpdGlvbiBhbmQga2lsbCBhbnkgcGVuZGluZ1xuICogYW5pbWF0aW9uIHRhc2tzLiAgVGhpcyB3aWxsIHR5cGljYWxseSBiZSByZXBsYWNlZCBieSBhbiBhcHBsaWNhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUGxheU9wZW5pbmdBbmltYXRpb24gVHJ1ZSBpZiBhbiBvcGVuaW5nIGFuaW1hdGlvbiBpc1xuICogICB0byBiZSBwbGF5ZWQuXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoc2hvdWxkUGxheU9wZW5pbmdBbmltYXRpb24pIHtcbiAgLy8gVE9ETyAoYmJ1Y2hhbmFuKTogTG9vayBmb3IgY29tb24gcmVzZXQgbG9naWMgd2UgY2FuIHB1bGwgaGVyZVxuICAvLyBPdmVycmlkZSBpbiBhcHAgc3ViY2xhc3Ncbn07XG5cblxuLyoqXG4gKiBPdmVycmlkZSB0byBjaGFuZ2UgcnVuIGJlaGF2aW9yLlxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLnJ1bkJ1dHRvbkNsaWNrID0gZnVuY3Rpb24oKSB7fTtcblxuLyoqXG4gKiBUb2dnbGUgd2hldGhlciBydW4gYnV0dG9uIG9yIHJlc2V0IGJ1dHRvbiBpcyBzaG93blxuICogQHBhcmFtIHtzdHJpbmd9IGJ1dHRvbiBCdXR0b24gdG8gc2hvdywgZWl0aGVyIFwicnVuXCIgb3IgXCJyZXNldFwiXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUudG9nZ2xlUnVuUmVzZXQgPSBmdW5jdGlvbihidXR0b24pIHtcbiAgdmFyIHNob3dSdW4gPSAoYnV0dG9uID09PSAncnVuJyk7XG4gIGlmIChidXR0b24gIT09ICdydW4nICYmIGJ1dHRvbiAhPT0gJ3Jlc2V0Jykge1xuICAgIHRocm93IFwiVW5leHBlY3RlZCBpbnB1dFwiO1xuICB9XG5cbiAgdmFyIHJ1biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdydW5CdXR0b24nKTtcbiAgdmFyIHJlc2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jlc2V0QnV0dG9uJyk7XG4gIHJ1bi5zdHlsZS5kaXNwbGF5ID0gc2hvd1J1biA/ICdpbmxpbmUtYmxvY2snIDogJ25vbmUnO1xuICBydW4uZGlzYWJsZWQgPSAhc2hvd1J1bjtcbiAgcmVzZXQuc3R5bGUuZGlzcGxheSA9ICFzaG93UnVuID8gJ2lubGluZS1ibG9jaycgOiAnbm9uZSc7XG4gIHJlc2V0LmRpc2FibGVkID0gc2hvd1J1bjtcblxuICAvLyBUb2dnbGUgc29mdC1idXR0b25zIChhbGwgaGF2ZSB0aGUgJ2Fycm93JyBjbGFzcyBzZXQpOlxuICAkKCcuYXJyb3cnKS5wcm9wKFwiZGlzYWJsZWRcIiwgc2hvd1J1bik7XG59O1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGFzc29jaWF0ZSBhIHNldCBvZiBhdWRpbyBmaWxlcyB0byBhIGdpdmVuIG5hbWVcbiAqIEhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgY2RvU291bmRzIGRvZXMgbm90IGV4aXN0LCBlLmcuIGluIHRlc3RzXG4gKiBhbmQgZ3J1bnQgZGV2IHByZXZpZXcgbW9kZVxuICogQHBhcmFtIHtPYmplY3R9IGF1ZGlvQ29uZmlnIHNvdW5kIGNvbmZpZ3VyYXRpb25cbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5yZWdpc3RlckF1ZGlvID0gZnVuY3Rpb24oYXVkaW9Db25maWcpIHtcbiAgaWYgKCF0aGlzLmNkb1NvdW5kcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuY2RvU291bmRzLnJlZ2lzdGVyKGF1ZGlvQ29uZmlnKTtcbn07XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gYXNzb2NpYXRlIGEgc2V0IG9mIGF1ZGlvIGZpbGVzIHRvIGEgZ2l2ZW4gbmFtZVxuICogSGFuZGxlcyB0aGUgY2FzZSB3aGVyZSBjZG9Tb3VuZHMgZG9lcyBub3QgZXhpc3QsIGUuZy4gaW4gdGVzdHNcbiAqIGFuZCBncnVudCBkZXYgcHJldmlldyBtb2RlXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBmaWxlbmFtZXMgZmlsZSBwYXRocyBmb3Igc291bmRzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBJRCB0byBhc3NvY2lhdGUgc291bmQgZWZmZWN0IHdpdGhcbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5sb2FkQXVkaW8gPSBmdW5jdGlvbihmaWxlbmFtZXMsIG5hbWUpIHtcbiAgaWYgKCF0aGlzLmNkb1NvdW5kcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuY2RvU291bmRzLnJlZ2lzdGVyQnlGaWxlbmFtZXNBbmRJRChmaWxlbmFtZXMsIG5hbWUpO1xufTtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBwbGF5IGEgc291bmQgZWZmZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBzb3VuZCBJRFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgZm9yIHNvdW5kIHBsYXliYWNrXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy52b2x1bWUgdmFsdWUgYmV0d2VlbiAwLjAgYW5kIDEuMCBzcGVjaWZ5aW5nIHZvbHVtZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMub25FbmRlZF1cbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5wbGF5QXVkaW8gPSBmdW5jdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gIGlmICghdGhpcy5jZG9Tb3VuZHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGRlZmF1bHRPcHRpb25zID0ge3ZvbHVtZTogMC41fTtcbiAgdmFyIG5ld09wdGlvbnMgPSB1dGlscy5leHRlbmQoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICB0aGlzLmNkb1NvdW5kcy5wbGF5KG5hbWUsIG5ld09wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBTdG9wcyBsb29waW5nIGEgZ2l2ZW4gc291bmRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIElEIG9mIHNvdW5kXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuc3RvcExvb3BpbmdBdWRpbyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYgKCF0aGlzLmNkb1NvdW5kcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuY2RvU291bmRzLnN0b3BMb29waW5nQXVkaW8obmFtZSk7XG59O1xuXG4vKipcbiogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIGZvciBCbG9ja2x5LiBQYXJhbWV0ZXJzIGFyZVxuKiBvcHRpb25hbCBhbmQgaW5jbHVkZTpcbiogIC0ge3N0cmluZ30gcGF0aCBUaGUgcm9vdCBwYXRoIHRvIHRoZSAvYXBwcyBkaXJlY3RvcnksIGRlZmF1bHRzIHRvIHRoZVxuKiAgICB0aGUgZGlyZWN0b3J5IGluIHdoaWNoIHRoaXMgc2NyaXB0IGlzIGxvY2F0ZWQuXG4qICAtIHtib29sZWFufSBydGwgVHJ1ZSBpZiB0aGUgY3VycmVudCBsYW5ndWFnZSByaWdodCB0byBsZWZ0LlxuKiAgLSB7RG9tRWxlbWVudH0gdG9vbGJveCBUaGUgZWxlbWVudCBpbiB3aGljaCB0byBpbnNlcnQgdGhlIHRvb2xib3gsXG4qICAgIGRlZmF1bHRzIHRvIHRoZSBlbGVtZW50IHdpdGggJ3Rvb2xib3gnLlxuKiAgLSB7Ym9vbGVhbn0gdHJhc2hjYW4gVHJ1ZSBpZiB0aGUgdHJhc2hjYW4gc2hvdWxkIGJlIGRpc3BsYXllZCwgZGVmYXVsdHMgdG9cbiogICAgdHJ1ZS5cbiogQHBhcmFtIHtFbGVtZW50fSBkaXYgVGhlIHBhcmVudCBkaXYgaW4gd2hpY2ggdG8gaW5zZXJ0IEJsb2NrbHkuXG4qL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5pbmplY3QgPSBmdW5jdGlvbihkaXYsIG9wdGlvbnMpIHtcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGFzc2V0VXJsOiB0aGlzLmFzc2V0VXJsLFxuICAgIHJ0bDogdGhpcy5pc1J0bCgpLFxuICAgIHRvb2xib3g6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0b29sYm94JyksXG4gICAgdHJhc2hjYW46IHRydWUsXG4gICAgY3VzdG9tU2ltcGxlRGlhbG9nOiB0aGlzLmZlZWRiYWNrXy5zaG93U2ltcGxlRGlhbG9nLmJpbmQodGhpcy5mZWVkYmFja18sXG4gICAgICAgIHRoaXMuRGlhbG9nKVxuICB9O1xuICBCbG9ja2x5LmluamVjdChkaXYsIHV0aWxzLmV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyksIHRoaXMuY2RvU291bmRzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IEhUTUwgcGFnZSBpcyBpbiByaWdodC10by1sZWZ0IGxhbmd1YWdlIG1vZGUuXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuaXNSdGwgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICBpZiAoaGVhZCAmJiBoZWFkLnBhcmVudEVsZW1lbnQpIHtcbiAgICB2YXIgZGlyID0gaGVhZC5wYXJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlyJyk7XG4gICAgcmV0dXJuIChkaXIgJiYgZGlyLnRvTG93ZXJDYXNlKCkgPT09ICdydGwnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSBMb2NhbGUgZGlyZWN0aW9uIHN0cmluZyBiYXNlZCBvbiBhcHAgZGlyZWN0aW9uLlxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLmxvY2FsZURpcmVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMuaXNSdGwoKSA/ICdydGwnIDogJ2x0cicpO1xufTtcblxuLyoqXG4qIEluaXRpYWxpemUgQmxvY2tseSBmb3IgYSByZWFkb25seSBpZnJhbWUuICBDYWxsZWQgb24gcGFnZSBsb2FkLiBObyBzb3VuZHMuXG4qIFhNTCBhcmd1bWVudCBtYXkgYmUgZ2VuZXJhdGVkIGZyb20gdGhlIGNvbnNvbGUgd2l0aDpcbiogQmxvY2tseS5YbWwuZG9tVG9UZXh0KEJsb2NrbHkuWG1sLmJsb2NrU3BhY2VUb0RvbShCbG9ja2x5Lm1haW5CbG9ja1NwYWNlKSkuc2xpY2UoNSwgLTYpXG4qL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5pbml0UmVhZG9ubHkgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIEJsb2NrbHkuaW5qZWN0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb2RlV29ya3NwYWNlJyksIHtcbiAgICBhc3NldFVybDogdGhpcy5hc3NldFVybCxcbiAgICByZWFkT25seTogdHJ1ZSxcbiAgICBydGw6IHRoaXMuaXNSdGwoKSxcbiAgICBzY3JvbGxiYXJzOiBmYWxzZVxuICB9KTtcbiAgdGhpcy5sb2FkQmxvY2tzKG9wdGlvbnMuYmxvY2tzKTtcbn07XG5cbi8qKlxuKiBMb2FkIHRoZSBlZGl0b3Igd2l0aCBibG9ja3MuXG4qIEBwYXJhbSB7c3RyaW5nfSBibG9ja3NYbWwgVGV4dCByZXByZXNlbnRhdGlvbiBvZiBibG9ja3MuXG4qL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5sb2FkQmxvY2tzID0gZnVuY3Rpb24oYmxvY2tzWG1sKSB7XG4gIHZhciB4bWwgPSBwYXJzZVhtbEVsZW1lbnQoYmxvY2tzWG1sKTtcbiAgQmxvY2tseS5YbWwuZG9tVG9CbG9ja1NwYWNlKEJsb2NrbHkubWFpbkJsb2NrU3BhY2UsIHhtbCk7XG59O1xuXG4vKipcbiogQXBwbGllcyB0aGUgc3BlY2lmaWVkIGFycmFuZ2VtZW50IHRvIHRvcCBzdGFydEJsb2Nrcy4gSWYgYW55XG4qIGluZGl2aWR1YWwgYmxvY2tzIGhhdmUgeCBvciB5IHByb3BlcnRpZXMgc2V0IGluIHRoZSBYTUwsIHRob3NlIHZhbHVlc1xuKiB0YWtlIHByaW9yaXR5LiBJZiBubyBhcnJhbmdlbWVudCBmb3IgYSBwYXJ0aWN1bGFyIGJsb2NrIHR5cGUgaXNcbiogc3BlY2lmaWVkLCBibG9ja3MgYXJlIGF1dG9tYXRpY2FsbHkgcG9zaXRpb25lZCBieSBCbG9ja2x5LlxuKlxuKiBOb3RlIHRoYXQsIGN1cnJlbnRseSwgb25seSBib3VuY2UgYW5kIGZsYXBweSB1c2UgYXJyYW5nZW1lbnRzLlxuKlxuKiBAcGFyYW0ge3N0cmluZ30gc3RhcnRCbG9ja3MgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHN0YXJ0IGJsb2NrcyB4bWwuXG4qIEBwYXJhbSB7T2JqZWN0LjxPYmplY3Q+fSBhcnJhbmdlbWVudCBBIG1hcCBmcm9tIGJsb2NrIHR5cGUgdG8gcG9zaXRpb24uXG4qIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHN0YXJ0IGJsb2NrcyB4bWwsIGluY2x1ZGluZ1xuKiAgICBibG9jayBwb3NpdGlvbi5cbiovXG5TdHVkaW9BcHAucHJvdG90eXBlLmFycmFuZ2VCbG9ja1Bvc2l0aW9uID0gZnVuY3Rpb24oc3RhcnRCbG9ja3MsIGFycmFuZ2VtZW50KSB7XG5cbiAgdmFyIHR5cGUsIHhtbENoaWxkO1xuXG4gIHZhciB4bWwgPSBwYXJzZVhtbEVsZW1lbnQoc3RhcnRCbG9ja3MpO1xuXG4gIHZhciB4bWxDaGlsZE5vZGVzID0geG1sLmNoaWxkTm9kZXMgfHwgW107XG4gIGFycmFuZ2VtZW50ID0gYXJyYW5nZW1lbnQgfHwge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4bWxDaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgeG1sQ2hpbGQgPSB4bWxDaGlsZE5vZGVzW2ldO1xuXG4gICAgLy8gT25seSBsb29rIGF0IGVsZW1lbnQgbm9kZXNcbiAgICBpZiAoeG1sQ2hpbGQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIC8vIGxvb2sgdG8gc2VlIGlmIHdlIGhhdmUgYSBwcmVkZWZpbmVkIGFycmFuZ2VtZW50IGZvciB0aGlzIHR5cGVcbiAgICAgIHR5cGUgPSB4bWxDaGlsZC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgIGlmIChhcnJhbmdlbWVudFt0eXBlXSkge1xuICAgICAgICBpZiAoYXJyYW5nZW1lbnRbdHlwZV0ueCAmJiAheG1sQ2hpbGQuaGFzQXR0cmlidXRlKCd4JykpIHtcbiAgICAgICAgICB4bWxDaGlsZC5zZXRBdHRyaWJ1dGUoJ3gnLCBhcnJhbmdlbWVudFt0eXBlXS54KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYW5nZW1lbnRbdHlwZV0ueSAmJiAheG1sQ2hpbGQuaGFzQXR0cmlidXRlKCd5JykpIHtcbiAgICAgICAgICB4bWxDaGlsZC5zZXRBdHRyaWJ1dGUoJ3knLCBhcnJhbmdlbWVudFt0eXBlXS55KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gQmxvY2tseS5YbWwuZG9tVG9UZXh0KHhtbCk7XG59O1xuXG5TdHVkaW9BcHAucHJvdG90eXBlLmNyZWF0ZU1vZGFsRGlhbG9nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zLkRpYWxvZyA9IHV0aWxzLnZhbHVlT3Iob3B0aW9ucy5EaWFsb2csIHRoaXMuRGlhbG9nKTtcbiAgcmV0dXJuIHRoaXMuZmVlZGJhY2tfLmNyZWF0ZU1vZGFsRGlhbG9nKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBTaW1wbGUgcGFzc3Rocm91Z2ggdG8gQXV0aG9yZWRIaW50cy5kaXNwbGF5TWlzc2luZ0Jsb2NrSGludHNcbiAqIEBwYXJhbSB7U3RyaW5nW119IGJsb2NrcyBBbiBhcnJheSBvZiBYTUwgc3RyaW5ncyByZXByZXNlbnRpbmcgdGhlXG4gKiAgICAgICAgbWlzc2luZyByZWNvbW1lbmRlZCBCbG9ja2x5IEJsb2NrcyBmb3Igd2hpY2ggd2Ugd2FudCB0b1xuICogICAgICAgIGRpc3BsYXkgaGludHMuXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuZGlzcGxheU1pc3NpbmdCbG9ja0hpbnRzID0gZnVuY3Rpb24gKGJsb2Nrcykge1xuICB0aGlzLmF1dGhvcmVkSGludHNDb250cm9sbGVyXy5kaXNwbGF5TWlzc2luZ0Jsb2NrSGludHMoYmxvY2tzKTtcbn07XG5cblN0dWRpb0FwcC5wcm90b3R5cGUub25SZXBvcnRDb21wbGV0ZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICB0aGlzLmF1dGhvcmVkSGludHNDb250cm9sbGVyXy5maW5pc2hIaW50cyhyZXNwb25zZSk7XG59O1xuXG5TdHVkaW9BcHAucHJvdG90eXBlLnNob3dJbnN0cnVjdGlvbnNfID0gZnVuY3Rpb24obGV2ZWwsIGF1dG9DbG9zZSwgc2hvd0hpbnRzKSB7XG4gIHZhciBpbnN0cnVjdGlvbnNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIHJlbmRlcmVkTWFya2Rvd247XG4gIHZhciBoZWFkZXJFbGVtZW50O1xuXG4gIHZhciBwdXp6bGVUaXRsZSA9IG1zZy5wdXp6bGVUaXRsZSh7XG4gICAgc3RhZ2VfdG90YWw6IGxldmVsLnN0YWdlX3RvdGFsLFxuICAgIHB1enpsZV9udW1iZXI6IGxldmVsLnB1enpsZV9udW1iZXJcbiAgfSk7XG5cbiAgdmFyIG1hcmtkb3duTW9kZSA9IHdpbmRvdy5tYXJrZWQgJiYgbGV2ZWwubWFya2Rvd25JbnN0cnVjdGlvbnMgJiYgdGhpcy5MT0NBTEUgPT09IEVOR0xJU0hfTE9DQUxFO1xuXG4gIGlmIChtYXJrZG93bk1vZGUpIHtcbiAgICB2YXIgbWFya2Rvd25XaXRoSW1hZ2VzID0gdGhpcy5zdWJzdGl0dXRlSW5zdHJ1Y3Rpb25JbWFnZXMobGV2ZWwubWFya2Rvd25JbnN0cnVjdGlvbnMpO1xuICAgIHJlbmRlcmVkTWFya2Rvd24gPSBtYXJrZWQobWFya2Rvd25XaXRoSW1hZ2VzKTtcbiAgICBpbnN0cnVjdGlvbnNEaXYuY2xhc3NOYW1lICs9ICcgbWFya2Rvd24taW5zdHJ1Y3Rpb25zLWNvbnRhaW5lcic7XG4gICAgaGVhZGVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gxJyk7XG4gICAgaGVhZGVyRWxlbWVudC5jbGFzc05hbWUgPSAnbWFya2Rvd24tbGV2ZWwtaGVhZGVyLXRleHQgZGlhbG9nLXRpdGxlJztcbiAgICBoZWFkZXJFbGVtZW50LmlubmVySFRNTCA9IHB1enpsZVRpdGxlO1xuICAgIGlmICghdGhpcy5pY29uKSB7XG4gICAgICBoZWFkZXJFbGVtZW50LmNsYXNzTmFtZSArPSAnIG5vLW1vZGFsLWljb24nO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhdXRob3JlZEhpbnRzO1xuICBpZiAoc2hvd0hpbnRzKSB7XG4gICAgYXV0aG9yZWRIaW50cyA9IHRoaXMuYXV0aG9yZWRIaW50c0NvbnRyb2xsZXJfLmdldEhpbnRzRGlzcGxheSgpO1xuICB9XG5cbiAgdmFyIGluc3RydWN0aW9uc0NvbnRlbnQgPSBSZWFjdC5jcmVhdGVFbGVtZW50KEluc3RydWN0aW9ucywge1xuICAgIHB1enpsZVRpdGxlOiBwdXp6bGVUaXRsZSxcbiAgICBpbnN0cnVjdGlvbnM6IHRoaXMuc3Vic3RpdHV0ZUluc3RydWN0aW9uSW1hZ2VzKGxldmVsLmluc3RydWN0aW9ucyksXG4gICAgaW5zdHJ1Y3Rpb25zMjogdGhpcy5zdWJzdGl0dXRlSW5zdHJ1Y3Rpb25JbWFnZXMobGV2ZWwuaW5zdHJ1Y3Rpb25zMiksXG4gICAgcmVuZGVyZWRNYXJrZG93bjogcmVuZGVyZWRNYXJrZG93bixcbiAgICBtYXJrZG93bkNsYXNzaWNNYXJnaW5zOiBsZXZlbC5tYXJrZG93bkluc3RydWN0aW9uc1dpdGhDbGFzc2ljTWFyZ2lucyxcbiAgICBhbmlHaWZVUkw6IGxldmVsLmFuaUdpZlVSTCxcbiAgICBhdXRob3JlZEhpbnRzOiBhdXRob3JlZEhpbnRzXG4gIH0pO1xuXG4gIC8vIENyZWF0ZSBhIGRpdiB0byBldmVudHVhbGx5IGhvbGQgdGhpcyBjb250ZW50LCBhbmQgYWRkIGl0IHRvIHRoZVxuICAvLyBvdmVyYWxsIGNvbnRhaW5lci4gV2UgZG9uJ3Qgd2FudCB0byByZW5kZXIgZGlyZWN0bHkgaW50byB0aGVcbiAgLy8gY29udGFpbmVyIGp1c3QgeWV0LCBiZWNhdXNlIG91ciBSZWFjdCBjb21wb25lbnQgY291bGQgY29udGFpbiBzb21lXG4gIC8vIGVsZW1lbnRzIHRoYXQgZG9uJ3Qgd2FudCB0byBiZSByZW5kZXJlZCB1bnRpbCB0aGV5IGFyZSBpbiB0aGUgRE9NXG4gIHZhciBpbnN0cnVjdGlvbnNSZWFjdENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBpbnN0cnVjdGlvbnNSZWFjdENvbnRhaW5lci5jbGFzc05hbWU9J2luc3RydWN0aW9ucy1jb250YWluZXInO1xuICBpbnN0cnVjdGlvbnNEaXYuYXBwZW5kQ2hpbGQoaW5zdHJ1Y3Rpb25zUmVhY3RDb250YWluZXIpO1xuXG4gIHZhciBidXR0b25zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGJ1dHRvbnMuaW5uZXJIVE1MID0gcmVxdWlyZSgnLi90ZW1wbGF0ZXMvYnV0dG9ucy5odG1sLmVqcycpKHtcbiAgICBkYXRhOiB7XG4gICAgICBvazogdHJ1ZVxuICAgIH1cbiAgfSk7XG5cbiAgaW5zdHJ1Y3Rpb25zRGl2LmFwcGVuZENoaWxkKGJ1dHRvbnMpO1xuXG4gIC8vIElmIHRoZXJlIGlzIGFuIGluc3RydWN0aW9ucyBibG9jayBvbiB0aGUgc2NyZWVuLCB3ZSB3YW50IHRoZSBpbnN0cnVjdGlvbnMgZGlhbG9nIHRvXG4gIC8vIHNocmluayBkb3duIHRvIHRoYXQgaW5zdHJ1Y3Rpb25zIGJsb2NrIHdoZW4gaXQncyBkaXNtaXNzZWQuXG4gIC8vIFdlIHRoZW4gd2FudCB0byBmbGFzaCB0aGUgaW5zdHJ1Y3Rpb25zIGJsb2NrLlxuICB2YXIgaGlkZU9wdGlvbnMgPSBudWxsO1xuICB2YXIgZW5kVGFyZ2V0U2VsZWN0b3IgPSBcIiNidWJibGVcIjtcblxuICBpZiAoJChlbmRUYXJnZXRTZWxlY3RvcikubGVuZ3RoKSB7XG4gICAgaGlkZU9wdGlvbnMgPSB7fTtcbiAgICBoaWRlT3B0aW9ucy5lbmRUYXJnZXQgPSBlbmRUYXJnZXRTZWxlY3RvcjtcbiAgfVxuXG4gIHZhciBoaWRlRm4gPSBfLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgLy8gTW9tZW50YXJpbHkgZmxhc2ggdGhlIGluc3RydWN0aW9uIGJsb2NrIHdoaXRlIHRoZW4gYmFjayB0byByZWd1bGFyLlxuICAgIGlmICgkKGVuZFRhcmdldFNlbGVjdG9yKS5sZW5ndGgpIHtcbiAgICAgICQoZW5kVGFyZ2V0U2VsZWN0b3IpLmNzcyh7XCJiYWNrZ3JvdW5kLWNvbG9yXCI6XCJyZ2JhKDI1NSwyNTUsMjU1LDEpXCJ9KVxuICAgICAgICAuZGVsYXkoNTAwKVxuICAgICAgICAuYW5pbWF0ZSh7XCJiYWNrZ3JvdW5kLWNvbG9yXCI6XCJyZ2JhKDAsMCwwLDApXCJ9LDEwMDApO1xuICAgIH1cbiAgICAvLyBTZXQgZm9jdXMgdG8gYWNlIGVkaXRvciB3aGVuIGluc3RydWN0aW9ucyBjbG9zZTpcbiAgICBpZiAodGhpcy5lZGl0Q29kZSAmJiB0aGlzLmVkaXRvciAmJiAhdGhpcy5lZGl0b3IuY3VycmVudGx5VXNpbmdCbG9ja3MpIHtcbiAgICAgIHRoaXMuZWRpdG9yLmFjZUVkaXRvci5mb2N1cygpO1xuICAgIH1cblxuICAgIC8vIEZpcmUgYSBjdXN0b20gZXZlbnQgb24gdGhlIGRvY3VtZW50IHNvIHRoYXQgb3RoZXIgY29kZSBjYW4gcmVzcG9uZFxuICAgIC8vIHRvIGluc3RydWN0aW9ucyBiZWluZyBjbG9zZWQuXG4gICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KCdpbnN0cnVjdGlvbnNIaWRkZW4nLCB0cnVlLCB0cnVlKTtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfSwgdGhpcyk7XG5cbiAgdGhpcy5pbnN0cnVjdGlvbnNEaWFsb2cgPSB0aGlzLmNyZWF0ZU1vZGFsRGlhbG9nKHtcbiAgICBtYXJrZG93bk1vZGU6IG1hcmtkb3duTW9kZSxcbiAgICBjb250ZW50RGl2OiBpbnN0cnVjdGlvbnNEaXYsXG4gICAgaWNvbjogdGhpcy5pY29uLFxuICAgIGRlZmF1bHRCdG5TZWxlY3RvcjogJyNvay1idXR0b24nLFxuICAgIG9uSGlkZGVuOiBoaWRlRm4sXG4gICAgc2Nyb2xsQ29udGVudDogdHJ1ZSxcbiAgICBzY3JvbGxhYmxlU2VsZWN0b3I6IFwiLmluc3RydWN0aW9ucy1jb250YWluZXJcIixcbiAgICBoZWFkZXI6IGhlYWRlckVsZW1lbnRcbiAgfSk7XG5cbiAgLy8gTm93IHRoYXQgb3VyIGVsZW1lbnRzIGFyZSBndWFyYW50ZWVkIHRvIGJlIGluIHRoZSBET00sIHdlIGNhblxuICAvLyByZW5kZXIgaW4gb3VyIHJlYWN0IGNvbXBvbmVudHNcbiAgJCh0aGlzLmluc3RydWN0aW9uc0RpYWxvZy5kaXYpLm9uKCdzaG93LmJzLm1vZGFsJywgZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0RE9NLnJlbmRlcihpbnN0cnVjdGlvbnNDb250ZW50LCBpbnN0cnVjdGlvbnNSZWFjdENvbnRhaW5lcik7XG4gIH0pO1xuXG4gIGlmIChhdXRvQ2xvc2UpIHtcbiAgICBzZXRUaW1lb3V0KF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zRGlhbG9nLmhpZGUoKTtcbiAgICB9LCB0aGlzKSwgMzIwMDApO1xuICB9XG5cbiAgdmFyIG9rYXlCdXR0b24gPSBidXR0b25zLnF1ZXJ5U2VsZWN0b3IoJyNvay1idXR0b24nKTtcbiAgaWYgKG9rYXlCdXR0b24pIHtcbiAgICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KG9rYXlCdXR0b24sIF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmluc3RydWN0aW9uc0RpYWxvZykge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9uc0RpYWxvZy5oaWRlKCk7XG4gICAgICB9XG4gICAgfSwgdGhpcykpO1xuICB9XG5cbiAgdGhpcy5pbnN0cnVjdGlvbnNEaWFsb2cuc2hvdyh7aGlkZU9wdGlvbnM6IGhpZGVPcHRpb25zfSk7XG5cbiAgaWYgKHJlbmRlcmVkTWFya2Rvd24pIHtcbiAgICAvLyBwcm9jZXNzIDxkZXRhaWxzPiB0YWdzIHdpdGggcG9seWZpbGwgalF1ZXJ5IHBsdWdpblxuICAgICQoJ2RldGFpbHMnKS5kZXRhaWxzKCk7XG4gIH1cblxuICAvLyBGaXJlIGEgY3VzdG9tIGV2ZW50IG9uIHRoZSBkb2N1bWVudCBzbyB0aGF0IG90aGVyIGNvZGUgY2FuIHJlc3BvbmRcbiAgLy8gdG8gaW5zdHJ1Y3Rpb25zIGJlaW5nIHNob3duLlxuICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgZXZlbnQuaW5pdEV2ZW50KCdpbnN0cnVjdGlvbnNTaG93bicsIHRydWUsIHRydWUpO1xuICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn07XG5cbi8qKlxuKiAgUmVzaXplcyB0aGUgYmxvY2tseSB3b3Jrc3BhY2UuXG4qL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5vblJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgd29ya3NwYWNlV2lkdGggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29kZVdvcmtzcGFjZScpLmNsaWVudFdpZHRoO1xuXG4gIC8vIEtlZXAgYmxvY2tzIHN0YXRpYyByZWxhdGl2ZSB0byB0aGUgcmlnaHQgZWRnZSBpbiBSVEwgbW9kZVxuICBpZiAodGhpcy5pc1VzaW5nQmxvY2tseSgpICYmIEJsb2NrbHkuUlRMKSB7XG4gICAgaWYgKHRoaXMubGFzdFdvcmtzcGFjZVdpZHRoICYmICh0aGlzLmxhc3RXb3Jrc3BhY2VXaWR0aCAhPT0gd29ya3NwYWNlV2lkdGgpKSB7XG4gICAgICB2YXIgYmxvY2tPZmZzZXQgPSB3b3Jrc3BhY2VXaWR0aCAtIHRoaXMubGFzdFdvcmtzcGFjZVdpZHRoO1xuICAgICAgQmxvY2tseS5tYWluQmxvY2tTcGFjZS5nZXRUb3BCbG9ja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0b3BCbG9jaykge1xuICAgICAgICB0b3BCbG9jay5tb3ZlQnkoYmxvY2tPZmZzZXQsIDApO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHRoaXMubGFzdFdvcmtzcGFjZVdpZHRoID0gd29ya3NwYWNlV2lkdGg7XG5cbiAgLy8gRHJvcGxldCB0b29sYm94IHdpZHRoIHZhcmllcyBhcyB0aGUgd2luZG93IHNpemUgY2hhbmdlcywgc28gcmVmcmVzaDpcbiAgdGhpcy5yZXNpemVUb29sYm94SGVhZGVyKCk7XG5cbiAgLy8gQ29udGVudCBiZWxvdyB2aXN1YWxpemF0aW9uIGlzIGEgcmVzaXppbmcgc2Nyb2xsIGFyZWEgaW4gcGlubmVkIG1vZGVcbiAgb25SZXNpemVTbWFsbEZvb3RlcigpO1xufTtcblxuLyoqXG4gKiBSZXNpemVzIHRoZSBjb250ZW50IGFyZWEgYmVsb3cgdGhlIHZpc3VhbGl6YXRpb24gaW4gcGlubmVkICh2aWV3cG9ydCBoZWlnaHQpXG4gKiB2aWV3IG1vZGUuXG4gKi9cbmZ1bmN0aW9uIHJlc2l6ZVBpbm5lZEJlbG93VmlzdWFsaXphdGlvbkFyZWEoKSB7XG4gIHZhciBwaW5uZWRCZWxvd1Zpc3VhbGl6YXRpb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgJyN2aXN1YWxpemF0aW9uQ29sdW1uLnBpbl9ib3R0b20gI2JlbG93VmlzdWFsaXphdGlvbicpO1xuICBpZiAoIXBpbm5lZEJlbG93VmlzdWFsaXphdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwbGF5U3BhY2VIZWFkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGxheVNwYWNlSGVhZGVyJyk7XG4gIHZhciB2aXN1YWxpemF0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Zpc3VhbGl6YXRpb24nKTtcbiAgdmFyIGdhbWVCdXR0b25zID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2dhbWVCdXR0b25zJyk7XG4gIHZhciBzbWFsbEZvb3RlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwYWdlLXNtYWxsLWZvb3RlciAuc21hbGwtZm9vdGVyLWJhc2UnKTtcblxuICB2YXIgdG9wID0gMDtcbiAgaWYgKHBsYXlTcGFjZUhlYWRlcikge1xuICAgIHRvcCArPSAkKHBsYXlTcGFjZUhlYWRlcikub3V0ZXJIZWlnaHQodHJ1ZSk7XG4gIH1cblxuICBpZiAodmlzdWFsaXphdGlvbikge1xuICAgIHRvcCArPSAkKHZpc3VhbGl6YXRpb24pLm91dGVySGVpZ2h0KHRydWUpO1xuICB9XG5cbiAgaWYgKGdhbWVCdXR0b25zKSB7XG4gICAgdG9wICs9ICQoZ2FtZUJ1dHRvbnMpLm91dGVySGVpZ2h0KHRydWUpO1xuICB9XG5cbiAgdmFyIGJvdHRvbSA9IDA7XG4gIGlmIChzbWFsbEZvb3Rlcikge1xuICAgIHZhciBjb2RlQXBwID0gJCgnI2NvZGVBcHAnKTtcbiAgICBib3R0b20gKz0gJChzbWFsbEZvb3Rlcikub3V0ZXJIZWlnaHQodHJ1ZSk7XG4gICAgLy8gRm9vdGVyIGlzIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCwgbm90IGNvZGVBcHAsIHNvIHdlIG5lZWQgdG9cbiAgICAvLyByZW1vdmUgdGhlIGNvZGVBcHAgYm90dG9tIG9mZnNldCB0byBnZXQgdGhlIGNvcnJlY3QgbWFyZ2luLlxuICAgIGJvdHRvbSAtPSBwYXJzZUludChjb2RlQXBwLmNzcygnYm90dG9tJyksIDEwKTtcbiAgfVxuXG4gIHBpbm5lZEJlbG93VmlzdWFsaXphdGlvbi5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuICBwaW5uZWRCZWxvd1Zpc3VhbGl6YXRpb24uc3R5bGUuYm90dG9tID0gYm90dG9tICsgJ3B4Jztcbn1cblxuLyoqXG4gKiBEZWJvdW5jZWQgb25SZXNpemUgb3BlcmF0aW9ucyB0aGF0IHVwZGF0ZSB0aGUgbGF5b3V0IHRvIHN1cHBvcnQgc2l6aW5nXG4gKiB0byB2aWV3cG9ydCBoZWlnaHQgYW5kIHVzaW5nIHRoZSBzbWFsbCBmb290ZXIuXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cbnZhciBvblJlc2l6ZVNtYWxsRm9vdGVyID0gXy5kZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gIHJlc2l6ZVBpbm5lZEJlbG93VmlzdWFsaXphdGlvbkFyZWEoKTtcbn0sIDEwKTtcblxuU3R1ZGlvQXBwLnByb3RvdHlwZS5vbk1vdXNlRG93blZpelJlc2l6ZUJhciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAvLyBXaGVuIHdlIHNlZSBhIG1vdXNlIGRvd24gaW4gdGhlIHJlc2l6ZSBiYXIsIHN0YXJ0IHRyYWNraW5nIG1vdXNlIG1vdmVzOlxuXG4gIGlmICghdGhpcy5vbk1vdXNlTW92ZUJvdW5kSGFuZGxlcikge1xuICAgIHRoaXMub25Nb3VzZU1vdmVCb3VuZEhhbmRsZXIgPSBfLmJpbmQodGhpcy5vbk1vdXNlTW92ZVZpelJlc2l6ZUJhciwgdGhpcyk7XG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlQm91bmRIYW5kbGVyKTtcbiAgICB0aGlzLm1vdXNlTW92ZVRvdWNoRXZlbnROYW1lID0gZG9tLmdldFRvdWNoRXZlbnROYW1lKCdtb3VzZW1vdmUnKTtcbiAgICBpZiAodGhpcy5tb3VzZU1vdmVUb3VjaEV2ZW50TmFtZSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKHRoaXMubW91c2VNb3ZlVG91Y2hFdmVudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk1vdXNlTW92ZUJvdW5kSGFuZGxlcik7XG4gICAgfVxuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm1TY2FsZVRvQ2hpbGRyZW4oZWxlbWVudCwgc2NhbGUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgYXBwbHlUcmFuc2Zvcm1TY2FsZShlbGVtZW50LmNoaWxkcmVuW2ldLCBzY2FsZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtU2NhbGUoZWxlbWVudCwgc2NhbGUpIHtcbiAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBzY2FsZTtcbiAgZWxlbWVudC5zdHlsZS5tc1RyYW5zZm9ybSA9IHNjYWxlO1xuICBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHNjYWxlO1xufVxuZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm1PcmlnaW4oZWxlbWVudCwgb3JpZ2luKSB7XG4gIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xuICBlbGVtZW50LnN0eWxlLm1zVHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xuICBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9IG9yaWdpbjtcbn1cblxuLyoqXG4qICBIYW5kbGUgbW91c2UgbW92ZXMgd2hpbGUgZHJhZ2dpbmcgdGhlIHZpc3VhbGl6YXRpb24gcmVzaXplIGJhci4gV2Ugc2V0XG4qICBzdHlsZXMgb24gZWFjaCBvZiB0aGUgZWxlbWVudHMgZGlyZWN0bHksIG92ZXJyaWRpbmcgdGhlIG5vcm1hbCByZXNwb25zaXZlXG4qICBjbGFzc2VzIHRoYXQgd291bGQgdHlwaWNhbGx5IGFkanVzdCB3aWR0aCBhbmQgc2NhbGUuXG4qL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5vbk1vdXNlTW92ZVZpelJlc2l6ZUJhciA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgdmlzdWFsaXphdGlvblJlc2l6ZUJhciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aXN1YWxpemF0aW9uUmVzaXplQmFyJyk7XG5cbiAgdmFyIHJlY3QgPSB2aXN1YWxpemF0aW9uUmVzaXplQmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgb2Zmc2V0O1xuICB2YXIgbmV3Vml6V2lkdGg7XG4gIGlmICh0aGlzLmlzUnRsKCkpIHtcbiAgICBvZmZzZXQgPSB3aW5kb3cuaW5uZXJXaWR0aCAtXG4gICAgICAod2luZG93LnBhZ2VYT2Zmc2V0ICsgcmVjdC5sZWZ0ICsgKHJlY3Qud2lkdGggLyAyKSkgLVxuICAgICAgcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodmlzdWFsaXphdGlvblJlc2l6ZUJhcikucmlnaHQsIDEwKTtcbiAgICBuZXdWaXpXaWR0aCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtIGV2ZW50LnBhZ2VYKSAtIG9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXQgPSB3aW5kb3cucGFnZVhPZmZzZXQgKyByZWN0LmxlZnQgKyAocmVjdC53aWR0aCAvIDIpIC1cbiAgICAgIHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHZpc3VhbGl6YXRpb25SZXNpemVCYXIpLmxlZnQsIDEwKTtcbiAgICBuZXdWaXpXaWR0aCA9IGV2ZW50LnBhZ2VYIC0gb2Zmc2V0O1xuICB9XG4gIHRoaXMucmVzaXplVmlzdWFsaXphdGlvbihuZXdWaXpXaWR0aCk7XG59O1xuXG4vKipcbiAqIFJlc2l6ZSB0aGUgdmlzdWFsaXphdGlvbiB0byB0aGUgZ2l2ZW4gd2lkdGhcbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5yZXNpemVWaXN1YWxpemF0aW9uID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gIHZhciBjb2RlV29ya3NwYWNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvZGVXb3Jrc3BhY2UnKTtcbiAgdmFyIHZpc3VhbGl6YXRpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmlzdWFsaXphdGlvbicpO1xuICB2YXIgdmlzdWFsaXphdGlvblJlc2l6ZUJhciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aXN1YWxpemF0aW9uUmVzaXplQmFyJyk7XG4gIHZhciB2aXN1YWxpemF0aW9uQ29sdW1uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Zpc3VhbGl6YXRpb25Db2x1bW4nKTtcbiAgdmFyIHZpc3VhbGl6YXRpb25FZGl0b3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmlzdWFsaXphdGlvbkVkaXRvcicpO1xuXG4gIHZhciBvbGRWaXpXaWR0aCA9ICQodmlzdWFsaXphdGlvbkNvbHVtbikud2lkdGgoKTtcbiAgdmFyIG5ld1ZpeldpZHRoID0gTWF0aC5tYXgodGhpcy5taW5WaXN1YWxpemF0aW9uV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4odGhpcy5tYXhWaXN1YWxpemF0aW9uV2lkdGgsIHdpZHRoKSk7XG4gIHZhciBuZXdWaXpXaWR0aFN0cmluZyA9IG5ld1ZpeldpZHRoICsgJ3B4JztcbiAgdmFyIG5ld1ZpekhlaWdodFN0cmluZyA9IChuZXdWaXpXaWR0aCAvIHRoaXMudml6QXNwZWN0UmF0aW8pICsgJ3B4JztcbiAgdmFyIHZpelNpZGVCb3JkZXJXaWR0aCA9IHZpc3VhbGl6YXRpb24ub2Zmc2V0V2lkdGggLSB2aXN1YWxpemF0aW9uLmNsaWVudFdpZHRoO1xuXG4gIGlmICh0aGlzLmlzUnRsKCkpIHtcbiAgICB2aXN1YWxpemF0aW9uUmVzaXplQmFyLnN0eWxlLnJpZ2h0ID0gbmV3Vml6V2lkdGhTdHJpbmc7XG4gICAgY29kZVdvcmtzcGFjZS5zdHlsZS5yaWdodCA9IG5ld1ZpeldpZHRoU3RyaW5nO1xuICB9IGVsc2Uge1xuICAgIHZpc3VhbGl6YXRpb25SZXNpemVCYXIuc3R5bGUubGVmdCA9IG5ld1ZpeldpZHRoU3RyaW5nO1xuICAgIGNvZGVXb3Jrc3BhY2Uuc3R5bGUubGVmdCA9IG5ld1ZpeldpZHRoU3RyaW5nO1xuICB9XG4gIHZpc3VhbGl6YXRpb25SZXNpemVCYXIuc3R5bGUubGluZUhlaWdodCA9IG5ld1ZpekhlaWdodFN0cmluZztcbiAgLy8gQWRkIGV4dHJhIHdpZHRoIHRvIHZpc3VhbGl6YXRpb25Db2x1bW4gaWYgdmlzdWFsaXphdGlvbiBoYXMgYSBib3JkZXI6XG4gIHZpc3VhbGl6YXRpb25Db2x1bW4uc3R5bGUubWF4V2lkdGggPSAobmV3Vml6V2lkdGggKyB2aXpTaWRlQm9yZGVyV2lkdGgpICsgJ3B4JztcbiAgdmlzdWFsaXphdGlvbi5zdHlsZS5tYXhXaWR0aCA9IG5ld1ZpeldpZHRoU3RyaW5nO1xuICB2aXN1YWxpemF0aW9uLnN0eWxlLm1heEhlaWdodCA9IG5ld1ZpekhlaWdodFN0cmluZztcblxuICAvLyBXZSBkb24ndCBnZXQgdGhlIGJlbmVmaXRzIG9mIG91ciByZXNwb25zaXZlIHN0eWxpbmcsIHNvIHNldCBoZWlnaHRcbiAgLy8gZXhwbGljaXRseVxuICBpZiAoIXV0aWxzLmJyb3dzZXJTdXBwb3J0c0Nzc01lZGlhKCkpIHtcbiAgICB2aXN1YWxpemF0aW9uLnN0eWxlLmhlaWdodCA9IG5ld1ZpekhlaWdodFN0cmluZztcbiAgICB2aXN1YWxpemF0aW9uLnN0eWxlLndpZHRoID0gbmV3Vml6V2lkdGhTdHJpbmc7XG4gIH1cbiAgdmFyIHNjYWxlID0gKG5ld1ZpeldpZHRoIC8gdGhpcy5uYXRpdmVWaXpXaWR0aCk7XG5cbiAgYXBwbHlUcmFuc2Zvcm1TY2FsZVRvQ2hpbGRyZW4odmlzdWFsaXphdGlvbiwgJ3NjYWxlKCcgKyBzY2FsZSArICcpJyk7XG4gIGlmICh2aXN1YWxpemF0aW9uRWRpdG9yKSB7XG4gICAgdmlzdWFsaXphdGlvbkVkaXRvci5zdHlsZS5tYXJnaW5MZWZ0ID0gbmV3Vml6V2lkdGhTdHJpbmc7XG4gIH1cblxuICBpZiAob2xkVml6V2lkdGggPCAyMzAgJiYgbmV3Vml6V2lkdGggPj0gMjMwKSB7XG4gICAgJCgnI3NvZnQtYnV0dG9ucycpLnJlbW92ZUNsYXNzKCdzb2Z0LWJ1dHRvbnMtY29tcGFjdCcpO1xuICB9IGVsc2UgaWYgKG9sZFZpeldpZHRoID4gMjMwICYmIG5ld1ZpeldpZHRoIDw9IDIzMCkge1xuICAgICQoJyNzb2Z0LWJ1dHRvbnMnKS5hZGRDbGFzcygnc29mdC1idXR0b25zLWNvbXBhY3QnKTtcbiAgfVxuXG4gIHZhciBzbWFsbEZvb3RlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwYWdlLXNtYWxsLWZvb3RlciAuc21hbGwtZm9vdGVyLWJhc2UnKTtcbiAgaWYgKHNtYWxsRm9vdGVyKSB7XG4gICAgc21hbGxGb290ZXIuc3R5bGUubWF4V2lkdGggPSBuZXdWaXpXaWR0aFN0cmluZztcblxuICAgIC8vIElmIHRoZSBzbWFsbCBwcmludCBhbmQgbGFuZ3VhZ2Ugc2VsZWN0b3IgYXJlIG9uIHRoZSBzYW1lIGxpbmUsXG4gICAgLy8gdGhlIHNtYWxsIHByaW50IHNob3VsZCBmbG9hdCByaWdodC4gIE90aGVyd2lzZSwgaXQgc2hvdWxkIGZsb2F0IGxlZnQuXG4gICAgdmFyIGxhbmd1YWdlU2VsZWN0b3IgPSBzbWFsbEZvb3Rlci5xdWVyeVNlbGVjdG9yKCdmb3JtJyk7XG4gICAgdmFyIHNtYWxsUHJpbnQgPSBzbWFsbEZvb3Rlci5xdWVyeVNlbGVjdG9yKCdzbWFsbCcpO1xuICAgIGlmIChsYW5ndWFnZVNlbGVjdG9yICYmIHNtYWxsUHJpbnQub2Zmc2V0VG9wID09PSBsYW5ndWFnZVNlbGVjdG9yLm9mZnNldFRvcCkge1xuICAgICAgc21hbGxQcmludC5zdHlsZS5mbG9hdCA9ICdyaWdodCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNtYWxsUHJpbnQuc3R5bGUuZmxvYXQgPSAnbGVmdCc7XG4gICAgfVxuICB9XG5cbiAgLy8gRmlyZSByZXNpemUgc28gYmxvY2tseSBhbmQgZHJvcGxldCBoYW5kbGUgdGhpcyB0eXBlIG9mIHJlc2l6ZSBwcm9wZXJseTpcbiAgdXRpbHMuZmlyZVJlc2l6ZUV2ZW50KCk7XG59O1xuXG5TdHVkaW9BcHAucHJvdG90eXBlLm9uTW91c2VVcFZpelJlc2l6ZUJhciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAvLyBJZiB3ZSBoYXZlIGJlZW4gdHJhY2tpbmcgbW91c2UgbW92ZXMsIHJlbW92ZSB0aGUgaGFuZGxlciBub3c6XG4gIGlmICh0aGlzLm9uTW91c2VNb3ZlQm91bmRIYW5kbGVyKSB7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlQm91bmRIYW5kbGVyKTtcbiAgICBpZiAodGhpcy5tb3VzZU1vdmVUb3VjaEV2ZW50TmFtZSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMubW91c2VNb3ZlVG91Y2hFdmVudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk1vdXNlTW92ZUJvdW5kSGFuZGxlcik7XG4gICAgfVxuICAgIHRoaXMub25Nb3VzZU1vdmVCb3VuZEhhbmRsZXIgPSBudWxsO1xuICB9XG59O1xuXG5cbi8qKlxuKiAgVXBkYXRlcyB0aGUgd2lkdGggb2YgdGhlIHRvb2xib3gtaGVhZGVyIHRvIG1hdGNoIHRoZSB3aWR0aCBvZiB0aGUgdG9vbGJveFxuKiAgb3IgcGFsZXR0ZSBpbiB0aGUgd29ya3NwYWNlIGJlbG93IHRoZSBoZWFkZXIuXG4qL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5yZXNpemVUb29sYm94SGVhZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0b29sYm94V2lkdGggPSAwO1xuICBpZiAodGhpcy5lZGl0Q29kZSAmJiB0aGlzLmVkaXRvciAmJiB0aGlzLmVkaXRvci5wYWxldHRlRW5hYmxlZCkge1xuICAgIC8vIElmIGluIHRoZSBkcm9wbGV0IGVkaXRvciwgc2V0IHRvb2xib3hXaWR0aCBiYXNlZCBvbiB0aGUgYmxvY2sgcGFsZXR0ZSB3aWR0aDpcbiAgICB2YXIgY2F0ZWdvcmllcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kcm9wbGV0LXBhbGV0dGUtd3JhcHBlcicpO1xuICAgIHRvb2xib3hXaWR0aCA9IGNhdGVnb3JpZXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gIH0gZWxzZSBpZiAodGhpcy5pc1VzaW5nQmxvY2tseSgpKSB7XG4gICAgdG9vbGJveFdpZHRoID0gQmxvY2tseS5tYWluQmxvY2tTcGFjZUVkaXRvci5nZXRUb29sYm94V2lkdGgoKTtcbiAgfVxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndG9vbGJveC1oZWFkZXInKS5zdHlsZS53aWR0aCA9IHRvb2xib3hXaWR0aCArICdweCc7XG59O1xuXG4vKipcbiogSGlnaGxpZ2h0IHRoZSBibG9jayAob3IgY2xlYXIgaGlnaGxpZ2h0aW5nKS5cbiogQHBhcmFtIHs/c3RyaW5nfSBpZCBJRCBvZiBibG9jayB0aGF0IHRyaWdnZXJlZCB0aGlzIGFjdGlvbi5cbiogQHBhcmFtIHtib29sZWFufSBzcG90bGlnaHQgT3B0aW9uYWwuICBIaWdobGlnaHQgZW50aXJlIGJsb2NrIGlmIHRydWVcbiovXG5TdHVkaW9BcHAucHJvdG90eXBlLmhpZ2hsaWdodCA9IGZ1bmN0aW9uKGlkLCBzcG90bGlnaHQpIHtcbiAgaWYgKHRoaXMuaXNVc2luZ0Jsb2NrbHkoKSkge1xuICAgIGlmIChpZCkge1xuICAgICAgdmFyIG0gPSBpZC5tYXRjaCgvXmJsb2NrX2lkXyhcXGQrKSQvKTtcbiAgICAgIGlmIChtKSB7XG4gICAgICAgIGlkID0gbVsxXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBCbG9ja2x5Lm1haW5CbG9ja1NwYWNlLmhpZ2hsaWdodEJsb2NrKGlkLCBzcG90bGlnaHQpO1xuICB9XG59O1xuXG4vKipcbiogUmVtb3ZlIGhpZ2hsaWdodGluZyBmcm9tIGFsbCBibG9ja3NcbiovXG5TdHVkaW9BcHAucHJvdG90eXBlLmNsZWFySGlnaGxpZ2h0aW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5pc1VzaW5nQmxvY2tseSgpKSB7XG4gICAgdGhpcy5oaWdobGlnaHQobnVsbCk7XG4gIH0gZWxzZSBpZiAodGhpcy5lZGl0Q29kZSAmJiB0aGlzLmVkaXRvcikge1xuICAgIC8vIENsZWFyIGV2ZXJ5dGhpbmcgKHN0ZXAgaGlnaGxpZ2h0aW5nLCBlcnJvcnMsIGV0Yy4pXG4gICAgY29kZWdlbi5jbGVhckRyb3BsZXRBY2VIaWdobGlnaHRpbmcodGhpcy5lZGl0b3IsIHRydWUpO1xuICB9XG59O1xuXG4vKipcbiogRGlzcGxheSBmZWVkYmFjayBiYXNlZCBvbiB0ZXN0IHJlc3VsdHMuICBUaGUgdGVzdCByZXN1bHRzIG11c3QgYmVcbiogZXhwbGljaXRseSBwcm92aWRlZC5cbiogQHBhcmFtIHt7ZmVlZGJhY2tUeXBlOiBudW1iZXJ9fSBUZXN0IHJlc3VsdHMgKGEgY29uc3RhbnQgcHJvcGVydHkgb2ZcbiogICAgIHRoaXMuVGVzdFJlc3VsdHMpLlxuKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuZGlzcGxheUZlZWRiYWNrID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zLkRpYWxvZyA9IHRoaXMuRGlhbG9nO1xuICBvcHRpb25zLm9uQ29udGludWUgPSB0aGlzLm9uQ29udGludWU7XG4gIG9wdGlvbnMuYmFja1RvUHJldmlvdXNMZXZlbCA9IHRoaXMuYmFja1RvUHJldmlvdXNMZXZlbDtcbiAgb3B0aW9ucy5zZW5kVG9QaG9uZSA9IHRoaXMuc2VuZFRvUGhvbmU7XG5cbiAgLy8gU3BlY2lhbCB0ZXN0IGNvZGUgZm9yIGVkaXQgYmxvY2tzLlxuICBpZiAob3B0aW9ucy5sZXZlbC5lZGl0X2Jsb2Nrcykge1xuICAgIG9wdGlvbnMuZmVlZGJhY2tUeXBlID0gdGhpcy5UZXN0UmVzdWx0cy5FRElUX0JMT0NLUztcbiAgfVxuXG4gIHRoaXMuZmVlZGJhY2tfLmRpc3BsYXlGZWVkYmFjayhvcHRpb25zLCB0aGlzLnJlcXVpcmVkQmxvY2tzXyxcbiAgICAgIHRoaXMubWF4UmVxdWlyZWRCbG9ja3NUb0ZsYWdfLCB0aGlzLnJlY29tbWVuZGVkQmxvY2tzXyxcbiAgICAgIHRoaXMubWF4UmVjb21tZW5kZWRCbG9ja3NUb0ZsYWdfKTtcbn07XG5cbi8qKlxuICogUnVucyB0aGUgdGVzdHMgYW5kIHJldHVybnMgcmVzdWx0cy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbGV2ZWxDb21wbGV0ZSBXYXMgdGhlIGxldmVsIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHk/XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYXBwcm9wcmlhdGUgcHJvcGVydHkgb2YgVGVzdFJlc3VsdHMuXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuZ2V0VGVzdFJlc3VsdHMgPSBmdW5jdGlvbihsZXZlbENvbXBsZXRlLCBvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmZlZWRiYWNrXy5nZXRUZXN0UmVzdWx0cyhsZXZlbENvbXBsZXRlLFxuICAgICAgdGhpcy5yZXF1aXJlZEJsb2Nrc18sIHRoaXMucmVjb21tZW5kZWRCbG9ja3NfLCB0aGlzLmNoZWNrRm9yRW1wdHlCbG9ja3NfLCBvcHRpb25zKTtcbn07XG5cbi8vIEJ1aWxkcyB0aGUgZG9tIHRvIGdldCBtb3JlIGluZm8gZnJvbSB0aGUgdXNlci4gQWZ0ZXIgdXNlciBlbnRlcnMgaW5mb1xuLy8gYW5kIGNsaWNrIFwiY3JlYXRlIGxldmVsXCIgb25BdHRlbXB0Q2FsbGJhY2sgaXMgY2FsbGVkIHRvIGRlbGl2ZXIgdGhlIGluZm9cbi8vIHRvIHRoZSBzZXJ2ZXIuXG5TdHVkaW9BcHAucHJvdG90eXBlLmJ1aWxkZXJGb3JtXyA9IGZ1bmN0aW9uKG9uQXR0ZW1wdENhbGxiYWNrKSB7XG4gIHZhciBidWlsZGVyRGV0YWlscyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBidWlsZGVyRGV0YWlscy5pbm5lckhUTUwgPSByZXF1aXJlKCcuL3RlbXBsYXRlcy9idWlsZGVyLmh0bWwuZWpzJykoKTtcbiAgdmFyIGRpYWxvZyA9IHRoaXMuY3JlYXRlTW9kYWxEaWFsb2coe1xuICAgIGNvbnRlbnREaXY6IGJ1aWxkZXJEZXRhaWxzLFxuICAgIGljb246IHRoaXMuaWNvblxuICB9KTtcbiAgdmFyIGNyZWF0ZUxldmVsQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NyZWF0ZS1sZXZlbC1idXR0b24nKTtcbiAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChjcmVhdGVMZXZlbEJ1dHRvbiwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluc3RydWN0aW9ucyA9IGJ1aWxkZXJEZXRhaWxzLnF1ZXJ5U2VsZWN0b3IoJ1tuYW1lPVwiaW5zdHJ1Y3Rpb25zXCJdJykudmFsdWU7XG4gICAgdmFyIG5hbWUgPSBidWlsZGVyRGV0YWlscy5xdWVyeVNlbGVjdG9yKCdbbmFtZT1cImxldmVsX25hbWVcIl0nKS52YWx1ZTtcbiAgICB2YXIgcXVlcnkgPSB1cmwucGFyc2Uod2luZG93LmxvY2F0aW9uLmhyZWYsIHRydWUpLnF1ZXJ5O1xuICAgIG9uQXR0ZW1wdENhbGxiYWNrKHV0aWxzLmV4dGVuZCh7XG4gICAgICBcImluc3RydWN0aW9uc1wiOiBpbnN0cnVjdGlvbnMsXG4gICAgICBcIm5hbWVcIjogbmFtZVxuICAgIH0sIHF1ZXJ5KSk7XG4gIH0pO1xuXG4gIGRpYWxvZy5zaG93KHsgYmFja2Ryb3A6ICdzdGF0aWMnIH0pO1xufTtcblxuLyoqXG4qIFJlcG9ydCBiYWNrIHRvIHRoZSBzZXJ2ZXIsIGlmIGF2YWlsYWJsZS5cbiogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBwYXJhbWV0ZXIgYmxvY2sgd2hpY2ggaW5jbHVkZXM6XG4qIHtzdHJpbmd9IGFwcCBUaGUgbmFtZSBvZiB0aGUgYXBwbGljYXRpb24uXG4qIHtudW1iZXJ9IGlkIEEgdW5pcXVlIGlkZW50aWZpZXIgZ2VuZXJhdGVkIHdoZW4gdGhlIHBhZ2Ugd2FzIGxvYWRlZC5cbioge3N0cmluZ30gbGV2ZWwgVGhlIElEIG9mIHRoZSBjdXJyZW50IGxldmVsLlxuKiB7bnVtYmVyfSByZXN1bHQgQW4gaW5kaWNhdG9yIG9mIHRoZSBzdWNjZXNzIG9mIHRoZSBjb2RlLlxuKiB7bnVtYmVyfSB0ZXN0UmVzdWx0IE1vcmUgc3BlY2lmaWMgZGF0YSBvbiBzdWNjZXNzIG9yIGZhaWx1cmUgb2YgY29kZS5cbioge2Jvb2xlYW59IHN1Ym1pdHRlZCBXaGV0aGVyIHRoZSAoc3VibWl0dGFibGUpIGxldmVsIGlzIGJlaW5nIHN1Ym1pdHRlZC5cbioge3N0cmluZ30gcHJvZ3JhbSBUaGUgdXNlciBwcm9ncmFtLCB3aGljaCB3aWxsIGdldCBVUkwtZW5jb2RlZC5cbioge2Z1bmN0aW9ufSBvbkNvbXBsZXRlIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB1cG9uIGNvbXBsZXRpb24uXG4qL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5yZXBvcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIC8vIGNvcHkgZnJvbSBvcHRpb25zOiBhcHAsIGxldmVsLCByZXN1bHQsIHRlc3RSZXN1bHQsIHByb2dyYW0sIG9uQ29tcGxldGVcbiAgdmFyIHJlcG9ydCA9ICQuZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgcGFzczogdGhpcy5mZWVkYmFja18uY2FuQ29udGludWVUb05leHRMZXZlbChvcHRpb25zLnRlc3RSZXN1bHQpLFxuICAgIHRpbWU6ICgobmV3IERhdGUoKS5nZXRUaW1lKCkpIC0gdGhpcy5pbml0VGltZSksXG4gICAgYXR0ZW1wdDogdGhpcy5hdHRlbXB0cyxcbiAgICBsaW5lczogdGhpcy5mZWVkYmFja18uZ2V0TnVtQmxvY2tzVXNlZCgpLFxuICB9KTtcblxuICB0aGlzLmxhc3RUZXN0UmVzdWx0ID0gb3B0aW9ucy50ZXN0UmVzdWx0O1xuXG5cbiAgLy8gSWYgaGlkZVNvdXJjZSBpcyBlbmFibGVkLCB0aGUgdXNlciBpcyBsb29raW5nIGF0IGEgc2hhcmVkIGxldmVsIHRoYXRcbiAgLy8gdGhleSBjYW5ub3QgaGF2ZSBtb2RpZmllZC4gSW4gdGhhdCBjYXNlLCBkb24ndCByZXBvcnQgaXQgdG8gdGhlIHNlcnZpY2VcbiAgLy8gb3IgY2FsbCB0aGUgb25Db21wbGV0ZSgpIGNhbGxiYWNrIGV4cGVjdGVkLiBUaGUgYXBwIHdpbGwganVzdCBzaXRcbiAgLy8gdGhlcmUgd2l0aCB0aGUgUmVzZXQgYnV0dG9uIGFzIHRoZSBvbmx5IG9wdGlvbi5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoISh0aGlzLmhpZGVTb3VyY2UgJiYgdGhpcy5zaGFyZSkpIHtcbiAgICB2YXIgb25BdHRlbXB0Q2FsbGJhY2sgPSAoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYnVpbGRlckRldGFpbHMpIHtcbiAgICAgICAgZm9yICh2YXIgb3B0aW9uIGluIGJ1aWxkZXJEZXRhaWxzKSB7XG4gICAgICAgICAgcmVwb3J0W29wdGlvbl0gPSBidWlsZGVyRGV0YWlsc1tvcHRpb25dO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYub25BdHRlbXB0KHJlcG9ydCk7XG4gICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICAvLyBJZiB0aGlzIGlzIHRoZSBsZXZlbCBidWlsZGVyLCBnbyB0byBidWlsZGVyRm9ybSB0byBnZXQgbW9yZSBpbmZvIGZyb21cbiAgICAvLyB0aGUgbGV2ZWwgYnVpbGRlci5cbiAgICBpZiAob3B0aW9ucy5idWlsZGVyKSB7XG4gICAgICB0aGlzLmJ1aWxkZXJGb3JtXyhvbkF0dGVtcHRDYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uQXR0ZW1wdENhbGxiYWNrKCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiogQ2xpY2sgdGhlIHJlc2V0IGJ1dHRvbi4gIFJlc2V0IHRoZSBhcHBsaWNhdGlvbi5cbiovXG5TdHVkaW9BcHAucHJvdG90eXBlLnJlc2V0QnV0dG9uQ2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5vblJlc2V0UHJlc3NlZCgpO1xuICB0aGlzLnRvZ2dsZVJ1blJlc2V0KCdydW4nKTtcbiAgdGhpcy5jbGVhckhpZ2hsaWdodGluZygpO1xuICBpZiAodGhpcy5pc1VzaW5nQmxvY2tseSgpKSB7XG4gICAgQmxvY2tseS5tYWluQmxvY2tTcGFjZUVkaXRvci5zZXRFbmFibGVUb29sYm94KHRydWUpO1xuICAgIEJsb2NrbHkubWFpbkJsb2NrU3BhY2UudHJhY2VPbihmYWxzZSk7XG4gIH1cbiAgdGhpcy5yZXNldChmYWxzZSk7XG59O1xuXG4vKipcbiogQWRkIGNvdW50IG9mIGJsb2NrcyB1c2VkLlxuKi9cblN0dWRpb0FwcC5wcm90b3R5cGUudXBkYXRlQmxvY2tDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAvLyBJZiB0aGUgbnVtYmVyIG9mIGJsb2NrIHVzZWQgaXMgYmlnZ2VyIHRoYW4gdGhlIGlkZWFsIG51bWJlciBvZiBibG9ja3MsXG4gIC8vIHNldCBpdCB0byBiZSB5ZWxsb3csIG90aGVyd2lzZSwga2VlcCBpdCBhcyBibGFjay5cbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmxvY2tVc2VkJyk7XG4gIGlmICh0aGlzLklERUFMX0JMT0NLX05VTSA8IHRoaXMuZmVlZGJhY2tfLmdldE51bUNvdW50YWJsZUJsb2NrcygpKSB7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBcImJsb2NrLWNvdW50ZXItb3ZlcmZsb3dcIjtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IFwiYmxvY2stY291bnRlci1kZWZhdWx0XCI7XG4gIH1cblxuICAvLyBVcGRhdGUgbnVtYmVyIG9mIGJsb2NrcyB1c2VkLlxuICBpZiAoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJyc7ICAvLyBSZW1vdmUgZXhpc3RpbmcgY2hpbGRyZW4gb3IgdGV4dC5cbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxuICAgICAgdGhpcy5mZWVkYmFja18uZ2V0TnVtQ291bnRhYmxlQmxvY2tzKCkpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgdGhlIGlkZWFsIE51bWJlciBvZiBibG9ja3MuXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuc2V0SWRlYWxCbG9ja051bWJlcl8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWRlYWxCbG9ja051bWJlcicpO1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaWRlYWxCbG9ja051bWJlck1zZyA9IHRoaXMuSURFQUxfQkxPQ0tfTlVNID09PSBJbmZpbml0eSA/XG4gICAgbXNnLmluZmluaXR5KCkgOiB0aGlzLklERUFMX0JMT0NLX05VTTtcbiAgZWxlbWVudC5pbm5lckhUTUwgPSAnJzsgIC8vIFJlbW92ZSBleGlzdGluZyBjaGlsZHJlbiBvciB0ZXh0LlxuICBlbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxuICAgIGlkZWFsQmxvY2tOdW1iZXJNc2cpKTtcbn07XG5cblxuLyoqXG4gKlxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLmZpeFZpZXdwb3J0Rm9yU21hbGxTY3JlZW5zXyA9IGZ1bmN0aW9uICh2aWV3cG9ydCwgY29uZmlnKSB7XG4gIHZhciBkZXZpY2VXaWR0aDtcbiAgdmFyIGRlc2lyZWRXaWR0aDtcbiAgdmFyIG1pbldpZHRoO1xuICBpZiAodGhpcy5zaGFyZSAmJiBkb20uaXNNb2JpbGUoKSkge1xuICAgIHZhciBtb2JpbGVOb1BhZGRpbmdTaGFyZVdpZHRoID1cbiAgICAgIGNvbmZpZy5tb2JpbGVOb1BhZGRpbmdTaGFyZVdpZHRoIHx8IERFRkFVTFRfTU9CSUxFX05PX1BBRERJTkdfU0hBUkVfV0lEVEg7XG4gICAgLy8gZm9yIG1vYmlsZSBzaGFyaW5nLCBmYXZvciBwb3J0cmFpdCBtb2RlLCBzbyB3aWR0aCBpcyB0aGUgc2hvcnRlciBvZiB0aGUgdHdvXG4gICAgZGV2aWNlV2lkdGggPSBkZXNpcmVkV2lkdGggPSBNYXRoLm1pbihzY3JlZW4ud2lkdGgsIHNjcmVlbi5oZWlnaHQpO1xuICAgIGlmICh0aGlzLm5vUGFkZGluZyAmJiBkZXZpY2VXaWR0aCA8IE1BWF9QSE9ORV9XSURUSCkge1xuICAgICAgZGVzaXJlZFdpZHRoID0gTWF0aC5taW4oZGVzaXJlZFdpZHRoLCBtb2JpbGVOb1BhZGRpbmdTaGFyZVdpZHRoKTtcbiAgICB9XG4gICAgbWluV2lkdGggPSBtb2JpbGVOb1BhZGRpbmdTaGFyZVdpZHRoO1xuICB9IGVsc2Uge1xuICAgIC8vIGFzc3VtZSB3ZSBhcmUgaW4gbGFuZHNjYXBlIG1vZGUsIHNvIHdpZHRoIGlzIHRoZSBsb25nZXIgb2YgdGhlIHR3b1xuICAgIGRldmljZVdpZHRoID0gZGVzaXJlZFdpZHRoID0gTWF0aC5tYXgoc2NyZWVuLndpZHRoLCBzY3JlZW4uaGVpZ2h0KTtcbiAgICBtaW5XaWR0aCA9IE1JTl9XSURUSDtcbiAgfVxuICB2YXIgd2lkdGggPSBNYXRoLm1heChtaW5XaWR0aCwgZGVzaXJlZFdpZHRoKTtcbiAgdmFyIHNjYWxlID0gZGV2aWNlV2lkdGggLyB3aWR0aDtcbiAgdmFyIGNvbnRlbnQgPSBbJ3dpZHRoPScgKyB3aWR0aCxcbiAgICAnbWluaW1hbC11aScsXG4gICAgJ2luaXRpYWwtc2NhbGU9JyArIHNjYWxlLFxuICAgICdtYXhpbXVtLXNjYWxlPScgKyBzY2FsZSxcbiAgICAnbWluaW11bS1zY2FsZT0nICsgc2NhbGUsXG4gICAgJ3RhcmdldC1kZW5zaXR5RHBpPWRldmljZS1kcGknLFxuICAgICd1c2VyLXNjYWxhYmxlPW5vJ107XG4gIHZpZXdwb3J0LnNldEF0dHJpYnV0ZSgnY29udGVudCcsIGNvbnRlbnQuam9pbignLCAnKSk7XG59O1xuXG4vKipcbiAqXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuc2V0Q29uZmlnVmFsdWVzXyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdGhpcy5zaGFyZSA9IGNvbmZpZy5zaGFyZTtcbiAgdGhpcy5jZW50ZXJFbWJlZGRlZCA9IHV0aWxzLnZhbHVlT3IoY29uZmlnLmNlbnRlckVtYmVkZGVkLCB0aGlzLmNlbnRlckVtYmVkZGVkKTtcbiAgdGhpcy53aXJlZnJhbWVTaGFyZSA9IHV0aWxzLnZhbHVlT3IoY29uZmlnLndpcmVmcmFtZVNoYXJlLCB0aGlzLndpcmVmcmFtZVNoYXJlKTtcblxuICAvLyBpZiB0cnVlLCBkb250IHByb3ZpZGUgbGlua3MgdG8gc2hhcmUgb24gZmIvdHdpdHRlclxuICB0aGlzLmRpc2FibGVTb2NpYWxTaGFyZSA9IGNvbmZpZy5kaXNhYmxlU29jaWFsU2hhcmU7XG4gIHRoaXMuc2VuZFRvUGhvbmUgPSBjb25maWcuc2VuZFRvUGhvbmU7XG4gIHRoaXMubm9QYWRkaW5nID0gY29uZmlnLm5vUGFkZGluZztcblxuICAvLyBjb250cmFjdCBlZGl0b3IgcmVxdWlyZXMgbW9yZSB2ZXJ0aWNhbCBzcGFjZS4gc2V0IGhlaWdodCB0byAxMjUwIHVubGVzc1xuICAvLyBleHBsaWNpdGx5IHNwZWNpZmllZFxuICBpZiAoY29uZmlnLmxldmVsLnVzZUNvbnRyYWN0RWRpdG9yKSB7XG4gICAgY29uZmlnLmxldmVsLm1pbldvcmtzcGFjZUhlaWdodCA9IGNvbmZpZy5sZXZlbC5taW5Xb3Jrc3BhY2VIZWlnaHQgfHwgMTI1MDtcbiAgfVxuXG4gIHRoaXMuYXBwTXNnID0gY29uZmlnLmFwcE1zZztcbiAgdGhpcy5JREVBTF9CTE9DS19OVU0gPSBjb25maWcubGV2ZWwuaWRlYWwgfHwgSW5maW5pdHk7XG4gIHRoaXMuTUlOX1dPUktTUEFDRV9IRUlHSFQgPSBjb25maWcubGV2ZWwubWluV29ya3NwYWNlSGVpZ2h0IHx8IDgwMDtcbiAgdGhpcy5yZXF1aXJlZEJsb2Nrc18gPSBjb25maWcubGV2ZWwucmVxdWlyZWRCbG9ja3MgfHwgW107XG4gIHRoaXMucmVjb21tZW5kZWRCbG9ja3NfID0gY29uZmlnLmxldmVsLnJlY29tbWVuZGVkQmxvY2tzIHx8IFtdO1xuICB0aGlzLnN0YXJ0QmxvY2tzXyA9IGNvbmZpZy5sZXZlbC5sYXN0QXR0ZW1wdCB8fCBjb25maWcubGV2ZWwuc3RhcnRCbG9ja3MgfHwgJyc7XG4gIHRoaXMudml6QXNwZWN0UmF0aW8gPSBjb25maWcudml6QXNwZWN0UmF0aW8gfHwgMS4wO1xuICB0aGlzLm5hdGl2ZVZpeldpZHRoID0gY29uZmlnLm5hdGl2ZVZpeldpZHRoIHx8IHRoaXMubWF4VmlzdWFsaXphdGlvbldpZHRoO1xuXG4gIC8vIGVuYWJsZVNob3dDb2RlIGRlZmF1bHRzIHRvIHRydWUgaWYgbm90IGRlZmluZWRcbiAgdGhpcy5lbmFibGVTaG93Q29kZSA9IChjb25maWcuZW5hYmxlU2hvd0NvZGUgIT09IGZhbHNlKTtcbiAgdGhpcy5lbmFibGVTaG93TGluZXNDb3VudCA9IChjb25maWcuZW5hYmxlU2hvd0xpbmVzQ291bnQgIT09IGZhbHNlKTtcblxuICAvLyBJZiB0aGUgbGV2ZWwgaGFzIG5vIGlkZWFsIGJsb2NrIGNvdW50LCBkb24ndCBzaG93IGEgYmxvY2sgY291bnQuIElmIGl0IGRvZXNcbiAgLy8gaGF2ZSBhbiBpZGVhbCwgc2hvdyBibG9jayBjb3VudCB1bmxlc3MgZXhwbGljaXRseSBjb25maWd1cmVkIG5vdCB0by5cbiAgaWYgKGNvbmZpZy5sZXZlbCAmJiAoY29uZmlnLmxldmVsLmlkZWFsID09PSB1bmRlZmluZWQgfHwgY29uZmlnLmxldmVsLmlkZWFsID09PSBJbmZpbml0eSkpIHtcbiAgICB0aGlzLmVuYWJsZVNob3dCbG9ja0NvdW50ID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5lbmFibGVTaG93QmxvY2tDb3VudCA9IGNvbmZpZy5lbmFibGVTaG93QmxvY2tDb3VudCAhPT0gZmFsc2U7XG4gIH1cblxuICAvLyBTdG9yZSBjb25maWd1cmF0aW9uLlxuICB0aGlzLm9uQXR0ZW1wdCA9IGNvbmZpZy5vbkF0dGVtcHQgfHwgZnVuY3Rpb24gKCkge307XG4gIHRoaXMub25Db250aW51ZSA9IGNvbmZpZy5vbkNvbnRpbnVlIHx8IGZ1bmN0aW9uICgpIHt9O1xuICB0aGlzLm9uSW5pdGlhbGl6ZSA9IGNvbmZpZy5vbkluaXRpYWxpemUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLm9uSW5pdGlhbGl6ZS5iaW5kKGNvbmZpZykgOiBmdW5jdGlvbiAoKSB7fTtcbiAgdGhpcy5vblJlc2V0UHJlc3NlZCA9IGNvbmZpZy5vblJlc2V0UHJlc3NlZCB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgdGhpcy5iYWNrVG9QcmV2aW91c0xldmVsID0gY29uZmlnLmJhY2tUb1ByZXZpb3VzTGV2ZWwgfHwgZnVuY3Rpb24gKCkge307XG4gIHRoaXMuc2tpbiA9IGNvbmZpZy5za2luO1xuICB0aGlzLnNob3dJbnN0cnVjdGlvbnMgPSB0aGlzLnNob3dJbnN0cnVjdGlvbnNfLmJpbmQodGhpcywgY29uZmlnLmxldmVsLCBmYWxzZSk7XG4gIHRoaXMucG9saXNoQ29kZUhvb2sgPSBjb25maWcucG9saXNoQ29kZUhvb2s7XG59O1xuXG4vLyBPdmVyd3JpdHRlbiBieSBhcHBsYWIuXG5TdHVkaW9BcHAucHJvdG90eXBlLnJ1bkJ1dHRvbkNsaWNrV3JhcHBlciA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBpZiAod2luZG93LiQpIHtcbiAgICAkKHdpbmRvdykudHJpZ2dlcigncnVuX2J1dHRvbl9wcmVzc2VkJyk7XG4gICAgJCh3aW5kb3cpLnRyaWdnZXIoJ2FwcE1vZGVDaGFuZ2VkJyk7XG4gIH1cbiAgY2FsbGJhY2soKTtcbn07XG5cbi8qKlxuICogQmVnaW4gbW9kaWZ5aW5nIHRoZSBET00gYmFzZWQgb24gY29uZmlnLlxuICogTm90ZTogSGFzIHNpZGUgZWZmZWN0cyBvbiBjb25maWdcbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5jb25maWd1cmVEb20gPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb25maWcuY29udGFpbmVySWQpO1xuICBpZiAoIXRoaXMuZW5hYmxlU2hvd0NvZGUpIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2hvdy1jb2RlLWhlYWRlcicpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cbiAgdmFyIGNvZGVXb3Jrc3BhY2UgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignI2NvZGVXb3Jrc3BhY2UnKTtcblxuICB2YXIgcnVuQnV0dG9uID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJyNydW5CdXR0b24nKTtcbiAgdmFyIHJlc2V0QnV0dG9uID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJyNyZXNldEJ1dHRvbicpO1xuICB2YXIgcnVuQ2xpY2sgPSB0aGlzLnJ1bkJ1dHRvbkNsaWNrLmJpbmQodGhpcyk7XG4gIHZhciB0aHJvdHRsZWRSdW5DbGljayA9IF8uZGVib3VuY2UodGhpcy5ydW5CdXR0b25DbGlja1dyYXBwZXIuYmluZCh0aGlzLCBydW5DbGljayksIDI1MCwgdHJ1ZSk7XG4gIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQocnVuQnV0dG9uLCBfLmJpbmQodGhyb3R0bGVkUnVuQ2xpY2ssIHRoaXMpKTtcbiAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChyZXNldEJ1dHRvbiwgXy5iaW5kKHRoaXMucmVzZXRCdXR0b25DbGljaywgdGhpcykpO1xuXG4gIC8vIFRPRE8gKGNwaXJpY2gpOiBtYWtlIGNvbmRpdGlvbmFsIGZvciBhcHBsYWJcbiAgdmFyIGJlbG93Vml6ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JlbG93VmlzdWFsaXphdGlvbicpO1xuICB2YXIgcmVmZXJlbmNlQXJlYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZWZlcmVuY2VfYXJlYScpO1xuICBpZiAocmVmZXJlbmNlQXJlYSkge1xuICAgIGJlbG93Vml6LmFwcGVuZENoaWxkKHJlZmVyZW5jZUFyZWEpO1xuICB9XG5cbiAgdmFyIHZpc3VhbGl6YXRpb25Db2x1bW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmlzdWFsaXphdGlvbkNvbHVtbicpO1xuICB2YXIgdmlzdWFsaXphdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aXN1YWxpemF0aW9uJyk7XG5cbiAgaWYgKCFjb25maWcuaGlkZVNvdXJjZSB8fCBjb25maWcuZW1iZWQpIHtcbiAgICB2YXIgdml6SGVpZ2h0ID0gdGhpcy5NSU5fV09SS1NQQUNFX0hFSUdIVDtcbiAgICBpZiAodGhpcy5pc1VzaW5nQmxvY2tseSgpICYmIGNvbmZpZy5sZXZlbC5lZGl0X2Jsb2Nrcykge1xuICAgICAgLy8gU2V0IGEgY2xhc3Mgb24gdGhlIG1haW4gYmxvY2tseSBkaXYgc28gQ1NTIGNhbiBzdHlsZSBibG9ja3MgZGlmZmVyZW50bHlcbiAgICAgICQoY29kZVdvcmtzcGFjZSkuYWRkQ2xhc3MoJ2VkaXQnKTtcbiAgICAgIC8vIElmIGluIGxldmVsIGJ1aWxkZXIgZWRpdGluZyBibG9ja3MsIG1ha2Ugd29ya3NwYWNlIGV4dHJhIHRhbGxcbiAgICAgIHZpekhlaWdodCA9IDMwMDA7XG4gICAgICAvLyBNb2RpZnkgdGhlIGFycmFuZ2VtZW50IG9mIHRvb2xib3ggYmxvY2tzIHNvIGNhdGVnb3JpZXMgYWxpZ24gbGVmdFxuICAgICAgaWYgKGNvbmZpZy5sZXZlbC5lZGl0X2Jsb2NrcyA9PSBcInRvb2xib3hfYmxvY2tzXCIpIHtcbiAgICAgICAgdGhpcy5ibG9ja1lDb29yZGluYXRlSW50ZXJ2YWwgPSA4MDtcbiAgICAgICAgY29uZmlnLmJsb2NrQXJyYW5nZW1lbnQgPSB7IGNhdGVnb3J5IDogeyB4OiAyMCB9IH07XG4gICAgICB9XG4gICAgICAvLyBFbmFibGUgcGFyYW0gJiB2YXIgZWRpdGluZyBpbiBsZXZlbGJ1aWxkZXIsIHJlZ2FyZGxlc3Mgb2YgbGV2ZWwgc2V0dGluZ1xuICAgICAgY29uZmlnLmxldmVsLmRpc2FibGVQYXJhbUVkaXRpbmcgPSBmYWxzZTtcbiAgICAgIGNvbmZpZy5sZXZlbC5kaXNhYmxlVmFyaWFibGVFZGl0aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5waW5Xb3Jrc3BhY2VUb0JvdHRvbSkge1xuICAgICAgdmFyIGJvZHlFbGVtZW50ID0gZG9jdW1lbnQuYm9keTtcbiAgICAgIGJvZHlFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICAgIGJvZHlFbGVtZW50LmNsYXNzTmFtZSA9IGJvZHlFbGVtZW50LmNsYXNzTmFtZSArIFwiIHBpbl9ib3R0b21cIjtcbiAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBjb250YWluZXIuY2xhc3NOYW1lICsgXCIgcGluX2JvdHRvbVwiO1xuICAgICAgdmlzdWFsaXphdGlvbkNvbHVtbi5jbGFzc05hbWUgPSB2aXN1YWxpemF0aW9uQ29sdW1uLmNsYXNzTmFtZSArIFwiIHBpbl9ib3R0b21cIjtcbiAgICAgIGNvZGVXb3Jrc3BhY2UuY2xhc3NOYW1lID0gY29kZVdvcmtzcGFjZS5jbGFzc05hbWUgKyBcIiBwaW5fYm90dG9tXCI7XG4gICAgICBpZiAodGhpcy5lZGl0Q29kZSkge1xuICAgICAgICB2YXIgY29kZVRleHRib3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29kZVRleHRib3gnKTtcbiAgICAgICAgY29kZVRleHRib3guY2xhc3NOYW1lID0gY29kZVRleHRib3guY2xhc3NOYW1lICsgXCIgcGluX2JvdHRvbVwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2aXN1YWxpemF0aW9uQ29sdW1uLnN0eWxlLm1pbkhlaWdodCA9IHZpekhlaWdodCArICdweCc7XG4gICAgICBjb250YWluZXIuc3R5bGUubWluSGVpZ2h0ID0gdml6SGVpZ2h0ICsgJ3B4JztcbiAgICB9XG4gIH1cblxuICBpZiAoY29uZmlnLnJlYWRvbmx5V29ya3NwYWNlKSB7XG4gICAgJChjb2RlV29ya3NwYWNlKS5hZGRDbGFzcygncmVhZG9ubHknKTtcbiAgfVxuXG4gIC8vIE5PVEU6IENhbiBlbmQgdXAgd2l0aCBlbWJlZCB0cnVlIGFuZCBoaWRlU291cmNlIGZhbHNlIGluIGxldmVsIGJ1aWxkZXJcbiAgLy8gc2NlbmFyaW9zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NvZGUtZG90LW9yZy9jb2RlLWRvdC1vcmcvcHVsbC8xNzQ0XG4gIGlmIChjb25maWcuZW1iZWQgJiYgY29uZmlnLmhpZGVTb3VyY2UgJiYgdGhpcy5jZW50ZXJFbWJlZGRlZCkge1xuICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBjb250YWluZXIuY2xhc3NOYW1lICsgXCIgY2VudGVyZWRfZW1iZWRcIjtcbiAgICB2aXN1YWxpemF0aW9uQ29sdW1uLmNsYXNzTmFtZSA9IHZpc3VhbGl6YXRpb25Db2x1bW4uY2xhc3NOYW1lICsgXCIgY2VudGVyZWRfZW1iZWRcIjtcbiAgfVxuXG4gIGlmICghY29uZmlnLmVtYmVkICYmICFjb25maWcuaGlkZVNvdXJjZSkge1xuICAgIC8vIE1ha2UgdGhlIHZpc3VhbGl6YXRpb24gcmVzcG9uc2l2ZSB0byBzY3JlZW4gc2l6ZSwgZXhjZXB0IG9uIHNoYXJlIHBhZ2UuXG4gICAgdmlzdWFsaXphdGlvbi5jbGFzc05hbWUgKz0gXCIgcmVzcG9uc2l2ZVwiO1xuICAgIHZpc3VhbGl6YXRpb25Db2x1bW4uY2xhc3NOYW1lICs9IFwiIHJlc3BvbnNpdmVcIjtcbiAgICB2YXIgc21hbGxGb290ZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcGFnZS1zbWFsbC1mb290ZXIgLnNtYWxsLWZvb3Rlci1iYXNlJyk7XG4gICAgaWYgKHNtYWxsRm9vdGVyKSB7XG4gICAgICBzbWFsbEZvb3Rlci5jbGFzc05hbWUgKz0gXCIgcmVzcG9uc2l2ZVwiO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKlxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLmhhbmRsZUhpZGVTb3VyY2VfID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMuY29udGFpbmVySWQpO1xuICB0aGlzLmhpZGVTb3VyY2UgPSB0cnVlO1xuICB2YXIgd29ya3NwYWNlRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvZGVXb3Jrc3BhY2UnKTtcbiAgaWYgKCFvcHRpb25zLmVtYmVkIHx8IG9wdGlvbnMubGV2ZWwuc2tpcEluc3RydWN0aW9uc1BvcHVwKSB7XG4gICAgY29udGFpbmVyLmNsYXNzTmFtZSA9ICdoaWRlLXNvdXJjZSc7XG4gIH1cbiAgd29ya3NwYWNlRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aXN1YWxpemF0aW9uUmVzaXplQmFyJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAvLyBDaHJvbWUtbGVzcyBzaGFyZSBwYWdlLlxuICBpZiAodGhpcy5zaGFyZSkge1xuICAgIGlmIChvcHRpb25zLmlzTGVnYWN5U2hhcmUgfHwgdGhpcy53aXJlZnJhbWVTaGFyZSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnIzIwMkIzNCc7XG5cbiAgICAgICQoJy5oZWFkZXItd3JhcHBlcicpLmhpZGUoKTtcbiAgICAgIHZhciB2aXpDb2x1bW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmlzdWFsaXphdGlvbkNvbHVtbicpO1xuICAgICAgaWYgKGRvbS5pc01vYmlsZSgpICYmIChvcHRpb25zLmlzTGVnYWN5U2hhcmUgfHwgIWRvbS5pc0lQYWQoKSkpIHtcbiAgICAgICAgJCh2aXpDb2x1bW4pLmFkZENsYXNzKCdjaHJvbWVsZXNzU2hhcmUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQodml6Q29sdW1uKS5hZGRDbGFzcygnd2lyZWZyYW1lU2hhcmUnKTtcblxuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgUmVhY3RET00ucmVuZGVyKFJlYWN0LmNyZWF0ZUVsZW1lbnQoV2lyZWZyYW1lU2VuZFRvUGhvbmUsIHtcbiAgICAgICAgICBjaGFubmVsSWQ6IGRhc2hib2FyZC5wcm9qZWN0LmdldEN1cnJlbnRJZCgpLFxuICAgICAgICAgIGFwcFR5cGU6IGRhc2hib2FyZC5wcm9qZWN0LmdldFN0YW5kYWxvbmVBcHAoKVxuICAgICAgICB9KSwgZGl2KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLmVtYmVkKSB7XG4gICAgICAgIHZhciBydW5CdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnVuQnV0dG9uJyk7XG4gICAgICAgIHZhciBidXR0b25Sb3cgPSBydW5CdXR0b24ucGFyZW50RWxlbWVudDtcbiAgICAgICAgdmFyIG9wZW5Xb3Jrc3BhY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgb3BlbldvcmtzcGFjZS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ29wZW4td29ya3NwYWNlJyk7XG4gICAgICAgIG9wZW5Xb3Jrc3BhY2UuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobXNnLm9wZW5Xb3Jrc3BhY2UoKSkpO1xuXG4gICAgICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQob3BlbldvcmtzcGFjZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIC9jLyBVUkxzIGdvIHRvIC9lZGl0IHdoZW4gd2UgY2xpY2sgb3BlbiB3b3Jrc3BhY2UuXG4gICAgICAgICAgLy8gL3Byb2plY3QvIFVSTHMgd2Ugd2FudCB0byBnbyB0byAvdmlldyAod2hpY2ggZG9lc250IHJlcXVpcmUgbG9naW4pXG4gICAgICAgICAgaWYgKC9eXFwvY1xcLy8udGVzdChsb2NhdGlvbi5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgIGxvY2F0aW9uLmhyZWYgKz0gJy9lZGl0JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9jYXRpb24uaHJlZiArPSAnL3ZpZXcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYnV0dG9uUm93LmFwcGVuZENoaWxkKG9wZW5Xb3Jrc3BhY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuU3R1ZGlvQXBwLnByb3RvdHlwZS5oYW5kbGVFZGl0Q29kZV8gPSBmdW5jdGlvbiAoY29uZmlnKSB7XG5cbiAgaWYgKHRoaXMuaGlkZVNvdXJjZSkge1xuICAgIC8vIEluIGhpZGUgc291cmNlIG1vZGUsIGp1c3QgY2FsbCBhZnRlckluamVjdCBhbmQgZXhpdCBpbW1lZGlhdGVseVxuICAgIGlmIChjb25maWcuYWZ0ZXJJbmplY3QpIHtcbiAgICAgIGNvbmZpZy5hZnRlckluamVjdCgpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGlzcGxheU1lc3NhZ2UsIGV4YW1wbGVQcm9ncmFtcywgbWVzc2FnZUVsZW1lbnQsIG9uQ2hhbmdlLCBzdGFydGluZ1RleHQ7XG5cbiAgLy8gRW5zdXJlIGdsb2JhbCBhY2UgdmFyaWFibGUgaXMgdGhlIHNhbWUgYXMgd2luZG93LmFjZVxuICAvLyAoaW1wb3J0YW50IGJlY2F1c2UgdGhleSBjYW4gYmUgZGlmZmVyZW50IGluIG91ciB0ZXN0IGVudmlyb25tZW50KVxuXG4gIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgYWNlID0gd2luZG93LmFjZTtcbiAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuICB2YXIgZnVsbERyb3BsZXRQYWxldHRlID0gZHJvcGxldFV0aWxzLmdlbmVyYXRlRHJvcGxldFBhbGV0dGUoXG4gICAgY29uZmlnLmxldmVsLmNvZGVGdW5jdGlvbnMsIGNvbmZpZy5kcm9wbGV0Q29uZmlnKTtcbiAgdGhpcy5lZGl0b3IgPSBuZXcgZHJvcGxldC5FZGl0b3IoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvZGVUZXh0Ym94JyksIHtcbiAgICBtb2RlOiAnamF2YXNjcmlwdCcsXG4gICAgbW9kZU9wdGlvbnM6IGRyb3BsZXRVdGlscy5nZW5lcmF0ZURyb3BsZXRNb2RlT3B0aW9ucyhjb25maWcpLFxuICAgIHBhbGV0dGU6IGZ1bGxEcm9wbGV0UGFsZXR0ZSxcbiAgICBzaG93UGFsZXR0ZUluVGV4dE1vZGU6IHRydWUsXG4gICAgc2hvd0Ryb3Bkb3duSW5QYWxldHRlOiBjb25maWcuc2hvd0Ryb3Bkb3duSW5QYWxldHRlLFxuICAgIGFsbG93RmxvYXRpbmdCbG9ja3M6IGZhbHNlLFxuICAgIGRyb3BJbnRvQWNlQXRMaW5lU3RhcnQ6IGNvbmZpZy5kcm9wSW50b0FjZUF0TGluZVN0YXJ0LFxuICAgIGVuYWJsZVBhbGV0dGVBdFN0YXJ0OiAhY29uZmlnLnJlYWRvbmx5V29ya3NwYWNlLFxuICAgIHRleHRNb2RlQXRTdGFydDogY29uZmlnLmxldmVsLnRleHRNb2RlQXRTdGFydFxuICB9KTtcblxuICB0aGlzLmVkaXRvci5hY2VFZGl0b3Iuc2V0U2hvd1ByaW50TWFyZ2luKGZhbHNlKTtcblxuICAvLyBJbml0IGFuZCBkZWZpbmUgb3VyIGN1c3RvbSBhY2UgbW9kZTpcbiAgYWNlTW9kZS5kZWZpbmVGb3JBY2UoY29uZmlnLmRyb3BsZXRDb25maWcsIGNvbmZpZy51bnVzZWRDb25maWcsIHRoaXMuZWRpdG9yKTtcbiAgLy8gTm93IHNldCB0aGUgZWRpdG9yIHRvIHRoYXQgbW9kZTpcbiAgdmFyIGFjZUVkaXRvciA9IHRoaXMuZWRpdG9yLmFjZUVkaXRvcjtcbiAgYWNlRWRpdG9yLnNlc3Npb24uc2V0TW9kZSgnYWNlL21vZGUvamF2YXNjcmlwdF9jb2Rlb3JnJyk7XG5cbiAgLy8gRXh0ZW5kIHRoZSBjb21tYW5kIGxpc3Qgb24gdGhlIGFjZSBBdXRvY29tcGxldGUgb2JqZWN0IHRvIGluY2x1ZGUgdGhlIHBlcmlvZDpcbiAgdmFyIEF1dG9jb21wbGV0ZSA9IHdpbmRvdy5hY2UucmVxdWlyZShcImFjZS9hdXRvY29tcGxldGVcIikuQXV0b2NvbXBsZXRlO1xuICBBdXRvY29tcGxldGUucHJvdG90eXBlLmNvbW1hbmRzWycuJ10gPSBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAvLyBGaXJzdCwgaW5zZXJ0IHRoZSBwZXJpb2QgYW5kIHVwZGF0ZSB0aGUgY29tcGxldGlvbnM6XG4gICAgZWRpdG9yLmluc2VydChcIi5cIik7XG4gICAgZWRpdG9yLmNvbXBsZXRlci51cGRhdGVDb21wbGV0aW9ucyh0cnVlKTtcbiAgICB2YXIgZmlsdGVyZWQgPSBlZGl0b3IuY29tcGxldGVyLmNvbXBsZXRpb25zICYmXG4gICAgICAgIGVkaXRvci5jb21wbGV0ZXIuY29tcGxldGlvbnMuZmlsdGVyZWQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoZmlsdGVyZWQgJiYgZmlsdGVyZWQubGVuZ3RoKTsgaSsrKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGFueSBleGFjdCBtYWNoZXMgaW4gb3VyIGZpbHRlcmVkIGNvbXBsZXRpb25zIHRoYXQgaW5jbHVkZVxuICAgICAgLy8gdGhpcyBwZXJpb2QsIGFsbG93IHRoZSBjb21wbGV0ZXIgdG8gc3RheSBhY3RpdmU6XG4gICAgICBpZiAoZmlsdGVyZWRbaV0uZXhhY3RNYXRjaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSwgZGV0YWNoIHRoZSBjb21wbGV0ZXI6XG4gICAgZWRpdG9yLmNvbXBsZXRlci5kZXRhY2goKTtcbiAgfTtcblxuICB2YXIgbGFuZ1Rvb2xzID0gd2luZG93LmFjZS5yZXF1aXJlKFwiYWNlL2V4dC9sYW5ndWFnZV90b29sc1wiKTtcblxuICAvLyBXZSBkb24ndCB3YW50IHRvIGluY2x1ZGUgdGhlIHRleHRDb21wbGV0ZXIuIGxhbmdUb29scyBkb2Vzbid0IGdpdmUgdXMgYSB3YXlcbiAgLy8gdG8gcmVtb3ZlIGJhc2UgY29tcGxldGVycyAobm90ZTogaXQgZG9lcyBpbiBuZXdlciB2ZXJzaW9ucyBvZiBhY2UpLCBzb1xuICAvLyB3ZSBzZXQgYWNlRWRpdG9yLmNvbXBsZXRlcnMgbWFudWFsbHlcbiAgYWNlRWRpdG9yLmNvbXBsZXRlcnMgPSBbbGFuZ1Rvb2xzLnNuaXBwZXRDb21wbGV0ZXIsIGxhbmdUb29scy5rZXlXb3JkQ29tcGxldGVyXTtcbiAgLy8gbWFrZSBzZXRDb21wbGV0ZXJzIGZhaWwgc28gdGhhdCBhdHRlbXB0cyB0byB1c2UgaXQgcmVzdWx0IGluIGNsZWFyIGZhaWx1cmVcbiAgLy8gaW5zdGVhZCBvZiBqdXN0IHNpbGVudGx5IG5vdCB3b3JraW5nXG4gIGxhbmdUb29scy5zZXRDb21wbGV0ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0Q29tcGxldGVycyBkaXNhYmxlZC4gc2V0IGFjZUVkaXRvci5jb21wbGV0ZXJzIGRpcmVjdGx5Jyk7XG4gIH07XG5cbiAgLy8gQWRkIGFuIGFjZSBjb21wbGV0ZXIgZm9yIHRoZSBBUEkgZnVuY3Rpb25zIGV4cG9zZWQgZm9yIHRoaXMgbGV2ZWxcbiAgaWYgKGNvbmZpZy5kcm9wbGV0Q29uZmlnKSB7XG4gICAgdmFyIGZ1bmN0aW9uc0ZpbHRlciA9IG51bGw7XG4gICAgaWYgKGNvbmZpZy5sZXZlbC5hdXRvY29tcGxldGVQYWxldHRlQXBpc09ubHkpIHtcbiAgICAgICBmdW5jdGlvbnNGaWx0ZXIgPSBjb25maWcubGV2ZWwuY29kZUZ1bmN0aW9ucztcbiAgICB9XG5cbiAgICBhY2VFZGl0b3IuY29tcGxldGVycy5wdXNoKFxuICAgICAgZHJvcGxldFV0aWxzLmdlbmVyYXRlQWNlQXBpQ29tcGxldGVyKGZ1bmN0aW9uc0ZpbHRlciwgY29uZmlnLmRyb3BsZXRDb25maWcpKTtcbiAgfVxuXG4gIHRoaXMuZWRpdG9yLmFjZUVkaXRvci5zZXRPcHRpb25zKHtcbiAgICBlbmFibGVCYXNpY0F1dG9jb21wbGV0aW9uOiB0cnVlLFxuICAgIGVuYWJsZUxpdmVBdXRvY29tcGxldGlvbjogdHJ1ZVxuICB9KTtcblxuICB0aGlzLmRyb3BsZXRUb29sdGlwTWFuYWdlciA9IG5ldyBEcm9wbGV0VG9vbHRpcE1hbmFnZXIoXG4gICAgdGhpcy5hcHBNc2csXG4gICAgY29uZmlnLmRyb3BsZXRDb25maWcsXG4gICAgY29uZmlnLmxldmVsLmNvZGVGdW5jdGlvbnMsXG4gICAgY29uZmlnLmxldmVsLmF1dG9jb21wbGV0ZVBhbGV0dGVBcGlzT25seSk7XG4gIGlmIChjb25maWcubGV2ZWwuZHJvcGxldFRvb2x0aXBzRGlzYWJsZWQpIHtcbiAgICB0aGlzLmRyb3BsZXRUb29sdGlwTWFuYWdlci5zZXRUb29sdGlwc0VuYWJsZWQoZmFsc2UpO1xuICB9XG4gIHRoaXMuZHJvcGxldFRvb2x0aXBNYW5hZ2VyLnJlZ2lzdGVyQmxvY2tzKCk7XG5cbiAgLy8gQmluZCBsaXN0ZW5lciB0byBwYWxldHRlL3Rvb2xib3ggJ0hpZGUnIGFuZCAnU2hvdycgbGlua3NcbiAgdmFyIGhpZGVUb29sYm94SGVhZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Rvb2xib3gtaGVhZGVyJyk7XG4gIHZhciBoaWRlVG9vbGJveEljb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGlkZS10b29sYm94LWljb24nKTtcbiAgdmFyIHNob3dUb29sYm94SGVhZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Nob3ctdG9vbGJveC1oZWFkZXInKTtcbiAgaWYgKGhpZGVUb29sYm94SGVhZGVyICYmIGhpZGVUb29sYm94SWNvbiAmJiBzaG93VG9vbGJveEhlYWRlcikge1xuICAgIGhpZGVUb29sYm94SGVhZGVyLmNsYXNzTmFtZSArPSAnIHRvZ2dsZWFibGUnO1xuICAgIGhpZGVUb29sYm94SWNvbi5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgdmFyIGhhbmRsZVRvZ2dsZVBhbGV0dGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5lZGl0b3IpIHtcbiAgICAgICAgdGhpcy5lZGl0b3IuZW5hYmxlUGFsZXR0ZSghdGhpcy5lZGl0b3IucGFsZXR0ZUVuYWJsZWQpO1xuICAgICAgICBzaG93VG9vbGJveEhlYWRlci5zdHlsZS5kaXNwbGF5ID1cbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLnBhbGV0dGVFbmFibGVkID8gJ25vbmUnIDogJ2lubGluZS1ibG9jayc7XG4gICAgICAgIGhpZGVUb29sYm94SWNvbi5zdHlsZS5kaXNwbGF5ID1cbiAgICAgICAgICAgICF0aGlzLmVkaXRvci5wYWxldHRlRW5hYmxlZCA/ICdub25lJyA6ICdpbmxpbmUtYmxvY2snO1xuICAgICAgICB0aGlzLnJlc2l6ZVRvb2xib3hIZWFkZXIoKTtcbiAgICAgIH1cbiAgICB9KS5iaW5kKHRoaXMpO1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQoaGlkZVRvb2xib3hIZWFkZXIsIGhhbmRsZVRvZ2dsZVBhbGV0dGUpO1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQoc2hvd1Rvb2xib3hIZWFkZXIsIGhhbmRsZVRvZ2dsZVBhbGV0dGUpO1xuICB9XG5cbiAgdGhpcy5yZXNpemVUb29sYm94SGVhZGVyKCk7XG5cbiAgdmFyIHN0YXJ0QmxvY2tzID0gY29uZmlnLmxldmVsLmxhc3RBdHRlbXB0IHx8IGNvbmZpZy5sZXZlbC5zdGFydEJsb2NrcztcbiAgaWYgKHN0YXJ0QmxvY2tzKSB7XG5cbiAgICB0cnkge1xuICAgICAgLy8gRG9uJ3QgcGFzcyBDUkxGIHBhaXJzIHRvIGRyb3BsZXQgdW50aWwgdGhleSBmaXggQ1IgaGFuZGxpbmc6XG4gICAgICB0aGlzLmVkaXRvci5zZXRWYWx1ZShzdGFydEJsb2Nrcy5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGNhdGNoIGVycm9ycyB3aXRob3V0IGJsb3dpbmcgdXAgZW50aXJlbHkuIHdlIG1heSBzdGlsbCBub3QgYmUgaW4gYVxuICAgICAgLy8gZ3JlYXQgc3RhdGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgIH1cbiAgICAvLyBSZXNldCBkcm9wbGV0IFVuZG8gc3RhY2s6XG4gICAgdGhpcy5lZGl0b3IuY2xlYXJVbmRvU3RhY2soKTtcbiAgICAvLyBSZXNldCBhY2UgVW5kbyBzdGFjazpcbiAgICB2YXIgVW5kb01hbmFnZXIgPSB3aW5kb3cuYWNlLnJlcXVpcmUoXCJhY2UvdW5kb21hbmFnZXJcIikuVW5kb01hbmFnZXI7XG4gICAgdGhpcy5lZGl0b3IuYWNlRWRpdG9yLmdldFNlc3Npb24oKS5zZXRVbmRvTWFuYWdlcihuZXcgVW5kb01hbmFnZXIoKSk7XG4gIH1cblxuICBpZiAoY29uZmlnLnJlYWRvbmx5V29ya3NwYWNlKSB7XG4gICAgLy8gV2hlbiBpbiByZWFkT25seSBtb2RlLCBzaG93IHNvdXJjZSwgYnV0IGRvIG5vdCBhbGxvdyBlZGl0aW5nLFxuICAgIC8vIGRpc2FibGUgdGhlIHBhbGV0dGUsIGFuZCBoaWRlIHRoZSBVSSB0byBzaG93IHRoZSBwYWxldHRlOlxuICAgIHRoaXMuZWRpdG9yLnNldFJlYWRPbmx5KHRydWUpO1xuICAgIHNob3dUb29sYm94SGVhZGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cblxuICAvLyBkcm9wbGV0IG1heSBub3cgYmUgaW4gY29kZSBtb2RlIGlmIGl0IGNvdWxkbid0IHBhcnNlIHRoZSBjb2RlIGludG9cbiAgLy8gYmxvY2tzLCBzbyB1cGRhdGUgdGhlIFVJIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIChkb24ndCBhdXRvZm9jdXNcbiAgLy8gaWYgd2UgaGF2ZSBhbHJlYWR5IGNyZWF0ZWQgYW4gaW5zdHJ1Y3Rpb25zRGlhbG9nIGF0IHRoaXMgc3RhZ2Ugb2YgaW5pdClcbiAgdGhpcy5vbkRyb3BsZXRUb2dnbGVfKCF0aGlzLmluc3RydWN0aW9uc0RpYWxvZyk7XG5cbiAgdGhpcy5kcm9wbGV0VG9vbHRpcE1hbmFnZXIucmVnaXN0ZXJEcm9wbGV0QmxvY2tNb2RlSGFuZGxlcnModGhpcy5lZGl0b3IpO1xuXG4gIHRoaXMuZWRpdG9yLm9uKCdwYWxldHRldG9nZ2xlZG9uZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAvLyBSZXBvc2l0aW9uIGNhbGxvdXRzIGFmdGVyIGJsb2NrL3RleHQgdG9nZ2xlIChpbiBjYXNlIHRoZXkgbmVlZCB0byBtb3ZlKVxuICAgICQoJy5jZG8tcXRpcHMnKS5xdGlwKCdyZXBvc2l0aW9uJywgbnVsbCwgZmFsc2UpO1xuICB9KTtcblxuICBpZiAodGhpcy5pbnN0cnVjdGlvbnNEaWFsb2cpIHtcbiAgICAvLyBJbml0aWFsaXppbmcgdGhlIGRyb3BsZXQgZWRpdG9yIGluIHRleHQgbW9kZSAoYWNlKSBjYW4gc3RlYWwgdGhlIGZvY3VzXG4gICAgLy8gZnJvbSBvdXIgdmlzaWJsZSBpbnN0cnVjdGlvbnMgZGlhbG9nLiBSZXN0b3JlIGZvY3VzIHdoZXJlIGl0IGJlbG9uZ3M6XG4gICAgdGhpcy5pbnN0cnVjdGlvbnNEaWFsb2cuZm9jdXMoKTtcbiAgfVxuXG4gIGlmIChjb25maWcuYWZ0ZXJFZGl0b3JSZWFkeSkge1xuICAgIGNvbmZpZy5hZnRlckVkaXRvclJlYWR5KCk7XG4gIH1cblxuICBpZiAoY29uZmlnLmFmdGVySW5qZWN0KSB7XG4gICAgY29uZmlnLmFmdGVySW5qZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogRW5hYmxlIGFkZGluZy9yZW1vdmluZyBicmVha3BvaW50cyBieSBjbGlja2luZyBpbiB0aGUgZ3V0dGVyIG9mIHRoZSBlZGl0b3IuXG4gKiBQcmVyZXF1aXNpdGVzOiBEcm9wbGV0IGVkaXRvciBtdXN0IGJlIGluIHVzZSBhbmQgaW5pdGlhbGl6ZWQgKGUuZy4geW91IGhhdmVcbiAqIHRvIGNhbGwgaGFuZGxlRWRpdENvZGVfIGZpcnN0KS5cbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5lbmFibGVCcmVha3BvaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmVkaXRvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignRHJvcGxldCBlZGl0b3IgbXVzdCBiZSBpbiB1c2UgdG8gZW5hYmxlIGJyZWFrcG9pbnRzLicpO1xuICB9XG5cbiAgLy8gU2V0IHVwIGFuIGV2ZW50IGhhbmRsZXIgdG8gY3JlYXRlIGJyZWFrcG9pbnRzIHdoZW4gY2xpY2tpbmcgaW4gdGhlIGd1dHRlcjpcbiAgdGhpcy5lZGl0b3Iub24oJ2d1dHRlcm1vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgYnBzID0gdGhpcy5lZGl0b3IuZ2V0QnJlYWtwb2ludHMoKTtcbiAgICBpZiAoYnBzW2UubGluZV0pIHtcbiAgICAgIHRoaXMuZWRpdG9yLmNsZWFyQnJlYWtwb2ludChlLmxpbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVkaXRvci5zZXRCcmVha3BvaW50KGUubGluZSk7XG4gICAgfVxuICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBTZXQgd2hldGhlciB0byBhbGVydCB1c2VyIHRvIGVtcHR5IGJsb2Nrcywgc2hvcnQtY2lyY3VpdGluZyBhbGwgb3RoZXIgdGVzdHMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrQmxvY2tzIFdoZXRoZXIgdG8gY2hlY2sgZm9yIGVtcHR5IGJsb2Nrcy5cbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5zZXRDaGVja0ZvckVtcHR5QmxvY2tzID0gZnVuY3Rpb24gKGNoZWNrQmxvY2tzKSB7XG4gIHRoaXMuY2hlY2tGb3JFbXB0eUJsb2Nrc18gPSBjaGVja0Jsb2Nrcztcbn07XG5cbi8qKlxuICogQWRkIHRoZSBzdGFydGluZyBibG9jayhzKS4gIERvbid0IGxvYWQgbGFzdEF0dGVtcHQgZm9yIEppZ3NhdyBsZXZlbHMgb3IgdGhlXG4gKiBsZXZlbCB3aWxsIGFkdmFuY2UgYXMgc29vbiBhcyBpdCdzIGxvYWRlZC5cbiAqIEBwYXJhbSBsb2FkTGFzdEF0dGVtcHQgSWYgdHJ1ZSwgdHJ5IHRvIGxvYWQgY29uZmlnLmxhc3RBdHRlbXB0LlxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLnNldFN0YXJ0QmxvY2tzXyA9IGZ1bmN0aW9uIChjb25maWcsIGxvYWRMYXN0QXR0ZW1wdCkge1xuICBpZiAoY29uZmlnLmxldmVsLmVkaXRfYmxvY2tzKSB7XG4gICAgbG9hZExhc3RBdHRlbXB0ID0gZmFsc2U7XG4gIH1cbiAgdmFyIHN0YXJ0QmxvY2tzID0gY29uZmlnLmxldmVsLnN0YXJ0QmxvY2tzIHx8ICcnO1xuICBpZiAobG9hZExhc3RBdHRlbXB0ICYmIGNvbmZpZy5sZXZlbEdhbWVOYW1lICE9PSAnSmlnc2F3Jykge1xuICAgIHN0YXJ0QmxvY2tzID0gY29uZmlnLmxldmVsLmxhc3RBdHRlbXB0IHx8IHN0YXJ0QmxvY2tzO1xuICB9XG4gIGlmIChjb25maWcuZm9yY2VJbnNlcnRUb3BCbG9jaykge1xuICAgIHN0YXJ0QmxvY2tzID0gYmxvY2tVdGlscy5mb3JjZUluc2VydFRvcEJsb2NrKHN0YXJ0QmxvY2tzLFxuICAgICAgICBjb25maWcuZm9yY2VJbnNlcnRUb3BCbG9jayk7XG4gIH1cbiAgc3RhcnRCbG9ja3MgPSB0aGlzLmFycmFuZ2VCbG9ja1Bvc2l0aW9uKHN0YXJ0QmxvY2tzLCBjb25maWcuYmxvY2tBcnJhbmdlbWVudCk7XG4gIHRyeSB7XG4gICAgdGhpcy5sb2FkQmxvY2tzKHN0YXJ0QmxvY2tzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChsb2FkTGFzdEF0dGVtcHQpIHtcbiAgICAgIEJsb2NrbHkubWFpbkJsb2NrU3BhY2UuY2xlYXIoKTtcbiAgICAgIC8vIFRyeSBsb2FkaW5nIHRoZSBkZWZhdWx0IHN0YXJ0IGJsb2NrcyBpbnN0ZWFkLlxuICAgICAgdGhpcy5zZXRTdGFydEJsb2Nrc18oY29uZmlnLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFNob3cgdGhlIGNvbmZpZ3VyZWQgc3RhcnRpbmcgZnVuY3Rpb24gZGVmaW5pdGlvbi5cbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5vcGVuRnVuY3Rpb25EZWZpbml0aW9uXyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICBpZiAoQmxvY2tseS5jb250cmFjdEVkaXRvcikge1xuICAgIEJsb2NrbHkuY29udHJhY3RFZGl0b3IuYXV0b09wZW5XaXRoTGV2ZWxDb25maWd1cmF0aW9uKHtcbiAgICAgIGF1dG9PcGVuRnVuY3Rpb246IGNvbmZpZy5sZXZlbC5vcGVuRnVuY3Rpb25EZWZpbml0aW9uLFxuICAgICAgY29udHJhY3RDb2xsYXBzZTogY29uZmlnLmxldmVsLmNvbnRyYWN0Q29sbGFwc2UsXG4gICAgICBjb250cmFjdEhpZ2hsaWdodDogY29uZmlnLmxldmVsLmNvbnRyYWN0SGlnaGxpZ2h0LFxuICAgICAgZXhhbXBsZXNDb2xsYXBzZTogY29uZmlnLmxldmVsLmV4YW1wbGVzQ29sbGFwc2UsXG4gICAgICBleGFtcGxlc0hpZ2hsaWdodDogY29uZmlnLmxldmVsLmV4YW1wbGVzSGlnaGxpZ2h0LFxuICAgICAgZGVmaW5pdGlvbkNvbGxhcHNlOiBjb25maWcubGV2ZWwuZGVmaW5pdGlvbkNvbGxhcHNlLFxuICAgICAgZGVmaW5pdGlvbkhpZ2hsaWdodDogY29uZmlnLmxldmVsLmRlZmluaXRpb25IaWdobGlnaHRcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBCbG9ja2x5LmZ1bmN0aW9uRWRpdG9yLmF1dG9PcGVuRnVuY3Rpb24oY29uZmlnLmxldmVsLm9wZW5GdW5jdGlvbkRlZmluaXRpb24pO1xuICB9XG59O1xuXG4vKipcbiAqXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuaGFuZGxlVXNpbmdCbG9ja2x5XyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgLy8gQWxsb3cgZW1wdHkgYmxvY2tzIGlmIGVkaXRpbmcgYmxvY2tzLlxuICBpZiAoY29uZmlnLmxldmVsLmVkaXRfYmxvY2tzKSB7XG4gICAgdGhpcy5jaGVja0ZvckVtcHR5QmxvY2tzXyA9IGZhbHNlO1xuICAgIGlmIChjb25maWcubGV2ZWwuZWRpdF9ibG9ja3MgPT09ICdyZXF1aXJlZF9ibG9ja3MnIHx8XG4gICAgICAgIGNvbmZpZy5sZXZlbC5lZGl0X2Jsb2NrcyA9PT0gJ3Rvb2xib3hfYmxvY2tzJyB8fFxuICAgICAgICBjb25maWcubGV2ZWwuZWRpdF9ibG9ja3MgPT09ICdyZWNvbW1lbmRlZF9ibG9ja3MnKSB7XG4gICAgICAvLyBEb24ndCBzaG93IHdoZW4gcnVuIGJsb2NrIGZvciB0b29sYm94L3JlcXVpcmVkL3JlY29tbWVuZGVkIGJsb2NrIGVkaXRpbmdcbiAgICAgIGNvbmZpZy5mb3JjZUluc2VydFRvcEJsb2NrID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBJZiBsZXZlbGJ1aWxkZXIgcHJvdmlkZXMgYW4gZW1wdHkgdG9vbGJveCwgc29tZSBhcHBzIChsaWtlIGFydGlzdClcbiAgLy8gcmVwbGFjZSBpdCB3aXRoIGEgZnVsbCB0b29sYm94LiBJIHRoaW5rIHNvbWUgbGV2ZWxzIG1heSBkZXBlbmQgb24gdGhpc1xuICAvLyBiZWhhdmlvci4gV2Ugd2FudCBhIHdheSB0byBzcGVjaWZ5IG5vIHRvb2xib3gsIHdoaWNoIGlzIDx4bWw+PC94bWw+XG4gIGlmIChjb25maWcubGV2ZWwudG9vbGJveCkge1xuICAgIHZhciB0b29sYm94V2l0aG91dFdoaXRlc3BhY2UgPSBjb25maWcubGV2ZWwudG9vbGJveC5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgIGlmICh0b29sYm94V2l0aG91dFdoaXRlc3BhY2UgPT09ICc8eG1sPjwveG1sPicgfHxcbiAgICAgICAgdG9vbGJveFdpdGhvdXRXaGl0ZXNwYWNlID09PSAnPHhtbC8+Jykge1xuICAgICAgY29uZmlnLmxldmVsLnRvb2xib3ggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb2RlV29ya3NwYWNlJyk7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIHRvb2xib3g6IGNvbmZpZy5sZXZlbC50b29sYm94LFxuICAgIGRpc2FibGVQYXJhbUVkaXRpbmc6IHV0aWxzLnZhbHVlT3IoY29uZmlnLmxldmVsLmRpc2FibGVQYXJhbUVkaXRpbmcsIHRydWUpLFxuICAgIGRpc2FibGVWYXJpYWJsZUVkaXRpbmc6IHV0aWxzLnZhbHVlT3IoY29uZmlnLmxldmVsLmRpc2FibGVWYXJpYWJsZUVkaXRpbmcsIGZhbHNlKSxcbiAgICB1c2VNb2RhbEZ1bmN0aW9uRWRpdG9yOiB1dGlscy52YWx1ZU9yKGNvbmZpZy5sZXZlbC51c2VNb2RhbEZ1bmN0aW9uRWRpdG9yLCBmYWxzZSksXG4gICAgdXNlQ29udHJhY3RFZGl0b3I6IHV0aWxzLnZhbHVlT3IoY29uZmlnLmxldmVsLnVzZUNvbnRyYWN0RWRpdG9yLCBmYWxzZSksXG4gICAgZGlzYWJsZUV4YW1wbGVzOiB1dGlscy52YWx1ZU9yKGNvbmZpZy5sZXZlbC5kaXNhYmxlRXhhbXBsZXMsIGZhbHNlKSxcbiAgICBkZWZhdWx0TnVtRXhhbXBsZUJsb2NrczogdXRpbHMudmFsdWVPcihjb25maWcubGV2ZWwuZGVmYXVsdE51bUV4YW1wbGVCbG9ja3MsIDIpLFxuICAgIHNjcm9sbGJhcnM6IGNvbmZpZy5sZXZlbC5zY3JvbGxiYXJzLFxuICAgIGhhc1ZlcnRpY2FsU2Nyb2xsYmFyczogY29uZmlnLmhhc1ZlcnRpY2FsU2Nyb2xsYmFycyxcbiAgICBoYXNIb3Jpem9udGFsU2Nyb2xsYmFyczogY29uZmlnLmhhc0hvcml6b250YWxTY3JvbGxiYXJzLFxuICAgIGVkaXRCbG9ja3M6IHV0aWxzLnZhbHVlT3IoY29uZmlnLmxldmVsLmVkaXRfYmxvY2tzLCBmYWxzZSksXG4gICAgcmVhZE9ubHk6IHV0aWxzLnZhbHVlT3IoY29uZmlnLnJlYWRvbmx5V29ya3NwYWNlLCBmYWxzZSksXG4gICAgc2hvd0V4YW1wbGVUZXN0QnV0dG9uczogdXRpbHMudmFsdWVPcihjb25maWcuc2hvd0V4YW1wbGVUZXN0QnV0dG9ucywgZmFsc2UpXG4gIH07XG4gIFsndHJhc2hjYW4nLCAndmFyc0luR2xvYmFscycsICdncmF5T3V0VW5kZWxldGFibGVCbG9ja3MnLFxuICAgICdkaXNhYmxlUGFyYW1FZGl0aW5nJ10uZm9yRWFjaChcbiAgICBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgaWYgKGNvbmZpZ1twcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnNbcHJvcF0gPSBjb25maWdbcHJvcF07XG4gICAgICB9XG4gICAgfSk7XG4gIHRoaXMuaW5qZWN0KGRpdiwgb3B0aW9ucyk7XG4gIHRoaXMub25SZXNpemUoKTtcblxuICBpZiAoY29uZmlnLmFmdGVySW5qZWN0KSB7XG4gICAgY29uZmlnLmFmdGVySW5qZWN0KCk7XG4gIH1cbiAgdGhpcy5zZXRTdGFydEJsb2Nrc18oY29uZmlnLCB0cnVlKTtcbn07XG5cbi8qKlxuICogTW9kaWZ5IHRoZSB3b3Jrc3BhY2UgaGVhZGVyIGFmdGVyIGEgZHJvcGxldCBibG9ja3MvY29kZSBvciBwYWxldHRlIHRvZ2dsZVxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLnVwZGF0ZUhlYWRlcnNBZnRlckRyb3BsZXRUb2dnbGVfID0gZnVuY3Rpb24gKHVzaW5nQmxvY2tzKSB7XG4gIC8vIFVwZGF0ZSBoZWFkZXIgdGl0bGVzOlxuICB2YXIgc2hvd0NvZGVIZWFkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2hvdy1jb2RlLWhlYWRlcicpO1xuICB2YXIgY29udGVudFNwYW4gPSBzaG93Q29kZUhlYWRlci5maXJzdENoaWxkO1xuICB2YXIgZm9udEF3ZXNvbWVHbHlwaCA9IF8uZmluZChjb250ZW50U3Bhbi5jaGlsZE5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiAvXFxiZmFcXGIvLnRlc3Qobm9kZS5jbGFzc05hbWUpO1xuICB9KTtcbiAgdmFyIGltZ0Jsb2Nrc0dseXBoID0gXy5maW5kKGNvbnRlbnRTcGFuLmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIC9cXGJibG9ja3MtZ2x5cGhcXGIvLnRlc3Qobm9kZS5jbGFzc05hbWUpO1xuICB9KTtcblxuICAvLyBDaGFuZ2UgZ2x5cGhcbiAgaWYgKHVzaW5nQmxvY2tzKSB7XG4gICAgaWYgKGZvbnRBd2Vzb21lR2x5cGggJiYgaW1nQmxvY2tzR2x5cGgpIHtcbiAgICAgIGZvbnRBd2Vzb21lR2x5cGguc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgaW1nQmxvY2tzR2x5cGguc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG4gICAgY29udGVudFNwYW4ubGFzdENoaWxkLnRleHRDb250ZW50ID0gbXNnLnNob3dUZXh0SGVhZGVyKCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGZvbnRBd2Vzb21lR2x5cGggJiYgaW1nQmxvY2tzR2x5cGgpIHtcbiAgICAgIGZvbnRBd2Vzb21lR2x5cGguc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIGltZ0Jsb2Nrc0dseXBoLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICB9XG4gICAgY29udGVudFNwYW4ubGFzdENoaWxkLnRleHRDb250ZW50ID0gbXNnLnNob3dCbG9ja3NIZWFkZXIoKTtcbiAgfVxuXG4gIHZhciBibG9ja0NvdW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Jsb2NrQ291bnRlcicpO1xuICBpZiAoYmxvY2tDb3VudCkge1xuICAgIGJsb2NrQ291bnQuc3R5bGUuZGlzcGxheSA9XG4gICAgICAodXNpbmdCbG9ja3MgJiYgdGhpcy5lbmFibGVTaG93QmxvY2tDb3VudCkgPyAnaW5saW5lLWJsb2NrJyA6ICdub25lJztcbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGUgdXBkYXRlcyBhZnRlciBhIGRyb3BsZXQgdG9nZ2xlIGJldHdlZW4gYmxvY2tzL2NvZGUgaGFzIHRha2VuIHBsYWNlXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUub25Ecm9wbGV0VG9nZ2xlXyA9IGZ1bmN0aW9uIChhdXRvRm9jdXMpIHtcbiAgYXV0b0ZvY3VzID0gdXRpbHMudmFsdWVPcihhdXRvRm9jdXMsIHRydWUpO1xuICB0aGlzLnVwZGF0ZUhlYWRlcnNBZnRlckRyb3BsZXRUb2dnbGVfKHRoaXMuZWRpdG9yLmN1cnJlbnRseVVzaW5nQmxvY2tzKTtcbiAgaWYgKCF0aGlzLmVkaXRvci5jdXJyZW50bHlVc2luZ0Jsb2Nrcykge1xuICAgIGlmIChhdXRvRm9jdXMpIHtcbiAgICAgIHRoaXMuZWRpdG9yLmFjZUVkaXRvci5mb2N1cygpO1xuICAgIH1cbiAgICB0aGlzLmRyb3BsZXRUb29sdGlwTWFuYWdlci5yZWdpc3RlckRyb3BsZXRUZXh0TW9kZUhhbmRsZXJzKHRoaXMuZWRpdG9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEbyB3ZSBoYXZlIGFueSBmbG9hdGluZyBibG9ja3Mgbm90IGF0dGFjaGVkIHRvIGFuIGV2ZW50IGJsb2NrIG9yIGZ1bmN0aW9uIGJsb2NrP1xuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLmhhc0V4dHJhVG9wQmxvY2tzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5mZWVkYmFja18uaGFzRXh0cmFUb3BCbG9ja3MoKTtcbn07XG5cbi8qKlxuICpcbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5oYXNRdWVzdGlvbk1hcmtzSW5OdW1iZXJGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZmVlZGJhY2tfLmhhc1F1ZXN0aW9uTWFya3NJbk51bWJlckZpZWxkKCk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHRydWUgaWYgYW55IG5vbi1leGFtcGxlIGJsb2NrIGluIHRoZSB3b3Jrc3BhY2UgaGFzIGFuIHVuZmlsbGVkIGlucHV0XG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuaGFzVW5maWxsZWRGdW5jdGlvbmFsQmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIXRoaXMuZ2V0VW5maWxsZWRGdW5jdGlvbmFsQmxvY2soKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge0Jsb2NrfSBUaGUgZmlyc3QgYmxvY2sgdGhhdCBoYXMgYW4gdW5maWxsZWQgaW5wdXQsIG9yIHVuZGVmaW5lZFxuICogICBpZiB0aGVyZSBpc24ndCBvbmUuXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuZ2V0VW5maWxsZWRGdW5jdGlvbmFsQmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldEZpbHRlcmVkVW5maWxsZWRGdW5jdGlvbmFsQmxvY2tfKGZ1bmN0aW9uIChyb290QmxvY2spIHtcbiAgICByZXR1cm4gcm9vdEJsb2NrLnR5cGUgIT09ICdmdW5jdGlvbmFsX2V4YW1wbGUnO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge0Jsb2NrfSBUaGUgZmlyc3QgZXhhbXBsZSBibG9jayB0aGF0IGhhcyBhbiB1bmZpbGxlZCBpbnB1dCwgb3JcbiAqICAgdW5kZWZpbmVkIGlmIHRoZXJlIGlzbid0IG9uZS4gSWdub3JlcyBleGFtcGxlIGJsb2NrcyB0aGF0IGRvbid0IGhhdmUgYVxuICogICBjYWxsIHBvcnRpb24sIGFzIHRoZXNlIGFyZSBjb25zaWRlcmVkIGludmFsaWQuXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuZ2V0VW5maWxsZWRGdW5jdGlvbmFsRXhhbXBsZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0RmlsdGVyZWRVbmZpbGxlZEZ1bmN0aW9uYWxCbG9ja18oZnVuY3Rpb24gKHJvb3RCbG9jaykge1xuICAgIGlmIChyb290QmxvY2sudHlwZSAhPT0gJ2Z1bmN0aW9uYWxfZXhhbXBsZScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGFjdHVhbCA9IHJvb3RCbG9jay5nZXRJbnB1dFRhcmdldEJsb2NrKCdBQ1RVQUwnKTtcbiAgICByZXR1cm4gYWN0dWFsICYmIGFjdHVhbC5nZXRUaXRsZVZhbHVlKCdOQU1FJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmaWx0ZXIgUnVuIGFnYWluc3Qgcm9vdCBibG9jayBpbiBjaGFpbi4gUmV0dXJucyB0cnVlIGlmXG4gKiAgIHRoaXMgaXMgYSBibG9jayB3ZSBjYXJlIGFib3V0XG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuZ2V0RmlsdGVyZWRVbmZpbGxlZEZ1bmN0aW9uYWxCbG9ja18gPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gIHZhciB1bmZpbGxlZEJsb2NrO1xuICBCbG9ja2x5Lm1haW5CbG9ja1NwYWNlLmdldEFsbEJsb2NrcygpLnNvbWUoZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgLy8gR2V0IHRoZSByb290IGJsb2NrIGluIHRoZSBjaGFpblxuICAgIHZhciByb290QmxvY2sgPSBibG9jay5nZXRSb290QmxvY2soKTtcbiAgICBpZiAoIWZpbHRlcihyb290QmxvY2spKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGJsb2NrLmhhc1VuZmlsbGVkRnVuY3Rpb25hbElucHV0KCkpIHtcbiAgICAgIHVuZmlsbGVkQmxvY2sgPSBibG9jaztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHVuZmlsbGVkQmxvY2s7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gdGhhdCBkb2Vzbid0IGhhdmUgYW55IGV4YW1wbGVzLCBvclxuICogICB1bmRlZmluZWQgaWYgYWxsIGhhdmUgYXQgbGVhc3Qgb25lLlxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLmdldEZ1bmN0aW9uV2l0aG91dFR3b0V4YW1wbGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGVmaW5pdGlvbk5hbWVzID0gQmxvY2tseS5tYWluQmxvY2tTcGFjZS5nZXRUb3BCbG9ja3MoKS5maWx0ZXIoZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgcmV0dXJuIGJsb2NrLnR5cGUgPT09ICdmdW5jdGlvbmFsX2RlZmluaXRpb24nICYmICFibG9jay5pc1ZhcmlhYmxlKCk7XG4gIH0pLm1hcChmdW5jdGlvbiAoZGVmaW5pdGlvbkJsb2NrKSB7XG4gICAgcmV0dXJuIGRlZmluaXRpb25CbG9jay5nZXRQcm9jZWR1cmVJbmZvKCkubmFtZTtcbiAgfSk7XG5cbiAgdmFyIGV4YW1wbGVOYW1lcyA9IEJsb2NrbHkubWFpbkJsb2NrU3BhY2UuZ2V0VG9wQmxvY2tzKCkuZmlsdGVyKGZ1bmN0aW9uIChibG9jaykge1xuICAgIGlmIChibG9jay50eXBlICE9PSAnZnVuY3Rpb25hbF9leGFtcGxlJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIE9ubHkgY2FyZSBhYm91dCBmdW5jdGlvbmFsX2V4YW1wbGVzIHRoYXQgaGF2ZSBhbiBBQ1RVQUwgaW5wdXQgKGkuZS4gaXQnc1xuICAgIC8vIGNsZWFyIHdoaWNoIGZ1bmN0aW9uIHRoZXkncmUgZm9yXG4gICAgdmFyIGFjdHVhbCA9IGJsb2NrLmdldElucHV0VGFyZ2V0QmxvY2soJ0FDVFVBTCcpO1xuICAgIHJldHVybiBhY3R1YWwgJiYgYWN0dWFsLmdldFRpdGxlVmFsdWUoJ05BTUUnKTtcbiAgfSkubWFwKGZ1bmN0aW9uIChleGFtcGxlQmxvY2spIHtcbiAgICByZXR1cm4gZXhhbXBsZUJsb2NrLmdldElucHV0VGFyZ2V0QmxvY2soJ0FDVFVBTCcpLmdldFRpdGxlVmFsdWUoJ05BTUUnKTtcbiAgfSk7XG5cbiAgdmFyIGRlZmluaXRpb25XaXRoTGVzc1RoYW5Ud29FeGFtcGxlcztcbiAgZGVmaW5pdGlvbk5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGRlZikge1xuICAgIHZhciBkZWZpbml0aW9uRXhhbXBsZXMgPSBleGFtcGxlTmFtZXMuZmlsdGVyKGZ1bmN0aW9uKGV4YW1wbGUpIHtcbiAgICAgIHJldHVybiBkZWYgPT09IGV4YW1wbGU7XG4gICAgfSk7XG5cbiAgICBpZiAoZGVmaW5pdGlvbkV4YW1wbGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGRlZmluaXRpb25XaXRoTGVzc1RoYW5Ud29FeGFtcGxlcyA9IGRlZjtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGVmaW5pdGlvbldpdGhMZXNzVGhhblR3b0V4YW1wbGVzO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGVycm9yIG1lc3NhZ2Ugd2hlbiB3ZSBoYXZlIGFuIHVuZmlsbGVkIGJsb2NrXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFRoZSBibG9jay50eXBlIEZvciBvdXIgZXhwZWN0ZWQgdG9wIGxldmVsIGJsb2NrXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuZ2V0VW5maWxsZWRGdW5jdGlvbmFsQmxvY2tFcnJvciA9IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUpIHtcbiAgdmFyIHVuZmlsbGVkID0gdGhpcy5nZXRVbmZpbGxlZEZ1bmN0aW9uYWxCbG9jaygpO1xuXG4gIGlmICghdW5maWxsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciB0b3BQYXJlbnQgPSB1bmZpbGxlZDtcbiAgd2hpbGUgKHRvcFBhcmVudC5nZXRQYXJlbnQoKSkge1xuICAgIHRvcFBhcmVudCA9IHRvcFBhcmVudC5nZXRQYXJlbnQoKTtcbiAgfVxuXG4gIGlmICh1bmZpbGxlZC50eXBlID09PSB0b3BMZXZlbFR5cGUpIHtcbiAgICByZXR1cm4gbXNnLmVtcHR5VG9wTGV2ZWxCbG9jayh7dG9wTGV2ZWxCbG9ja05hbWU6IHVuZmlsbGVkLmdldFRpdGxlVmFsdWUoKX0pO1xuICB9XG5cbiAgaWYgKHRvcFBhcmVudC50eXBlICE9PSAnZnVuY3Rpb25hbF9kZWZpbml0aW9uJykge1xuICAgIHJldHVybiBtc2cuZW1wdHlGdW5jdGlvbmFsQmxvY2soKTtcbiAgfVxuXG4gIHZhciBwcm9jZWR1cmVJbmZvID0gdG9wUGFyZW50LmdldFByb2NlZHVyZUluZm8oKTtcbiAgaWYgKHRvcFBhcmVudC5pc1ZhcmlhYmxlKCkpIHtcbiAgICByZXR1cm4gbXNnLmVtcHR5QmxvY2tJblZhcmlhYmxlKHtuYW1lOiBwcm9jZWR1cmVJbmZvLm5hbWV9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbXNnLmVtcHR5QmxvY2tJbkZ1bmN0aW9uKHtuYW1lOiBwcm9jZWR1cmVJbmZvLm5hbWV9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBMb29rcyBmb3IgZmFpbGluZyBleGFtcGxlcywgYW5kIHVwZGF0ZXMgdGhlIHJlc3VsdCB0ZXh0IGZvciB0aGVtIGlmIHRoZXkncmVcbiAqIG9wZW4gaW4gdGhlIGNvbnRyYWN0IGVkaXRvclxuICogQHBhcmFtIHtmdW5jdGlvbn0gZmFpbHVyZUNoZWNrZXIgQXBwcyBleGFtcGxlIHRlc3RlciB0aGF0IHRha2VzIGluIGFuIGV4YW1wbGVcbiAqICAgYmxvY2ssIGFuZCBvdXRwdXRzIGEgZmFpbHVyZSBzdHJpbmcgKG9yIG51bGwgaWYgc3VjY2VzcylcbiAqIEByZXR1cm5zIHtzdHJpbmd9IE5hbWUgb2YgYmxvY2sgY29udGFpbmluZyBmaXJzdCBmYWlsaW5nIGV4YW1wbGUgd2UgZm91bmQsIG9yXG4gKiAgIGVtcHR5IHN0cmluZyBpZiBubyBmYWlsdXJlcy5cbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5jaGVja0ZvckZhaWxpbmdFeGFtcGxlcyA9IGZ1bmN0aW9uIChmYWlsdXJlQ2hlY2tlcikge1xuICB2YXIgZmFpbGluZ0Jsb2NrTmFtZSA9ICcnO1xuICBCbG9ja2x5Lm1haW5CbG9ja1NwYWNlLmZpbmRGdW5jdGlvbkV4YW1wbGVzKCkuZm9yRWFjaChmdW5jdGlvbiAoZXhhbXBsZUJsb2NrKSB7XG4gICAgdmFyIGZhaWx1cmUgPSBmYWlsdXJlQ2hlY2tlcihleGFtcGxlQmxvY2ssIGZhbHNlKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgZXhhbXBsZSByZXN1bHQuIE5vLW9wIGlmIHdlJ3JlIG5vdCBjdXJyZW50bHkgZWRpdGluZyB0aGlzXG4gICAgLy8gZnVuY3Rpb24uXG4gICAgQmxvY2tseS5jb250cmFjdEVkaXRvci51cGRhdGVFeGFtcGxlUmVzdWx0KGV4YW1wbGVCbG9jaywgZmFpbHVyZSk7XG5cbiAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgZmFpbGluZ0Jsb2NrTmFtZSA9IGV4YW1wbGVCbG9jay5nZXRJbnB1dFRhcmdldEJsb2NrKCdBQ1RVQUwnKVxuICAgICAgICAuZ2V0VGl0bGVWYWx1ZSgnTkFNRScpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmYWlsaW5nQmxvY2tOYW1lO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB3ZSBoYXZlIGEgZnVuY3Rpb24gb3IgdmFyaWFibGUgbmFtZWQgXCJcIiAoZW1wdHkgc3RyaW5nKVxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLmhhc0VtcHR5RnVuY3Rpb25PclZhcmlhYmxlTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIEJsb2NrbHkubWFpbkJsb2NrU3BhY2UuZ2V0VG9wQmxvY2tzKCkuc29tZShmdW5jdGlvbiAoYmxvY2spIHtcbiAgICBpZiAoYmxvY2sudHlwZSAhPT0gJ2Z1bmN0aW9uYWxfZGVmaW5pdGlvbicpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gIShibG9jay5nZXRQcm9jZWR1cmVJbmZvKCkubmFtZSk7XG4gIH0pO1xufTtcblxuU3R1ZGlvQXBwLnByb3RvdHlwZS5jcmVhdGVDb29yZGluYXRlR3JpZEJhY2tncm91bmQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgc3ZnTmFtZSA9IG9wdGlvbnMuc3ZnO1xuICB2YXIgb3JpZ2luID0gb3B0aW9ucy5vcmlnaW47XG4gIHZhciBmaXJzdExhYmVsID0gb3B0aW9ucy5maXJzdExhYmVsO1xuICB2YXIgbGFzdExhYmVsID0gb3B0aW9ucy5sYXN0TGFiZWw7XG4gIHZhciBpbmNyZW1lbnQgPSBvcHRpb25zLmluY3JlbWVudDtcblxuICB2YXIgQ0FOVkFTX0hFSUdIVCA9IDQwMDtcbiAgdmFyIENBTlZBU19XSURUSCA9IDQwMDtcblxuICB2YXIgc3ZnID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc3ZnTmFtZSk7XG5cbiAgdmFyIGJib3gsIHRleHQsIHJlY3Q7XG4gIGZvciAodmFyIGxhYmVsID0gZmlyc3RMYWJlbDsgbGFiZWwgPD0gbGFzdExhYmVsOyBsYWJlbCArPSBpbmNyZW1lbnQpIHtcbiAgICAvLyBjcmVhdGUgeCBheGlzIGxhYmVsc1xuICAgIHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3RleHQnKTtcbiAgICB0ZXh0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsKSk7XG4gICAgc3ZnLmFwcGVuZENoaWxkKHRleHQpO1xuICAgIGJib3ggPSB0ZXh0LmdldEJCb3goKTtcbiAgICB0ZXh0LnNldEF0dHJpYnV0ZSgneCcsIGxhYmVsIC0gb3JpZ2luIC0gYmJveC53aWR0aCAvIDIpO1xuICAgIHRleHQuc2V0QXR0cmlidXRlKCd5JywgQ0FOVkFTX0hFSUdIVCk7XG4gICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ2ZvbnQtd2VpZ2h0JywgJ2JvbGQnKTtcbiAgICByZWN0ID0gcmVjdEZyb21FbGVtZW50Qm91bmRpbmdCb3godGV4dCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnd2hpdGUnKTtcbiAgICBzdmcuaW5zZXJ0QmVmb3JlKHJlY3QsIHRleHQpO1xuXG4gICAgLy8gY3JlYXRlIHkgYXhpcyBsYWJlbHNcbiAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICd0ZXh0Jyk7XG4gICAgdGV4dC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsYWJlbCkpO1xuICAgIHN2Zy5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICBiYm94ID0gdGV4dC5nZXRCQm94KCk7XG4gICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ3gnLCAwKTtcbiAgICB0ZXh0LnNldEF0dHJpYnV0ZSgneScsIENBTlZBU19IRUlHSFQgLSAobGFiZWwgLSBvcmlnaW4pKTtcbiAgICB0ZXh0LnNldEF0dHJpYnV0ZSgnZG9taW5hbnQtYmFzZWxpbmUnLCAnY2VudHJhbCcpO1xuICAgIHRleHQuc2V0QXR0cmlidXRlKCdmb250LXdlaWdodCcsICdib2xkJyk7XG4gICAgcmVjdCA9IHJlY3RGcm9tRWxlbWVudEJvdW5kaW5nQm94KHRleHQpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlKCdmaWxsJywgJ3doaXRlJyk7XG4gICAgc3ZnLmluc2VydEJlZm9yZShyZWN0LCB0ZXh0KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVjdEZyb21FbGVtZW50Qm91bmRpbmdCb3goZWxlbWVudCkge1xuICB2YXIgYmJveCA9IGVsZW1lbnQuZ2V0QkJveCgpO1xuICB2YXIgcmVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAncmVjdCcpO1xuICByZWN0LnNldEF0dHJpYnV0ZSgneCcsIGJib3gueCk7XG4gIHJlY3Quc2V0QXR0cmlidXRlKCd5JywgYmJveC55KTtcbiAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgYmJveC53aWR0aCk7XG4gIHJlY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBiYm94LmhlaWdodCk7XG4gIHJldHVybiByZWN0O1xufVxuXG4vKipcbiAqIERpc3BsYXlzIGEgc21hbGwgYWxlcnQgYm94IGluc2lkZSBET00gZWxlbWVudCBhdCBwYXJlbnRTZWxlY3Rvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRTZWxlY3RvclxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIEEgc2V0IG9mIFJlYWN0IHByb3BlcnRpZXMgcGFzc2VkIHRvIHRoZSBBYnVzZUVycm9yXG4gKiAgIGNvbXBvbmVudFxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLmRpc3BsYXlBbGVydCA9IGZ1bmN0aW9uIChwYXJlbnRTZWxlY3RvciwgcHJvcHMpIHtcbiAgLy8gRWFjaCBwYXJlbnQgaXMgYXNzdW1lZCB0byBoYXZlIGF0IG1vc3QgYSBzaW5nbGUgYWxlcnQuIFRoaXMgYXNzdW1wdGlvblxuICAvLyBjb3VsZCBiZSBjaGFuZ2VkLCBidXQgd2Ugd291bGQgdGhlbiB3YW50IHRvIGNsZWFuIHVwIG91ciBET00gZWxlbWVudCBvblxuICAvLyBjbG9zZVxuICB2YXIgcGFyZW50ID0gJChwYXJlbnRTZWxlY3Rvcik7XG4gIHZhciBjb250YWluZXIgPSBwYXJlbnQuY2hpbGRyZW4oJy5yZWFjdC1hbGVydCcpO1xuICBpZiAoY29udGFpbmVyLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnRhaW5lciA9ICQoXCI8ZGl2IGNsYXNzPSdyZWFjdC1hbGVydCcvPlwiKTtcbiAgICBwYXJlbnQuYXBwZW5kKGNvbnRhaW5lcik7XG4gIH1cblxuICB2YXIgcmVhY3RQcm9wcyA9ICQuZXh0ZW5kKHt9LCB7XG4gICAgY2xhc3NOYW1lOiAnYWxlcnQtZXJyb3InLFxuICAgIG9uQ2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIFJlYWN0LnVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyWzBdKTtcbiAgICB9XG4gIH0sIHByb3BzKTtcblxuICB2YXIgZWxlbWVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoQWxlcnQsIHJlYWN0UHJvcHMpO1xuICBSZWFjdERPTS5yZW5kZXIoZWxlbWVudCwgY29udGFpbmVyWzBdKTtcbn07XG5cbi8qKlxuICogSWYgdGhlIGN1cnJlbnQgcHJvamVjdCBpcyBjb25zaWRlcmVkIGFidXNpdmUsIGRpc3BsYXkgYSBzbWFsbCBhbGVydCBib3hcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRTZWxlY3RvciBUaGUgc2VsZWN0b3IgZm9yIHRoZSBET00gZWxlbWVudCBwYXJlbnQgd2VcbiAqICAgc2hvdWxkIGRpc3BsYXkgdGhlIGVycm9yIGluLlxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLmFsZXJ0SWZBYnVzaXZlUHJvamVjdCA9IGZ1bmN0aW9uIChwYXJlbnRTZWxlY3Rvcikge1xuICBpZiAod2luZG93LmRhc2hib2FyZCAmJiBkYXNoYm9hcmQucHJvamVjdC5leGNlZWRzQWJ1c2VUaHJlc2hvbGQoKSkge1xuICAgIHRoaXMuZGlzcGxheUFsZXJ0KHBhcmVudFNlbGVjdG9yLCB7XG4gICAgICBib2R5OiBSZWFjdC5jcmVhdGVFbGVtZW50KGRhc2hib2FyZC5BYnVzZUVycm9yLCB7XG4gICAgICAgIGkxOG46IHtcbiAgICAgICAgICB0b3M6IHdpbmRvdy5kYXNoYm9hcmQuaTE4bi50KCdwcm9qZWN0LmFidXNlLnRvcycpLFxuICAgICAgICAgIGNvbnRhY3RfdXM6IHdpbmRvdy5kYXNoYm9hcmQuaTE4bi50KCdwcm9qZWN0LmFidXNlLmNvbnRhY3RfdXMnKVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHRvcDogNDUsXG4gICAgICAgIGxlZnQ6IDM1MCxcbiAgICAgICAgcmlnaHQ6IDUwXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogU2VhcmNoZXMgZm9yIGNhc2VzIHdoZXJlIHdlIGhhdmUgdHdvIChvciBtb3JlKSBuZXN0ZWQgZm9yIGxvb3BzIGluIHdoaWNoXG4gKiBib3RoIGxvb3BzIHVzZSB0aGUgc2FtZSB2YXJpYWJsZS4gVGhpcyBjYW4gY2F1c2UgaW5maW5pdGUgbG9vcHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB3ZSBkZXRlY3QgYW4gaW5zdGFuY2Ugb2YgdGhpcy5cbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5oYXNEdXBsaWNhdGVWYXJpYWJsZXNJbkZvckxvb3BzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5lZGl0Q29kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gQmxvY2tseS5tYWluQmxvY2tTcGFjZS5nZXRBbGxCbG9ja3MoKS5zb21lKHRoaXMuZm9yTG9vcEhhc0R1cGxpY2F0ZWROZXN0ZWRWYXJpYWJsZXNfKTtcbn07XG5cbi8qKlxuICogTG9va3MgdG8gc2VlIGlmIGEgcGFydGljdWxhciBibG9jayBpcyAoYSkgYSBmb3IgbG9vcCBhbmQgKGIpIGhhcyBhIGRlc2NlbmRhbnRcbiAqIGZvciBsb29wIHVzaW5nIHRoZSBzYW1lIHZhcmlhYmxlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhhdCBpcyB0cnVlIG9mIHRoaXMgYmxvY2tcbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5mb3JMb29wSGFzRHVwbGljYXRlZE5lc3RlZFZhcmlhYmxlc18gPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgaWYgKCFibG9jayB8fCBibG9jay50eXBlICE9PSAnY29udHJvbHNfZm9yJyAmJlxuICAgICAgYmxvY2sudHlwZSAhPT0gJ2NvbnRyb2xzX2Zvcl9jb3VudGVyJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpbm5lckJsb2NrID0gYmxvY2suZ2V0SW5wdXQoJ0RPJykuY29ubmVjdGlvbi50YXJnZXRCbG9jaygpO1xuXG4gIC8vIE5vdCB0aGUgbW9zdCBlZmZpY2llbnQgb2YgYWxnbydzLCBidXQgd2Ugc2hvdWxkbid0IGhhdmUgZW5vdWdoIGJsb2NrcyBmb3JcbiAgLy8gaXQgdG8gbWF0dGVyLlxuICByZXR1cm4gYmxvY2suZ2V0VmFycygpLnNvbWUoZnVuY3Rpb24gKHZhck5hbWUpIHtcbiAgICByZXR1cm4gaW5uZXJCbG9jay5nZXREZXNjZW5kYW50cygpLnNvbWUoZnVuY3Rpb24gKGRlc2NlbmRhbnQpIHtcbiAgICAgIGlmIChkZXNjZW5kYW50LnR5cGUgIT09ICdjb250cm9sc19mb3InICYmXG4gICAgICAgICAgZGVzY2VuZGFudC50eXBlICE9PSAnY29udHJvbHNfZm9yX2NvdW50ZXInKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNjZW5kYW50LmdldFZhcnMoKS5pbmRleE9mKHZhck5hbWUpICE9PSAtMTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFBvbGlzaGVzIHRoZSBnZW5lcmF0ZWQgY29kZSBzdHJpbmcgYmVmb3JlIGRpc3BsYXlpbmcgaXQgdG8gdGhlIHVzZXIuIElmIHRoZVxuICogYXBwIHByb3ZpZGVkIGEgcG9saXNoQ29kZUhvb2sgZnVuY3Rpb24sIGl0IHdpbGwgYmUgY2FsbGVkLlxuICogQHJldHVybnMge3N0cmluZ30gY29kZSBzdHJpbmcgdGhhdCBtYXkvbWF5IG5vdCBoYXZlIGJlZW4gbW9kaWZpZWRcbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5wb2xpc2hHZW5lcmF0ZWRDb2RlU3RyaW5nID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgaWYgKHRoaXMucG9saXNoQ29kZUhvb2spIHtcbiAgICByZXR1cm4gdGhpcy5wb2xpc2hDb2RlSG9vayhjb2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29kZTtcbiAgfVxufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eW2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oW2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCFpc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55IGNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHRoZSBwYXJ0IG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXMgbm9uIEFTQ0lJIGNoYXJhY3RlcnMuIEkuZS4gaXQgZG9zZW50IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgaW4gQVNDSUkuXG4gICAgICB2YXIgZG9tYWluQXJyYXkgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KCcuJyk7XG4gICAgICB2YXIgbmV3T3V0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbWFpbkFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzID0gZG9tYWluQXJyYXlbaV07XG4gICAgICAgIG5ld091dC5wdXNoKHMubWF0Y2goL1teQS1aYS16MC05Xy1dLykgP1xuICAgICAgICAgICAgJ3huLS0nICsgcHVueWNvZGUuZW5jb2RlKHMpIDogcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmhvc3RuYW1lID0gbmV3T3V0LmpvaW4oJy4nKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKGlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIGlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmIChpc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgT2JqZWN0LmtleXModGhpcykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgcmVzdWx0W2tdID0gdGhpc1trXTtcbiAgfSwgdGhpcyk7XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICBPYmplY3Qua2V5cyhyZWxhdGl2ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICBpZiAoayAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgfSk7XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgT2JqZWN0LmtleXMocmVsYXRpdmUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIWlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCkgJiYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fFxuICAgICAgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIWlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gIGFyZyA9PSBudWxsO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjMuMiBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4zLjInLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIm1vZHVsZS5leHBvcnRzPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24gYW5vbnltb3VzKGxvY2FscywgZmlsdGVycywgZXNjYXBlXG4vKiovKSB7XG5lc2NhcGUgPSBlc2NhcGUgfHwgZnVuY3Rpb24gKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xudmFyIGJ1ZiA9IFtdO1xud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyBcbiBidWYucHVzaCgnJyk7MTsgdmFyIG1zZyA9IHJlcXVpcmUoJy4uL2xvY2FsZScpIDsgYnVmLnB1c2goJ1xcblxcbjxkaXYgaWQ9XCJtYWtlLXlvdXItb3duXCI+XFxuXFxuICA8aDE+PGEgaHJlZj0nLCBlc2NhcGUoKDUsICBkYXRhLm1ha2VVcmwgKSksICc+JywgZXNjYXBlKCg1LCAgZGF0YS5tYWtlU3RyaW5nICkpLCAnPC9hPjwvaDE+XFxuICA8YSBocmVmPScsIGVzY2FwZSgoNiwgIGRhdGEubWFrZVVybCApKSwgJz48aW1nIHNyYz0nLCBlc2NhcGUoKDYsICBkYXRhLm1ha2VJbWFnZSApKSwgJz48L2E+XFxuXFxuPC9kaXY+XFxuJyk7IH0pKCk7XG59IFxucmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG4gIHJldHVybiBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICByZXR1cm4gdChsb2NhbHMsIHJlcXVpcmUoXCJlanNcIikuZmlsdGVycyk7XG4gIH1cbn0oKSk7IiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCcnKTsxOyB2YXIgbXNnID0gcmVxdWlyZSgnLi4vbG9jYWxlJykgOyBidWYucHVzaCgnXFxuXFxuJyk7MzsgdmFyIHJvb3QgPSBsb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBsb2NhdGlvbi5ob3N0LnJlcGxhY2UoJ2xlYXJuXFwuJywgJycpLnJlcGxhY2UoJ3N0dWRpb1xcLicsICcnKTsgXG47IGJ1Zi5wdXNoKCdcXG5cXG48ZGl2IGlkPVwibGVhcm5cIj5cXG5cXG4gIDxoMT48YSBocmVmPVwiJywgZXNjYXBlKCg3LCAgcm9vdCApKSwgJ1wiPicsIGVzY2FwZSgoNywgIG1zZy53YW50VG9MZWFybigpICkpLCAnPC9hPjwvaDE+XFxuICA8YSBocmVmPVwiJywgZXNjYXBlKCg4LCAgcm9vdCApKSwgJ1wiPjxpbWcgaWQ9XCJsZWFybi10by1jb2RlXCIgc3JjPVwiJywgZXNjYXBlKCg4LCAgYXNzZXRVcmwoJ21lZGlhL3Byb21vLnBuZycpICkpLCAnXCI+PC9hPlxcbiAgPGEgaHJlZj1cIicsIGVzY2FwZSgoOSwgIHJvb3QgKSksICdcIj4nLCBlc2NhcGUoKDksICBtc2cud2F0Y2hWaWRlbygpICkpLCAnPC9hPlxcbiAgPGEgaHJlZj1cIicsIGVzY2FwZSgoMTAsICByb290ICkpLCAnXCI+JywgZXNjYXBlKCgxMCwgIG1zZy50cnlIT0MoKSApKSwgJzwvYT5cXG4gIDxhIGhyZWY9XCInLCBlc2NhcGUoKDExLCAgbG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgbG9jYXRpb24uaG9zdCBcbikpLCAnXCI+JywgZXNjYXBlKCgxMSwgIG1zZy5zaWdudXAoKSApKSwgJzwvYT5cXG5cXG48L2Rpdj5cXG4nKTsgfSkoKTtcbn0gXG5yZXR1cm4gYnVmLmpvaW4oJycpO1xufTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxvY2Fscykge1xuICAgIHJldHVybiB0KGxvY2FscywgcmVxdWlyZShcImVqc1wiKS5maWx0ZXJzKTtcbiAgfVxufSgpKTsiLCJtb2R1bGUuZXhwb3J0cz0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IGZ1bmN0aW9uIGFub255bW91cyhsb2NhbHMsIGZpbHRlcnMsIGVzY2FwZVxuLyoqLykge1xuZXNjYXBlID0gZXNjYXBlIHx8IGZ1bmN0aW9uIChodG1sKXtcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxuICAgIC5yZXBsYWNlKC8mKD8hXFx3KzspL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufTtcbnZhciBidWYgPSBbXTtcbndpdGggKGxvY2FscyB8fCB7fSkgeyAoZnVuY3Rpb24oKXsgXG4gYnVmLnB1c2goJzxkaXY+PHNwYW4+SW5zdHJ1Y3Rpb25zOiA8L3NwYW4+PHRleHRhcmVhIHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImluc3RydWN0aW9uc1wiPjwvdGV4dGFyZWE+PC9kaXY+XFxuPGRpdj48c3Bhbj5MZXZlbCBOYW1lOiA8L3NwYW4+PHRleHRhcmVhIHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImxldmVsX25hbWVcIj48L3RleHRhcmVhPjwvZGl2PlxcbjxidXR0b24gaWQ9XCJjcmVhdGUtbGV2ZWwtYnV0dG9uXCIgY2xhc3M9XCJsYXVuY2hcIj5cXG4gIENyZWF0ZSBMZXZlbFxcbjwvYnV0dG9uPlxcbjxkaXYgaWQ9XCJidWlsZGVyLWVycm9yXCI+PC9kaXY+XFxuJyk7IH0pKCk7XG59IFxucmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG4gIHJldHVybiBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICByZXR1cm4gdChsb2NhbHMsIHJlcXVpcmUoXCJlanNcIikuZmlsdGVycyk7XG4gIH1cbn0oKSk7IiwiLyogZ2xvYmFsICQgKi9cblxuXG4vKipcbiAqIFNpbXBsZSBib290LXN0cmFwcGVkIHN0eWxlIGFsZXJ0LlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgcHJvcFR5cGVzOiB7XG4gICAgYm9keTogUmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgUmVhY3QuUHJvcFR5cGVzLmVsZW1lbnRcbiAgICBdKS5pc1JlcXVpcmVkLFxuICAgIGNsYXNzTmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBzdHlsZTogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBvbkNsb3NlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0eWxlID0gJC5leHRlbmQoe30sIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgekluZGV4OiAxMDAwXG4gICAgfSwgdGhpcy5wcm9wcy5zdHlsZSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBzdHlsZT17c3R5bGV9PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17XCJhbGVydCBmYWRlIGluIFwiICsgKHRoaXMucHJvcHMuY2xhc3NOYW1lIHx8ICcnKX0+XG4gICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImFsZXJ0LWJ1dHRvbiBjbG9zZVwiXG4gICAgICAgICAgICBzdHlsZT17eyBtYXJnaW46IDAgfX0+XG4gICAgICAgICAgICA8c3BhbiBvbkNsaWNrPXt0aGlzLnByb3BzLm9uQ2xvc2V9PiZ0aW1lczs8L3NwYW4+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAge3RoaXMucHJvcHMuYm9keX1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59KTtcbiIsIi8qIGdsb2JhbHMgJCwgZGFzaGJvYXJkICovXG5cbnZhciBTZW5kVG9QaG9uZSA9IHdpbmRvdy5kYXNoYm9hcmQgPyB3aW5kb3cuZGFzaGJvYXJkLlNlbmRUb1Bob25lIDogdW5kZWZpbmVkO1xuXG52YXIgc3R5bGVzID0ge1xuICBtYWluOiB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgYm90dG9tOiAxMCxcbiAgICByaWdodDogMTAsXG4gICAgdGV4dEFsaWduOiAncmlnaHQnLFxuICAgIHRleHRTaGFkb3c6ICcjMDAwIC0xcHggLTFweCAwJyxcbiAgICBmb250OiAnMTJwdCBcIkdvdGhhbSA1clwiLCBzYW5zLXNlcmlmJyxcbiAgICBjb2xvcjogJyM4Rjk0OTknXG4gIH0sXG4gIGljb246IHtcbiAgICBmb250U2l6ZTogJzEuNWVtJ1xuICB9LFxuICBzZW5kVG9QaG9uZToge1xuICAgIGxhYmVsOiB7XG4gICAgICBmb250OiAnMTJwdCBcIkdvdGhhbSA1clwiLCBzYW5zLXNlcmlmJyxcbiAgICAgIGNvbG9yOiAnIzhGOTQ5OSdcbiAgICB9LFxuICAgIGRpdjoge1xuICAgICAgbWFyZ2luOiAwXG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogU2hvd3MgYSBwcm9tcHQgZm9yIFNlbmRUb1Bob25lLiBPbiBjbGljaywgcmVwbGFjZXMgcHJvbXB0IHdpdGggb3VyXG4gKiBTZW5kVG9QaG9uZSBjb21wb25lbnQuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBwcm9wVHlwZXM6IHtcbiAgICBjaGFubmVsSWQ6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBhcHBUeXBlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWRcbiAgfSxcblxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xpY2tlZDogZmFsc2VcbiAgICB9O1xuICB9LFxuXG4gIGhhbmRsZUNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7Y2xpY2tlZDogIXRoaXMuc3RhdGUuY2xpY2tlZH0pO1xuICAgIHJldHVybiBmYWxzZTsgLy8gc28gdGhlICMgbGluayBkb2Vzbid0IGdvIGFueXdoZXJlLlxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IHN0eWxlPXtzdHlsZXMubWFpbn0+XG4gICAgICAgIHt0aGlzLnJlbmRlclNlbmRUb1Bob25lKCl9XG4gICAgICAgIDxhIGNsYXNzTmFtZT1cIldpcmVmcmFtZVNlbmRUb1Bob25lX3NlbmQtdG8tcGhvbmUtbGlua1wiIGhyZWY9XCIjXCIgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja30+XG4gICAgICAgICAgPGkgc3R5bGU9e3N0eWxlcy5pY29ufSBjbGFzc05hbWU9XCJmYSBmYS1tb2JpbGVcIi8+IFNlZSB0aGlzIGFwcCBvbiB5b3VyIHBob25lXG4gICAgICAgIDwvYT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH0sXG5cbiAgcmVuZGVyU2VuZFRvUGhvbmU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmNsaWNrZWQpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxTZW5kVG9QaG9uZVxuICAgICAgICAgIHN0eWxlcz17c3R5bGVzLnNlbmRUb1Bob25lfVxuICAgICAgICAgIGNoYW5uZWxJZD17dGhpcy5wcm9wcy5jaGFubmVsSWR9XG4gICAgICAgICAgYXBwVHlwZT17dGhpcy5wcm9wcy5hcHBUeXBlfVxuICAgICAgICAvPlxuICAgICAgKTtcbiAgICB9XG4gIH1cbn0pO1xuIiwiLyogZ2xvYmFsIGRhc2hib2FyZCAqL1xudmFyIFZlcnNpb25Sb3cgPSByZXF1aXJlKCcuL1ZlcnNpb25Sb3cuanN4Jyk7XG52YXIgc291cmNlc0FwaSA9IHJlcXVpcmUoJy4uL2NsaWVudEFwaScpLnNvdXJjZXM7XG5cbi8qKlxuICogQSBjb21wb25lbnQgZm9yIHZpZXdpbmcgcHJvamVjdCB2ZXJzaW9uIGhpc3RvcnkuXG4gKi9cbnZhciBWZXJzaW9uSGlzdG9yeSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgcHJvcFR5cGVzOiB7XG4gICAgaGFuZGxlQ2xlYXJQdXp6bGU6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybnMge3tzdGF0dXNNZXNzYWdlOiBzdHJpbmcsIHZlcnNpb25zOiAobnVsbHx7XG4gICAqICAgbGFzdE1vZGlmaWVkOiBEYXRlLFxuICAgKiAgIGlzTGF0ZXN0OiBib29sZWFuLFxuICAgKiAgIHZlcnNpb25JZDogc3RyaW5nXG4gICAqIH1bXSl9fVxuICAgKi9cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnNpb25zOiBudWxsLFxuICAgICAgc3RhdHVzTWVzc2FnZTogJycsXG4gICAgICBzaG93U3Bpbm5lcjogdHJ1ZSxcbiAgICAgIGNvbmZpcm1pbmdDbGVhclB1enpsZTogZmFsc2VcbiAgICB9O1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE86IFVzZSBEYXZlJ3MgY2xpZW50IGFwaSB3aGVuIGl0J3MgZmluaXNoZWQuXG4gICAgc291cmNlc0FwaS5hamF4KCdHRVQnLCAnbWFpbi5qc29uL3ZlcnNpb25zJywgdGhpcy5vblZlcnNpb25MaXN0UmVjZWl2ZWQsIHRoaXMub25BamF4RmFpbHVyZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGxlZCBhZnRlciB0aGUgY29tcG9uZW50IG1vdW50cywgd2hlbiB0aGUgc2VydmVyIHJlc3BvbmRzIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgbGlzdCBvZiB2ZXJzaW9ucy5cbiAgICogQHBhcmFtIHhoclxuICAgKi9cbiAgb25WZXJzaW9uTGlzdFJlY2VpdmVkOiBmdW5jdGlvbiAoeGhyKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7dmVyc2lvbnM6IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCksIHNob3dTcGlubmVyOiBmYWxzZX0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsZWQgaWYgdGhlIHNlcnZlciByZXNwb25kcyB3aXRoIGFuIGVycm9yIHdoZW4gbG9hZGluZyBhbiBBUEkgcmVxdWVzdC5cbiAgICovXG4gIG9uQWpheEZhaWx1cmU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtzdGF0dXNNZXNzYWdlOiAnQW4gZXJyb3Igb2NjdXJyZWQuJ30pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgc2VydmVyIHJlc3BvbmRzIHRvIGEgcmVxdWVzdCB0byByZXN0b3JlIGEgcHJldmlvdXMgdmVyc2lvbi5cbiAgICovXG4gIG9uUmVzdG9yZVN1Y2Nlc3M6IGZ1bmN0aW9uICgpIHtcbiAgICBsb2NhdGlvbi5yZWxvYWQoKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIHVzZXIgY2hvb3NlcyBhIHByZXZpb3VzIHZlcnNpb24gdG8gcmVzdG9yZS5cbiAgICogQHBhcmFtIHZlcnNpb25JZFxuICAgKi9cbiAgb25DaG9vc2VWZXJzaW9uOiBmdW5jdGlvbiAodmVyc2lvbklkKSB7XG4gICAgLy8gVE9ETzogVXNlIERhdmUncyBjbGllbnQgYXBpIHdoZW4gaXQncyBmaW5pc2hlZC5cbiAgICBzb3VyY2VzQXBpLmFqYXgoJ1BVVCcsICdtYWluLmpzb24vcmVzdG9yZT92ZXJzaW9uPScgKyB2ZXJzaW9uSWQsIHRoaXMub25SZXN0b3JlU3VjY2VzcywgdGhpcy5vbkFqYXhGYWlsdXJlKTtcblxuICAgIC8vIFNob3cgdGhlIHNwaW5uZXIuXG4gICAgdGhpcy5zZXRTdGF0ZSh7c2hvd1NwaW5uZXI6IHRydWV9KTtcbiAgfSxcblxuICBvbkNvbmZpcm1DbGVhclB1enpsZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe2NvbmZpcm1pbmdDbGVhclB1enpsZTogdHJ1ZX0pO1xuICB9LFxuXG4gIG9uQ2FuY2VsQ2xlYXJQdXp6bGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtjb25maXJtaW5nQ2xlYXJQdXp6bGU6IGZhbHNlfSk7XG4gIH0sXG5cbiAgb25DbGVhclB1enpsZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe3Nob3dTcGlubmVyOiB0cnVlfSk7XG4gICAgdGhpcy5wcm9wcy5oYW5kbGVDbGVhclB1enpsZSgpO1xuICAgIGRhc2hib2FyZC5wcm9qZWN0LnNhdmUoZnVuY3Rpb24gKCkge1xuICAgICAgbG9jYXRpb24ucmVsb2FkKCk7XG4gICAgfSwgdHJ1ZSk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJvZHk7XG4gICAgaWYgKHRoaXMuc3RhdGUuc2hvd1NwaW5uZXIpIHtcbiAgICAgIGJvZHkgPSAoXG4gICAgICAgICAgPGRpdiBzdHlsZT17e21hcmdpbjogJzFlbSAwJywgdGV4dEFsaWduOiAnY2VudGVyJ319PlxuICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwiZmEgZmEtc3Bpbm5lciBmYS1zcGluXCIgc3R5bGU9e3tmb250U2l6ZTogJzMycHgnfX0+PC9pPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuY29uZmlybWluZ0NsZWFyUHV6emxlKSB7XG4gICAgICBib2R5ID0gKFxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxwPkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBjbGVhciBhbGwgcHJvZ3Jlc3MgZm9yIHRoaXMgbGV2ZWwmIzYzOzwvcD5cbiAgICAgICAgICA8YnV0dG9uIGlkPVwiY29uZmlybS1idXR0b25cIiBzdHlsZT17e2Zsb2F0OiAncmlnaHQnfX0gb25DbGljaz17dGhpcy5vbkNsZWFyUHV6emxlfT5TdGFydCBPdmVyPC9idXR0b24+XG4gICAgICAgICAgPGJ1dHRvbiBpZD1cImFnYWluLWJ1dHRvblwiIG9uQ2xpY2s9e3RoaXMub25DYW5jZWxDbGVhclB1enpsZX0+Q2FuY2VsPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJvd3MgPSB0aGlzLnN0YXRlLnZlcnNpb25zLm1hcChmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICByZXR1cm4gPFZlcnNpb25Sb3dcbiAgICAgICAgICBrZXk9e3ZlcnNpb24udmVyc2lvbklkfVxuICAgICAgICAgIGxhc3RNb2RpZmllZD17bmV3IERhdGUodmVyc2lvbi5sYXN0TW9kaWZpZWQpfVxuICAgICAgICAgIGlzTGF0ZXN0PXt2ZXJzaW9uLmlzTGF0ZXN0fVxuICAgICAgICAgIG9uQ2hvb3NlPXt0aGlzLm9uQ2hvb3NlVmVyc2lvbi5iaW5kKHRoaXMsIHZlcnNpb24udmVyc2lvbklkKX0gLz47XG4gICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICBib2R5ID0gKFxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxkaXYgc3R5bGU9e3ttYXhIZWlnaHQ6ICczMzBweCcsIG92ZXJmbG93WDogJ3Njcm9sbCcsIG1hcmdpbjogJzFlbSAwJ319PlxuICAgICAgICAgICAgPHRhYmxlIHN0eWxlPXt7d2lkdGg6ICcxMDAlJ319PlxuICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAge3Jvd3N9XG4gICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICAgICAgICA8cCBzdHlsZT17e21hcmdpbjogMH19PkluaXRpYWwgdmVyc2lvbjwvcD5cbiAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICA8dGQgd2lkdGg9XCIyNTBcIiBzdHlsZT17e3RleHRBbGlnbjogJ3JpZ2h0J319PlxuICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJidG4tZGFuZ2VyXCIgb25DbGljaz17dGhpcy5vbkNvbmZpcm1DbGVhclB1enpsZX0gc3R5bGU9e3tmbG9hdDogJ3JpZ2h0J319PlxuICAgICAgICAgICAgICAgICAgICBEZWxldGUgUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsLWNvbnRlbnRcIiBzdHlsZT17e21hcmdpbjogMH19PlxuICAgICAgICA8cCBjbGFzc05hbWU9XCJkaWFsb2ctdGl0bGVcIj5WZXJzaW9uIEhpc3Rvcnk8L3A+XG4gICAgICAgIHtib2R5fVxuICAgICAgICB7dGhpcy5zdGF0ZS5zdGF0dXNNZXNzYWdlfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFZlcnNpb25IaXN0b3J5O1xuIiwiLyogZ2xvYmFscyAkICovXG5cblxuLyoqXG4gKiBBIHNpbmdsZSByb3cgaW4gdGhlIFZlcnNpb25IaXN0b3J5IGRpYWxvZywgZGVzY3JpYmluZyBvbmUgdmVyc2lvbiBvZiBhIHByb2plY3QuXG4gKi9cbnZhciBWZXJzaW9uUm93ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBwcm9wVHlwZXM6IHtcbiAgICBsYXN0TW9kaWZpZWQ6IFJlYWN0LlByb3BUeXBlcy5pbnN0YW5jZU9mKERhdGUpLFxuICAgIGlzTGF0ZXN0OiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvbkNob29zZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbiAgfSxcblxuICBnZXRMYXN0TW9kaWZpZWRUaW1lc3RhbXA6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGltZXN0YW1wID0gdGhpcy5wcm9wcy5sYXN0TW9kaWZpZWQ7XG4gICAgaWYgKHRpbWVzdGFtcC50b0xvY2FsZVN0cmluZykge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcC50b0xvY2FsZVN0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gdGltZXN0YW1wLnRvU3RyaW5nKCk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJ1dHRvbjtcbiAgICBpZiAodGhpcy5wcm9wcy5pc0xhdGVzdCkge1xuICAgICAgYnV0dG9uID0gPGJ1dHRvbiBjbGFzc05hbWU9XCJidG4tZGVmYXVsdFwiIGRpc2FibGVkPVwiZGlzYWJsZWRcIiBzdHlsZT17e2N1cnNvcjogXCJkZWZhdWx0XCJ9fT5DdXJyZW50IFZlcnNpb248L2J1dHRvbj47XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1dHRvbiA9IDxidXR0b24gY2xhc3NOYW1lPVwiYnRuLWluZm9cIiBvbkNsaWNrPXt0aGlzLnByb3BzLm9uQ2hvb3NlfT5cbiAgICAgICAgUmVzdG9yZSB0aGlzIFZlcnNpb25cbiAgICAgIDwvYnV0dG9uPjtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPHRyIGNsYXNzTmFtZT1cInZlcnNpb25Sb3dcIj5cbiAgICAgICAgPHRkPlxuICAgICAgICAgIDxwPlNhdmVkIDx0aW1lIGNsYXNzTmFtZT1cInZlcnNpb25UaW1lc3RhbXBcIiBkYXRlVGltZT17dGhpcy5wcm9wcy5sYXN0TW9kaWZpZWQudG9JU09TdHJpbmcoKX0+e3RoaXMuZ2V0TGFzdE1vZGlmaWVkVGltZXN0YW1wKCl9PC90aW1lPjwvcD5cbiAgICAgICAgICB7dGhpcy5nZXRMYXN0TW9kaWZpZWRUaW1lc3RhbXAoKX1cbiAgICAgICAgPC90ZD5cbiAgICAgICAgPHRkIHdpZHRoPVwiMjUwXCIgc3R5bGU9e3t0ZXh0QWxpZ246ICdyaWdodCd9fT5cbiAgICAgICAgICB7YnV0dG9ufVxuICAgICAgICA8L3RkPlxuICAgICAgPC90cj5cbiAgICApO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgJCgnLnZlcnNpb25UaW1lc3RhbXAnKS50aW1lYWdvKCk7XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBWZXJzaW9uUm93O1xuIiwidmFyIEluc3RydWN0aW9ucyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICBwcm9wVHlwZXM6IHtcbiAgICBwdXp6bGVUaXRsZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBpbnN0cnVjdGlvbnM6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgaW5zdHJ1Y3Rpb25zMjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICByZW5kZXJlZE1hcmtkb3duOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG1hcmtkb3duQ2xhc3NpY01hcmdpbnM6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGFuaUdpZlVSTDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBhdXRob3JlZEhpbnRzOiBSZWFjdC5Qcm9wVHlwZXMuZWxlbWVudFxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gQm9keSBsb2dpYyBpcyBhcyBmb2xsb3dzOlxuICAgIC8vXG4gICAgLy8gSWYgd2UgaGF2ZSBiZWVuIGdpdmVuIHJlbmRlcmVkIG1hcmtkb3duLCByZW5kZXIgYSBkaXYgY29udGFpbmluZ1xuICAgIC8vIHRoYXQsIG9wdGlvbmFsbHkgd2l0aCBpbmxpbmUtc3R5bGVkIG1hcmdpbnMuIFdlIGRvbid0IG5lZWQgdG9cbiAgICAvLyB3b3JyeSBhYm91dCB0aGUgdGl0bGUgaW4gdGhpcyBjYXNlLCBhcyBpdCBpcyByZW5kZXJlZCBieSB0aGVcbiAgICAvLyBEaWFsb2cgaGVhZGVyXG4gICAgLy9cbiAgICAvLyBPdGhlcndpc2UsIHJlbmRlciB0aGUgdGl0bGUgYW5kIHVwIHRvIHR3byBzZXRzIG9mIGluc3RydWN0aW9ucy5cbiAgICAvLyBUaGVzZSBpbnN0cnVjdGlvbnMgbWF5IGNvbnRhaW4gc3BhbnMgYW5kIGltYWdlcyBhcyBkZXRlcm1pbmVkIGJ5XG4gICAgLy8gU3R1ZGlvQXBwLnN1YnN0aXR1dGVJbnN0cnVjdGlvbkltYWdlc1xuICAgIHZhciBib2R5O1xuICAgIGlmICh0aGlzLnByb3BzLnJlbmRlcmVkTWFya2Rvd24pIHtcbiAgICAgIC8vIE9wdGlvbmFsbHkgZ2l2ZSBtYXJrZG93biBkaWFsb2cgd2lkZSBsZWZ0IG1hcmdpbiBzbyBpdCBsb29rcyBtb3JlIGxpa2UgYVxuICAgICAgLy8gbm9uLW1hcmtkb3duIGluc3RydWN0aW9ucyBkaWFsb2cgKHVzZWZ1bCBpZiBtaXhpbmcgbWFya2Rvd24gaW5zdHJ1Y3Rpb25zXG4gICAgICAvLyB3aXRoIG5vbi1tYXJrZG93biBpbnN0cnVjdGlvbnMgaW4gb25lIHR1dG9yaWFsKS5cbiAgICAgIHZhciBib2R5U3R5bGUgPSAodGhpcy5wcm9wcy5tYXJrZG93bkNsYXNzaWNNYXJnaW5zKSA/IHtcbiAgICAgICAgcGFkZGluZ1RvcDogMCxcbiAgICAgICAgbWFyZ2luTGVmdDogJzkwcHgnXG4gICAgICB9IDoge307XG5cbiAgICAgIGJvZHkgPSAoPGRpdiBcbiAgICAgICAgY2xhc3NOYW1lPSdpbnN0cnVjdGlvbnMtbWFya2Rvd24nXG4gICAgICAgIHN0eWxlPXsgYm9keVN0eWxlIH1cbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiB0aGlzLnByb3BzLnJlbmRlcmVkTWFya2Rvd24gfX1cbiAgICAgIC8+KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keSA9IFs8cCBrZXk9J2RpYWxvZy10aXRsZScgY2xhc3NOYW1lPSdkaWFsb2ctdGl0bGUnPnsgdGhpcy5wcm9wcy5wdXp6bGVUaXRsZSB9PC9wPl07XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLmluc3RydWN0aW9ucykge1xuICAgICAgICBib2R5LnB1c2goPHAga2V5PSdpbnN0cnVjdGlvbnMtMScgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiB0aGlzLnByb3BzLmluc3RydWN0aW9ucyB9fS8+KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHJvcHMuaW5zdHJ1Y3Rpb25zMikge1xuICAgICAgICBib2R5LnB1c2goPHAga2V5PSdpbnN0cnVjdGlvbnMtMicgY2xhc3NOYW1lPSdpbnN0cnVjdGlvbnMyJyBkYW5nZXJvdXNseVNldElubmVySFRNTD17eyBfX2h0bWw6IHRoaXMucHJvcHMuaW5zdHJ1Y3Rpb25zMiB9fS8+KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYW5pR2lmO1xuICAgIGlmICh0aGlzLnByb3BzLmFuaUdpZlVSTCkge1xuICAgICAgYW5pR2lmID0gPGltZyBjbGFzc05hbWU9XCJhbmlHaWYgZXhhbXBsZS1pbWFnZVwiIHNyYz17IHRoaXMucHJvcHMuYW5pR2lmVVJMIH0vPjtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdj5cbiAgICAgICAge2JvZHl9XG4gICAgICAgIHthbmlHaWZ9XG4gICAgICAgIHt0aGlzLnByb3BzLmF1dGhvcmVkSGludHN9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gSW5zdHJ1Y3Rpb25zO1xuIiwidmFyIFBhZ2VBY3Rpb24gPSB7XG4gIERyb3BsZXRUcmFuc2l0aW9uRXJyb3I6ICdEcm9wbGV0VHJhbnNpdGlvbkVycm9yJyxcbiAgU2FuaXRpemVkTGV2ZWxIdG1sOiAnU2FuaXRpemVkTGV2ZWxIdG1sJyxcbiAgVXNlckphdmFTY3JpcHRFcnJvcjogJ1VzZXJKYXZhU2NyaXB0RXJyb3InXG59O1xuXG52YXIgTUFYX0ZJRUxEX0xFTkdUSCA9IDQwOTU7XG5cbi8qKlxuICogU2hpbXMgd2luZG93Lm5ld3JlbGljLCB3aGljaCBpcyBvbmx5IGluY2x1ZGVkIGluIHByb2R1Y3Rpb24uIFRoaXMgY2F1c2VzIHVzXG4gKiB0byBuby1vcCBpbiBvdGhlciBlbnZpcm9ubWVudHMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBQYWdlQWN0aW9uOiBQYWdlQWN0aW9uLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uTmFtZSAtIE11c3QgYmUgb25lIG9mIHRoZSBrZXlzIGZyb20gUGFnZUFjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWUgLSBPYmplY3QgbGl0ZXJhbCByZXByZXNlbnRpbmcgY29sdW1ucyB3ZSB3YW50IHRvXG4gICAqICAgYWRkIGZvciB0aGlzIGFjdGlvblxuICAgKi9cbiAgYWRkUGFnZUFjdGlvbjogZnVuY3Rpb24gKGFjdGlvbk5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCF3aW5kb3cubmV3cmVsaWMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIVBhZ2VBY3Rpb25bYWN0aW9uTmFtZV0pIHtcbiAgICAgIGNvbnNvbGUubG9nKCdVbmtub3duIGFjdGlvbk5hbWU6ICcgKyBhY3Rpb25OYW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mKHZhbHVlKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc29sZS5sb2coJ0V4cGVjdGVkIHZhbHVlIHRvIGJlIGFuIG9iamVjdCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIHByb3AgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVbcHJvcF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbHVlW3Byb3BdID0gdmFsdWVbcHJvcF0uc3Vic3RyaW5nKDAsIE1BWF9GSUVMRF9MRU5HVEgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdpbmRvdy5uZXdyZWxpYy5hZGRQYWdlQWN0aW9uKGFjdGlvbk5hbWUsIHZhbHVlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhbiBhdHRyaWJ1dGUgdGhhdCB3aWxsIGJlIGluY2x1ZGVkIG9uIGFueSBzdWJzZXF1ZW50IGdlbmVyYXRlZCBldmVudHNcbiAgICovXG4gIHNldEN1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIXdpbmRvdy5uZXdyZWxpYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdpbmRvdy5uZXdyZWxpYy5zZXRDdXN0b21BdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gIH1cbn07XG4iLCIvKiBnbG9iYWwgdHJhY2tFdmVudCwgYXBwT3B0aW9ucyAqL1xuXG4vLyBOT1RFOiBUaGVzZSBtdXN0IGJlIGtlcHQgaW4gc3luYyB3aXRoIGFjdGl2aXR5X2hpbnQucmIgaW4gZGFzaGJvYXJkLlxudmFyIEhJTlRfUkVRVUVTVF9QTEFDRU1FTlQgPSB7XG4gIE5PTkU6IDAsICAvLyBUaGlzIHZhbHVlIG11c3Qgbm90IGJlIGNoYW5nZWQuXG4gIExFRlQ6IDEsICAvLyBIaW50IHJlcXVlc3QgYnV0dG9uIGlzIG9uIGxlZnQuXG4gIFJJR0hUOiAyICAvLyBIaW50IHJlcXVlc3QgYnV0dG9uIGlzIG9uIHJpZ2h0LlxufTtcblxuLyoqXG4gKiBCYWcgb2YgdXRpbGl0eSBmdW5jdGlvbnMgcmVsYXRlZCB0byBidWlsZGluZyBhbmQgZGlzcGxheWluZyBmZWVkYmFja1xuICogdG8gc3R1ZGVudHMuXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7U3R1ZGlvQXBwfSBzdHVkaW9BcHAgQSBzdHVkaW9BcHAgaW5zdGFuY2UgdXNlZCB0byBwdWxsXG4gKiAgIGNvbmZpZ3VyYXRpb24gYW5kIHBlcmZvcm0gb3BlcmF0aW9ucy5cbiAqL1xudmFyIEZlZWRiYWNrVXRpbHMgPSBmdW5jdGlvbiAoc3R1ZGlvQXBwKSB7XG4gIHRoaXMuc3R1ZGlvQXBwXyA9IHN0dWRpb0FwcDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IEZlZWRiYWNrVXRpbHM7XG5cbi8vIEdsb2JhbHMgdXNlZCBpbiB0aGlzIGZpbGU6XG4vLyAgIEJsb2NrbHlcblxudmFyIHRyb3BoeSA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL3Ryb3BoeS5odG1sLmVqcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIF8gPSB1dGlscy5nZXRMb2Rhc2goKTtcbnZhciBjb2RlZ2VuID0gcmVxdWlyZSgnLi9jb2RlZ2VuJyk7XG52YXIgbXNnID0gcmVxdWlyZSgnLi9sb2NhbGUnKTtcbnZhciBkb20gPSByZXF1aXJlKCcuL2RvbScpO1xudmFyIHhtbCA9IHJlcXVpcmUoJy4veG1sJyk7XG52YXIgRmVlZGJhY2tCbG9ja3MgPSByZXF1aXJlKCcuL2ZlZWRiYWNrQmxvY2tzJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbnZhciBUZXN0UmVzdWx0cyA9IGNvbnN0YW50cy5UZXN0UmVzdWx0cztcbnZhciBLZXlDb2RlcyA9IGNvbnN0YW50cy5LZXlDb2RlcztcbnZhciBwdXp6bGVSYXRpbmdVdGlscyA9IHJlcXVpcmUoJy4vcHV6emxlUmF0aW5nVXRpbHMnKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUZXN0YWJsZUJsb2NrXG4gKiBAcHJvcGVydHkge3N0cmluZ3xmdW5jdGlvbn0gdGVzdCAtIEEgdGVzdCB3aGV0aGVyIHRoZSBibG9jayBpc1xuICogICAgICAgICAgIHByZXNlbnQsIGVpdGhlcjpcbiAqICAgICAgICAgICAtIEEgc3RyaW5nLCBpbiB3aGljaCBjYXNlIHRoZSBzdHJpbmcgaXMgc2VhcmNoZWQgZm9yIGluXG4gKiAgICAgICAgICAgICB0aGUgZ2VuZXJhdGVkIGNvZGUuXG4gKiAgICAgICAgICAgLSBBIHNpbmdsZS1hcmd1bWVudCBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZWFjaCB1c2VyLWFkZGVkXG4gKiAgICAgICAgICAgICBibG9jayBpbmRpdmlkdWFsbHkuICBJZiBhbnkgY2FsbCByZXR1cm5zIHRydWUsIHRoZSBibG9ja1xuICogICAgICAgICAgICAgaXMgZGVlbWVkIHByZXNlbnQuICBcIlVzZXItYWRkZWRcIiBibG9ja3MgYXJlIG9uZXMgdGhhdCBhcmVcbiAqICAgICAgICAgICAgIG5laXRoZXIgZGlzYWJsZWQgb3IgdW5kZWxldGFibGUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIGJsb2NrIHRvIGJlIHByb2R1Y2VkIGZvclxuICogICAgICAgICAgIGRpc3BsYXkgdG8gdGhlIHVzZXIgaWYgdGhlIHRlc3QgZmFpbGVkLlxuICogQHByb3BlcnR5IHtPYmplY3R9IFt0aXRsZXNdIC0gQSBkaWN0aW9uYXJ5LCB3aGVyZSwgZm9yIGVhY2hcbiAqICAgICAgICAgICBLRVktVkFMVUUgcGFpciwgdGhpcyBpcyBhZGRlZCB0byB0aGUgYmxvY2sgZGVmaW5pdGlvbjpcbiAqICAgICAgICAgICA8dGl0bGUgbmFtZT1cIktFWVwiPlZBTFVFPC90aXRsZT4uXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3ZhbHVlXSAtIEEgZGljdGlvbmFyeSwgd2hlcmUsIGZvciBlYWNoXG4gKiAgICAgICAgICAgS0VZLVZBTFVFIHBhaXIsIHRoaXMgaXMgYWRkZWQgdG8gdGhlIGJsb2NrIGRlZmluaXRpb246XG4gKiAgICAgICAgICAgPHZhbHVlIG5hbWU9XCJLRVlcIj5WQUxVRTwvdmFsdWU+XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2V4dHJhXSAtIEEgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIGJsYWNrZWRcbiAqICAgICAgICAgICBiZXR3ZWVuIHRoZSBcImJsb2NrXCIgc3RhcnQgYW5kIGVuZCB0YWdzLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7IVRlc3RhYmxlQmxvY2tbXX0gcmVxdWlyZWRCbG9ja3MgVGhlIGJsb2NrcyB0aGF0IGFyZSByZXF1aXJlZCB0byBiZSB1c2VkIGluXG4gKiAgIHRoZSBzb2x1dGlvbiB0byB0aGlzIGxldmVsLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFJlcXVpcmVkQmxvY2tzVG9GbGFnIFRoZSBudW1iZXIgb2YgcmVxdWlyZWQgYmxvY2tzIHRvXG4gKiAgIGdpdmUgaGludHMgYWJvdXQgYXQgYW55IG9uZSB0aW1lLiAgU2V0IHRoaXMgdG8gSW5maW5pdHkgdG8gc2hvdyBhbGwuXG4gKiBAcGFyYW0geyFUZXN0YWJsZUJsb2NrW119IHJlY29tbWVuZGVkQmxvY2tzIFRoZSBibG9ja3MgdGhhdCBhcmUgcmVjb21tZW5kZWQgdG8gYmUgdXNlZCBpblxuICogICB0aGUgc29sdXRpb24gdG8gdGhpcyBsZXZlbC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhSZWNvbW1lbmRlZEJsb2Nrc1RvRmxhZyBUaGUgbnVtYmVyIG9mIHJlY29tbWVuZGVkIGJsb2NrcyB0b1xuICogICBnaXZlIGhpbnRzIGFib3V0IGF0IGFueSBvbmUgdGltZS4gIFNldCB0aGlzIHRvIEluZmluaXR5IHRvIHNob3cgYWxsLlxuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5kaXNwbGF5RmVlZGJhY2sgPSBmdW5jdGlvbihvcHRpb25zLCByZXF1aXJlZEJsb2NrcyxcbiAgICBtYXhSZXF1aXJlZEJsb2Nrc1RvRmxhZywgcmVjb21tZW5kZWRCbG9ja3MsIG1heFJlY29tbWVuZGVkQmxvY2tzVG9GbGFnKSB7XG5cbiAgb3B0aW9ucy5sZXZlbCA9IG9wdGlvbnMubGV2ZWwgfHwge307XG4gIG9wdGlvbnMubnVtVHJvcGhpZXMgPSB0aGlzLm51bVRyb3BoaWVzRWFybmVkXyhvcHRpb25zKTtcblxuICAvLyBUcmFja2luZyBldmVudCBmb3IgbGV2ZWwgbmV3bHkgY29tcGxldGVkXG4gIGlmIChvcHRpb25zLnJlc3BvbnNlICYmIG9wdGlvbnMucmVzcG9uc2UubmV3X2xldmVsX2NvbXBsZXRlZCkge1xuICAgIHRyYWNrRXZlbnQoJ1B1enpsZScsICdDb21wbGV0ZWQnLCBvcHRpb25zLnJlc3BvbnNlLmxldmVsX3BhdGgsIG9wdGlvbnMucmVzcG9uc2UubGV2ZWxfYXR0ZW1wdHMpO1xuICB9XG5cbiAgdmFyIGhhZFNoYXJlRmFpbHVyZSA9IChvcHRpb25zLnJlc3BvbnNlICYmIG9wdGlvbnMucmVzcG9uc2Uuc2hhcmVfZmFpbHVyZSk7XG4gIC8vIG9wdGlvbnMucmVzcG9uc2UubGV2ZWxfc291cmNlIGlzIHRoZSB1cmwgdGhhdCB3ZSBhcmUgc2hhcmluZzsgY2FuJ3RcbiAgLy8gc2hhcmUgd2l0aG91dCBpdFxuICB2YXIgY2FuU2hhcmUgPSBvcHRpb25zLnJlc3BvbnNlICYmIG9wdGlvbnMucmVzcG9uc2UubGV2ZWxfc291cmNlO1xuICB2YXIgc2hvd2luZ1NoYXJpbmcgPSBvcHRpb25zLnNob3dpbmdTaGFyaW5nICYmICFoYWRTaGFyZUZhaWx1cmUgJiYgY2FuU2hhcmU7XG5cbiAgdmFyIGNhbkNvbnRpbnVlID0gdGhpcy5jYW5Db250aW51ZVRvTmV4dExldmVsKG9wdGlvbnMuZmVlZGJhY2tUeXBlKTtcbiAgdmFyIGRpc3BsYXlTaG93Q29kZSA9IHRoaXMuc3R1ZGlvQXBwXy5lbmFibGVTaG93Q29kZSAmJiB0aGlzLnN0dWRpb0FwcF8uZW5hYmxlU2hvd0xpbmVzQ291bnQgJiYgY2FuQ29udGludWUgJiYgIXNob3dpbmdTaGFyaW5nO1xuICB2YXIgZmVlZGJhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIHNoYXJpbmdEaXYgPSAoY2FuQ29udGludWUgJiYgc2hvd2luZ1NoYXJpbmcpID8gdGhpcy5jcmVhdGVTaGFyaW5nRGl2KG9wdGlvbnMpIDogbnVsbDtcbiAgdmFyIHNob3dDb2RlID0gZGlzcGxheVNob3dDb2RlID8gdGhpcy5nZXRTaG93Q29kZUVsZW1lbnRfKG9wdGlvbnMpIDogbnVsbDtcbiAgdmFyIHNoYXJlRmFpbHVyZURpdiA9IGhhZFNoYXJlRmFpbHVyZSA/IHRoaXMuZ2V0U2hhcmVGYWlsdXJlXyhvcHRpb25zKSA6IG51bGw7XG4gIGlmIChoYWRTaGFyZUZhaWx1cmUpIHtcbiAgICB0cmFja0V2ZW50KCdTaGFyZScsICdGYWlsdXJlJywgb3B0aW9ucy5yZXNwb25zZS5zaGFyZV9mYWlsdXJlLnR5cGUpO1xuICB9XG4gIHZhciBmZWVkYmFja0Jsb2NrcztcbiAgaWYgKHRoaXMuc3R1ZGlvQXBwXy5pc1VzaW5nQmxvY2tseSgpKSB7XG4gICAgZmVlZGJhY2tCbG9ja3MgPSBuZXcgRmVlZGJhY2tCbG9ja3MoXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHRoaXMuZ2V0TWlzc2luZ0Jsb2Nrc18ocmVxdWlyZWRCbG9ja3MsIG1heFJlcXVpcmVkQmxvY2tzVG9GbGFnKSxcbiAgICAgICAgdGhpcy5nZXRNaXNzaW5nQmxvY2tzXyhyZWNvbW1lbmRlZEJsb2NrcywgbWF4UmVjb21tZW5kZWRCbG9ja3NUb0ZsYWcpLFxuICAgICAgICB0aGlzLnN0dWRpb0FwcF8pO1xuICB9XG4gIC8vIGZlZWRiYWNrTWVzc2FnZSBtdXN0IGJlIGluaXRpYWxpemVkIGFmdGVyIGZlZWRiYWNrQmxvY2tzXG4gIC8vIGJlY2F1c2UgRmVlZGJhY2tCbG9ja3MgY2FuIG11dGF0ZSBvcHRpb25zLnJlc3BvbnNlLmhpbnQuXG4gIHZhciBmZWVkYmFja01lc3NhZ2UgPSB0aGlzLmdldEZlZWRiYWNrTWVzc2FnZV8ob3B0aW9ucyk7XG5cbiAgaWYgKGZlZWRiYWNrTWVzc2FnZSkge1xuICAgIGZlZWRiYWNrLmFwcGVuZENoaWxkKGZlZWRiYWNrTWVzc2FnZSk7XG4gIH1cbiAgaWYgKG9wdGlvbnMubnVtVHJvcGhpZXMpIHtcbiAgICAvLyBUcmFja2luZyBldmVudCBmb3IgbmV3IHRyb3BoeSBlYXJuZWRcbiAgICBpZiAob3B0aW9ucy5udW1Ucm9waGllcyA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5udW1Ucm9waGllczsgaSsrKSB7XG4gICAgICAgIHZhciBjb25jZXB0X25hbWUgPSBvcHRpb25zLnJlc3BvbnNlLnRyb3BoeV91cGRhdGVzW2ldWzBdO1xuICAgICAgICB2YXIgdHJvcGh5X25hbWUgPSBvcHRpb25zLnJlc3BvbnNlLnRyb3BoeV91cGRhdGVzW2ldWzFdO1xuICAgICAgICB0cmFja0V2ZW50KCdUcm9waHknLCBjb25jZXB0X25hbWUsIHRyb3BoeV9uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHRyb3BoaWVzID0gdGhpcy5nZXRUcm9waGllc0VsZW1lbnRfKG9wdGlvbnMpO1xuICAgIGZlZWRiYWNrLmFwcGVuZENoaWxkKHRyb3BoaWVzKTtcbiAgfVxuICBpZiAoZmVlZGJhY2tCbG9ja3MgJiYgZmVlZGJhY2tCbG9ja3MuZGl2KSB7XG4gICAgaWYgKGZlZWRiYWNrTWVzc2FnZSAmJiB0aGlzLnVzZVNwZWNpYWxGZWVkYmFja0Rlc2lnbl8ob3B0aW9ucykpIHtcbiAgICAgIC8vIHB1dCB0aGUgYmxvY2tzIGlmcmFtZSBpbnNpZGUgdGhlIGZlZWRiYWNrTWVzc2FnZSBmb3IgdGhpcyBzcGVjaWFsIGNhc2U6XG4gICAgICBmZWVkYmFja01lc3NhZ2UuYXBwZW5kQ2hpbGQoZmVlZGJhY2tCbG9ja3MuZGl2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmVlZGJhY2suYXBwZW5kQ2hpbGQoZmVlZGJhY2tCbG9ja3MuZGl2KTtcbiAgICB9XG4gIH1cbiAgaWYgKHNoYXJpbmdEaXYpIHtcbiAgICBmZWVkYmFjay5hcHBlbmRDaGlsZChzaGFyaW5nRGl2KTtcbiAgfVxuICBpZiAoc2hvd2luZ1NoYXJpbmcpIHtcbiAgICB2YXIgc2hhcmVDb2RlU3BhY2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc2hhcmVDb2RlU3BhY2VyLmNsYXNzTmFtZSA9IFwic2hhcmUtY29kZS1zcGFjZXJcIjtcbiAgICBmZWVkYmFjay5hcHBlbmRDaGlsZChzaGFyZUNvZGVTcGFjZXIpO1xuICB9XG4gIGlmIChzaGFyZUZhaWx1cmVEaXYpIHtcbiAgICBmZWVkYmFjay5hcHBlbmRDaGlsZChzaGFyZUZhaWx1cmVEaXYpO1xuICB9XG4gIGlmIChzaG93Q29kZSkge1xuICAgIGZlZWRiYWNrLmFwcGVuZENoaWxkKHNob3dDb2RlKTtcbiAgfVxuICBpZiAob3B0aW9ucy5sZXZlbC5pc0sxKSB7XG4gICAgZmVlZGJhY2suY2xhc3NOYW1lICs9IFwiIGsxXCI7XG4gIH1cbiAgaWYgKG9wdGlvbnMuYXBwRGl2KSB7XG4gICAgZmVlZGJhY2suYXBwZW5kQ2hpbGQob3B0aW9ucy5hcHBEaXYpO1xuICB9XG5cbiAgZmVlZGJhY2suY2xhc3NOYW1lICs9IGNhbkNvbnRpbnVlID8gXCIgd2luLWZlZWRiYWNrXCIgOiBcIiBmYWlsdXJlLWZlZWRiYWNrXCI7XG5cbiAgdmFyIGZpbmFsTGV2ZWwgPSAob3B0aW9ucy5yZXNwb25zZSAmJlxuICAgIChvcHRpb25zLnJlc3BvbnNlLm1lc3NhZ2UgPT09IFwibm8gbW9yZSBsZXZlbHNcIikpO1xuXG4gIGZlZWRiYWNrLmFwcGVuZENoaWxkKFxuICAgIHRoaXMuZ2V0RmVlZGJhY2tCdXR0b25zXyh7XG4gICAgICBmZWVkYmFja1R5cGU6IG9wdGlvbnMuZmVlZGJhY2tUeXBlLFxuICAgICAgdHJ5QWdhaW5UZXh0OiBvcHRpb25zLnRyeUFnYWluVGV4dCxcbiAgICAgIGtlZXBQbGF5aW5nVGV4dDogb3B0aW9ucy5rZWVwUGxheWluZ1RleHQsXG4gICAgICBjb250aW51ZVRleHQ6IG9wdGlvbnMuY29udGludWVUZXh0LFxuICAgICAgc2hvd1ByZXZpb3VzQnV0dG9uOiBvcHRpb25zLmxldmVsLnNob3dQcmV2aW91c0xldmVsQnV0dG9uLFxuICAgICAgaXNLMTogb3B0aW9ucy5sZXZlbC5pc0sxLFxuICAgICAgZnJlZVBsYXk6IG9wdGlvbnMubGV2ZWwuZnJlZVBsYXksXG4gICAgICBmaW5hbExldmVsOiBmaW5hbExldmVsXG4gICAgfSlcbiAgKTtcblxuICB2YXIgYWdhaW5CdXR0b24gPSBmZWVkYmFjay5xdWVyeVNlbGVjdG9yKCcjYWdhaW4tYnV0dG9uJyk7XG4gIHZhciBoaW50UmVxdWVzdEJ1dHRvbiA9IGZlZWRiYWNrLnF1ZXJ5U2VsZWN0b3IoJyNoaW50LXJlcXVlc3QtYnV0dG9uJyk7XG4gIHZhciBwcmV2aW91c0xldmVsQnV0dG9uID0gZmVlZGJhY2sucXVlcnlTZWxlY3RvcignI2JhY2stYnV0dG9uJyk7XG4gIHZhciBjb250aW51ZUJ1dHRvbiA9IGZlZWRiYWNrLnF1ZXJ5U2VsZWN0b3IoJyNjb250aW51ZS1idXR0b24nKTtcblxuICB2YXIgb25seUNvbnRpbnVlID0gY29udGludWVCdXR0b24gJiYgIWFnYWluQnV0dG9uICYmICFwcmV2aW91c0xldmVsQnV0dG9uO1xuXG4gIC8vIGdldCB0aGUgdG9wbW9zdCBtaXNzaW5nIHJlY29tbWVuZGVkIGJsb2NrLCBpZiBpdCBleGlzdHMsIHRvIGJlXG4gIC8vIGFkZGVkIHRvIHRoZSBxdWV1ZSBvZiBjb250ZXh0dWFsIGhpbnRzLiBJZiB0aGUgdXNlciB2aWV3cyB0aGUgYmxvY2tcbiAgLy8gaW4gdGhlIGRpYWxvZywgbWFyayBpdCBhcyBzZWVuIGFuZCBhZGQgaXQgdG8gdGhlIGxpc3QgYXMgc3VjaC5cbiAgdmFyIG1pc3NpbmdSZWNvbW1lbmRlZEJsb2NrSGludHMgPSB0aGlzLmdldE1pc3NpbmdCbG9ja3NfKHJlY29tbWVuZGVkQmxvY2tzLCAxKVxuICAgIC5ibG9ja3NUb0Rpc3BsYXlcbiAgICAubWFwKGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgYmxvY2suYWxyZWFkeVNlZW4gPSBmYWxzZTtcbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9KTtcbiAgdmFyIG1hcmtDb250ZXh0dWFsSGludHNBc1NlZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgbWlzc2luZ1JlY29tbWVuZGVkQmxvY2tIaW50cy5maWx0ZXIoZnVuY3Rpb24gKGhpbnQpIHtcbiAgICAgIHJldHVybiBmZWVkYmFja0Jsb2NrcyAmJiBmZWVkYmFja0Jsb2Nrcy54bWwgJiYgZmVlZGJhY2tCbG9ja3MueG1sLmluZGV4T2YoaGludC5ibG9ja0Rpc3BsYXlYTUwpID4gLTE7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoaGludCkge1xuICAgICAgaGludC5hbHJlYWR5U2VlbiA9IHRydWU7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIG9uSGlkZGVuID0gb25seUNvbnRpbnVlID8gb3B0aW9ucy5vbkNvbnRpbnVlIDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3R1ZGlvQXBwXy5kaXNwbGF5TWlzc2luZ0Jsb2NrSGludHMobWlzc2luZ1JlY29tbWVuZGVkQmxvY2tIaW50cyk7XG4gIH0uYmluZCh0aGlzKTtcblxuICB2YXIgaWNvbjtcbiAgaWYgKCFvcHRpb25zLmhpZGVJY29uKSB7XG4gICAgaWNvbiA9IGNhbkNvbnRpbnVlID8gdGhpcy5zdHVkaW9BcHBfLndpbkljb24gOiB0aGlzLnN0dWRpb0FwcF8uZmFpbHVyZUljb247XG4gIH1cbiAgdmFyIGRlZmF1bHRCdG5TZWxlY3RvciA9IG9ubHlDb250aW51ZSA/ICcjY29udGludWUtYnV0dG9uJyA6ICcjYWdhaW4tYnV0dG9uJztcblxuICB2YXIgZmVlZGJhY2tEaWFsb2cgPSB0aGlzLmNyZWF0ZU1vZGFsRGlhbG9nKHtcbiAgICBEaWFsb2c6IG9wdGlvbnMuRGlhbG9nLFxuICAgIGNvbnRlbnREaXY6IGZlZWRiYWNrLFxuICAgIGljb246IGljb24sXG4gICAgZGVmYXVsdEJ0blNlbGVjdG9yOiBkZWZhdWx0QnRuU2VsZWN0b3IsXG4gICAgb25IaWRkZW46IG9uSGlkZGVuLFxuICAgIGlkOiAnZmVlZGJhY2stZGlhbG9nJ1xuICB9KTtcblxuICAvLyBVcGRhdGUgdGhlIGJhY2tncm91bmQgY29sb3IgaWYgaXQgaXMgc2V0IHRvIGJlIGluIHNwZWNpYWwgZGVzaWduLlxuICBpZiAodGhpcy51c2VTcGVjaWFsRmVlZGJhY2tEZXNpZ25fKG9wdGlvbnMpKSB7XG4gICAgaWYgKG9wdGlvbnMucmVzcG9uc2UuZGVzaWduID09IFwid2hpdGVfYmFja2dyb3VuZFwiKSB7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmVlZGJhY2stZGlhbG9nJylcbiAgICAgICAgICAuY2xhc3NOYW1lICs9IFwiIHdoaXRlLWJhY2tncm91bmRcIjtcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmZWVkYmFjay1jb250ZW50JylcbiAgICAgICAgICAuY2xhc3NOYW1lICs9IFwiIGxpZ2h0LXllbGxvdy1iYWNrZ3JvdW5kXCI7XG4gICAgfVxuICB9XG5cbiAgaWYgKGFnYWluQnV0dG9uKSB7XG4gICAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChhZ2FpbkJ1dHRvbiwgZnVuY3Rpb24oKSB7XG4gICAgICBmZWVkYmFja0RpYWxvZy5oaWRlKCk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocHJldmlvdXNMZXZlbEJ1dHRvbikge1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQocHJldmlvdXNMZXZlbEJ1dHRvbiwgZnVuY3Rpb24oKSB7XG4gICAgICBmZWVkYmFja0RpYWxvZy5oaWRlKCk7XG4gICAgICBvcHRpb25zLmJhY2tUb1ByZXZpb3VzTGV2ZWwoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGlzIGEgaGludCByZXF1ZXN0IGJ1dHRvbiwgaGlkZSB0aGUgaGludCB0aGF0IHdvdWxkIG9yZGluYXJpbHlcbiAgLy8gYmUgc2hvd24gKGluY2x1ZGluZyBhbnkgZmVlZGJhY2sgYmxvY2tzKSwgYW5kIGFkZCBjb2RlIHRvIHJlc3RvcmUgdGhlXG4gIC8vIGhpbnQgaWYgdGhlIGJ1dHRvbiBnZXRzIHByZXNzZWQuXG4gIGlmIChoaW50UmVxdWVzdEJ1dHRvbikge1xuXG4gICAgdmFyIGFscmVhZHlTZWVuID0gb3B0aW9ucy5yZXNwb25zZSAmJlxuICAgICAgICBvcHRpb25zLnJlc3BvbnNlLmhpbnRfdmlld19yZXF1ZXN0cyAmJlxuICAgICAgICBvcHRpb25zLnJlc3BvbnNlLmhpbnRfdmlld19yZXF1ZXN0cy5zb21lKGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdmFyIHJlcXVlc3RNYXRjaGVzRmVlZGJhY2sgPSByZXF1ZXN0LmZlZWRiYWNrX3R5cGUgPT09IG9wdGlvbnMuZmVlZGJhY2tUeXBlO1xuICAgICAgICAgIGlmIChmZWVkYmFja0Jsb2NrcyAmJiBmZWVkYmFja0Jsb2Nrcy54bWwpIHtcbiAgICAgICAgICAgIHJlcXVlc3RNYXRjaGVzRmVlZGJhY2sgPSByZXF1ZXN0TWF0Y2hlc0ZlZWRiYWNrICYmIHJlcXVlc3QuZmVlZGJhY2tfeG1sID09PSBmZWVkYmFja0Jsb2Nrcy54bWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXF1ZXN0TWF0Y2hlc0ZlZWRiYWNrO1xuICAgICAgICB9KTtcblxuICAgIGlmIChhbHJlYWR5U2Vlbikge1xuICAgICAgLy8gUmVtb3ZlIFwiU2hvdyBoaW50XCIgYnV0dG9uLiAgTWFraW5nIGl0IGludmlzaWJsZSBpc24ndCBlbm91Z2gsXG4gICAgICAvLyBiZWNhdXNlIGl0IHdpbGwgc3RpbGwgdGFrZSB1cCBzcGFjZS5cbiAgICAgIGhpbnRSZXF1ZXN0QnV0dG9uLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaGludFJlcXVlc3RCdXR0b24pO1xuXG4gICAgICAvLyBtYXJrIHRoZSBjb3JyZXNwb25kaW5nIGJsb2NrIGhpbnQgYXMgc2VlblxuICAgICAgbWFya0NvbnRleHR1YWxIaW50c0FzU2VlbigpO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIEdlbmVyYXRlIGEgZ2VuZXJpYyBmZWVkYmFjayBtZXNzYWdlIHRvIGRpc3BsYXkgd2hlbiB3ZSBzaG93IHRoZVxuICAgICAgLy8gZmVlZGJhY2sgYmxvY2tcbiAgICAgIHZhciBnZW5lcmljRmVlZGJhY2sgPSB0aGlzLmdldEZlZWRiYWNrTWVzc2FnZV8oe21lc3NhZ2U6IG1zZy50cnlCbG9ja3NCZWxvd0ZlZWRiYWNrKCl9KTtcblxuICAgICAgLy8gSWYgdGhlcmUgYXJlIGZlZWRiYWNrIGJsb2NrcywgdGVtcG9yYXJpbHkgaGlkZSB0aGVtLlxuICAgICAgaWYgKGZlZWRiYWNrQmxvY2tzICYmIGZlZWRiYWNrQmxvY2tzLmRpdikge1xuICAgICAgICBmZWVkYmFja0Jsb2Nrcy5oaWRlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSB1c2VyIHJlcXVlc3RzIHRoZSBoaW50Li4uXG4gICAgICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KGhpbnRSZXF1ZXN0QnV0dG9uLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG1hcmsgdGhlIGNvcnJlc3BvbmRpbmcgYmxvY2sgaGludCBhcyBzZWVuXG4gICAgICAgIG1hcmtDb250ZXh0dWFsSGludHNBc1NlZW4oKTtcblxuICAgICAgICAvLyBTd2FwIG91dCB0aGUgc3BlY2lmaWMgZmVlZGJhY2sgbWVzc2FnZSB3aXRoIGEgZ2VuZXJpYyBvbmUuXG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gZmVlZGJhY2tNZXNzYWdlLnBhcmVudE5vZGU7XG4gICAgICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGdlbmVyaWNGZWVkYmFjaywgZmVlZGJhY2tNZXNzYWdlKTtcblxuICAgICAgICAvLyBSZW1vdmUgXCJTaG93IGhpbnRcIiBidXR0b24uICBNYWtpbmcgaXQgaW52aXNpYmxlIGlzbid0IGVub3VnaCxcbiAgICAgICAgLy8gYmVjYXVzZSBpdCB3aWxsIHN0aWxsIHRha2UgdXAgc3BhY2UuXG4gICAgICAgIGhpbnRSZXF1ZXN0QnV0dG9uLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaGludFJlcXVlc3RCdXR0b24pO1xuXG4gICAgICAgIC8vIFJlc3RvcmUgZmVlZGJhY2sgYmxvY2tzLCBpZiBwcmVzZW50LlxuICAgICAgICBpZiAoZmVlZGJhY2tCbG9ja3MgJiYgZmVlZGJhY2tCbG9ja3MuZGl2KSB7XG4gICAgICAgICAgZmVlZGJhY2tCbG9ja3Muc2hvdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVwb3J0IGhpbnQgcmVxdWVzdCB0byBzZXJ2ZXIuXG4gICAgICAgIGlmIChvcHRpb25zLnJlc3BvbnNlLmhpbnRfdmlld19yZXF1ZXN0X3VybCkge1xuICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6IG9wdGlvbnMucmVzcG9uc2UuaGludF92aWV3X3JlcXVlc3RfdXJsLFxuICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBzY3JpcHRfaWQ6IG9wdGlvbnMucmVzcG9uc2Uuc2NyaXB0X2lkLFxuICAgICAgICAgICAgICBsZXZlbF9pZDogb3B0aW9ucy5yZXNwb25zZS5sZXZlbF9pZCxcbiAgICAgICAgICAgICAgZmVlZGJhY2tfdHlwZTogb3B0aW9ucy5mZWVkYmFja1R5cGUsXG4gICAgICAgICAgICAgIGZlZWRiYWNrX3htbDogZmVlZGJhY2tCbG9ja3MgPyBmZWVkYmFja0Jsb2Nrcy54bWwgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gIH1cblxuICBpZiAoY29udGludWVCdXR0b24pIHtcblxuICAgIGlmIChvcHRpb25zLnJlc3BvbnNlICYmIG9wdGlvbnMucmVzcG9uc2UucHV6emxlX3JhdGluZ3NfZW5hYmxlZCkge1xuICAgICAgZmVlZGJhY2suYXBwZW5kQ2hpbGQocHV6emxlUmF0aW5nVXRpbHMuYnVpbGRQdXp6bGVSYXRpbmdCdXR0b25zKCkpO1xuICAgIH1cblxuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQoY29udGludWVCdXR0b24sIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZlZWRiYWNrRGlhbG9nLmhpZGUoKTtcblxuICAgICAgaWYgKG9wdGlvbnMucmVzcG9uc2UgJiYgb3B0aW9ucy5yZXNwb25zZS5wdXp6bGVfcmF0aW5nc19lbmFibGVkKSB7XG4gICAgICAgIHB1enpsZVJhdGluZ1V0aWxzLmNhY2hlUHV6emxlUmF0aW5nKGZlZWRiYWNrLCB7XG4gICAgICAgICAgc2NyaXB0X2lkOiBvcHRpb25zLnJlc3BvbnNlLnNjcmlwdF9pZCxcbiAgICAgICAgICBsZXZlbF9pZDogb3B0aW9ucy5yZXNwb25zZS5sZXZlbF9pZFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gb25Db250aW51ZSB3aWxsIGZpcmUgYWxyZWFkeSBpZiB0aGVyZSB3YXMgb25seSBhIGNvbnRpbnVlIGJ1dHRvblxuICAgICAgaWYgKCFvbmx5Q29udGludWUpIHtcbiAgICAgICAgb3B0aW9ucy5vbkNvbnRpbnVlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBzZXQgdXAgdGhlIFNhdmUgVG8gR2FsbGVyeSBidXR0b24gaWYgbmVjZXNzYXJ5XG4gIHZhciBzYXZlVG9HYWxsZXJ5QnV0dG9uID0gZmVlZGJhY2sucXVlcnlTZWxlY3RvcignI3NhdmUtdG8tZ2FsbGVyeS1idXR0b24nKTtcbiAgaWYgKHNhdmVUb0dhbGxlcnlCdXR0b24gJiYgb3B0aW9ucy5yZXNwb25zZSAmJiBvcHRpb25zLnJlc3BvbnNlLnNhdmVfdG9fZ2FsbGVyeV91cmwpIHtcbiAgICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KHNhdmVUb0dhbGxlcnlCdXR0b24sIGZ1bmN0aW9uKCkge1xuICAgICAgJC5wb3N0KG9wdGlvbnMucmVzcG9uc2Uuc2F2ZV90b19nYWxsZXJ5X3VybCxcbiAgICAgICAgICAgICBmdW5jdGlvbigpIHsgJCgnI3NhdmUtdG8tZ2FsbGVyeS1idXR0b24nKS5wcm9wKCdkaXNhYmxlZCcsIHRydWUpLnRleHQoXCJTYXZlZCFcIik7IH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSGlkZGVuUHJpbnRXaW5kb3coc3JjKSB7XG4gICAgdmFyIGlmcmFtZSA9ICQoJzxpZnJhbWUgaWQ9XCJwcmludF9mcmFtZVwiIHN0eWxlPVwiZGlzcGxheTogbm9uZVwiPjwvaWZyYW1lPicpOyAvLyBDcmVhdGVkIGEgaGlkZGVuIGlmcmFtZSB3aXRoIGp1c3QgdGhlIGRlc2lyZWQgaW1hZ2UgYXMgaXRzIGNvbnRlbnRzXG4gICAgaWZyYW1lLmFwcGVuZFRvKFwiYm9keVwiKTtcbiAgICBpZnJhbWVbMF0uY29udGVudFdpbmRvdy5kb2N1bWVudC53cml0ZShcIjxpbWcgc3JjPSdcIiArIHNyYyArIFwiJy8+XCIpO1xuICAgIGlmcmFtZVswXS5jb250ZW50V2luZG93LmRvY3VtZW50LndyaXRlKFwiPHNjcmlwdD5pZiAoZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ3ByaW50JywgZmFsc2UsIG51bGwpKSB7ICB9IGVsc2UgeyB3aW5kb3cucHJpbnQoKTsgIH0gPC9zY3JpcHQ+XCIpO1xuICAgICQoXCIjcHJpbnRfZnJhbWVcIikucmVtb3ZlKCk7IC8vIFJlbW92ZSB0aGUgaWZyYW1lIHdoZW4gdGhlIHByaW50IGRpYWxvZ3VlIGhhcyBiZWVuIGxhdW5jaGVkXG4gIH1cblxuICB2YXIgcHJpbnRCdXR0b24gPSBmZWVkYmFjay5xdWVyeVNlbGVjdG9yKCcjcHJpbnQtYnV0dG9uJyk7XG4gIGlmIChwcmludEJ1dHRvbikge1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQocHJpbnRCdXR0b24sIGZ1bmN0aW9uKCkge1xuICAgICAgY3JlYXRlSGlkZGVuUHJpbnRXaW5kb3cob3B0aW9ucy5mZWVkYmFja0ltYWdlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZlZWRiYWNrRGlhbG9nLnNob3coe1xuICAgIGJhY2tkcm9wOiAob3B0aW9ucy5hcHAgPT09ICdmbGFwcHknID8gJ3N0YXRpYycgOiB0cnVlKVxuICB9KTtcblxuICBpZiAoZmVlZGJhY2tCbG9ja3MgJiYgZmVlZGJhY2tCbG9ja3MuZGl2KSB7XG4gICAgZmVlZGJhY2tCbG9ja3MucmVuZGVyKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ291bnRzIHRoZSBudW1iZXIgb2YgYmxvY2tzIHVzZWQuICBCbG9ja3MgYXJlIG9ubHkgY291bnRlZCBpZiB0aGV5IGFyZVxuICogbm90IGRpc2FibGVkLCBhcmUgZGVsZXRhYmxlLlxuICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgYmxvY2tzIHVzZWQuXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmdldE51bUJsb2Nrc1VzZWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLnN0dWRpb0FwcF8uZWRpdENvZGUpIHtcbiAgICB2YXIgY29kZUxpbmVzID0gMDtcbiAgICAvLyBxdWljayBhbmQgZGlydHkgbWV0aG9kIHRvIGNvdW50IG5vbi1ibGFuayBsaW5lcyB0aGF0IGRvbid0IHN0YXJ0IHdpdGggLy9cbiAgICB2YXIgbGluZXMgPSB0aGlzLmdldEdlbmVyYXRlZENvZGVTdHJpbmdfKCkuc3BsaXQoXCJcXG5cIik7XG4gICAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoKGxpbmVzW2ldLmxlbmd0aCA+IDEpICYmIChsaW5lc1tpXVswXSAhPSAnLycgfHwgbGluZXNbaV1bMV0gIT0gJy8nKSkge1xuICAgICAgICBjb2RlTGluZXMrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvZGVMaW5lcztcbiAgfVxuICByZXR1cm4gdGhpcy5nZXRVc2VyQmxvY2tzXygpLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ291bnRzIHRoZSB0b3RhbCBudW1iZXIgb2YgYmxvY2tzLiBCbG9ja3MgYXJlIG9ubHkgY291bnRlZCBpZiB0aGV5IGFyZVxuICogbm90IGRpc2FibGVkLlxuICogQHJldHVybiB7bnVtYmVyfSBUb3RhbCBudW1iZXIgb2YgYmxvY2tzLlxuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5nZXROdW1Db3VudGFibGVCbG9ja3MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLnN0dWRpb0FwcF8uZWRpdENvZGUpIHtcbiAgICB2YXIgY29kZUxpbmVzID0gMDtcbiAgICAvLyBxdWljayBhbmQgZGlydHkgbWV0aG9kIHRvIGNvdW50IG5vbi1ibGFuayBsaW5lcyB0aGF0IGRvbid0IHN0YXJ0IHdpdGggLy9cbiAgICB2YXIgbGluZXMgPSB0aGlzLmdldEdlbmVyYXRlZENvZGVTdHJpbmdfKCkuc3BsaXQoXCJcXG5cIik7XG4gICAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoKGxpbmVzW2ldLmxlbmd0aCA+IDEpICYmIChsaW5lc1tpXVswXSAhPSAnLycgfHwgbGluZXNbaV1bMV0gIT0gJy8nKSkge1xuICAgICAgICBjb2RlTGluZXMrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvZGVMaW5lcztcbiAgfVxuICByZXR1cm4gdGhpcy5nZXRDb3VudGFibGVCbG9ja3NfKCkubGVuZ3RoO1xufTtcblxuLyoqXG4gKlxuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5nZXRGZWVkYmFja0J1dHRvbnNfID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgYnV0dG9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBidXR0b25zLmlkID0gJ2ZlZWRiYWNrQnV0dG9ucyc7XG5cbiAgdmFyIHRyeUFnYWluVGV4dCA9ICcnO1xuICBpZiAob3B0aW9ucy5mZWVkYmFja1R5cGUgIT09IFRlc3RSZXN1bHRzLkFMTF9QQVNTKSB7XG4gICAgdHJ5QWdhaW5UZXh0ID0gdXRpbHMudmFsdWVPcihvcHRpb25zLnRyeUFnYWluVGV4dCwgbXNnLnRyeUFnYWluKCkpO1xuICB9XG4gIGlmIChvcHRpb25zLmtlZXBQbGF5aW5nVGV4dCkge1xuICAgIHRyeUFnYWluVGV4dCA9IG9wdGlvbnMua2VlcFBsYXlpbmdUZXh0O1xuICB9XG5cbiAgYnV0dG9ucy5pbm5lckhUTUwgPSByZXF1aXJlKCcuL3RlbXBsYXRlcy9idXR0b25zLmh0bWwuZWpzJykoe1xuICAgIGRhdGE6IHtcbiAgICAgIHByZXZpb3VzTGV2ZWw6XG4gICAgICAgICF0aGlzLmNhbkNvbnRpbnVlVG9OZXh0TGV2ZWwob3B0aW9ucy5mZWVkYmFja1R5cGUpICYmXG4gICAgICAgIG9wdGlvbnMuc2hvd1ByZXZpb3VzQnV0dG9uLFxuICAgICAgdHJ5QWdhaW46IHRyeUFnYWluVGV4dCxcbiAgICAgIGNvbnRpbnVlVGV4dDogb3B0aW9ucy5jb250aW51ZVRleHQgfHwgKG9wdGlvbnMuZmluYWxMZXZlbCA/IG1zZy5maW5pc2goKSA6IG1zZy5jb250aW51ZSgpKSxcbiAgICAgIG5leHRMZXZlbDogdGhpcy5jYW5Db250aW51ZVRvTmV4dExldmVsKG9wdGlvbnMuZmVlZGJhY2tUeXBlKSxcbiAgICAgIHNob3VsZFByb21wdEZvckhpbnQ6IHRoaXMuc2hvdWxkUHJvbXB0Rm9ySGludChvcHRpb25zLmZlZWRiYWNrVHlwZSksXG4gICAgICBpc0sxOiBvcHRpb25zLmlzSzEsXG4gICAgICBhc3NldFVybDogdGhpcy5zdHVkaW9BcHBfLmFzc2V0VXJsLFxuICAgICAgZnJlZVBsYXk6IG9wdGlvbnMuZnJlZVBsYXlcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBidXR0b25zO1xufTtcblxuLyoqXG4gKlxuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5nZXRTaGFyZUZhaWx1cmVfID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgc2hhcmVGYWlsdXJlID0gb3B0aW9ucy5yZXNwb25zZS5zaGFyZV9mYWlsdXJlO1xuICB2YXIgc2hhcmVGYWlsdXJlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHNoYXJlRmFpbHVyZURpdi5pbm5lckhUTUwgPSByZXF1aXJlKCcuL3RlbXBsYXRlcy9zaGFyZUZhaWx1cmUuaHRtbC5lanMnKSh7c2hhcmVGYWlsdXJlOiBzaGFyZUZhaWx1cmV9KTtcbiAgcmV0dXJuIHNoYXJlRmFpbHVyZURpdjtcbn07XG5cbi8qKlxuICpcbiAqL1xuRmVlZGJhY2tVdGlscy5wcm90b3R5cGUudXNlU3BlY2lhbEZlZWRiYWNrRGVzaWduXyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gcmV0dXJuIG9wdGlvbnMucmVzcG9uc2UgJiZcbiAgICAgICAgb3B0aW9ucy5yZXNwb25zZS5kZXNpZ24gJiZcbiAgICAgICAgb3B0aW9ucy5yZXNwb25zZS5oaW50O1xufTtcblxuLy8gVGhpcyByZXR1cm5zIGEgZG9jdW1lbnQgZWxlbWVudCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBmZWVkYmFjayBtZXNzYWdlLlxuLy8gVGhlIG1lc3NhZ2Ugd2lsbCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZywgZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCBwcmVjZWRlbmNlOlxuLy8gMC4gRmFpbHVyZSBvdmVycmlkZSBtZXNzYWdlIHNwZWNpZmllZCBvbiBsZXZlbCAob3B0aW9ucy5sZXZlbC5mYWlsdXJlTWVzc2FnZU92ZXJyaWRlKVxuLy8gMS4gTWVzc2FnZSBwYXNzZWQgaW4gYnkgY2FsbGVyIChvcHRpb25zLm1lc3NhZ2UpLlxuLy8gMi4gTWVzc2FnZSBmcm9tIGRhc2hib2FyZCBkYXRhYmFzZSAob3B0aW9ucy5yZXNwb25zZS5oaW50KS5cbi8vIDMuIEhlYWRlciBtZXNzYWdlIGR1ZSB0byBkYXNoYm9hcmQgdGV4dCBjaGVjayBmYWlsIChvcHRpb25zLnJlc3BvbnNlLnNoYXJlX2ZhaWx1cmUpLlxuLy8gNC4gTGV2ZWwtc3BlY2lmaWMgbWVzc2FnZSAoZS5nLiwgb3B0aW9ucy5sZXZlbC5lbXB0eUJsb2Nrc0Vycm9yTXNnKSBmb3Jcbi8vICAgIHNwZWNpZmljIHJlc3VsdCB0eXBlIChlLmcuLCBUZXN0UmVzdWx0cy5FTVBUWV9CTE9DS19GQUlMKS5cbi8vIDUuIFN5c3RlbS13aWRlIG1lc3NhZ2UgKGUuZy4sIG1zZy5lbXB0eUJsb2Nrc0Vycm9yTXNnKCkpIGZvciBzcGVjaWZpY1xuLy8gICAgcmVzdWx0IHR5cGUgKGUuZy4sIFRlc3RSZXN1bHRzLkVNUFRZX0JMT0NLX0ZBSUwpLlxuRmVlZGJhY2tVdGlscy5wcm90b3R5cGUuZ2V0RmVlZGJhY2tNZXNzYWdlXyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIGZlZWRiYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICBmZWVkYmFjay5jbGFzc05hbWUgPSAnY29uZ3JhdHMnO1xuICB2YXIgbWVzc2FnZTtcblxuICAvLyBJZiBhIG1lc3NhZ2Ugd2FzIGV4cGxpY2l0bHkgcGFzc2VkIGluLCB1c2UgdGhhdC5cbiAgaWYgKG9wdGlvbnMuZmVlZGJhY2tUeXBlICE9PSBUZXN0UmVzdWx0cy5BTExfUEFTUyAmJlxuICAgICAgb3B0aW9ucy5sZXZlbCAmJiBvcHRpb25zLmxldmVsLmZhaWx1cmVNZXNzYWdlT3ZlcnJpZGUpIHtcbiAgICBtZXNzYWdlID0gb3B0aW9ucy5sZXZlbC5mYWlsdXJlTWVzc2FnZU92ZXJyaWRlO1xuICB9IGVsc2UgIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICBtZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMucmVzcG9uc2UgJiYgb3B0aW9ucy5yZXNwb25zZS5zaGFyZV9mYWlsdXJlKSB7XG4gICAgbWVzc2FnZSA9IG1zZy5zaGFyZUZhaWx1cmUoKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLnJlc3BvbnNlICYmIG9wdGlvbnMucmVzcG9uc2UuaGludCkge1xuICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlcmUncyBhIGRhc2hib2FyZCBkYXRhYmFzZSBoaW50LCB1c2UgdGhhdC5cbiAgICBtZXNzYWdlID0gb3B0aW9ucy5yZXNwb25zZS5oaW50O1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSwgdGhlIG1lc3NhZ2Ugd2lsbCBkZXBlbmQgb24gdGhlIHRlc3QgcmVzdWx0LlxuICAgIHN3aXRjaCAob3B0aW9ucy5mZWVkYmFja1R5cGUpIHtcbiAgICAgIGNhc2UgVGVzdFJlc3VsdHMuUlVOVElNRV9FUlJPUl9GQUlMOlxuICAgICAgICBtZXNzYWdlID0gbXNnLnJ1bnRpbWVFcnJvck1zZyh7IGxpbmVOdW1iZXI6IG9wdGlvbnMuZXhlY3V0aW9uRXJyb3IubGluZU51bWJlciB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlc3RSZXN1bHRzLlNZTlRBWF9FUlJPUl9GQUlMOlxuICAgICAgICBtZXNzYWdlID0gbXNnLnN5bnRheEVycm9yTXNnKHsgbGluZU51bWJlcjogb3B0aW9ucy5leGVjdXRpb25FcnJvci5saW5lTnVtYmVyIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVGVzdFJlc3VsdHMuRU1QVFlfQkxPQ0tfRkFJTDpcbiAgICAgICAgbWVzc2FnZSA9IG9wdGlvbnMubGV2ZWwuZW1wdHlCbG9ja3NFcnJvck1zZyB8fFxuICAgICAgICAgICAgbXNnLmVtcHR5QmxvY2tzRXJyb3JNc2coKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlc3RSZXN1bHRzLkVNUFRZX0ZVTkNUSU9OX0JMT0NLX0ZBSUw6XG4gICAgICAgIGlmIChvcHRpb25zLmxldmVsLmVtcHR5RnVuY3Rpb25CbG9ja3NFcnJvck1zZykge1xuICAgICAgICAgIG1lc3NhZ2UgPSBvcHRpb25zLmxldmVsLmVtcHR5RnVuY3Rpb25CbG9ja3NFcnJvck1zZztcbiAgICAgICAgfSBlbHNlIGlmIChCbG9ja2x5LnVzZUNvbnRyYWN0RWRpdG9yIHx8IEJsb2NrbHkudXNlTW9kYWxGdW5jdGlvbkVkaXRvcikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBtc2cuZXJyb3JFbXB0eUZ1bmN0aW9uQmxvY2tNb2RhbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lc3NhZ2UgPSBtc2cuZW1wdHlGdW5jdGlvbkJsb2Nrc0Vycm9yTXNnKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlc3RSZXN1bHRzLlRPT19GRVdfQkxPQ0tTX0ZBSUw6XG4gICAgICAgIG1lc3NhZ2UgPSBvcHRpb25zLmxldmVsLnRvb0Zld0Jsb2Nrc01zZyB8fCBtc2cudG9vRmV3QmxvY2tzTXNnKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUZXN0UmVzdWx0cy5MRVZFTF9JTkNPTVBMRVRFX0ZBSUw6XG4gICAgICAgIG1lc3NhZ2UgPSBvcHRpb25zLmxldmVsLmxldmVsSW5jb21wbGV0ZUVycm9yIHx8XG4gICAgICAgICAgICBtc2cubGV2ZWxJbmNvbXBsZXRlRXJyb3IoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlc3RSZXN1bHRzLkVYVFJBX1RPUF9CTE9DS1NfRkFJTDpcbiAgICAgICAgdmFyIGhhc1doZW5SdW4gPSBCbG9ja2x5Lm1haW5CbG9ja1NwYWNlLmdldFRvcEJsb2NrcygpLnNvbWUoZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgICAgcmV0dXJuIGJsb2NrLnR5cGUgPT09ICd3aGVuX3J1bicgJiYgYmxvY2suaXNVc2VyVmlzaWJsZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZGVmYXVsdE1lc3NhZ2UgPSBoYXNXaGVuUnVuID9cbiAgICAgICAgICBtc2cuZXh0cmFUb3BCbG9ja3NXaGVuUnVuKCkgOiBtc2cuZXh0cmFUb3BCbG9ja3MoKTtcbiAgICAgICAgbWVzc2FnZSA9IG9wdGlvbnMubGV2ZWwuZXh0cmFUb3BCbG9ja3MgfHwgZGVmYXVsdE1lc3NhZ2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUZXN0UmVzdWx0cy5BUFBfU1BFQ0lGSUNfRkFJTDpcbiAgICAgICAgbWVzc2FnZSA9IG9wdGlvbnMubGV2ZWwuYXBwU3BlY2lmaWNGYWlsRXJyb3I7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUZXN0UmVzdWx0cy5VTlVTRURfUEFSQU06XG4gICAgICAgIG1lc3NhZ2UgPSBtc2cuZXJyb3JVbnVzZWRQYXJhbSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVGVzdFJlc3VsdHMuVU5VU0VEX0ZVTkNUSU9OOlxuICAgICAgICBtZXNzYWdlID0gbXNnLmVycm9yVW51c2VkRnVuY3Rpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlc3RSZXN1bHRzLlBBUkFNX0lOUFVUX1VOQVRUQUNIRUQ6XG4gICAgICAgIG1lc3NhZ2UgPSBtc2cuZXJyb3JQYXJhbUlucHV0VW5hdHRhY2hlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVGVzdFJlc3VsdHMuSU5DT01QTEVURV9CTE9DS19JTl9GVU5DVElPTjpcbiAgICAgICAgbWVzc2FnZSA9IG1zZy5lcnJvckluY29tcGxldGVCbG9ja0luRnVuY3Rpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlc3RSZXN1bHRzLlFVRVNUSU9OX01BUktTX0lOX05VTUJFUl9GSUVMRDpcbiAgICAgICAgbWVzc2FnZSA9IG1zZy5lcnJvclF1ZXN0aW9uTWFya3NJbk51bWJlckZpZWxkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUZXN0UmVzdWx0cy5UT09fTUFOWV9CTE9DS1NfRkFJTDpcbiAgICAgICAgICAvLyBBbGxvdyBhcHBzIHRvIG92ZXJyaWRlIHRoZSBcInRvbyBtYW55IGJsb2Nrc1wiIGZhaWx1cmUgbWVzc2FnZVxuICAgICAgICAgIC8vIFBhc3NlZCBhcyBhIG1zZyBmdW5jdGlvbiB0byBhbGxvdyB0aGUgcGFyYW1ldGVycyB0byBiZSBwYXNzZWQgaW4uXG4gICAgICAgIHZhciBtZXNzYWdlRnVuY3Rpb24gPSAob3B0aW9ucy5hcHBTdHJpbmdzICYmIG9wdGlvbnMuYXBwU3RyaW5ncy50b29NYW55QmxvY2tzRmFpbE1zZ0Z1bmN0aW9uKSB8fFxuICAgICAgICAgICAgbXNnLm51bUJsb2Nrc05lZWRlZDtcbiAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VGdW5jdGlvbih7XG4gICAgICAgICAgbnVtQmxvY2tzOiB0aGlzLnN0dWRpb0FwcF8uSURFQUxfQkxPQ0tfTlVNLFxuICAgICAgICAgIHB1enpsZU51bWJlcjogb3B0aW9ucy5sZXZlbC5wdXp6bGVfbnVtYmVyIHx8IDBcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUZXN0UmVzdWx0cy5BUFBfU1BFQ0lGSUNfQUNDRVBUQUJMRV9GQUlMOlxuICAgICAgICBtZXNzYWdlID0gb3B0aW9ucy5sZXZlbC5hcHBTcGVjaWZpY0FjY2VwdGFibGVGYWlsRXJyb3I7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUZXN0UmVzdWx0cy5FRElUX0JMT0NLUzpcbiAgICAgICAgbWVzc2FnZSA9IG9wdGlvbnMubGV2ZWwuZWRpdF9ibG9ja3Nfc3VjY2VzcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlc3RSZXN1bHRzLk1JU1NJTkdfQkxPQ0tfVU5GSU5JU0hFRDpcbiAgICAgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVGVzdFJlc3VsdHMuTUlTU0lOR19CTE9DS19GSU5JU0hFRDpcbiAgICAgICAgbWVzc2FnZSA9IG9wdGlvbnMubGV2ZWwubWlzc2luZ1JlcXVpcmVkQmxvY2tzRXJyb3JNc2cgfHxcbiAgICAgICAgICAgIG1zZy5taXNzaW5nUmVxdWlyZWRCbG9ja3NFcnJvck1zZygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVGVzdFJlc3VsdHMuTUlTU0lOR19SRUNPTU1FTkRFRF9CTE9DS19VTkZJTklTSEVEOlxuICAgICAgICBtZXNzYWdlID0gbXNnLm1pc3NpbmdSZWNvbW1lbmRlZEJsb2Nrc0Vycm9yTXNnKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUZXN0UmVzdWx0cy5NSVNTSU5HX1JFQ09NTUVOREVEX0JMT0NLX0ZJTklTSEVEOlxuICAgICAgICB2YXIgbnVtRW5hYmxlZEJsb2NrcyA9IHRoaXMuZ2V0TnVtQ291bnRhYmxlQmxvY2tzKCk7XG4gICAgICAgIGlmICh0aGlzLnN0dWRpb0FwcF8uSURFQUxfQkxPQ0tfTlVNICYmIG51bUVuYWJsZWRCbG9ja3MgPiB0aGlzLnN0dWRpb0FwcF8uSURFQUxfQkxPQ0tfTlVNKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IG1zZy5udW1CbG9ja3NOZWVkZWQoe1xuICAgICAgICAgICAgbnVtQmxvY2tzOiB0aGlzLnN0dWRpb0FwcF8uSURFQUxfQkxPQ0tfTlVNLFxuICAgICAgICAgICAgcHV6emxlTnVtYmVyOiBvcHRpb25zLmxldmVsLnB1enpsZV9udW1iZXIgfHwgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lc3NhZ2UgPSBtc2cuY29tcGxldGVkV2l0aG91dFJlY29tbWVuZGVkQmxvY2soe1xuICAgICAgICAgICAgcHV6emxlTnVtYmVyOiBvcHRpb25zLmxldmVsLnB1enpsZV9udW1iZXIgfHwgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUZXN0UmVzdWx0cy5ORVNURURfRk9SX1NBTUVfVkFSSUFCTEU6XG4gICAgICAgIG1lc3NhZ2UgPSBtc2cubmVzdGVkRm9yU2FtZVZhcmlhYmxlKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBTdWNjZXNzLlxuICAgICAgY2FzZSBUZXN0UmVzdWx0cy5BTExfUEFTUzpcbiAgICAgIGNhc2UgVGVzdFJlc3VsdHMuRlJFRV9QTEFZOlxuICAgICAgICB2YXIgZmluYWxMZXZlbCA9IChvcHRpb25zLnJlc3BvbnNlICYmXG4gICAgICAgICAgKG9wdGlvbnMucmVzcG9uc2UubWVzc2FnZSA9PT0gXCJubyBtb3JlIGxldmVsc1wiKSk7XG4gICAgICAgIHZhciBzdGFnZUNvbXBsZXRlZCA9IG51bGw7XG4gICAgICAgIGlmIChvcHRpb25zLnJlc3BvbnNlICYmIG9wdGlvbnMucmVzcG9uc2Uuc3RhZ2VfY2hhbmdpbmcpIHtcbiAgICAgICAgICBzdGFnZUNvbXBsZXRlZCA9IG9wdGlvbnMucmVzcG9uc2Uuc3RhZ2VfY2hhbmdpbmcucHJldmlvdXMubmFtZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbXNnUGFyYW1zID0ge1xuICAgICAgICAgIG51bVRyb3BoaWVzOiBvcHRpb25zLm51bVRyb3BoaWVzLFxuICAgICAgICAgIHN0YWdlTnVtYmVyOiAwLCAvLyBUT0RPOiByZW1vdmUgb25jZSBsb2NhbGl6ZWQgc3RyaW5ncyBoYXZlIGJlZW4gZml4ZWRcbiAgICAgICAgICBzdGFnZU5hbWU6IHN0YWdlQ29tcGxldGVkLFxuICAgICAgICAgIHB1enpsZU51bWJlcjogb3B0aW9ucy5sZXZlbC5wdXp6bGVfbnVtYmVyIHx8IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZmVlZGJhY2tUeXBlID09PSBUZXN0UmVzdWx0cy5GUkVFX1BMQVkgJiYgIW9wdGlvbnMubGV2ZWwuZGlzYWJsZVNoYXJpbmcpIHtcbiAgICAgICAgICB2YXIgcmVpbmZGZWVkYmFja01zZyA9IChvcHRpb25zLmFwcFN0cmluZ3MgJiZcbiAgICAgICAgICAgICAgb3B0aW9ucy5hcHBTdHJpbmdzLnJlaW5mRmVlZGJhY2tNc2cpIHx8ICcnO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMubGV2ZWwuZGlzYWJsZUZpbmFsU3RhZ2VNZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gcmVpbmZGZWVkYmFja01zZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGZpbmFsTGV2ZWwgPyAobXNnLmZpbmFsU3RhZ2UobXNnUGFyYW1zKSArICcgJykgOiAnJztcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlICsgcmVpbmZGZWVkYmFja01zZztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5udW1Ucm9waGllcyA+IDApIHtcbiAgICAgICAgICBtZXNzYWdlID0gZmluYWxMZXZlbCA/IG1zZy5maW5hbFN0YWdlVHJvcGhpZXMobXNnUGFyYW1zKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFnZUNvbXBsZXRlZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2cubmV4dFN0YWdlVHJvcGhpZXMobXNnUGFyYW1zKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2cubmV4dExldmVsVHJvcGhpZXMobXNnUGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbmV4dExldmVsTXNnID0gKG9wdGlvbnMuYXBwU3RyaW5ncyAmJiBvcHRpb25zLmFwcFN0cmluZ3MubmV4dExldmVsTXNnKSB8fFxuICAgICAgICAgICAgICBtc2cubmV4dExldmVsKG1zZ1BhcmFtcyk7XG4gICAgICAgICAgbWVzc2FnZSA9IGZpbmFsTGV2ZWwgPyBtc2cuZmluYWxTdGFnZShtc2dQYXJhbXMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWdlQ29tcGxldGVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2cubmV4dFN0YWdlKG1zZ1BhcmFtcykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRMZXZlbE1zZztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAkKGZlZWRiYWNrKS50ZXh0KG1lc3NhZ2UpO1xuXG4gIC8vIFVwZGF0ZSB0aGUgZmVlZGJhY2sgYm94IGRlc2lnbiwgaWYgdGhlIGhpbnQgbWVzc2FnZSBjYW1lIGZyb20gc2VydmVyLlxuICBpZiAodGhpcy51c2VTcGVjaWFsRmVlZGJhY2tEZXNpZ25fKG9wdGlvbnMpKSB7XG4gICAgLy8gU2V0dXAgYSBuZXcgZGl2XG4gICAgdmFyIGZlZWRiYWNrRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZmVlZGJhY2tEaXYuY2xhc3NOYW1lID0gJ2ZlZWRiYWNrLWNhbGxvdXQnO1xuICAgIGZlZWRiYWNrRGl2LmlkID0gJ2ZlZWRiYWNrLWNvbnRlbnQnO1xuXG4gICAgLy8gSW5zZXJ0IGFuIGltYWdlXG4gICAgdmFyIGltYWdlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgaW1hZ2VEaXYuY2xhc3NOYW1lID0gXCJoaW50LWltYWdlXCI7XG4gICAgaW1hZ2VEaXYuc3JjID0gdGhpcy5zdHVkaW9BcHBfLmFzc2V0VXJsKFxuICAgICAgJ21lZGlhL2xpZ2h0YnVsYl9mb3JfJyArIG9wdGlvbnMucmVzcG9uc2UuZGVzaWduICsgJy5wbmcnKTtcbiAgICBmZWVkYmFja0Rpdi5hcHBlbmRDaGlsZChpbWFnZURpdik7XG4gICAgLy8gQWRkIG5ldyB0ZXh0XG4gICAgdmFyIGhpbnRIZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgJChoaW50SGVhZGVyKS50ZXh0KG1zZy5oaW50SGVhZGVyKCkpO1xuICAgIGZlZWRiYWNrRGl2LmFwcGVuZENoaWxkKGhpbnRIZWFkZXIpO1xuICAgIGhpbnRIZWFkZXIuY2xhc3NOYW1lID0gJ2hpbnQtaGVhZGVyJztcbiAgICAvLyBBcHBlbmQgdGhlIG9yaWdpbmFsIHRleHRcbiAgICBmZWVkYmFja0Rpdi5hcHBlbmRDaGlsZChmZWVkYmFjayk7XG4gICAgcmV0dXJuIGZlZWRiYWNrRGl2O1xuICB9XG4gIHJldHVybiBmZWVkYmFjaztcbn07XG5cbi8qKlxuICpcbiAqL1xuRmVlZGJhY2tVdGlscy5wcm90b3R5cGUuY3JlYXRlU2hhcmluZ0RpdiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgLy8gVE9ETzogdGhpcyBieXBhc3NlcyB0aGUgY29uZmlnIGVuY2Fwc3VsYXRpb24gdG8gZW5zdXJlIHdlIGhhdmUgdGhlIG1vc3QgdXAtdG8tZGF0ZSB2YWx1ZS5cbiAgaWYgKHRoaXMuc3R1ZGlvQXBwXy5kaXNhYmxlU29jaWFsU2hhcmUgfHwgd2luZG93LmFwcE9wdGlvbnMuZGlzYWJsZVNvY2lhbFNoYXJlKSB7XG4gICAgLy8gQ2xlYXIgb3V0IG91ciB1cmxzIHNvIHRoYXQgd2UgZG9uJ3QgZGlzcGxheSBhbnkgb2Ygb3VyIHNvY2lhbCBzaGFyZSBsaW5rc1xuICAgIG9wdGlvbnMudHdpdHRlclVybCA9IHVuZGVmaW5lZDtcbiAgICBvcHRpb25zLmZhY2Vib29rVXJsID0gdW5kZWZpbmVkO1xuICAgIG9wdGlvbnMuc2VuZFRvUGhvbmUgPSBmYWxzZTtcbiAgfSBlbHNlIHtcblxuICAgIC8vIHNldCB1cCB0aGUgdHdpdHRlciBzaGFyZSB1cmxcbiAgICB2YXIgdHdpdHRlclVybCA9IFwiaHR0cHM6Ly90d2l0dGVyLmNvbS9pbnRlbnQvdHdlZXQ/dXJsPVwiICtcbiAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucmVzcG9uc2UubGV2ZWxfc291cmNlO1xuXG4gICAgaWYgKG9wdGlvbnMudHdpdHRlciAmJiBvcHRpb25zLnR3aXR0ZXIudGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0d2l0dGVyVXJsICs9IFwiJnRleHQ9XCIgKyBlbmNvZGVVUkkob3B0aW9ucy50d2l0dGVyLnRleHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHR3aXR0ZXJVcmwgKz0gXCImdGV4dD1cIiArIGVuY29kZVVSSShtc2cuZGVmYXVsdFR3aXR0ZXJUZXh0KCkgKyBcIiBAY29kZW9yZ1wiKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50d2l0dGVyICAmJiBvcHRpb25zLnR3aXR0ZXIuaGFzaHRhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0d2l0dGVyVXJsICs9IFwiJmhhc2h0YWdzPVwiICsgb3B0aW9ucy50d2l0dGVyLmhhc2h0YWc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdHdpdHRlclVybCArPSBcIiZoYXNodGFncz1cIiArICdIb3VyT2ZDb2RlJztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50d2l0dGVyICYmIG9wdGlvbnMudHdpdHRlci5yZWxhdGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHR3aXR0ZXJVcmwgKz0gXCImcmVsYXRlZD1cIiArIG9wdGlvbnMudHdpdHRlci5yZWxhdGVkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHR3aXR0ZXJVcmwgKz0gXCImcmVsYXRlZD1jb2Rlb3JnXCI7XG4gICAgfVxuXG4gICAgb3B0aW9ucy50d2l0dGVyVXJsID0gdHdpdHRlclVybDtcblxuICAgIC8vIHNldCB1cCB0aGUgZmFjZWJvb2sgc2hhcmUgdXJsXG4gICAgdmFyIGZhY2Vib29rVXJsID0gXCJodHRwczovL3d3dy5mYWNlYm9vay5jb20vc2hhcmVyL3NoYXJlci5waHA/dT1cIiArXG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5yZXNwb25zZS5sZXZlbF9zb3VyY2U7XG4gICAgb3B0aW9ucy5mYWNlYm9va1VybCA9IGZhY2Vib29rVXJsO1xuICB9XG5cbiAgb3B0aW9ucy5hc3NldFVybCA9IHRoaXMuc3R1ZGlvQXBwXy5hc3NldFVybDtcblxuICB2YXIgc2hhcmluZ0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBzaGFyaW5nRGl2LnNldEF0dHJpYnV0ZSgnaWQnLCAnc2hhcmluZycpO1xuICBzaGFyaW5nRGl2LmlubmVySFRNTCA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL3NoYXJpbmcuaHRtbC5lanMnKSh7XG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9KTtcblxuICAvLyBOb3RlOiBXZSBoYXZlIGEgZGVwZW5kZW5jeSBvbiBkYXNoYm9hcmQgaGVyZS4gVGhpcyBkZXBlbmRlbmN5IGhhcyBhbHdheXNcbiAgLy8gYmVlbiBoZXJlICh3ZSB1c2VkIHRvIG15c3RlcmlvdXNseSBqdXN0IGFsd2F5cyBidWJibGUgY2xpY2tzIG9uIGJvZHkgdG9cbiAgLy8gYS5wb3B1cC13aW5kb3cgaWYgaXQgZXhpc3RlZCksIGJ1dCBpdCBpcyBub3cgbW9yZSBleHBsaWNpdFxuICBpZiAod2luZG93LmRhc2hib2FyZCAmJiB3aW5kb3cuZGFzaGJvYXJkLnBvcHVwV2luZG93KSB7XG4gICAgJChzaGFyaW5nRGl2KS5maW5kKCdhLnBvcHVwLXdpbmRvdycpLmNsaWNrKHdpbmRvdy5kYXNoYm9hcmQucG9wdXBXaW5kb3cpO1xuICB9XG5cbiAgdmFyIHNoYXJpbmdJbnB1dCA9IHNoYXJpbmdEaXYucXVlcnlTZWxlY3RvcignI3NoYXJpbmctaW5wdXQnKTtcbiAgaWYgKHNoYXJpbmdJbnB1dCkge1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQoc2hhcmluZ0lucHV0LCBmdW5jdGlvbigpIHtcbiAgICAgIHNoYXJpbmdJbnB1dC5mb2N1cygpO1xuICAgICAgc2hhcmluZ0lucHV0LnNlbGVjdCgpO1xuICAgICAgc2hhcmluZ0lucHV0LnNldFNlbGVjdGlvblJhbmdlKDAsIDk5OTkpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gIFNNUy10by1waG9uZSBmZWF0dXJlXG4gIHZhciBzaGFyaW5nUGhvbmUgPSBzaGFyaW5nRGl2LnF1ZXJ5U2VsZWN0b3IoJyNzaGFyaW5nLXBob25lJyk7XG4gIGlmIChzaGFyaW5nUGhvbmUgJiYgb3B0aW9ucy5zZW5kVG9QaG9uZSkge1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQoc2hhcmluZ1Bob25lLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZW5kVG9QaG9uZSA9IHNoYXJpbmdEaXYucXVlcnlTZWxlY3RvcignI3NlbmQtdG8tcGhvbmUnKTtcbiAgICAgIGlmICgkKHNlbmRUb1Bob25lKS5pcygnOmhpZGRlbicpKSB7XG4gICAgICAgICQoc2VuZFRvUGhvbmUpLnNob3coKTtcbiAgICAgICAgdmFyIHBob25lID0gJChzaGFyaW5nRGl2LnF1ZXJ5U2VsZWN0b3IoXCIjcGhvbmVcIikpO1xuICAgICAgICB2YXIgc3VibWl0dGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBzdWJtaXRCdXR0b24gPSBzaGFyaW5nRGl2LnF1ZXJ5U2VsZWN0b3IoJyNwaG9uZS1zdWJtaXQnKTtcbiAgICAgICAgc3VibWl0QnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgcGhvbmUubWFzaygnKDAwMCkgMDAwLTAwMDAnLCB7XG4gICAgICAgICAgICBvbkNvbXBsZXRlOmZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIGlmICghc3VibWl0dGVkKSB7XG4gICAgICAgICAgICAgICAgc3VibWl0QnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBzdWJtaXRCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgcGhvbmUuZm9jdXMoKTtcbiAgICAgICAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChzdWJtaXRCdXR0b24sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwaG9uZSA9ICQoc2hhcmluZ0Rpdi5xdWVyeVNlbGVjdG9yKFwiI3Bob25lXCIpKTtcbiAgICAgICAgICB2YXIgcGFyYW1zID0galF1ZXJ5LnBhcmFtKHtcbiAgICAgICAgICAgIGxldmVsX3NvdXJjZTogb3B0aW9ucy5yZXNwb25zZS5sZXZlbF9zb3VyY2VfaWQsXG4gICAgICAgICAgICBwaG9uZTogcGhvbmUudmFsKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAkKHN1Ym1pdEJ1dHRvbikudmFsKFwiU2VuZGluZy4uXCIpO1xuICAgICAgICAgIHBob25lLnByb3AoJ3JlYWRvbmx5JywgdHJ1ZSk7XG4gICAgICAgICAgc3VibWl0QnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICBzdWJtaXR0ZWQgPSB0cnVlO1xuICAgICAgICAgIGpRdWVyeS5wb3N0KG9wdGlvbnMucmVzcG9uc2UucGhvbmVfc2hhcmVfdXJsLCBwYXJhbXMpXG4gICAgICAgICAgICAuZG9uZShmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgJChzdWJtaXRCdXR0b24pLnRleHQoXCJTZW50IVwiKTtcbiAgICAgICAgICAgICAgdHJhY2tFdmVudChcIlNlbmRUb1Bob25lXCIsIFwic3VjY2Vzc1wiKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmFpbChmdW5jdGlvbiAoeGhyKSB7XG4gICAgICAgICAgICAgICQoc3VibWl0QnV0dG9uKS50ZXh0KFwiRXJyb3IhXCIpO1xuICAgICAgICAgICAgICB0cmFja0V2ZW50KFwiU2VuZFRvUGhvbmVcIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7IC8vIG5vdCBoaWRkZW4sIGhpZGVcbiAgICAgICAgJChzZW5kVG9QaG9uZSkuaGlkZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHNoYXJpbmdEaXY7XG59O1xuXG4vKipcbiAqXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLm51bVRyb3BoaWVzRWFybmVkXyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMucmVzcG9uc2UgJiYgb3B0aW9ucy5yZXNwb25zZS50cm9waHlfdXBkYXRlcykge1xuICAgIHJldHVybiBvcHRpb25zLnJlc3BvbnNlLnRyb3BoeV91cGRhdGVzLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuLyoqXG4gKlxuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5nZXRUcm9waGllc0VsZW1lbnRfID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgaHRtbCA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5udW1Ucm9waGllczsgaSsrKSB7XG4gICAgaHRtbCArPSB0cm9waHkoe1xuICAgICAgaW1nX3VybDogb3B0aW9ucy5yZXNwb25zZS50cm9waHlfdXBkYXRlc1tpXVsyXSxcbiAgICAgIGNvbmNlcHRfbmFtZTogb3B0aW9ucy5yZXNwb25zZS50cm9waHlfdXBkYXRlc1tpXVswXVxuICAgIH0pO1xuICB9XG4gIHZhciB0cm9waGllcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0cm9waGllcy5pbm5lckhUTUwgPSBodG1sO1xuICByZXR1cm4gdHJvcGhpZXM7XG59O1xuXG4vKipcbiAqXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmdldFNob3dDb2RlRWxlbWVudF8gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBzaG93Q29kZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBzaG93Q29kZURpdi5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3Nob3ctY29kZScpO1xuXG4gIHZhciBudW1MaW5lc1dyaXR0ZW4gPSB0aGlzLmdldE51bUJsb2Nrc1VzZWQoKTtcbiAgdmFyIHNob3VsZFNob3dUb3RhbExpbmVzID1cbiAgICAob3B0aW9ucy5yZXNwb25zZSAmJlxuICAgICAgb3B0aW9ucy5yZXNwb25zZS50b3RhbF9saW5lcyAmJlxuICAgICAgKG9wdGlvbnMucmVzcG9uc2UudG90YWxfbGluZXMgIT09IG51bUxpbmVzV3JpdHRlbikpO1xuICB2YXIgdG90YWxOdW1MaW5lc1dyaXR0ZW4gPSBzaG91bGRTaG93VG90YWxMaW5lcyA/IG9wdGlvbnMucmVzcG9uc2UudG90YWxfbGluZXMgOiAwO1xuXG4gIHNob3dDb2RlRGl2LmlubmVySFRNTCA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL3Nob3dDb2RlLmh0bWwuZWpzJykoe1xuICAgIG51bUxpbmVzV3JpdHRlbjogbnVtTGluZXNXcml0dGVuLFxuICAgIHRvdGFsTnVtTGluZXNXcml0dGVuOiB0b3RhbE51bUxpbmVzV3JpdHRlblxuICB9KTtcblxuICB2YXIgc2hvd0NvZGVCdXR0b24gPSBzaG93Q29kZURpdi5xdWVyeVNlbGVjdG9yKCcjc2hvdy1jb2RlLWJ1dHRvbicpO1xuICBzaG93Q29kZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdlbmVyYXRlZENvZGVFbGVtZW50ID0gdGhpcy5nZXRHZW5lcmF0ZWRDb2RlRWxlbWVudF8oe1xuICAgICAgZ2VuZXJhdGVkQ29kZURlc2NyaXB0aW9uOiBvcHRpb25zLmFwcFN0cmluZ3MgJiYgb3B0aW9ucy5hcHBTdHJpbmdzLmdlbmVyYXRlZENvZGVEZXNjcmlwdGlvblxuICAgIH0pO1xuICAgIHNob3dDb2RlRGl2LmFwcGVuZENoaWxkKGdlbmVyYXRlZENvZGVFbGVtZW50KTtcbiAgICBzaG93Q29kZUJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9LCB0aGlzKSk7XG5cbiAgcmV0dXJuIHNob3dDb2RlRGl2O1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHVzZXIgY2FuIHByb2NlZWQgdG8gdGhlIG5leHQgbGV2ZWwsIGJhc2VkIG9uIHRoZSBsZXZlbCBmZWVkYmFja1xuICogQHBhcmFtIHtudW1iZXJ9IGZlZWRiYWNrVHlwZSBBIGNvbnN0YW50IHByb3BlcnR5IG9mIFRlc3RSZXN1bHRzLFxuICogICAgIHR5cGljYWxseSBwcm9kdWNlZCBieSBTdHVkaW9BcHAuZ2V0VGVzdFJlc3VsdHMoKS5cbiAqL1xuRmVlZGJhY2tVdGlscy5wcm90b3R5cGUuY2FuQ29udGludWVUb05leHRMZXZlbCA9IGZ1bmN0aW9uKGZlZWRiYWNrVHlwZSkge1xuICByZXR1cm4gKGZlZWRiYWNrVHlwZSA9PT0gVGVzdFJlc3VsdHMuQUxMX1BBU1MgfHxcbiAgICBmZWVkYmFja1R5cGUgPT09IFRlc3RSZXN1bHRzLlRPT19NQU5ZX0JMT0NLU19GQUlMIHx8XG4gICAgZmVlZGJhY2tUeXBlID09PSAgVGVzdFJlc3VsdHMuQVBQX1NQRUNJRklDX0FDQ0VQVEFCTEVfRkFJTCB8fFxuICAgIGZlZWRiYWNrVHlwZSA9PT0gIFRlc3RSZXN1bHRzLk1JU1NJTkdfUkVDT01NRU5ERURfQkxPQ0tfRklOSVNIRUQgfHxcbiAgICBmZWVkYmFja1R5cGUgPT09ICBUZXN0UmVzdWx0cy5GUkVFX1BMQVkpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgd2Ugc2hvdWxkIHByb21wdCB0aGUgdXNlciB0byBzaG93IHRoZSBnaXZlblxuICogZmVlZGJhY2ssIHJhdGhlciB0aGFuIHNob3dpbmcgaXQgdG8gdGhlbSBhdXRvbWF0aWNhbGx5LiBDdXJyZW50bHlcbiAqIG9ubHkgdXNlZCBmb3IgbWlzc2luZyBibG9jayBmZWVkYmFjazsgbWF5IGV4cGFuZCBpbiB0aGUgZnV0dXJlXG4gKiBAcGFyYW0ge251bWJlcn0gZmVlZGJhY2tUeXBlIEEgY29uc3RhbnQgcHJvcGVydHkgb2YgVGVzdFJlc3VsdHMsXG4gKiAgICAgdHlwaWNhbGx5IHByb2R1Y2VkIGJ5IFN0dWRpb0FwcC5nZXRUZXN0UmVzdWx0cygpLlxuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5zaG91bGRQcm9tcHRGb3JIaW50ID0gZnVuY3Rpb24oZmVlZGJhY2tUeXBlKSB7XG4gIHJldHVybiAoZmVlZGJhY2tUeXBlID09PSBUZXN0UmVzdWx0cy5NSVNTSU5HX0JMT0NLX1VORklOSVNIRUQgfHxcbiAgICBmZWVkYmFja1R5cGUgPT09IFRlc3RSZXN1bHRzLk1JU1NJTkdfQkxPQ0tfRklOSVNIRUQgfHxcbiAgICBmZWVkYmFja1R5cGUgPT09IFRlc3RSZXN1bHRzLk1JU1NJTkdfUkVDT01NRU5ERURfQkxPQ0tfRklOSVNIRUQgfHxcbiAgICBmZWVkYmFja1R5cGUgPT09IFRlc3RSZXN1bHRzLk1JU1NJTkdfUkVDT01NRU5ERURfQkxPQ0tfVU5GSU5JU0hFRCk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHVzZXIncyBnZW5lcmF0ZWQgSmF2YXNjcmlwdCBjb2RlLlxuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5nZXRHZW5lcmF0ZWRDb2RlU3RyaW5nXyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zdHVkaW9BcHBfLmVkaXRDb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R1ZGlvQXBwXy5lZGl0b3IgPyB0aGlzLnN0dWRpb0FwcF8uZWRpdG9yLmdldFZhbHVlKCkgOiAnJztcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gY29kZWdlbi53b3Jrc3BhY2VDb2RlKEJsb2NrbHkpO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIFwic2hvdyBjb2RlXCIgZGl2IHdpdGggYSBkZXNjcmlwdGlvbiBvZiB3aGF0IGNvZGUgaXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gb3B0aW9uYWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5nZW5lcmF0ZWRDb2RlRGVzY3JpcHRpb25dIC0gb3B0aW9uYWwgZGVzY3JpcHRpb25cbiAqICAgICAgICBvZiBjb2RlIHRvIHB1dCBpbiBwbGFjZSBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0XG4gKiBAcmV0dXJucyB7RWxlbWVudH1cbiAqIEBwcml2YXRlXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmdldEdlbmVyYXRlZENvZGVFbGVtZW50XyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGNvZGVJbmZvTXNnUGFyYW1zID0ge1xuICAgIGJlcmtlbGV5TGluazogXCI8YSBocmVmPSdodHRwOi8vYmpjLmJlcmtlbGV5LmVkdS8nIHRhcmdldD0nX2JsYW5rJz5CZXJrZWxleTwvYT5cIixcbiAgICBoYXJ2YXJkTGluazogXCI8YSBocmVmPSdodHRwczovL2NzNTAuaGFydmFyZC5lZHUvJyB0YXJnZXQ9J19ibGFuayc+SGFydmFyZDwvYT5cIlxuICB9O1xuXG4gIHZhciBpbmZvTWVzc2FnZSA9IHRoaXMuZ2V0R2VuZXJhdGVkQ29kZURlc2NyaXB0aW9uKGNvZGVJbmZvTXNnUGFyYW1zLFxuICAgICAgb3B0aW9ucy5nZW5lcmF0ZWRDb2RlRGVzY3JpcHRpb24pO1xuICB2YXIgY29kZSA9IHRoaXMuc3R1ZGlvQXBwXy5wb2xpc2hHZW5lcmF0ZWRDb2RlU3RyaW5nKHRoaXMuZ2V0R2VuZXJhdGVkQ29kZVN0cmluZ18oKSk7XG5cbiAgdmFyIGNvZGVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgY29kZURpdi5pbm5lckhUTUwgPSByZXF1aXJlKCcuL3RlbXBsYXRlcy9jb2RlLmh0bWwuZWpzJykoe1xuICAgIG1lc3NhZ2U6IGluZm9NZXNzYWdlLFxuICAgIGNvZGU6IGNvZGVcbiAgfSk7XG5cbiAgcmV0dXJuIGNvZGVEaXY7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBleHBsYW5hdGlvbiBvZiB3aGF0IGNvZGUgaXMuXG4gKiBAcGFyYW0ge09iamVjdH0gY29kZUluZm9Nc2dQYXJhbXMgLSBwYXJhbXMgZm9yIGdlbmVyYXRlZENvZGVJbmZvIG1zZyBmdW5jdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IFtnZW5lcmF0ZWRDb2RlRGVzY3JpcHRpb25dIC0gb3B0aW9uYWwgZGVzY3JpcHRpb24gdG8gdXNlXG4gKiAgICAgICAgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuRmVlZGJhY2tVdGlscy5wcm90b3R5cGUuZ2V0R2VuZXJhdGVkQ29kZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gKGNvZGVJbmZvTXNnUGFyYW1zLCBnZW5lcmF0ZWRDb2RlRGVzY3JpcHRpb24pIHtcbiAgaWYgKHRoaXMuc3R1ZGlvQXBwXy5lZGl0Q29kZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmIChnZW5lcmF0ZWRDb2RlRGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVkQ29kZURlc2NyaXB0aW9uO1xuICB9XG5cbiAgcmV0dXJuIG1zZy5nZW5lcmF0ZWRDb2RlSW5mbyhjb2RlSW5mb01zZ1BhcmFtcyk7XG59O1xuXG4vKipcbiAqIERpc3BsYXkgdGhlICdTaG93IENvZGUnIG1vZGFsIGRpYWxvZy5cbiAqIEBwYXJhbSB7RGlhbG9nfSBEaWFsb2dcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXBwU3RyaW5nc10gLSBvcHRpb25hbCBhcHAgc3RyaW5ncyB0byBvdmVycmlkZVxuICogQHBhcmFtIHtzdHJpbmd9IFthcHBTdHJpbmdzLmdlbmVyYXRlZENvZGVEZXNjcmlwdGlvbl0gLSBzdHJpbmdcbiAqICAgICAgICB0byBkaXNwbGF5IGluc3RlYWQgb2YgdGhlIHVzdWFsIHNob3cgY29kZSBkZXNjcmlwdGlvblxuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5zaG93R2VuZXJhdGVkQ29kZSA9IGZ1bmN0aW9uKERpYWxvZywgYXBwU3RyaW5ncykge1xuICB2YXIgY29kZURpdiA9IHRoaXMuZ2V0R2VuZXJhdGVkQ29kZUVsZW1lbnRfKHtcbiAgICBnZW5lcmF0ZWRDb2RlRGVzY3JpcHRpb246IGFwcFN0cmluZ3MgJiYgYXBwU3RyaW5ncy5nZW5lcmF0ZWRDb2RlRGVzY3JpcHRpb25cbiAgfSk7XG5cbiAgdmFyIGJ1dHRvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgYnV0dG9ucy5pbm5lckhUTUwgPSByZXF1aXJlKCcuL3RlbXBsYXRlcy9idXR0b25zLmh0bWwuZWpzJykoe1xuICAgIGRhdGE6IHtcbiAgICAgIG9rOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgY29kZURpdi5hcHBlbmRDaGlsZChidXR0b25zKTtcblxuICB2YXIgZGlhbG9nID0gdGhpcy5jcmVhdGVNb2RhbERpYWxvZyh7XG4gICAgICBEaWFsb2c6IERpYWxvZyxcbiAgICAgIGNvbnRlbnREaXY6IGNvZGVEaXYsXG4gICAgICBpY29uOiB0aGlzLnN0dWRpb0FwcF8uaWNvbixcbiAgICAgIGRlZmF1bHRCdG5TZWxlY3RvcjogJyNvay1idXR0b24nXG4gICAgICB9KTtcblxuICB2YXIgb2theUJ1dHRvbiA9IGJ1dHRvbnMucXVlcnlTZWxlY3RvcignI29rLWJ1dHRvbicpO1xuICBpZiAob2theUJ1dHRvbikge1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQob2theUJ1dHRvbiwgZnVuY3Rpb24oKSB7XG4gICAgICBkaWFsb2cuaGlkZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgZGlhbG9nLnNob3coKTtcbn07XG5cbi8qKlxuICogRGlzcGxheSB0aGUgXCJDbGVhciBQdXp6bGVcIiBjb25maXJtYXRpb24gZGlhbG9nLiAgVGFrZXMgYSBwYXJhbWV0ZXIgdG8gaGlkZVxuICogdGhlIGljb24uICBDYWxscyBgY2FsbGJhY2tgIGlmIHRoZSB1c2VyIGNvbmZpcm1zIHRoZXkgd2FudCB0byBjbGVhciB0aGUgcHV6emxlLlxuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5zaG93Q2xlYXJQdXp6bGVDb25maXJtYXRpb24gPSBmdW5jdGlvbihEaWFsb2csIGhpZGVJY29uLCBjYWxsYmFjaykge1xuICB0aGlzLnNob3dTaW1wbGVEaWFsb2coRGlhbG9nLCB7XG4gICAgaGVhZGVyVGV4dDogbXNnLmNsZWFyUHV6emxlQ29uZmlybUhlYWRlcigpLFxuICAgIGJvZHlUZXh0OiBtc2cuY2xlYXJQdXp6bGVDb25maXJtKCksXG4gICAgY29uZmlybVRleHQ6IG1zZy5jbGVhclB1enpsZSgpLFxuICAgIGNhbmNlbFRleHQ6IG1zZy5kaWFsb2dDYW5jZWwoKSxcbiAgICBvbkNvbmZpcm06IGNhbGxiYWNrLFxuICAgIG9uQ2FuY2VsOiBudWxsLFxuICAgIGhpZGVJY29uOiBoaWRlSWNvblxuICB9KTtcbn07XG5cbi8qKlxuICogU2hvd3MgYSBzaW1wbGUgZGlhbG9nIHRoYXQgaGFzIGEgaGVhZGVyLCBib2R5LCBjb250aW51ZSBidXR0b24sIGFuZCBjYW5jZWxcbiAqIGJ1dHRvblxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhYmxlIG9wdGlvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyVGV4dCBUZXh0IGZvciBoZWFkZXIgcG9ydGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGJvZHlUZXh0IFRleHQgZm9yIGJvZHkgcG9ydGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGNhbmNlbFRleHQgVGV4dCBmb3IgY2FuY2VsIGJ1dHRvblxuICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpcm1UZXh0IFRleHQgZm9yIGNvbmZpcm0gYnV0dG9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhpZGVJY29uIFdoZXRoZXIgdG8gaGlkZSB0aGUgaWNvblxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29uQ29uZmlybV0gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIGFmdGVyIGNsaWNraW5nIGNvbmZpcm1cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvbkNhbmNlbF0gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIGFmdGVyIGNsaWNraW5nIGNhbmNlbFxuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5zaG93U2ltcGxlRGlhbG9nID0gZnVuY3Rpb24gKERpYWxvZywgb3B0aW9ucykge1xuICB2YXIgY29udGVudERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb250ZW50RGl2LmlubmVySFRNTCA9ICcnO1xuICBpZiAob3B0aW9ucy5oZWFkZXJUZXh0KSB7XG4gICAgY29udGVudERpdi5pbm5lckhUTUwgKz0gJzxwIGNsYXNzPVwiZGlhbG9nLXRpdGxlXCI+JyArIG9wdGlvbnMuaGVhZGVyVGV4dCArICc8L3A+JztcbiAgfVxuICBpZiAob3B0aW9ucy5ib2R5VGV4dCkge1xuICAgIGNvbnRlbnREaXYuaW5uZXJIVE1MICs9ICc8cD4nICsgb3B0aW9ucy5ib2R5VGV4dCArICc8L3A+JztcbiAgfVxuXG4gIHZhciBidXR0b25zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGJ1dHRvbnMuaW5uZXJIVE1MID0gcmVxdWlyZSgnLi90ZW1wbGF0ZXMvYnV0dG9ucy5odG1sLmVqcycpKHtcbiAgICBkYXRhOiB7XG4gICAgICBjb25maXJtVGV4dDogb3B0aW9ucy5jb25maXJtVGV4dCxcbiAgICAgIGNhbmNlbFRleHQ6IG9wdGlvbnMuY2FuY2VsVGV4dCxcbiAgICAgIGNhbmNlbEJ1dHRvbkNsYXNzOiBvcHRpb25zLmNhbmNlbEJ1dHRvbkNsYXNzXG4gICAgfVxuICB9KTtcbiAgY29udGVudERpdi5hcHBlbmRDaGlsZChidXR0b25zKTtcblxuICB2YXIgZGlhbG9nID0gdGhpcy5jcmVhdGVNb2RhbERpYWxvZyh7XG4gICAgRGlhbG9nOiBEaWFsb2csXG4gICAgY29udGVudERpdjogY29udGVudERpdixcbiAgICBpY29uOiBvcHRpb25zLmhpZGVJY29uID8gbnVsbCA6IHRoaXMuc3R1ZGlvQXBwXy5pY29uLFxuICAgIGRlZmF1bHRCdG5TZWxlY3RvcjogJyNhZ2Fpbi1idXR0b24nXG4gIH0pO1xuXG4gIHZhciBjYW5jZWxCdXR0b24gPSBidXR0b25zLnF1ZXJ5U2VsZWN0b3IoJyNhZ2Fpbi1idXR0b24nKTtcbiAgaWYgKGNhbmNlbEJ1dHRvbikge1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQoY2FuY2VsQnV0dG9uLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChvcHRpb25zLm9uQ2FuY2VsKSB7XG4gICAgICAgIG9wdGlvbnMub25DYW5jZWwoKTtcbiAgICAgIH1cbiAgICAgIGRpYWxvZy5oaWRlKCk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgY29uZmlybUJ1dHRvbiA9IGJ1dHRvbnMucXVlcnlTZWxlY3RvcignI2NvbmZpcm0tYnV0dG9uJyk7XG4gIGlmIChjb25maXJtQnV0dG9uKSB7XG4gICAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChjb25maXJtQnV0dG9uLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChvcHRpb25zLm9uQ29uZmlybSkge1xuICAgICAgICBvcHRpb25zLm9uQ29uZmlybSgpO1xuICAgICAgfVxuICAgICAgZGlhbG9nLmhpZGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpYWxvZy5zaG93KCk7XG59O1xuXG4vKipcbiAqXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLnNob3dUb2dnbGVCbG9ja3NFcnJvciA9IGZ1bmN0aW9uKERpYWxvZykge1xuICB2YXIgY29udGVudERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb250ZW50RGl2LmlubmVySFRNTCA9IG1zZy50b2dnbGVCbG9ja3NFcnJvck1zZygpO1xuXG4gIHZhciBidXR0b25zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGJ1dHRvbnMuaW5uZXJIVE1MID0gcmVxdWlyZSgnLi90ZW1wbGF0ZXMvYnV0dG9ucy5odG1sLmVqcycpKHtcbiAgICBkYXRhOiB7XG4gICAgICBvazogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGNvbnRlbnREaXYuYXBwZW5kQ2hpbGQoYnV0dG9ucyk7XG5cbiAgdmFyIGRpYWxvZyA9IHRoaXMuY3JlYXRlTW9kYWxEaWFsb2coe1xuICAgICAgRGlhbG9nOiBEaWFsb2csXG4gICAgICBjb250ZW50RGl2OiBjb250ZW50RGl2LFxuICAgICAgaWNvbjogdGhpcy5zdHVkaW9BcHBfLmljb24sXG4gICAgICBkZWZhdWx0QnRuU2VsZWN0b3I6ICcjb2stYnV0dG9uJ1xuICB9KTtcblxuICB2YXIgb2theUJ1dHRvbiA9IGJ1dHRvbnMucXVlcnlTZWxlY3RvcignI29rLWJ1dHRvbicpO1xuICBpZiAob2theUJ1dHRvbikge1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQob2theUJ1dHRvbiwgZnVuY3Rpb24oKSB7XG4gICAgICBkaWFsb2cuaGlkZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgZGlhbG9nLnNob3coKTtcbn07XG5cbi8qKlxuICogR2V0IGFuIGVtcHR5IGNvbnRhaW5lciBibG9jaywgaWYgYW55IGFyZSBwcmVzZW50LlxuICogQHJldHVybiB7QmxvY2tseS5CbG9ja30gYW4gZW1wdHkgY29udGFpbmVyIGJsb2NrLCBvciBudWxsIGlmIG5vbmUgZXhpc3QuXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmdldEVtcHR5Q29udGFpbmVyQmxvY2tfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBibG9ja3MgPSBCbG9ja2x5Lm1haW5CbG9ja1NwYWNlLmdldEFsbEJsb2NrcygpO1xuICByZXR1cm4gQmxvY2tseS5maW5kRW1wdHlDb250YWluZXJCbG9jayhibG9ja3MpO1xufTtcblxuLyoqXG4gKiBDaGVjayBmb3IgZW1wdHkgY29udGFpbmVyIGJsb2NrcywgYW5kIHJldHVybiBhbiBhcHByb3ByaWF0ZSBmYWlsdXJlXG4gKiBjb2RlIGlmIGFueSBhcmUgZm91bmQuXG4gKiBAcmV0dXJuIHtUZXN0UmVzdWx0c30gQUxMX1BBU1MgaWYgbm8gZW1wdHkgYmxvY2tzIGFyZSBwcmVzZW50LCBvclxuICogICBFTVBUWV9CTE9DS19GQUlMIG9yIEVNUFRZX0ZVTkNUSU9OX0JMT0NLX0ZBSUwgaWYgZW1wdHkgYmxvY2tzXG4gKiAgIGFyZSBmb3VuZC5cbiAqL1xuRmVlZGJhY2tVdGlscy5wcm90b3R5cGUuY2hlY2tGb3JFbXB0eUNvbnRhaW5lckJsb2NrRmFpbHVyZV8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGVtcHR5QmxvY2sgPSB0aGlzLmdldEVtcHR5Q29udGFpbmVyQmxvY2tfKCk7XG4gIGlmICghZW1wdHlCbG9jaykge1xuICAgIHJldHVybiBUZXN0UmVzdWx0cy5BTExfUEFTUztcbiAgfVxuXG4gIHZhciB0eXBlID0gZW1wdHlCbG9jay50eXBlO1xuICBpZiAodHlwZSA9PT0gJ3Byb2NlZHVyZXNfZGVmbm9yZXR1cm4nIHx8IHR5cGUgPT09ICdwcm9jZWR1cmVzX2RlZnJldHVybicpIHtcbiAgICByZXR1cm4gVGVzdFJlc3VsdHMuRU1QVFlfRlVOQ1RJT05fQkxPQ0tfRkFJTDtcbiAgfVxuXG4gIC8vIEJsb2NrIGlzIGFzc3VtZWQgdG8gYmUgXCJpZlwiIG9yIFwicmVwZWF0XCIgaWYgd2UgcmVhY2ggaGVyZS5cbiAgLy8gVGhpcyBpcyB3aGVyZSB0byBhZGQgY2hlY2tzIGlmIHlvdSB3YW50IGEgZGlmZmVyZW50IFRlc3RSZXN1bHRcbiAgLy8gZm9yIFwiY29udHJvbHNfZm9yX2NvdW50ZXJcIiBibG9ja3MsIGZvciBleGFtcGxlLlxuICByZXR1cm4gVGVzdFJlc3VsdHMuRU1QVFlfQkxPQ0tfRkFJTDtcbn07XG5cbi8qKlxuICogVGhyb3dzIGVycm9ycyB3aXRoIGRlc2NyaXB0aXZlIG1lc3NhZ2VzIHdoZW4gZXhhbXBsZSBjYWxsIG9yIHJlc3VsdCBibG9ja3NcbiAqIGRvbid0IGV4aXN0IG9yIGhhdmUgdW5maWxsZWQgZnVuY3Rpb25hbCBpbnB1dHMuXG4gKiBAcGFyYW0ge0Jsb2NrbHkuQmxvY2t9IGNhbGxCbG9ja1xuICogQHBhcmFtIHtCbG9ja2x5LkJsb2NrfSByZXN1bHRCbG9ja1xuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS50aHJvd09uSW52YWxpZEV4YW1wbGVCbG9ja3MgPSBmdW5jdGlvbiAoY2FsbEJsb2NrLFxuICAgIHJlc3VsdEJsb2NrKSB7XG4gIGlmICghY2FsbEJsb2NrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENhbGwgQmxvY2snKTtcbiAgfVxuXG4gIGlmICghcmVzdWx0QmxvY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUmVzdWx0IEJsb2NrJyk7XG4gIH1cblxuICBpZiAocmVzdWx0QmxvY2suaGFzVW5maWxsZWRGdW5jdGlvbmFsSW5wdXQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVzdWx0IGhhcyB1bmZpbGxlZCBpbnB1dHMnKTtcbiAgfVxuXG4gIGlmIChjYWxsQmxvY2suaGFzVW5maWxsZWRGdW5jdGlvbmFsSW5wdXQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FsbCBoYXMgdW5maWxsZWQgaW5wdXRzJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgdXNlciBjb2RlIGhhcyBhbGwgdGhlIGdpdmVuIGJsb2Nrc1xuICogQHBhcmFtIHshVGVzdGFibGVCbG9ja1tdfSBibG9ja3NcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgYWxsIGJsb2NrcyBhcmUgcHJlc2VudCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5oYXNBbGxCbG9ja3NfID0gZnVuY3Rpb24oYmxvY2tzKSB7XG4gIC8vIEl0J3Mgb2theSAobWF5YmUgZmFzdGVyKSB0byBwYXNzIDEgZm9yIG1heEJsb2Nrc1RvRmxhZywgc2luY2UgaW4gdGhlIGVuZFxuICAvLyB3ZSB3YW50IHRvIGNoZWNrIHRoYXQgdGhlcmUgYXJlIHplcm8gYmxvY2tzIG1pc3NpbmcuXG4gIHZhciBtYXhCbG9ja3NUb0ZsYWcgPSAxO1xuICByZXR1cm4gdGhpcy5nZXRNaXNzaW5nQmxvY2tzXyhibG9ja3MsIG1heEJsb2Nrc1RvRmxhZykuYmxvY2tzVG9EaXNwbGF5Lmxlbmd0aCA9PT0gMDtcbn07XG5cbi8qKlxuICogR2V0IGJsb2NrcyB0aGF0IHRoZSB1c2VyIGludGVuZHMgaW4gdGhlIHByb2dyYW0uIFRoZXNlIGFyZSB0aGUgYmxvY2tzXG4gKiB0aGF0IGFyZSB1c2VkIHdoZW4gY2hlY2tpbmcgZm9yIHJlcXVpcmVkIGFuZCByZWNvbW1lbmRlZCBibG9ja3MgYW5kXG4gKiB3aGVuIGRldGVybWluaW5nIGxpbmVzIG9mIGNvZGUgd3JpdHRlbi5cbiAqIEByZXR1cm4ge0FycmF5PE9iamVjdD59IFRoZSBibG9ja3MuXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmdldFVzZXJCbG9ja3NfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhbGxCbG9ja3MgPSBCbG9ja2x5Lm1haW5CbG9ja1NwYWNlLmdldEFsbEJsb2NrcygpO1xuICB2YXIgYmxvY2tzID0gYWxsQmxvY2tzLmZpbHRlcihmdW5jdGlvbihibG9jaykge1xuICAgIHZhciBibG9ja1ZhbGlkID0gIWJsb2NrLmRpc2FibGVkICYmIGJsb2NrLnR5cGUgIT09ICd3aGVuX3J1bic7XG4gICAgLy8gSWYgQmxvY2tseSBpcyBpbiByZWFkT25seSBtb2RlLCB0aGVuIGFsbCBibG9ja3MgYXJlIHVuZWRpdGFibGVcbiAgICAvLyBzbyB0aGlzIGZpbHRlciB3b3VsZCBiZSB1c2VsZXNzLiBJZ25vcmUgdW5lZGl0YWJsZSBibG9ja3Mgb25seSBpZlxuICAgIC8vIEJsb2NrbHkgaXMgaW4gZWRpdCBtb2RlLlxuICAgIGlmICghQmxvY2tseS5tYWluQmxvY2tTcGFjZS5pc1JlYWRPbmx5KCkpIHtcbiAgICAgIGJsb2NrVmFsaWQgPSBibG9ja1ZhbGlkICYmIGJsb2NrLmlzRWRpdGFibGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGJsb2NrVmFsaWQ7XG4gIH0pO1xuICByZXR1cm4gYmxvY2tzO1xufTtcblxuLyoqXG4gKiBHZXQgY291bnRhYmxlIGJsb2NrcyBpbiB0aGUgcHJvZ3JhbSwgbmFtZWx5IGFueSB0aGF0IGFyZSBub3QgZGlzYWJsZWQuXG4gKiBUaGVzZSBhcmUgdXNlZCB3aGVuIGRldGVybWluZWQgdGhlIG51bWJlciBvZiBibG9ja3MgcmVsYXRpdmUgdG8gdGhlIGlkZWFsXG4gKiBibG9jayBjb3VudC5cbiAqIEByZXR1cm4ge0FycmF5PE9iamVjdD59IFRoZSBibG9ja3MuXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmdldENvdW50YWJsZUJsb2Nrc18gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGFsbEJsb2NrcyA9IEJsb2NrbHkubWFpbkJsb2NrU3BhY2UuZ2V0QWxsQmxvY2tzKCk7XG4gIHZhciBibG9ja3MgPSBhbGxCbG9ja3MuZmlsdGVyKGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgcmV0dXJuICFibG9jay5kaXNhYmxlZDtcbiAgfSk7XG4gIHJldHVybiBibG9ja3M7XG59O1xuXG4vKipcbiAqIENoZWNrIHRvIHNlZSBpZiB0aGUgdXNlcidzIGNvZGUgY29udGFpbnMgdGhlIGdpdmVuIGJsb2NrcyBmb3IgYSBsZXZlbC5cbiAqIEBwYXJhbSB7IVRlc3RhYmxlQmxvY2tbXX0gYmxvY2tzXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4QmxvY2tzVG9GbGFnIFRoZSBtYXhpbXVtIG51bWJlciBvZiBibG9ja3MgdG9cbiAqICAgcmV0dXJuLiBXZSBtb3N0IG9mdGVuIG9ubHkgY2FyZSBhYm91dCBhIHNpbmdsZSBibG9jayBhdCBhIHRpbWVcbiAqIEByZXR1cm4ge3tibG9ja3NUb0Rpc3BsYXk6IUFycmF5LCBtZXNzYWdlOj9zdHJpbmd9fSAnbWlzc2luZ0Jsb2NrcycgaXMgYW5cbiAqICAgYXJyYXkgb2YgYXJyYXkgb2Ygc3RyaW5ncyB3aGVyZSBlYWNoIGFycmF5IG9mIHN0cmluZ3MgaXMgYSBzZXQgb2YgYmxvY2tzXG4gKiAgIHRoYXQgYXQgbGVhc3Qgb25lIG9mIHRoZW0gc2hvdWxkIGJlIHVzZWQuIEVhY2ggYmxvY2sgaXMgcmVwcmVzZW50ZWQgYXMgdGhlXG4gKiAgIHByZWZpeCBvZiBhbiBpZCBpbiB0aGUgY29ycmVzcG9uZGluZyB0ZW1wbGF0ZS5zb3kuICdtZXNzYWdlJyBpcyBhblxuICogICBvcHRpb25hbCBtZXNzYWdlIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGVycm9yIHRleHQuXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmdldE1pc3NpbmdCbG9ja3NfID0gZnVuY3Rpb24gKGJsb2NrcywgbWF4QmxvY2tzVG9GbGFnKSB7XG4gIHZhciBtaXNzaW5nQmxvY2tzID0gW107XG4gIHZhciBjdXN0b21NZXNzYWdlID0gbnVsbDtcbiAgdmFyIGNvZGUgPSBudWxsOyAgLy8gSmF2YVNjcmlwdCBjb2RlLCB3aGljaCBpcyBpbml0aWFsaXplZCBsYXppbHkuXG4gIGlmIChibG9ja3MgJiYgYmxvY2tzLmxlbmd0aCkge1xuICAgIHZhciB1c2VyQmxvY2tzID0gdGhpcy5nZXRVc2VyQmxvY2tzXygpO1xuICAgIC8vIEZvciBlYWNoIGxpc3Qgb2YgYmxvY2tzXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgbnVtYmVyIG9mIHRoZSBtaXNzaW5nIGJsb2NrIGxpc3RzLiBJdCBzaG91bGQgbm90IGJlXG4gICAgLy8gYmlnZ2VyIHRoYW4gdGhlIG1heEJsb2Nrc1RvRmxhZyBwYXJhbS5cbiAgICB2YXIgbWlzc2luZ0Jsb2NrTnVtID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDtcbiAgICAgICAgIGkgPCBibG9ja3MubGVuZ3RoICYmXG4gICAgICAgICAgICAgbWlzc2luZ0Jsb2NrTnVtIDwgbWF4QmxvY2tzVG9GbGFnO1xuICAgICAgICAgaSsrKSB7XG4gICAgICB2YXIgYmxvY2sgPSBibG9ja3NbaV07XG4gICAgICAvLyBGb3IgZWFjaCBvZiB0aGUgdGVzdFxuICAgICAgLy8gSWYgYXQgbGVhc3Qgb25lIG9mIHRoZSB0ZXN0cyBzdWNjZWVkZWQsIHdlIGNvbnNpZGVyIHRoZSBibG9ja1xuICAgICAgLy8gaXMgdXNlZFxuICAgICAgdmFyIHVzZWRCbG9jayA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgdGVzdElkID0gMDsgdGVzdElkIDwgYmxvY2subGVuZ3RoOyB0ZXN0SWQrKykge1xuICAgICAgICB2YXIgdGVzdCA9IGJsb2NrW3Rlc3RJZF0udGVzdDtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvZGUgPSBjb2RlIHx8IEJsb2NrbHkuR2VuZXJhdG9yLmJsb2NrU3BhY2VUb0NvZGUoJ0phdmFTY3JpcHQnKTtcbiAgICAgICAgICBpZiAoY29kZS5pbmRleE9mKHRlc3QpICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gU3VjY2VlZGVkLCBtb3ZpbmcgdG8gdGhlIG5leHQgbGlzdCBvZiB0ZXN0c1xuICAgICAgICAgICAgdXNlZEJsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGVzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGlmICh1c2VyQmxvY2tzLnNvbWUodGVzdCkpIHtcbiAgICAgICAgICAgIC8vIFN1Y2NlZWRlZCwgbW92aW5nIHRvIHRoZSBuZXh0IGxpc3Qgb2YgdGVzdHNcbiAgICAgICAgICAgIHVzZWRCbG9jayA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VzdG9tTWVzc2FnZSA9IGJsb2NrW3Rlc3RJZF0ubWVzc2FnZSB8fCBjdXN0b21NZXNzYWdlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCB0ZXN0OiAnICsgdGVzdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdXNlZEJsb2NrKSB7XG4gICAgICAgIG1pc3NpbmdCbG9ja051bSsrO1xuICAgICAgICBtaXNzaW5nQmxvY2tzID0gbWlzc2luZ0Jsb2Nrcy5jb25jYXQoYmxvY2tzW2ldWzBdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBibG9ja3NUb0Rpc3BsYXk6IG1pc3NpbmdCbG9ja3MsXG4gICAgbWVzc2FnZTogY3VzdG9tTWVzc2FnZVxuICB9O1xufTtcblxuLyoqXG4gKiBEbyB3ZSBoYXZlIGFueSBmbG9hdGluZyBibG9ja3Mgbm90IGF0dGFjaGVkIHRvIGFuIGV2ZW50IGJsb2NrIG9yIGZ1bmN0aW9uIGJsb2NrP1xuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5oYXNFeHRyYVRvcEJsb2NrcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3R1ZGlvQXBwXy5lZGl0Q29kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdG9wQmxvY2tzID0gQmxvY2tseS5tYWluQmxvY2tTcGFjZS5nZXRUb3BCbG9ja3MoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3BCbG9ja3MubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBpZ25vcmUgZGlzYWJsZWQgdG9wIGJsb2Nrcy4gd2UgaGF2ZSBhIGxldmVsIHR1cnRsZToyXzcgdGhhdCBkZXBlbmRzIG9uXG4gICAgLy8gaGF2aW5nIGRpc2FibGVkIHRvcCBsZXZlbCBibG9ja3NcbiAgICBpZiAodG9wQmxvY2tzW2ldLmRpc2FibGVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gSWdub3JlIHRvcCBibG9ja3Mgd2hpY2ggYXJlIGZ1bmN0aW9uYWwgZGVmaW5pdGlvbnMuXG4gICAgaWYgKHRvcEJsb2Nrc1tpXS50eXBlID09PSAnZnVuY3Rpb25hbF9kZWZpbml0aW9uJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIE5vbmUgb2Ygb3VyIHRvcCBsZXZlbCBibG9ja3Mgc2hvdWxkIGhhdmUgYSBwcmV2aW91cyBvciBvdXRwdXQgY29ubmVjdGlvblxuICAgIC8vICh0aGV5IHNob3VsZCBvbmx5IGhhdmUgYSBuZXh0KVxuICAgIGlmICh0b3BCbG9ja3NbaV0ucHJldmlvdXNDb25uZWN0aW9uIHx8IHRvcEJsb2Nrc1tpXS5vdXRwdXRDb25uZWN0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSdW5zIHRoZSB0ZXN0cyBhbmQgcmV0dXJucyByZXN1bHRzLlxuICogQHBhcmFtIHtib29sZWFufSBsZXZlbENvbXBsZXRlIERpZCB0aGUgdXNlciBzdWNjZXNzZnVsbHkgY29tcGxldGUgdGhlIGxldmVsP1xuICogQHBhcmFtIHshVGVzdGFibGVCbG9ja1tdfSByZXF1aXJlZEJsb2NrcyBUaGUgYmxvY2tzIHRoYXQgYXJlIHJlcXVpcmVkXG4gKiAgIHRvIGJlIHVzZWQgaW4gdGhlIHNvbHV0aW9uIHRvIHRoaXMgbGV2ZWwuXG4gKiBAcGFyYW0geyFUZXN0YWJsZUJsb2NrW119IHJlY29tbWVuZGVkQmxvY2tzIFRoZSBibG9ja3MgdGhhdCBhcmVcbiAqICAgcmVjb21tZW5kZWQgdG8gYmUgdXNlZCBpbiB0aGUgc29sdXRpb24gdG8gdGhpcyBsZXZlbC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkQ2hlY2tGb3JFbXB0eUJsb2NrcyBXaGV0aGVyIGVtcHR5IGJsb2NrcyBzaG91bGQgY2F1c2VcbiAqICAgYSB0ZXN0IGZhaWwgcmVzdWx0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFwcHJvcHJpYXRlIHByb3BlcnR5IG9mIFRlc3RSZXN1bHRzLlxuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5nZXRUZXN0UmVzdWx0cyA9IGZ1bmN0aW9uKGxldmVsQ29tcGxldGUsIHJlcXVpcmVkQmxvY2tzLFxuICAgIHJlY29tbWVuZGVkQmxvY2tzLCBzaG91bGRDaGVja0ZvckVtcHR5QmxvY2tzLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAodGhpcy5zdHVkaW9BcHBfLmVkaXRDb2RlKSB7XG4gICAgaWYgKGxldmVsQ29tcGxldGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0dWRpb0FwcF8uVGVzdFJlc3VsdHMuQUxMX1BBU1M7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmV4ZWN1dGlvbkVycm9yICYmIG9wdGlvbnMuZXhlY3V0aW9uRXJyb3IuZXJyIGluc3RhbmNlb2YgU3ludGF4RXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0dWRpb0FwcF8uVGVzdFJlc3VsdHMuU1lOVEFYX0VSUk9SX0ZBSUw7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmV4ZWN1dGlvbkVycm9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHVkaW9BcHBfLlRlc3RSZXN1bHRzLlJVTlRJTUVfRVJST1JfRkFJTDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc3R1ZGlvQXBwXy5UZXN0UmVzdWx0cy5UT09fRkVXX0JMT0NLU19GQUlMO1xuICAgIH1cbiAgfVxuICBpZiAoc2hvdWxkQ2hlY2tGb3JFbXB0eUJsb2Nrcykge1xuICAgIHZhciBlbXB0eUJsb2NrRmFpbHVyZSA9IHRoaXMuY2hlY2tGb3JFbXB0eUNvbnRhaW5lckJsb2NrRmFpbHVyZV8oKTtcbiAgICBpZiAoZW1wdHlCbG9ja0ZhaWx1cmUgIT09IFRlc3RSZXN1bHRzLkFMTF9QQVNTKSB7XG4gICAgICByZXR1cm4gZW1wdHlCbG9ja0ZhaWx1cmU7XG4gICAgfVxuICB9XG4gIGlmICghb3B0aW9ucy5hbGxvd1RvcEJsb2NrcyAmJiB0aGlzLmhhc0V4dHJhVG9wQmxvY2tzKCkpIHtcbiAgICByZXR1cm4gVGVzdFJlc3VsdHMuRVhUUkFfVE9QX0JMT0NLU19GQUlMO1xuICB9XG4gIGlmICh0aGlzLnN0dWRpb0FwcF8uaGFzRHVwbGljYXRlVmFyaWFibGVzSW5Gb3JMb29wcygpKSB7XG4gICAgcmV0dXJuIFRlc3RSZXN1bHRzLk5FU1RFRF9GT1JfU0FNRV9WQVJJQUJMRTtcbiAgfVxuICBpZiAoQmxvY2tseS51c2VDb250cmFjdEVkaXRvciB8fCBCbG9ja2x5LnVzZU1vZGFsRnVuY3Rpb25FZGl0b3IpIHtcbiAgICBpZiAodGhpcy5oYXNVbnVzZWRQYXJhbV8oKSkge1xuICAgICAgcmV0dXJuIFRlc3RSZXN1bHRzLlVOVVNFRF9QQVJBTTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzVW51c2VkRnVuY3Rpb25fKCkpIHtcbiAgICAgIHJldHVybiBUZXN0UmVzdWx0cy5VTlVTRURfRlVOQ1RJT047XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc1BhcmFtSW5wdXRVbmF0dGFjaGVkXygpKSB7XG4gICAgICByZXR1cm4gVGVzdFJlc3VsdHMuUEFSQU1fSU5QVVRfVU5BVFRBQ0hFRDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzSW5jb21wbGV0ZUJsb2NrSW5GdW5jdGlvbl8oKSkge1xuICAgICAgcmV0dXJuIFRlc3RSZXN1bHRzLklOQ09NUExFVEVfQkxPQ0tfSU5fRlVOQ1RJT047XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLmhhc1F1ZXN0aW9uTWFya3NJbk51bWJlckZpZWxkKCkpIHtcbiAgICByZXR1cm4gVGVzdFJlc3VsdHMuUVVFU1RJT05fTUFSS1NfSU5fTlVNQkVSX0ZJRUxEO1xuICB9XG4gIGlmICghdGhpcy5oYXNBbGxCbG9ja3NfKHJlcXVpcmVkQmxvY2tzKSkge1xuICAgIHJldHVybiBsZXZlbENvbXBsZXRlID9cbiAgICAgICAgVGVzdFJlc3VsdHMuTUlTU0lOR19CTE9DS19GSU5JU0hFRCA6XG4gICAgICAgIFRlc3RSZXN1bHRzLk1JU1NJTkdfQkxPQ0tfVU5GSU5JU0hFRDtcbiAgfVxuICBpZiAoIXRoaXMuaGFzQWxsQmxvY2tzXyhyZWNvbW1lbmRlZEJsb2NrcykpIHtcbiAgICByZXR1cm4gbGV2ZWxDb21wbGV0ZSA/XG4gICAgICAgIFRlc3RSZXN1bHRzLk1JU1NJTkdfUkVDT01NRU5ERURfQkxPQ0tfRklOSVNIRUQgOlxuICAgICAgICBUZXN0UmVzdWx0cy5NSVNTSU5HX1JFQ09NTUVOREVEX0JMT0NLX1VORklOSVNIRUQ7XG4gIH1cbiAgdmFyIG51bUVuYWJsZWRCbG9ja3MgPSB0aGlzLmdldE51bUNvdW50YWJsZUJsb2NrcygpO1xuICBpZiAoIWxldmVsQ29tcGxldGUpIHtcbiAgICBpZiAodGhpcy5zdHVkaW9BcHBfLklERUFMX0JMT0NLX05VTSAmJlxuICAgICAgICB0aGlzLnN0dWRpb0FwcF8uSURFQUxfQkxPQ0tfTlVNICE9PSBJbmZpbml0eSAmJlxuICAgICAgICBudW1FbmFibGVkQmxvY2tzIDwgdGhpcy5zdHVkaW9BcHBfLklERUFMX0JMT0NLX05VTSkge1xuICAgICAgcmV0dXJuIFRlc3RSZXN1bHRzLlRPT19GRVdfQkxPQ0tTX0ZBSUw7XG4gICAgfVxuICAgIHJldHVybiBUZXN0UmVzdWx0cy5MRVZFTF9JTkNPTVBMRVRFX0ZBSUw7XG4gIH1cbiAgaWYgKHRoaXMuc3R1ZGlvQXBwXy5JREVBTF9CTE9DS19OVU0gJiZcbiAgICAgIG51bUVuYWJsZWRCbG9ja3MgPiB0aGlzLnN0dWRpb0FwcF8uSURFQUxfQkxPQ0tfTlVNKSB7XG4gICAgcmV0dXJuIFRlc3RSZXN1bHRzLlRPT19NQU5ZX0JMT0NLU19GQUlMO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBUZXN0UmVzdWx0cy5BTExfUEFTUztcbiAgfVxufTtcblxuLyoqXG4gKiBTaG93IGEgbW9kYWwgZGlhbG9nIHdpdGhvdXQgYW4gaWNvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0RpYWxvZ30gb3B0aW9ucy5EaWFsb2dcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmljb25cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9wdGlvbnMuY29udGVudERpdlxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZGVmYXVsdEJ0blNlbGVjdG9yXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMubWFya2Rvd25Nb2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2Nyb2xsQ29udGVudFxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNjcm9sbGFibGVTZWxlY3RvclxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5vbkhpZGRlblxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuaWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9wdGlvbnMuaGVhZGVyXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmNyZWF0ZU1vZGFsRGlhbG9nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgbW9kYWxCb2R5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGlmIChvcHRpb25zLmljb24pIHtcbiAgICB2YXIgaW1hZ2VEaXY7XG4gICAgaW1hZ2VEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICBpbWFnZURpdi5jbGFzc05hbWUgPSBcIm1vZGFsLWltYWdlXCI7XG4gICAgaW1hZ2VEaXYuc3JjID0gb3B0aW9ucy5pY29uO1xuICAgIG1vZGFsQm9keS5hcHBlbmRDaGlsZChpbWFnZURpdik7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5jb250ZW50RGl2LmNsYXNzTmFtZSArPSAnIG5vLW1vZGFsLWljb24nO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMubWFya2Rvd25Nb2RlKSB7XG4gICAgbW9kYWxCb2R5LmNsYXNzTmFtZSArPSAnIG1hcmtkb3duJztcbiAgfVxuXG4gIG9wdGlvbnMuY29udGVudERpdi5jbGFzc05hbWUgKz0gJyBtb2RhbC1jb250ZW50JztcbiAgbW9kYWxCb2R5LmFwcGVuZENoaWxkKG9wdGlvbnMuY29udGVudERpdik7XG5cbiAgdmFyIGJ0biA9IG9wdGlvbnMuY29udGVudERpdi5xdWVyeVNlbGVjdG9yKG9wdGlvbnMuZGVmYXVsdEJ0blNlbGVjdG9yKTtcbiAgdmFyIGtleWRvd25IYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgIGlmIChlLmtleUNvZGUgPT0gS2V5Q29kZXMuRU5URVIgfHwgZS5rZXlDb2RlID09IEtleUNvZGVzLlNQQUNFKSB7XG4gICAgICAvLyBTaW11bGF0ZSBhICdjbGljayc6XG4gICAgICB2YXIgZXZlbnQgPSBuZXcgTW91c2VFdmVudCgnY2xpY2snLCB7XG4gICAgICAgICAgJ3ZpZXcnOiB3aW5kb3csXG4gICAgICAgICAgJ2J1YmJsZXMnOiB0cnVlLFxuICAgICAgICAgICdjYW5jZWxhYmxlJzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBidG4uZGlzcGF0Y2hFdmVudChldmVudCk7XG5cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBzY3JvbGxhYmxlU2VsZWN0b3IgPSBvcHRpb25zLnNjcm9sbGFibGVTZWxlY3RvciB8fCAnLm1vZGFsLWNvbnRlbnQnO1xuICB2YXIgZWxlbWVudFRvU2Nyb2xsID0gb3B0aW9ucy5zY3JvbGxDb250ZW50ID8gc2Nyb2xsYWJsZVNlbGVjdG9yIDogbnVsbDtcbiAgcmV0dXJuIG5ldyBvcHRpb25zLkRpYWxvZyh7XG4gICAgYm9keTogbW9kYWxCb2R5LFxuICAgIG9uSGlkZGVuOiBvcHRpb25zLm9uSGlkZGVuLFxuICAgIG9uS2V5ZG93bjogYnRuID8ga2V5ZG93bkhhbmRsZXIgOiB1bmRlZmluZWQsXG4gICAgYXV0b1Jlc2l6ZVNjcm9sbGFibGVFbGVtZW50OiBlbGVtZW50VG9TY3JvbGwsXG4gICAgaWQ6IG9wdGlvbnMuaWQsXG4gICAgaGVhZGVyOiBvcHRpb25zLmhlYWRlclxuICB9KTtcbn07XG5cbi8qKlxuICogQ2hlY2sgZm9yICc/Pz8nIGluc3RlYWQgb2YgYSB2YWx1ZSBpbiBibG9jayBmaWVsZHMuXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmhhc1F1ZXN0aW9uTWFya3NJbk51bWJlckZpZWxkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gQmxvY2tseS5tYWluQmxvY2tTcGFjZS5nZXRBbGxCbG9ja3MoKS5zb21lKGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgcmV0dXJuIGJsb2NrLmdldFRpdGxlcygpLnNvbWUoZnVuY3Rpb24odGl0bGUpIHtcbiAgICAgIHJldHVybiB0aXRsZS52YWx1ZV8gPT09ICc/Pz8nIHx8IHRpdGxlLnRleHRfID09PSAnPz8/JztcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGFsbCBwcm9jZWR1cmUgZGVmaW5pdGlvbnMgYWN0dWFsbHkgdXNlIHRoZSBwYXJhbWV0ZXJzIHRoZXkgZGVmaW5lXG4gKiBpbnNpZGUgdGhlIHByb2NlZHVyZS5cbiAqL1xuRmVlZGJhY2tVdGlscy5wcm90b3R5cGUuaGFzVW51c2VkUGFyYW1fID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBCbG9ja2x5Lm1haW5CbG9ja1NwYWNlLmdldEFsbEJsb2NrcygpLnNvbWUoZnVuY3Rpb24odXNlckJsb2NrKSB7XG4gICAgdmFyIHBhcmFtcyA9IHVzZXJCbG9jay5wYXJhbWV0ZXJOYW1lc187XG4gICAgLy8gT25seSBzZWFyY2ggcHJvY2VkdXJlIGRlZmluaXRpb25zXG4gICAgcmV0dXJuIHBhcmFtcyAmJiBwYXJhbXMuc29tZShmdW5jdGlvbihwYXJhbU5hbWUpIHtcbiAgICAgIC8vIFVudXNlZCBwYXJhbSBpZiB0aGVyZSdzIG5vIHBhcmFtZXRlcnNfZ2V0IGRlc2NlbmRhbnQgd2l0aCB0aGUgc2FtZSBuYW1lXG4gICAgICByZXR1cm4gIXNlbGYuaGFzTWF0Y2hpbmdEZXNjZW5kYW50Xyh1c2VyQmxvY2ssIGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgICAgIHJldHVybiAoYmxvY2sudHlwZSA9PT0gJ3BhcmFtZXRlcnNfZ2V0JyB8fFxuICAgICAgICAgICAgYmxvY2sudHlwZSA9PT0gJ2Z1bmN0aW9uYWxfcGFyYW1ldGVyc19nZXQnIHx8XG4gICAgICAgICAgICBibG9jay50eXBlID09PSAndmFyaWFibGVzX2dldCcpICYmXG4gICAgICAgICAgICBibG9jay5nZXRUaXRsZVZhbHVlKCdWQVInKSA9PT0gcGFyYW1OYW1lO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhbGwgcHJvY2VkdXJlIGNhbGxzIGhhdmUgZWFjaCBwYXJhbWV0ZXIgaW5wdXQgY29ubmVjdGVkLlxuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5oYXNQYXJhbUlucHV0VW5hdHRhY2hlZF8gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBCbG9ja2x5Lm1haW5CbG9ja1NwYWNlLmdldEFsbEJsb2NrcygpLnNvbWUoZnVuY3Rpb24odXNlckJsb2NrKSB7XG4gICAgLy8gT25seSBjaGVjayBwcm9jZWR1cmVfY2FsbCogYmxvY2tzXG4gICAgaWYgKCEvXnByb2NlZHVyZXNfY2FsbC8udGVzdCh1c2VyQmxvY2sudHlwZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZXJCbG9jay5pbnB1dExpc3QuZmlsdGVyKGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICByZXR1cm4gKC9eQVJHLy50ZXN0KGlucHV0Lm5hbWUpKTtcbiAgICB9KS5zb21lKGZ1bmN0aW9uKGFyZ0lucHV0KSB7XG4gICAgICAvLyBVbmF0dGFjaGVkIHBhcmFtIGlucHV0IGlmIGFueSBBUkcqIGNvbm5lY3Rpb24gdGFyZ2V0IGlzIG51bGxcbiAgICAgIHJldHVybiAhYXJnSW5wdXQuY29ubmVjdGlvbi50YXJnZXRDb25uZWN0aW9uO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYWxsIHVzZXItZGVjbGFyZWQgcHJvY2VkdXJlcyBoYXZlIGFzc29jaWF0ZWQgY2FsbCBibG9ja3MuXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmhhc1VudXNlZEZ1bmN0aW9uXyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHVzZXJEZWZzID0gW107XG4gIHZhciBjYWxsQmxvY2tzID0ge307XG4gIEJsb2NrbHkubWFpbkJsb2NrU3BhY2UuZ2V0QWxsQmxvY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2spIHtcbiAgICB2YXIgbmFtZSA9IGJsb2NrLmdldFRpdGxlVmFsdWUoJ05BTUUnKTtcbiAgICBpZiAoL15wcm9jZWR1cmVzX2RlZi8udGVzdChibG9jay50eXBlKSAmJiBibG9jay51c2VyQ3JlYXRlZCkge1xuICAgICAgdXNlckRlZnMucHVzaChuYW1lKTtcbiAgICB9IGVsc2UgaWYgKC9ecHJvY2VkdXJlc19jYWxsLy50ZXN0KGJsb2NrLnR5cGUpKSB7XG4gICAgICBjYWxsQmxvY2tzW25hbWVdID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICAvLyBVbnVzZWQgZnVuY3Rpb24gaWYgc29tZSB1c2VyIGRlZiBkb2Vzbid0IGhhdmUgYSBtYXRjaGluZyBjYWxsXG4gIHJldHVybiB1c2VyRGVmcy5zb21lKGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuICFjYWxsQmxvY2tzW25hbWVdOyB9KTtcbn07XG5cbi8qKlxuICogRW5zdXJlIHRoZXJlIGFyZSBubyBpbmNvbXBsZXRlIGJsb2NrcyBpbnNpZGUgYW55IGZ1bmN0aW9uIGRlZmluaXRpb25zLlxuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5oYXNJbmNvbXBsZXRlQmxvY2tJbkZ1bmN0aW9uXyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gQmxvY2tseS5tYWluQmxvY2tTcGFjZS5nZXRBbGxCbG9ja3MoKS5zb21lKGZ1bmN0aW9uKHVzZXJCbG9jaykge1xuICAgIC8vIE9ubHkgc2VhcmNoIHByb2NlZHVyZSBkZWZpbml0aW9uc1xuICAgIGlmICghdXNlckJsb2NrLnBhcmFtZXRlck5hbWVzXykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZi5oYXNNYXRjaGluZ0Rlc2NlbmRhbnRfKHVzZXJCbG9jaywgZnVuY3Rpb24oYmxvY2spIHtcbiAgICAgIC8vIEluY29tcGxldGUgYmxvY2sgaWYgYW55IGlucHV0IGNvbm5lY3Rpb24gdGFyZ2V0IGlzIG51bGxcbiAgICAgIHJldHVybiBibG9jay5pbnB1dExpc3Quc29tZShmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQudHlwZSA9PT0gQmxvY2tseS5JTlBVVF9WQUxVRSAmJlxuICAgICAgICAgICAgIWlucHV0LmNvbm5lY3Rpb24udGFyZ2V0Q29ubmVjdGlvbjtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFueSBkZXNjZW5kYW50IChpbmNsdXNpdmUpIG9mIHRoZSBnaXZlbiBub2RlIG1hdGNoZXMgdGhlXG4gKiBnaXZlbiBmaWx0ZXIuXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmhhc01hdGNoaW5nRGVzY2VuZGFudF8gPSBmdW5jdGlvbiAobm9kZSwgZmlsdGVyKSB7XG4gIGlmIChmaWx0ZXIobm9kZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBub2RlLmNoaWxkQmxvY2tzXy5zb21lKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBzZWxmLmhhc01hdGNoaW5nRGVzY2VuZGFudF8oY2hpbGQsIGZpbHRlcik7XG4gIH0pO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24gYW5vbnltb3VzKGxvY2FscywgZmlsdGVycywgZXNjYXBlXG4vKiovKSB7XG5lc2NhcGUgPSBlc2NhcGUgfHwgZnVuY3Rpb24gKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xudmFyIGJ1ZiA9IFtdO1xud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyBcbiBidWYucHVzaCgnPGRpdiBjbGFzcz1cXCd0cm9waHlcXCc+PGltZyBjbGFzcz1cXCd0cm9waHlpbWdcXCcgc3JjPVxcJycsIGVzY2FwZSgoMSwgIGltZ191cmwgKSksICdcXCc+PGJyPicsIGVzY2FwZSgoMSwgIGNvbmNlcHRfbmFtZSApKSwgJzwvZGl2PlxcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIm1vZHVsZS5leHBvcnRzPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24gYW5vbnltb3VzKGxvY2FscywgZmlsdGVycywgZXNjYXBlXG4vKiovKSB7XG5lc2NhcGUgPSBlc2NhcGUgfHwgZnVuY3Rpb24gKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xudmFyIGJ1ZiA9IFtdO1xud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyBcbiBidWYucHVzaCgnJyk7MTsgdmFyIG1zZyA9IHJlcXVpcmUoJy4uL2xvY2FsZScpOyA7IGJ1Zi5wdXNoKCdcXG5cXG48cCBpZD1cIm51bS1saW5lcy1vZi1jb2RlXCIgY2xhc3M9XCJsaW5lcy1vZi1jb2RlLW1lc3NhZ2VcIj5cXG4gICcsIGVzY2FwZSgoNCwgIG1zZy5udW1MaW5lc09mQ29kZVdyaXR0ZW4oeyBudW1MaW5lczogbnVtTGluZXNXcml0dGVuIH0pICkpLCAnXFxuICA8YnV0dG9uIGlkPVwic2hvdy1jb2RlLWJ1dHRvblwiIGhyZWY9XCIjXCI+XFxuICAgICcsIGVzY2FwZSgoNiwgIG1zZy5zaG93R2VuZXJhdGVkQ29kZSgpICkpLCAnXFxuICA8L2J1dHRvbj5cXG48L3A+XFxuXFxuJyk7MTA7IGlmICh0b3RhbE51bUxpbmVzV3JpdHRlbiAhPT0gMCkgeyA7IGJ1Zi5wdXNoKCdcXG4gIDxwIGlkPVwidG90YWwtbnVtLWxpbmVzLW9mLWNvZGVcIiBjbGFzcz1cImxpbmVzLW9mLWNvZGUtbWVzc2FnZVwiPlxcbiAgICAnLCBlc2NhcGUoKDEyLCAgbXNnLnRvdGFsTnVtTGluZXNPZkNvZGVXcml0dGVuKHsgbnVtTGluZXM6IHRvdGFsTnVtTGluZXNXcml0dGVuIH0pICkpLCAnXFxuICA8L3A+XFxuJyk7MTQ7IH0gOyBidWYucHVzaCgnXFxuJyk7IH0pKCk7XG59IFxucmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG4gIHJldHVybiBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICByZXR1cm4gdChsb2NhbHMsIHJlcXVpcmUoXCJlanNcIikuZmlsdGVycyk7XG4gIH1cbn0oKSk7IiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCcnKTsxOyB2YXIgbXNnID0gcmVxdWlyZSgnLi4vbG9jYWxlJyk7IDsgYnVmLnB1c2goJ1xcbicpOzI7IGlmIChvcHRpb25zLmZlZWRiYWNrSW1hZ2UpIHsgOyBidWYucHVzaCgnXFxuICA8aW1nIGNsYXNzPVwiZmVlZGJhY2staW1hZ2VcIiBzcmM9XCInLCBlc2NhcGUoKDMsICBvcHRpb25zLmZlZWRiYWNrSW1hZ2UgKSksICdcIi8+XFxuICA8ZGl2IGNsYXNzPVwic2hhcmluZy1jb250ZW50XCI+XFxuJyk7NTsgfSBlbHNlIHsgOyBidWYucHVzaCgnXFxuICA8ZGl2IGNsYXNzPVwic2hhcmluZy1jb250ZW50IG5vLWltYWdlXCI+XFxuJyk7NzsgfSA7IGJ1Zi5wdXNoKCdcXG5cXG5cXG4nKTsxMDsgaWYgKG9wdGlvbnMucmVzcG9uc2UgJiYgb3B0aW9ucy5yZXNwb25zZS5sZXZlbF9zb3VyY2UpIHsgOyBidWYucHVzaCgnXFxuICAnKTsxMTsgaWYgKG9wdGlvbnMuYXBwU3RyaW5ncyAmJiBvcHRpb25zLmFwcFN0cmluZ3Muc2hhcmluZ1RleHQpIHsgOyBidWYucHVzaCgnXFxuICAgIDxkaXY+JywgZXNjYXBlKCgxMiwgIG9wdGlvbnMuYXBwU3RyaW5ncy5zaGFyaW5nVGV4dCApKSwgJzwvZGl2PlxcbiAgJyk7MTM7IH0gOyBidWYucHVzaCgnXFxuXFxuICA8ZGl2PlxcbiAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cInNoYXJpbmctaW5wdXRcIiB2YWx1ZT0nLCBlc2NhcGUoKDE2LCAgb3B0aW9ucy5yZXNwb25zZS5sZXZlbF9zb3VyY2UgKSksICcgcmVhZG9ubHk+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFwnc29jaWFsLWJ1dHRvbnNcXCc+XFxuICAgICcpOzE5OyBpZiAob3B0aW9ucy5mYWNlYm9va1VybCkgezsgYnVmLnB1c2goJyAgICAgIDxhIGhyZWY9XFwnJywgZXNjYXBlKCgxOSwgIG9wdGlvbnMuZmFjZWJvb2tVcmwgKSksICdcXCcgdGFyZ2V0PVwiX2JsYW5rXCIgY2xhc3M9XCJwb3B1cC13aW5kb3dcIj5cXG4gICAgICAgIDxidXR0b24+XFxuICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtZmFjZWJvb2sgZmEtbGdcIj48L2k+XFxuICAgICAgICA8L2J1dHRvbj5cXG4gICAgICA8L2E+XFxuICAgICcpOzI0OyB9OyBidWYucHVzaCgnICAgICcpOzI0OyBpZiAob3B0aW9ucy50d2l0dGVyVXJsKSB7OyBidWYucHVzaCgnICAgICAgPGEgaHJlZj1cXCcnLCBlc2NhcGUoKDI0LCAgb3B0aW9ucy50d2l0dGVyVXJsICkpLCAnXFwnIHRhcmdldD1cIl9ibGFua1wiIGNsYXNzPVwicG9wdXAtd2luZG93XCI+XFxuICAgICAgICA8YnV0dG9uPlxcbiAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLXR3aXR0ZXIgZmEtbGdcIj48L2k+XFxuICAgICAgICA8L2J1dHRvbj5cXG4gICAgICA8L2E+XFxuICAgICcpOzI5OyB9OyBidWYucHVzaCgnICAgICcpOzI5OyBpZiAoIW9wdGlvbnMub25NYWluUGFnZSAmJiAhb3B0aW9ucy5kaXNhYmxlUHJpbnRpbmcpIHsgOyBidWYucHVzaCgnXFxuICAgICAgPGJ1dHRvbiBpZD1cInByaW50LWJ1dHRvblwiPlxcbiAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1wcmludCBmYS1sZ1wiPjwvaT5cXG4gICAgICA8L2J1dHRvbj5cXG4gICAgJyk7MzM7IH0gOyBidWYucHVzaCgnXFxuICAgICcpOzM0OyBpZiAob3B0aW9ucy5hbHJlYWR5U2F2ZWQpIHsgOyBidWYucHVzaCgnXFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cInNhdmVkLXRvLWdhbGxlcnlcIiBkaXNhYmxlZD5cXG4gICAgICAgICcsIGVzY2FwZSgoMzYsICBtc2cuc2F2ZWRUb0dhbGxlcnkoKSApKSwgJ1xcbiAgICAgIDwvYnV0dG9uPlxcbiAgICAnKTszODsgfSBlbHNlIGlmIChvcHRpb25zLnNhdmVUb0dhbGxlcnlVcmwgJiYgIW9wdGlvbnMuZGlzYWJsZVNhdmVUb0dhbGxlcnkpIHsgOyBidWYucHVzaCgnXFxuICAgICAgPGJ1dHRvbiBpZD1cInNhdmUtdG8tZ2FsbGVyeS1idXR0b25cIiBjbGFzcz1cImxhdW5jaFwiPlxcbiAgICAgICAgJywgZXNjYXBlKCg0MCwgIG1zZy5zYXZlVG9HYWxsZXJ5KCkgKSksICdcXG4gICAgICA8L2J1dHRvbj5cXG4gICAgJyk7NDI7IH0gOyBidWYucHVzaCgnXFxuICAgICcpOzQzOyBpZiAob3B0aW9ucy5zZW5kVG9QaG9uZSkgezsgYnVmLnB1c2goJyAgICAgIDxidXR0b24gaWQ9XCJzaGFyaW5nLXBob25lXCI+XFxuICAgICAgICA8aSBjbGFzcz1cImZhIGZhLW1vYmlsZSBmYS1sZ1wiPjwvaT5cXG4gICAgICAgICcsIGVzY2FwZSgoNDUsICBtc2cuc2VuZFRvUGhvbmUoKSApKSwgJ1xcbiAgICAgIDwvYnV0dG9uPlxcbiAgICAnKTs0NzsgfTsgYnVmLnB1c2goJ1xcbiAgPC9kaXY+XFxuICA8ZGl2IGlkPVwic2VuZC10by1waG9uZVwiIHN0eWxlPVwiZGlzcGxheTogbm9uZVwiPlxcbiAgICA8bGFiZWwgZm9yPVwicGhvbmVcIj5FbnRlciBhIFVTIHBob25lIG51bWJlcjo8L2xhYmVsPlxcbiAgICA8aW5wdXQgdHlwZT1cInRlbFwiIGlkPVwicGhvbmVcIiBuYW1lPVwicGhvbmVcIiAvPlxcbiAgICA8YnV0dG9uIGlkPVwicGhvbmUtc3VibWl0XCIgb25DbGljaz1cInJldHVybiBmYWxzZTtcIj5TZW5kPC9idXR0b24+XFxuICAgIDxkaXYgaWQ9XCJwaG9uZS1jaGFyZ2VzXCI+QSB0ZXh0IG1lc3NhZ2Ugd2lsbCBiZSBzZW50IHZpYSA8YSBocmVmPVwiaHR0cDovL3R3aWxpby5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIj5Ud2lsaW88L2E+LiBDaGFyZ2VzIG1heSBhcHBseSB0byB0aGUgcmVjaXBpZW50LjwvZGl2PlxcbiAgPC9kaXY+XFxuJyk7NTU7IH0gOyBidWYucHVzaCgnXFxuXFxuPC9kaXY+XFxuJyk7IH0pKCk7XG59IFxucmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG4gIHJldHVybiBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICByZXR1cm4gdChsb2NhbHMsIHJlcXVpcmUoXCJlanNcIikuZmlsdGVycyk7XG4gIH1cbn0oKSk7IiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCc8cCBpZD1cInNoYXJlLWZhaWwtZXhwbGFuYXRpb25cIj4nLCBlc2NhcGUoKDEsICBzaGFyZUZhaWx1cmUubWVzc2FnZSApKSwgJzwvcD5cXG5cXG4nKTszOyBpZiAoc2hhcmVGYWlsdXJlLmNvbnRlbnRzKSB7IDsgYnVmLnB1c2goJ1xcbiAgPGRpdiBjbGFzcz1cInNoYXJlLWZhaWwtZXhjZXJwdFwiPlxcbiAgICA8cHJlIGNsYXNzPVwiZ2VuZXJhdGVkQ29kZVwiPicsIGVzY2FwZSgoNSwgIHNoYXJlRmFpbHVyZS5jb250ZW50cyApKSwgJzwvcHJlPlxcbiAgPC9kaXY+XFxuJyk7NzsgfSA7IGJ1Zi5wdXNoKCdcXG4nKTsgfSkoKTtcbn0gXG5yZXR1cm4gYnVmLmpvaW4oJycpO1xufTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxvY2Fscykge1xuICAgIHJldHVybiB0KGxvY2FscywgcmVxdWlyZShcImVqc1wiKS5maWx0ZXJzKTtcbiAgfVxufSgpKTsiLCJtb2R1bGUuZXhwb3J0cz0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IGZ1bmN0aW9uIGFub255bW91cyhsb2NhbHMsIGZpbHRlcnMsIGVzY2FwZVxuLyoqLykge1xuZXNjYXBlID0gZXNjYXBlIHx8IGZ1bmN0aW9uIChodG1sKXtcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxuICAgIC5yZXBsYWNlKC8mKD8hXFx3KzspL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufTtcbnZhciBidWYgPSBbXTtcbndpdGggKGxvY2FscyB8fCB7fSkgeyAoZnVuY3Rpb24oKXsgXG4gYnVmLnB1c2goJzxkaXYgY2xhc3M9XCJnZW5lcmF0ZWQtY29kZS1jb250YWluZXJcIj5cXG4gIDxwIGNsYXNzPVwiZ2VuZXJhdGVkQ29kZU1lc3NhZ2VcIj4nLCAoMiwgIG1lc3NhZ2UgKSwgJzwvcD5cXG4gIDxwcmUgY2xhc3M9XCJnZW5lcmF0ZWRDb2RlXCI+JywgZXNjYXBlKCgzLCAgY29kZSApKSwgJzwvcHJlPlxcbjwvZGl2PlxcblxcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIm1vZHVsZS5leHBvcnRzPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24gYW5vbnltb3VzKGxvY2FscywgZmlsdGVycywgZXNjYXBlXG4vKiovKSB7XG5lc2NhcGUgPSBlc2NhcGUgfHwgZnVuY3Rpb24gKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xudmFyIGJ1ZiA9IFtdO1xud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyBcbiBidWYucHVzaCgnJyk7MTsgdmFyIG1zZyA9IHJlcXVpcmUoJy4uL2xvY2FsZScpOyA7IGJ1Zi5wdXNoKCdcXG5cXG4nKTszOyBpZiAoZGF0YS5vaykgezsgYnVmLnB1c2goJyAgPGRpdiBjbGFzcz1cImZhclNpZGVcIiBzdHlsZT1cInBhZGRpbmc6IDFleCAzZXggMFwiPlxcbiAgICA8YnV0dG9uIGlkPVwib2stYnV0dG9uXCIgY2xhc3M9XCJzZWNvbmRhcnlcIj5cXG4gICAgICAnLCBlc2NhcGUoKDUsICBtc2cuZGlhbG9nT0soKSApKSwgJ1xcbiAgICA8L2J1dHRvbj5cXG4gIDwvZGl2PlxcbicpOzg7IH07IGJ1Zi5wdXNoKCdcXG4nKTs5OyBpZiAoZGF0YS5jYW5jZWxUZXh0KSB7OyBidWYucHVzaCgnPGJ1dHRvbiBpZD1cImFnYWluLWJ1dHRvblwiIGNsYXNzPVwiJywgZXNjYXBlKCg5LCAgZGF0YS5jYW5jZWxCdXR0b25DbGFzcyB8fCAnJyApKSwgJ1wiPlxcbiAgICAnLCBlc2NhcGUoKDEwLCAgZGF0YS5jYW5jZWxUZXh0ICkpLCAnXFxuPC9idXR0b24+XFxuJyk7MTI7IH07IGJ1Zi5wdXNoKCdcXG4nKTsxMzsgaWYgKGRhdGEuY29uZmlybVRleHQpIHs7IGJ1Zi5wdXNoKCc8YnV0dG9uIGlkPVwiY29uZmlybS1idXR0b25cIiBjbGFzcz1cImxhdW5jaFwiIHN0eWxlPVwiZmxvYXQ6IHJpZ2h0XCI+XFxuICAgICcsIGVzY2FwZSgoMTQsICBkYXRhLmNvbmZpcm1UZXh0ICkpLCAnXFxuPC9idXR0b24+XFxuJyk7MTY7IH07IGJ1Zi5wdXNoKCdcXG4nKTsxNzsgaWYgKGRhdGEucHJldmlvdXNMZXZlbCkgezsgYnVmLnB1c2goJyAgPGJ1dHRvbiBpZD1cImJhY2stYnV0dG9uXCIgY2xhc3M9XCJsYXVuY2hcIj5cXG4gICAgJywgZXNjYXBlKCgxOCwgIG1zZy5iYWNrVG9QcmV2aW91c0xldmVsKCkgKSksICdcXG4gIDwvYnV0dG9uPlxcbicpOzIwOyB9OyBidWYucHVzaCgnXFxuJyk7MjE7IGlmIChkYXRhLnRyeUFnYWluKSB7OyBidWYucHVzaCgnICAnKTsyMTsgaWYgKGRhdGEuaXNLMSAmJiAhZGF0YS5mcmVlUGxheSkgezsgYnVmLnB1c2goJyAgICA8ZGl2IGlkPVwiYWdhaW4tYnV0dG9uXCIgY2xhc3M9XCJsYXVuY2ggYXJyb3ctY29udGFpbmVyIGFycm93LWxlZnRcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVwiYXJyb3ctaGVhZFwiPjxpbWcgc3JjPVwiJywgZXNjYXBlKCgyMiwgIGRhdGEuYXNzZXRVcmwoJ21lZGlhL3RyeWFnYWluLWFycm93LWhlYWQucG5nJykgKSksICdcIiBhbHQ9XCJBcnJvd2hlYWRcIiB3aWR0aD1cIjY3XCIgaGVpZ2h0PVwiMTMwXCIvPjwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XCJhcnJvdy10ZXh0XCI+JywgZXNjYXBlKCgyMywgIGRhdGEudHJ5QWdhaW4gKSksICc8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAnKTsyNTsgfSBlbHNlIHs7IGJ1Zi5wdXNoKCcgICAgJyk7MjU7IGlmIChkYXRhLnNob3VsZFByb21wdEZvckhpbnQpIHs7IGJ1Zi5wdXNoKCcgICAgICA8YnV0dG9uIGlkPVwiaGludC1yZXF1ZXN0LWJ1dHRvblwiIGNsYXNzPVwibGlnaHRidWxiLWJ1dHRvblwiPlxcbiAgICAgICAgPHNwYW4+JyArIChmdW5jdGlvbigpe3ZhciBidWYgPSBbXTtcbiBidWYucHVzaCgnPHN2ZyB2ZXJzaW9uPVwiMS4xXCJcXG5cdCBpZD1cInN2ZzMwMTNcIiB4bWxuczpzb2RpcG9kaT1cImh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkXCIgeG1sbnM6c3ZnPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczpyZGY9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjXCIgeG1sbnM6aW5rc2NhcGU9XCJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlXCIgeG1sbnM6ZGM9XCJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xL1wiIHhtbG5zOmNjPVwiaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjXCIgc29kaXBvZGk6ZG9jbmFtZT1cImxpZ2h0X2J1bGJfZm9udF9hd2Vzb21lLnN2Z1wiIGlua3NjYXBlOnZlcnNpb249XCIwLjQ4LjMuMSByOTg4NlwiXFxuXHQgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHg9XCIwcHhcIiB5PVwiMHB4XCIgd2lkdGg9XCI0MHB4XCIgaGVpZ2h0PVwiNDBweFwiXFxuXHQgdmlld0JveD1cIjAgMCA2MTIgNzkyXCIgZW5hYmxlLWJhY2tncm91bmQ9XCJuZXcgMCAwIDYxMiA3OTJcIiB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPlxcbjxnIGlkPVwiYnVsYlwiPlxcbiAgPHBhdGggZmlsbD1cIiNFRkI4MzRcIiBkPVwiTTQ1My43NzUsMzUzLjE1NmMwLDI0LjAxMi01Ny4xODksMTI4Ljk0Mi02MS40MTQsMTMyLjI2NWMtMTIuMzg0LDkuNzQxLTQ4LjUxNCwxNS4zMTgtODIuODY5LDE2LjUxOFxcbiAgICBjLTguMzYyLDAuMjkyLTE2LjYxOSwwLjMyNS0yNC40MDMsMC4wOTZjLTIwLjcxNi0wLjYxMS0zOC4wODEtMy4wNzktNDUuMTU1LTcuNDY0Yy02Ljg5Ni00LjI3NC03NC40NzctMTE5LjI0LTc0LjQ3Ny0xNDEuNDE1XFxuICAgIGMwLTg5LjE5NSw2NC41NDItMTYxLjUwMiwxNDQuMTU5LTE2MS41MDJTNDUzLjc3NSwyNjMuOTYxLDQ1My43NzUsMzUzLjE1NnpcIi8+XFxuICA8ZyBpZD1cImczMDE1XCIgdHJhbnNmb3JtPVwibWF0cml4KDEsMCwwLC0xLDM3OS42NjEwMiwxMjkzLjAxNjkpXCI+XFxuICAgIDxwYXRoIGlkPVwicGF0aDMwMTdcIiBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPVwiMFwiIGZpbGw9XCIjNUQ1RDVEXCIgZD1cIk03LjM1Nyw5ODAuODU3YzAtMi45Ni0xLjA4MS01LjUyMS0zLjI0NC03LjY4NFxcbiAgICAgIHMtNC43MjQtMy4yNDQtNy42ODQtMy4yNDRzLTUuNTIxLDEuMDgxLTcuNjg0LDMuMjQ0cy0zLjI0NCw0LjcyNC0zLjI0NCw3LjY4NGMwLDEwLjQ3My02LjE0NywxOC41NTYtMTguNDQyLDI0LjI0OFxcbiAgICAgIGMtMTIuMjk1LDUuNjkyLTI0LjM2Miw4LjUzOC0zNi4yMDEsOC41MzhjLTIuOTYsMC01LjUyMSwxLjA4MS03LjY4NCwzLjI0NHMtMy4yNDQsNC43MjQtMy4yNDQsNy42ODRcXG4gICAgICBjMCwyLjk2LDEuMDgxLDUuNTIxLDMuMjQ0LDcuNjg0czQuNzI0LDMuMjQ0LDcuNjg0LDMuMjQ0YzExLjM4NCwwLDIyLjcxMS0xLjgyMSwzMy45ODEtNS40NjRzMjEuMTc0LTkuNzksMjkuNzEyLTE4LjQ0MlxcbiAgICAgIFM3LjM1Nyw5OTIuNjk2LDcuMzU3LDk4MC44NTd6IE02Miw5ODAuODU3YzAsMTYuMzkzLTMuOTI3LDMxLjY0Ny0xMS43ODIsNDUuNzYzcy0xOC4xLDI1LjY3MS0zMC43MzcsMzQuNjY0XFxuICAgICAgcy0yNi42MzgsMTYuMDUxLTQyLjAwNywyMS4xNzRzLTMwLjkwNyw3LjY4NC00Ni42MTcsNy42ODRzLTMxLjI0OS0yLjU2MS00Ni42MTctNy42ODRzLTI5LjM3MS0xMi4xODEtNDIuMDA3LTIxLjE3NFxcbiAgICAgIGMtMTIuNjM2LTguOTkzLTIyLjg4Mi0yMC41NDgtMzAuNzM3LTM0LjY2NGMtNy44NTUtMTQuMTE2LTExLjc4Mi0yOS4zNzEtMTEuNzgyLTQ1Ljc2M2MwLTIyLjk5Niw3Ljc0MS00My40ODcsMjMuMjIzLTYxLjQ3M1xcbiAgICAgIGMyLjI3Ny0yLjUwNCw1Ljc0OS02LjI2MSwxMC40MTYtMTEuMjdjNC42NjctNS4wMDksOC4xNC04Ljc2NiwxMC40MTYtMTEuMjdjMjkuMTQzLTM0LjgzNSw0NS4xOTQtNjguNzU5LDQ4LjE1NC0xMDEuNzcyaDc3Ljg2NlxcbiAgICAgIGMyLjk2LDMzLjAxMywxOS4wMTEsNjYuOTM4LDQ4LjE1NCwxMDEuNzcyYzIuMjc3LDIuNTA0LDUuNzQ5LDYuMjYxLDEwLjQxNiwxMS4yN3M4LjE0LDguNzY2LDEwLjQxNiwxMS4yN1xcbiAgICAgIEM1NC4yNTksOTM3LjM3LDYyLDk1Ny44NjIsNjIsOTgwLjg1N3ogTTEwNS43MTQsOTgwLjg1N2MwLTM1LjI5LTExLjcyNS02NS43OTktMzUuMTc2LTkxLjUyN1xcbiAgICAgIGMtMTAuMjQ2LTExLjE1Ni0xOC43MjctMjEuMDYtMjUuNDQzLTI5LjcxMnMtMTMuNDktMTkuNTIzLTIwLjMyLTMyLjYxNWMtNi44My0xMy4wOTItMTAuNzAxLTI1LjMyOS0xMS42MTItMzYuNzEzXFxuICAgICAgYzEwLjcwMS02LjM3NSwxNi4wNTEtMTUuNzEsMTYuMDUxLTI4LjAwNGMwLTguNDI0LTIuODQ2LTE1LjcxLTguNTM4LTIxLjg1N2M1LjY5Mi02LjE0Nyw4LjUzOC0xMy40MzMsOC41MzgtMjEuODU3XFxuICAgICAgYzAtMTEuODM5LTUuMTIzLTIxLjA2LTE1LjM2OC0yNy42NjNjMi45Ni01LjIzNyw0LjQ0LTEwLjU4Nyw0LjQ0LTE2LjA1MWMwLTEwLjQ3My0zLjU4Ni0xOC41NTYtMTAuNzU4LTI0LjI0OFxcbiAgICAgIHMtMTUuOTk0LTguNTM4LTI2LjQ2OC04LjUzOGMtNC41NTQtMTAuMDE4LTExLjM4NC0xNy45ODctMjAuNDkxLTIzLjkwNmMtOS4xMDctNS45Mi0xOS4wMTEtOC44NzktMjkuNzEyLTguODc5XFxuICAgICAgYy0xMC43MDEsMC0yMC42MDUsMi45Ni0yOS43MTIsOC44NzljLTkuMTA3LDUuOTItMTUuOTM4LDEzLjg4OC0yMC40OTEsMjMuOTA2Yy0xMC40NzMsMC0xOS4yOTYsMi44NDYtMjYuNDY4LDguNTM4XFxuICAgICAgcy0xMC43NTgsMTMuNzc1LTEwLjc1OCwyNC4yNDhjMCw1LjQ2NCwxLjQ4LDEwLjgxNSw0LjQ0LDE2LjA1MWMtMTAuMjQ2LDYuNjAzLTE1LjM2OCwxNS44MjQtMTUuMzY4LDI3LjY2M1xcbiAgICAgIGMwLDguNDI0LDIuODQ2LDE1LjcxLDguNTM4LDIxLjg1N2MtNS42OTIsNi4xNDctOC41MzgsMTMuNDMzLTguNTM4LDIxLjg1N2MwLDEyLjI5NSw1LjM1LDIxLjYyOSwxNi4wNTEsMjguMDA0XFxuICAgICAgYy0wLjkxMSwxMS4zODQtNC43ODEsMjMuNjIyLTExLjYxMiwzNi43MTNjLTYuODMsMTMuMDkxLTEzLjYwNCwyMy45NjMtMjAuMzIsMzIuNjE1cy0xNS4xOTgsMTguNTU2LTI1LjQ0MywyOS43MTJcXG4gICAgICBDLTIzMi4yNzUsOTE1LjA1OC0yNDQsOTQ1LjU2Ny0yNDQsOTgwLjg1N2MwLDIyLjU0LDUuMDY2LDQzLjU0NCwxNS4xOTgsNjMuMDFjMTAuMTMyLDE5LjQ2NywyMy40NTEsMzUuNjMyLDM5Ljk1OCw0OC40OTZcXG4gICAgICBjMTYuNTA3LDEyLjg2NCwzNS4xNzYsMjIuOTk1LDU2LjAwOSwzMC4zOTVzNDIuMDY0LDExLjA5OSw2My42OTMsMTEuMDk5czQyLjg2LTMuNyw2My42OTMtMTEuMDk5czM5LjUwMi0xNy41MzEsNTYuMDA5LTMwLjM5NVxcbiAgICAgIGMxNi41MDctMTIuODY0LDI5LjgyNi0yOS4wMjksMzkuOTU4LTQ4LjQ5NkMxMDAuNjQ4LDEwMjQuNDAxLDEwNS43MTQsMTAwMy4zOTcsMTA1LjcxNCw5ODAuODU3elwiLz5cXG4gIDwvZz5cXG4gIDxnPlxcbiAgICA8bGluZSBmaWxsPVwiI0VGQjgzNFwiIHgxPVwiNDczLjU4MlwiIHkxPVwiMjA4LjFcIiB4Mj1cIjU2MC41NzhcIiB5Mj1cIjE1OS4xNlwiLz5cXG4gICAgPHBhdGggZmlsbD1cIiNFRkI4MzRcIiBkPVwiTTQ3My4xNDEsMjA3LjMxNWMwLDAsMS4yMjUtMS4wMDMsMy4zOTYtMi43MTFjMS4wOC0wLjg2NCwyLjQwMi0xLjg5NCwzLjkyNS0zLjA2M1xcbiAgICAgIGMxLjUyNS0xLjE2NywzLjIyNy0yLjUxNCw1LjExNy0zLjkyN2MxLjg4Ny0xLjQxOCwzLjkzMS0yLjk1NCw2LjA5Mi00LjU3OGMyLjE1OC0xLjYzMiw0LjQ2Mi0zLjMsNi44MzEtNS4wNTVcXG4gICAgICBjMi4zODYtMS43MjMsNC44NDMtMy41MTksNy4zNzItNS4yODVjMi41MTUtMS43OTEsNS4xMDQtMy41NTIsNy42NzctNS4zNDFjMi41NzgtMS43NzgsNS4wNjUtMy43MjEsNy41MDMtNS42NDhcXG4gICAgICBjMS4yMjgtMC45NDgsMi40MzYtMS45MDcsMy42NjUtMi43OTJjMS4yMzEtMC44ODEsMi40NzgtMS42OTUsMy43MzYtMi40NDJjMi41MjctMS40NzIsNS4xMi0yLjYyOSw3LjY1Ni0zLjU4N1xcbiAgICAgIGMyLjUyOS0wLjk3MSw0Ljk5OC0xLjc1MSw3LjMzMS0yLjM3N2M0LjY1NS0xLjI2OCw4Ljc5Ny0xLjg1OCwxMS44MS0yLjA2OWMxLjUwNC0wLjEwOSwyLjcxOC0wLjEzOCwzLjU3Mi0wLjExMVxcbiAgICAgIGMwLjg0MywwLjAwNywxLjMxMywwLjA0NywxLjMxMywwLjA0N2wwLjg4MywxLjU2OWMwLDAtMC4yMSwwLjQyMi0wLjY0MSwxLjE0NmMtMC40MiwwLjc0NC0xLjA3NSwxLjc2Ni0xLjk1LDIuOTk1XFxuICAgICAgYy0xLjc0NSwyLjQ2NS00LjQsNS42OTgtNy45LDkuMDE5Yy0xLjc0NiwxLjY2OS0zLjY5NCwzLjM3NC01LjgzOCw1LjAzMWMtMi4xMzYsMS42NzEtNC40NzEsMy4yODUtNy4wNDEsNC42ODFcXG4gICAgICBjLTEuMjkxLDAuNjg3LTIuNjM1LDEuMzMxLTQuMDI3LDEuOTI1Yy0xLjM5NCwwLjU5MS0yLjg0MSwxLjEyNi00LjI4OSwxLjY4M2MtMi45MTQsMS4wODMtNS44NjUsMi4yLTguNzIzLDMuNDhcXG4gICAgICBjLTIuODY1LDEuMjctNS43MTMsMi41NjgtOC41NSwzLjc4OGMtMi44MjMsMS4yNDUtNS42MzMsMi40MTItOC4zNDUsMy41NTZjLTIuNzI5LDEuMTEzLTUuMzUyLDIuMjE3LTcuODY3LDMuMjEzXFxuICAgICAgYy0yLjUxMSwxLjAwNC00Ljg4NSwxLjk1My03LjA3NiwyLjgzYy0yLjE4OSwwLjg4MS00LjIyNCwxLjYzNy02LjAxMywyLjMzNGMtMS43OSwwLjY5NS0zLjM1NywxLjI5LTQuNjU2LDEuNzY0XFxuICAgICAgYy0yLjU4NywwLjk2OC00LjA4LDEuNDk0LTQuMDgsMS40OTRMNDczLjE0MSwyMDcuMzE1elwiLz5cXG4gIDwvZz5cXG4gIDxnPlxcbiAgICA8bGluZSBmaWxsPVwiI0VGQjgzNFwiIHgxPVwiNDkyLjM0OFwiIHkxPVwiNDEwLjAwOFwiIHgyPVwiNTg5LjUwOVwiIHkyPVwiNDMyLjg4M1wiLz5cXG4gICAgPHBhdGggZmlsbD1cIiNFRkI4MzRcIiBkPVwiTTQ5Mi41NTUsNDA5LjEzMmMwLDAsMS41ODEsMC4wOTEsNC4zMzUsMC4zMDNjMS4zOCwwLjA5NSwzLjA1LDAuMjMyLDQuOTYyLDAuNDAzXFxuICAgICAgYzEuOTEyLDAuMTczLDQuMDc3LDAuMzM0LDYuNDI0LDAuNTc0YzIuMzQ4LDAuMjM0LDQuODkyLDAuNDg3LDcuNTgzLDAuNzU1YzIuNjkzLDAuMjU5LDUuNTE5LDAuNTkyLDguNDUsMC45MDRcXG4gICAgICBjMi45MjMsMC4zNDcsNS45NDcsMC42ODgsOS4wMDQsMS4xMDFjMy4wNjQsMC4zODQsNi4xNjEsMC44NDEsOS4yNjYsMS4yNjZjMy4xMDIsMC40MzcsNi4yNDcsMC42OTEsOS4zNDYsMC45MjJcXG4gICAgICBjMS41NDYsMC4xMzMsMy4wODQsMC4yNDYsNC41ODgsMC40MjZjMS41MDIsMC4xODUsMi45NzIsMC40Myw0LjQwMywwLjczMmMyLjg1NywwLjYyOCw1LjU0OCwxLjUzMSw4LjA2NCwyLjU0M1xcbiAgICAgIGMyLjUxOSwwLjk5OCw0Ljg2NCwyLjA5NSw3LjAwNCwzLjIxM2M0LjI4NSwyLjIxOSw3LjczMiw0LjU4OCwxMC4wOTMsNi40NzJjMS4xODEsMC45MzgsMi4wOTQsMS43MzgsMi43MDQsMi4zMzdcXG4gICAgICBjMC42MTUsMC41NzYsMC45MzQsMC45MjMsMC45MzQsMC45MjNsLTAuNDEyLDEuNzUyYzAsMC0wLjQ0LDAuMTY5LTEuMjQ4LDAuNDFjLTAuODEzLDAuMjYzLTEuOTg3LDAuNTcyLTMuNDYzLDAuODg1XFxuICAgICAgYy0yLjk1MywwLjYzMy03LjA5NiwxLjIxNi0xMS45MiwxLjI5Yy0yLjQxNCwwLjA0Ni01LjAwMy0wLjAxOC03LjcwMi0wLjI0OWMtMi43MDMtMC4yMTYtNS41MTUtMC42MDktOC4zNTEtMS4zMjJcXG4gICAgICBjLTEuNDE1LTAuMzY4LTIuODQtMC44MDQtNC4yNjctMS4zMDljLTEuNDI2LTAuNTA5LTIuODUzLTEuMDk1LTQuMjk2LTEuNjY1Yy0yLjg3OC0xLjE3Ni01LjgwNS0yLjM1MS04Ljc3Ni0zLjM0NFxcbiAgICAgIGMtMi45NjgtMS4wMDQtNS45NDQtMS45NzctOC44NTctM2MtMi45Mi0wLjk5NS01Ljc3OS0yLjAzOC04LjU0OS0zLjAzMmMtMi43NjItMS4wMjktNS40NC0xLjk5Mi03Ljk2NS0yLjk2MVxcbiAgICAgIGMtMi41MjgtMC45NjEtNC45MTgtMS44NjktNy4xMjQtMi43MDhjLTIuMjA3LTAuODMzLTQuMjE3LTEuNjU1LTYuMDA1LTIuMzUzYy0xLjc4OC0wLjctMy4zNDQtMS4zMjMtNC42MjEtMS44NTRcXG4gICAgICBjLTIuNTU5LTEuMDM5LTQuMDE1LTEuNjYzLTQuMDE1LTEuNjYzTDQ5Mi41NTUsNDA5LjEzMnpcIi8+XFxuICA8L2c+XFxuICA8Zz5cXG4gICAgPGxpbmUgZmlsbD1cIiNFRkI4MzRcIiB4MT1cIjUwMi41NTlcIiB5MT1cIjMwMS43XCIgeDI9XCI2MDIuMzdcIiB5Mj1cIjMwMC42ODVcIi8+XFxuICAgIDxwYXRoIGZpbGw9XCIjRUZCODM0XCIgZD1cIk01MDIuNTUsMzAwLjhjMCwwLDEuNTU3LTAuMjg5LDQuMjgyLTAuNzQyYzEuMzYyLTAuMjM3LDMuMDE3LTAuNTA0LDQuOTE1LTAuNzk1XFxuICAgICAgYzEuODk4LTAuMjg5LDQuMDM5LTAuNjUsNi4zNzUtMC45NzljMi4zMzYtMC4zMzQsNC44NjctMC42OTcsNy41NDQtMS4wOGMyLjY3Ny0wLjM5Miw1LjUtMC43NDQsOC40MjEtMS4xNDJcXG4gICAgICBjMi45MjEtMC4zNjIsNS45MzktMC43NTMsOS4wMDYtMS4wODRjMy4wNjctMC4zNTksNi4xODMtMC42NTYsOS4zLTAuOTg1YzMuMTE2LTAuMzE3LDYuMjMtMC44MjMsOS4yOTYtMS4zMzlcXG4gICAgICBjMS41MzMtMC4yNCwzLjA1My0wLjQ5OSw0LjU1Ni0wLjY4M2MxLjUwMy0wLjE4LDIuOTg5LTAuMjkzLDQuNDUtMC4zNDJjMi45MjQtMC4wNzMsNS43NTMsMC4xNiw4LjQzOCwwLjU0MlxcbiAgICAgIGMyLjY4NSwwLjM2Niw1LjIyNCwwLjg3MSw3LjU3LDEuNDQ2YzQuNjkxLDEuMTMsOC42MDUsMi42MDcsMTEuMzQ3LDMuODcyYzEuMzcxLDAuNjI5LDIuNDQ5LDEuMTg3LDMuMTg1LDEuNjIyXFxuICAgICAgYzAuNzM1LDAuNDEyLDEuMTI4LDAuNjczLDEuMTI4LDAuNjczbDAuMDE4LDEuOGMwLDAtMC4zODcsMC4yNjktMS4xMTQsMC42OTZjLTAuNzI3LDAuNDUtMS43OTMsMS4wMzEtMy4xNTEsMS42ODdcXG4gICAgICBjLTIuNzE2LDEuMzIxLTYuNiwyLjg3Ny0xMS4yNjYsNC4xMDJjLTIuMzMzLDAuNjIyLTQuODYyLDEuMTc5LTcuNTM5LDEuNTk5Yy0yLjY3NiwwLjQzNi01LjUsMC43MjctOC40MjUsMC43MTNcXG4gICAgICBjLTEuNDYyLTAuMDE5LTIuOTUtMC4xMDItNC40NTYtMC4yNTFjLTEuNTA2LTAuMTUzLTMuMDMyLTAuMzgxLTQuNTY5LTAuNTljLTMuMDc1LTAuNDU0LTYuMTk5LTAuODk1LTkuMzIxLTEuMTQ5XFxuICAgICAgYy0zLjEyMi0wLjI2Ni02LjI0NC0wLjQ5OS05LjMxOC0wLjc5NmMtMy4wNzMtMC4yNjgtNi4wOTktMC41OTgtOS4wMjYtMC45Yy0yLjkyOC0wLjMzOC01Ljc1OC0wLjYzNC04LjQ0Mi0wLjk3MVxcbiAgICAgIGMtMi42ODQtMC4zMjktNS4yMjItMC42MzktNy41NjQtMC45MjZjLTIuMzQyLTAuMjgxLTQuNDktMC41OTktNi4zOTQtMC44NDljLTEuOTAzLTAuMjUzLTMuNTYzLTAuNDg2LTQuOTMtMC42OTVcXG4gICAgICBjLTIuNzM0LTAuMzk3LTQuMjk2LTAuNjU1LTQuMjk2LTAuNjU1TDUwMi41NSwzMDAuOHpcIi8+XFxuICA8L2c+XFxuICA8Zz5cXG4gICAgPGxpbmUgZmlsbD1cIiNFRkI4MzRcIiB4MT1cIjEzNS42NjFcIiB5MT1cIjIxMi43NjRcIiB4Mj1cIjQ4LjY2NVwiIHkyPVwiMTYzLjgyNFwiLz5cXG4gICAgPHBhdGggZmlsbD1cIiNFRkI4MzRcIiBkPVwiTTEzNS4yMiwyMTMuNTQ4YzAsMC0xLjQ5My0wLjUyNi00LjA4LTEuNDk0Yy0xLjI5OS0wLjQ3NC0yLjg2Ni0xLjA2OS00LjY1Ni0xLjc2NFxcbiAgICAgIGMtMS43ODktMC42OTctMy44MjQtMS40NTMtNi4wMTMtMi4zMzRjLTIuMTkxLTAuODc2LTQuNTY1LTEuODI2LTcuMDc2LTIuODNjLTIuNTE1LTAuOTk2LTUuMTM4LTIuMS03Ljg2Ny0zLjIxM1xcbiAgICAgIGMtMi43MTItMS4xNDQtNS41MjItMi4zMTItOC4zNDUtMy41NTZjLTIuODM3LTEuMjItNS42ODYtMi41MTgtOC41NS0zLjc4OGMtMi44NTktMS4yOC01LjgxLTIuMzk3LTguNzIzLTMuNDhcXG4gICAgICBjLTEuNDQ4LTAuNTU3LTIuODk1LTEuMDkyLTQuMjg5LTEuNjgzYy0xLjM5Mi0wLjU5NC0yLjczNi0xLjIzOC00LjAyNy0xLjkyNWMtMi41Ny0xLjM5Ni00LjkwNS0zLjAxLTcuMDQxLTQuNjgxXFxuICAgICAgYy0yLjE0My0xLjY1Ny00LjA5Mi0zLjM2My01LjgzOC01LjAzMWMtMy41LTMuMzItNi4xNTUtNi41NTQtNy45LTkuMDE5Yy0wLjg3NC0xLjIyOS0xLjUzLTIuMjUxLTEuOTUtMi45OTVcXG4gICAgICBjLTAuNDMxLTAuNzI0LTAuNjQxLTEuMTQ2LTAuNjQxLTEuMTQ2bDAuODgzLTEuNTY5YzAsMCwwLjQ3LTAuMDQsMS4zMTMtMC4wNDdjMC44NTQtMC4wMjcsMi4wNjgsMC4wMDIsMy41NzIsMC4xMTFcXG4gICAgICBjMy4wMTMsMC4yMTEsNy4xNTUsMC44MDEsMTEuODEsMi4wNjljMi4zMzIsMC42MjUsNC44MDEsMS40MDYsNy4zMzEsMi4zNzdjMi41MzcsMC45NTgsNS4xMjksMi4xMTUsNy42NTYsMy41ODdcXG4gICAgICBjMS4yNTgsMC43NDYsMi41MDUsMS41NjEsMy43MzYsMi40NDJjMS4yMjksMC44ODUsMi40MzcsMS44NDQsMy42NjUsMi43OTJjMi40MzgsMS45MjgsNC45MjUsMy44Nyw3LjUwMyw1LjY0OFxcbiAgICAgIGMyLjU3MywxLjc4OSw1LjE2MSwzLjU0OSw3LjY3Nyw1LjM0MWMyLjUyOSwxLjc2Niw0Ljk4NiwzLjU2Miw3LjM3Miw1LjI4NWMyLjM2OCwxLjc1NSw0LjY3MywzLjQyMyw2LjgzMSw1LjA1NVxcbiAgICAgIGMyLjE2MiwxLjYyNSw0LjIwNiwzLjE2LDYuMDkyLDQuNTc4YzEuODg5LDEuNDEzLDMuNTkyLDIuNzYsNS4xMTcsMy45MjdjMS41MjMsMS4xNjksMi44NDUsMi4xOTksMy45MjUsMy4wNjNcXG4gICAgICBjMi4xNywxLjcwOCwzLjM5NiwyLjcxMSwzLjM5NiwyLjcxMUwxMzUuMjIsMjEzLjU0OHpcIi8+XFxuICA8L2c+XFxuICA8Zz5cXG4gICAgPGxpbmUgZmlsbD1cIiNFRkI4MzRcIiB4MT1cIjEyMC44OTVcIiB5MT1cIjQxMS42NzJcIiB4Mj1cIjIzLjczNFwiIHkyPVwiNDM0LjU0N1wiLz5cXG4gICAgPHBhdGggZmlsbD1cIiNFRkI4MzRcIiBkPVwiTTEyMS4xMDEsNDEyLjU0OGMwLDAtMS40NTYsMC42MjMtNC4wMTUsMS42NjNjLTEuMjc3LDAuNTMtMi44MzMsMS4xNTMtNC42MjEsMS44NTRcXG4gICAgICBjLTEuNzg4LDAuNjk4LTMuNzk4LDEuNTItNi4wMDUsMi4zNTNjLTIuMjA2LDAuODM4LTQuNTk2LDEuNzQ3LTcuMTI0LDIuNzA4Yy0yLjUyNiwwLjk2OS01LjIwMywxLjkzMi03Ljk2NSwyLjk2MVxcbiAgICAgIGMtMi43NywwLjk5My01LjYyOSwyLjAzNy04LjU0OSwzLjAzMmMtMi45MTQsMS4wMjMtNS44ODksMS45OTYtOC44NTcsM2MtMi45NzEsMC45OTMtNS44OTksMi4xNjktOC43NzYsMy4zNDRcXG4gICAgICBjLTEuNDQzLDAuNTctMi44NywxLjE1Ni00LjI5NiwxLjY2NWMtMS40MjcsMC41MDUtMi44NTIsMC45NDEtNC4yNjcsMS4zMDljLTIuODM2LDAuNzEzLTUuNjQ4LDEuMTA1LTguMzUxLDEuMzIxXFxuICAgICAgYy0yLjY5OSwwLjIzMS01LjI4OCwwLjI5NS03LjcwMiwwLjI0OWMtNC44MjQtMC4wNzQtOC45NjctMC42NTctMTEuOTItMS4yOWMtMS40NzYtMC4zMTMtMi42NS0wLjYyMS0zLjQ2My0wLjg4NVxcbiAgICAgIGMtMC44MDgtMC4yNDEtMS4yNDgtMC40MS0xLjI0OC0wLjQxbC0wLjQxMy0xLjc1MmMwLDAsMC4zMTktMC4zNDcsMC45MzQtMC45MjNjMC42MS0wLjU5OCwxLjUyMy0xLjM5OSwyLjcwNC0yLjMzN1xcbiAgICAgIGMyLjM2LTEuODg0LDUuODA4LTQuMjU0LDEwLjA5My02LjQ3MmMyLjE0LTEuMTE5LDQuNDg1LTIuMjE2LDcuMDA0LTMuMjEzYzIuNTE2LTEuMDEyLDUuMjA3LTEuOTE1LDguMDY0LTIuNTQzXFxuICAgICAgYzEuNDMxLTAuMzAyLDIuOS0wLjU0Nyw0LjQwMy0wLjczMmMxLjUwMy0wLjE4MSwzLjA0Mi0wLjI5Myw0LjU4OC0wLjQyNmMzLjEtMC4yMzIsNi4yNDUtMC40ODYsOS4zNDYtMC45MjJcXG4gICAgICBjMy4xMDQtMC40MjUsNi4yMDEtMC44ODIsOS4yNjUtMS4yNjZjMy4wNTctMC40MTIsNi4wODEtMC43NTQsOS4wMDQtMS4xMDFjMi45MzEtMC4zMTIsNS43NTctMC42NDQsOC40NS0wLjkwNFxcbiAgICAgIGMyLjY5MS0wLjI2OCw1LjIzNS0wLjUyMSw3LjU4My0wLjc1NWMyLjM0Ny0wLjIzOSw0LjUxMi0wLjQsNi40MjQtMC41NzRjMS45MTMtMC4xNzEsMy41ODMtMC4zMDgsNC45NjItMC40MDNcXG4gICAgICBjMi43NTQtMC4yMTIsNC4zMzUtMC4zMDMsNC4zMzUtMC4zMDNMMTIxLjEwMSw0MTIuNTQ4elwiLz5cXG4gIDwvZz5cXG4gIDxnPlxcbiAgICA8bGluZSBmaWxsPVwiI0VGQjgzNFwiIHgxPVwiMTEyLjY4NFwiIHkxPVwiMzA2LjM2NFwiIHgyPVwiMTIuODczXCIgeTI9XCIzMDUuMzQ5XCIvPlxcbiAgICA8cGF0aCBmaWxsPVwiI0VGQjgzNFwiIGQ9XCJNMTEyLjY3NSwzMDcuMjY0YzAsMC0xLjU2MiwwLjI1Ny00LjI5NiwwLjY1NWMtMS4zNjcsMC4yMS0zLjAyNiwwLjQ0My00LjkzLDAuNjk1XFxuICAgICAgYy0xLjkwNCwwLjI1LTQuMDUxLDAuNTY4LTYuMzk0LDAuODQ5Yy0yLjM0MywwLjI4Ny00Ljg4LDAuNTk4LTcuNTY0LDAuOTI2Yy0yLjY4NCwwLjMzNy01LjUxNCwwLjYzMy04LjQ0MiwwLjk3MVxcbiAgICAgIGMtMi45MjgsMC4zMDItNS45NTMsMC42MzItOS4wMjYsMC45Yy0zLjA3NCwwLjI5Ny02LjE5NSwwLjUzLTkuMzE4LDAuNzk2Yy0zLjEyMiwwLjI1NC02LjI0NiwwLjY5Ni05LjMyMSwxLjE0OVxcbiAgICAgIGMtMS41MzcsMC4yMDktMy4wNjMsMC40MzctNC41NjksMC41OWMtMS41MDYsMC4xNDktMi45OTQsMC4yMzItNC40NTYsMC4yNTFjLTIuOTI1LDAuMDE0LTUuNzQ5LTAuMjc3LTguNDI1LTAuNzEzXFxuICAgICAgYy0yLjY3Ni0wLjQyMS01LjIwNS0wLjk3Ny03LjUzOS0xLjU5OWMtNC42NjctMS4yMjUtOC41NS0yLjc4MS0xMS4yNjYtNC4xMDJjLTEuMzU4LTAuNjU2LTIuNDI0LTEuMjM3LTMuMTUxLTEuNjg3XFxuICAgICAgYy0wLjcyNy0wLjQyNy0xLjExNC0wLjY5Ni0xLjExNC0wLjY5NmwwLjAxOC0xLjhjMCwwLDAuMzkzLTAuMjYxLDEuMTI4LTAuNjczYzAuNzM2LTAuNDM1LDEuODE0LTAuOTk0LDMuMTg1LTEuNjIyXFxuICAgICAgYzIuNzQyLTEuMjY1LDYuNjU3LTIuNzQyLDExLjM0Ny0zLjg3MmMyLjM0NS0wLjU3NSw0Ljg4NS0xLjA3OSw3LjU3LTEuNDQ2YzIuNjg1LTAuMzgyLDUuNTE0LTAuNjE1LDguNDM4LTAuNTQyXFxuICAgICAgYzEuNDYyLDAuMDQ5LDIuOTQ3LDAuMTYyLDQuNDUsMC4zNDJjMS41MDMsMC4xODQsMy4wMjQsMC40NDMsNC41NTYsMC42ODNjMy4wNjUsMC41MTYsNi4xOCwxLjAyMSw5LjI5NiwxLjMzOVxcbiAgICAgIGMzLjExNiwwLjMyOSw2LjIzMiwwLjYyNiw5LjI5OSwwLjk4NWMzLjA2NywwLjMzLDYuMDg1LDAuNzIyLDkuMDA2LDEuMDg0YzIuOTIsMC4zOTgsNS43NDQsMC43NSw4LjQyMSwxLjE0MlxcbiAgICAgIGMyLjY3NywwLjM4Myw1LjIwOCwwLjc0NSw3LjU0NCwxLjA4YzIuMzM2LDAuMzI5LDQuNDc3LDAuNjksNi4zNzUsMC45NzljMS44OTgsMC4yOTEsMy41NTIsMC41NTgsNC45MTUsMC43OTVcXG4gICAgICBjMi43MjUsMC40NTMsNC4yODIsMC43NDIsNC4yODIsMC43NDJMMTEyLjY3NSwzMDcuMjY0elwiLz5cXG4gIDwvZz5cXG48L2c+XFxuPGcgaWQ9XCJjb3VudFwiPlxcbiAgPHRleHQgeD1cIjQwMFwiIHk9XCI3MDBcIiBpZD1cImhpbnRDb3VudFwiPjwvdGV4dD5cXG48L2c+XFxuPC9zdmc+XFxuJyk7XG5yZXR1cm4gYnVmLmpvaW4oJycpO30pKCkgKyAnPC9zcGFuPlxcbiAgICAgICAgJywgZXNjYXBlKCgyNywgIG1zZy5oaW50UmVxdWVzdCgpICkpLCAnXFxuICAgICAgPC9idXR0b24+XFxuICAgICcpOzI5OyB9IDsgYnVmLnB1c2goJ1xcbiAgICA8YnV0dG9uIGlkPVwiYWdhaW4tYnV0dG9uXCIgY2xhc3M9XCJsYXVuY2hcIj5cXG4gICAgICAnLCBlc2NhcGUoKDMxLCAgZGF0YS50cnlBZ2FpbiApKSwgJ1xcbiAgICA8L2J1dHRvbj5cXG4gICcpOzMzOyB9OyBidWYucHVzaCgnJyk7MzM7IH07IGJ1Zi5wdXNoKCdcXG4nKTszNDsgaWYgKGRhdGEubmV4dExldmVsKSB7OyBidWYucHVzaCgnICAnKTszNDsgaWYgKGRhdGEuaXNLMSAmJiAhZGF0YS5mcmVlUGxheSkgezsgYnVmLnB1c2goJyAgICA8ZGl2IGlkPVwiY29udGludWUtYnV0dG9uXCIgY2xhc3M9XCJsYXVuY2ggYXJyb3ctY29udGFpbmVyIGFycm93LXJpZ2h0XCI+XFxuICAgICAgPGRpdiBjbGFzcz1cImFycm93LWhlYWRcIj48aW1nIHNyYz1cIicsIGVzY2FwZSgoMzUsICBkYXRhLmFzc2V0VXJsKCdtZWRpYS9uZXh0LWFycm93LWhlYWQucG5nJykgKSksICdcIiBhbHQ9XCJBcnJvd2hlYWRcIiB3aWR0aD1cIjY2XCIgaGVpZ2h0PVwiMTMwXCIvPjwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XCJhcnJvdy10ZXh0XCI+JywgZXNjYXBlKCgzNiwgIGRhdGEuY29udGludWVUZXh0ICkpLCAnPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgJyk7Mzg7IH0gZWxzZSB7OyBidWYucHVzaCgnICAgIDxidXR0b24gaWQ9XCJjb250aW51ZS1idXR0b25cIiBjbGFzcz1cImxhdW5jaFwiIHN0eWxlPVwiZmxvYXQ6IHJpZ2h0XCI+XFxuICAgICAgJywgZXNjYXBlKCgzOSwgIGRhdGEuY29udGludWVUZXh0ICkpLCAnXFxuICAgIDwvYnV0dG9uPlxcbiAgJyk7NDE7IH07IGJ1Zi5wdXNoKCcnKTs0MTsgfTsgYnVmLnB1c2goJzxkaXYgY2xhc3M9XCJhZnRlci1mZWVkYmFjay1idXR0b25zXCIvPlxcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIi8qKlxuICogQG92ZXJ2aWV3IEEgaGVscGVyIGNsYXNzIGZvciBhbGwgYWN0aW9ucyBhc3NvY2lhdGVkIHdpdGggUHV6emxlXG4gKiBSYXRpbmdzLCBha2EgdGhlIEZ1bi1PLU1ldGVyLlxuICovXG5cbnZhciBwdXp6bGVSYXRpbmdVdGlscyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHB1enpsZVJhdGluZ1V0aWxzO1xuXG52YXIgZG9tID0gcmVxdWlyZSgnLi9kb20nKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3QgdGhlIHB1enpsZSByYXRpbmcgYnV0dG9ucyB0aGVtc2VsdmVzXG4gKlxuICogQHJldHVybnMge0VsZW1lbnR9IGRpdiBjb250YWluaW5nIHB1enpsZSByYXRuZyBidXR0b25zIHdpdGggYXR0YWNoZWRcbiAqICAgICAgICAgIGNsaWNrIGhhbmRsZXJzXG4gKi9cbnB1enpsZVJhdGluZ1V0aWxzLmJ1aWxkUHV6emxlUmF0aW5nQnV0dG9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJ1dHRvbkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBidXR0b25Db250YWluZXIuaWQgPSAncHV6emxlUmF0aW5nQnV0dG9ucyc7XG4gIGJ1dHRvbkNvbnRhaW5lci5pbm5lckhUTUwgPSByZXF1aXJlKCcuL3RlbXBsYXRlcy9wdXp6bGVSYXRpbmcuaHRtbC5lanMnKSgpO1xuXG4gIHZhciBidXR0b25zID0gYnV0dG9uQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5wdXp6bGUtcmF0aW5nLWJ0bicpO1xuICB2YXIgYnV0dG9uQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBidXR0b247IChidXR0b24gPSBidXR0b25zW2ldKTsgaSsrKSB7XG4gICAgICBpZiAoYnV0dG9uICE9IHRoaXMpIHtcbiAgICAgICAgJChidXR0b24pLnJlbW92ZUNsYXNzKCdlbmFibGVkJyk7XG4gICAgICB9XG4gICAgfVxuICAgICQodGhpcykudG9nZ2xlQ2xhc3MoJ2VuYWJsZWQnKTtcbiAgfTtcbiAgZm9yICh2YXIgaSA9IDAsIGJ1dHRvbjsgKGJ1dHRvbiA9IGJ1dHRvbnNbaV0pOyBpKyspIHtcbiAgICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KGJ1dHRvbiwgYnV0dG9uQ2xpY2tIYW5kbGVyKTtcbiAgfVxuXG4gIHJldHVybiBidXR0b25Db250YWluZXI7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFB1enpsZVJhdGluZ1xuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzY3JpcHRfaWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZXZlbF9pZFxuICogQHByb3BlcnR5IHtudW1iZXJ8c3RyaW5nfSByYXRpbmcgLSBjYW4gYmUgYSBudW1iZXIgb3IgYW5cbiAqICAgICAgICAgICBpbnRlZ2VyLXBhcnNlYWJsZSBzdHJpbmdcbiAqL1xuXG4vKipcbiAqIFByaXZhdGUgZ2V0dGVyL2xvY2FsU3RvcmFnZSBwcm94eVxuICogQHJldHVybnMge1B1enpsZVJhdGluZ1tdfSAtIHJhdGluZ3NcbiAqL1xucHV6emxlUmF0aW5nVXRpbHMuZ2V0UHV6emxlUmF0aW5nc18gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByYXRpbmdzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3B1enpsZVJhdGluZ3MnKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcmF0aW5ncyA/IEpTT04ucGFyc2UocmF0aW5ncykgOiBbXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcml2YXRlIHNldHRlci9sb2NhbFN0b3JhZ2UgcHJveHlcbiAqIEBwYXJhbSB7UHV6emxlUmF0aW5nW119IHJhdGluZ3NcbiAqL1xucHV6emxlUmF0aW5nVXRpbHMuc2V0UHV6emxlUmF0aW5nc18gPSBmdW5jdGlvbiAocmF0aW5ncykge1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncHV6emxlUmF0aW5ncycsIEpTT04uc3RyaW5naWZ5KHJhdGluZ3MpKTtcbn07XG5cbi8qKlxuICogUHJpdmF0ZSBkZWxldGVyL2xvY2FsU3RvcmFnZSBwcm94eVxuICogQHBhcmFtIHtQdXp6bGVSYXRpbmd9IHJhdGluZ1xuICovXG5wdXp6bGVSYXRpbmdVdGlscy5yZW1vdmVQdXp6bGVSYXRpbmdfID0gZnVuY3Rpb24gKHJhdGluZykge1xuICB2YXIgcmF0aW5ncyA9IHB1enpsZVJhdGluZ1V0aWxzLmdldFB1enpsZVJhdGluZ3NfKCkuZmlsdGVyKGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHZhciBvdGhlckVxdWFsc1JhdGluZyA9IChyYXRpbmcubGV2ZWxfaWQgPT09IG90aGVyLmxldmVsX2lkICYmXG4gICAgICByYXRpbmcuc2NyaXB0X2lkID09PSBvdGhlci5zY3JpcHRfaWQgJiZcbiAgICAgIHJhdGluZy5yYXRpbmcgPT09IG90aGVyLnJhdGluZyk7XG4gICAgcmV0dXJuICFvdGhlckVxdWFsc1JhdGluZztcbiAgfSk7XG4gIHB1enpsZVJhdGluZ1V0aWxzLnNldFB1enpsZVJhdGluZ3NfKHJhdGluZ3MpO1xufTtcblxuLyoqXG4gKiBDYWNoZSB0aGUgc2VsZWN0ZWQgcmF0aW5nLCB0byBiZSBzdWJtaXR0ZWQgKHBvc3NpYmx5IHdpdGggb3RoZXJcbiAqIGNhY2hlZCByYXRpbmdzKSBhdCBzb21lIGxhdGVyIHBvaW50XG4gKlxuICogQHBhcmFtIHtqUXVlcnl9IGNvbnRhaW5lciAtIHNvbWUgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBidXR0b25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG90aGVyIGRhdGEgdG8gYmUgc3VibWl0dGVkIGFsb25nIHdpdGggdGhlXG4gKiAgICAgICAgcmF0aW5nLiBVc3VhbGx5IHNjcmlwdF9pZCBhbmQgbGV2ZWxfaWRcbiAqL1xucHV6emxlUmF0aW5nVXRpbHMuY2FjaGVQdXp6bGVSYXRpbmcgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gIHZhciBzZWxlY3RlZEJ1dHRvbiA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcucHV6emxlLXJhdGluZy1idG4uZW5hYmxlZCcpO1xuICBpZiAoc2VsZWN0ZWRCdXR0b24pIHtcbiAgICB2YXIgcmF0aW5nID0gJC5leHRlbmQoe30sIG9wdGlvbnMsIHsgcmF0aW5nOiBzZWxlY3RlZEJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKSB9KTtcbiAgICB2YXIgcmF0aW5ncyA9IHB1enpsZVJhdGluZ1V0aWxzLmdldFB1enpsZVJhdGluZ3NfKCk7XG4gICAgcmF0aW5ncy5wdXNoKHJhdGluZyk7XG4gICAgcHV6emxlUmF0aW5nVXRpbHMuc2V0UHV6emxlUmF0aW5nc18ocmF0aW5ncyk7XG4gIH1cbn07XG5cbi8qKlxuICogUE9TVCB0aGUgY2FjaGVkIHJhdGluZ3MgdG8gdGhlIGdpdmVuIFVSTCBhbmQgY2xlYXIgdGhlIGNhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFxuICovXG5wdXp6bGVSYXRpbmdVdGlscy5zdWJtaXRDYWNoZWRQdXp6bGVSYXRpbmdzID0gZnVuY3Rpb24gKHVybCkge1xuICB2YXIgcmF0aW5ncyA9IHB1enpsZVJhdGluZ1V0aWxzLmdldFB1enpsZVJhdGluZ3NfKCk7XG4gIHJhdGluZ3MuZm9yRWFjaChmdW5jdGlvbiAocmF0aW5nKSB7XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogdXJsLFxuICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgZGF0YTogcmF0aW5nLFxuICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcHV6emxlUmF0aW5nVXRpbHMucmVtb3ZlUHV6emxlUmF0aW5nXyhyYXRpbmcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cz0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IGZ1bmN0aW9uIGFub255bW91cyhsb2NhbHMsIGZpbHRlcnMsIGVzY2FwZVxuLyoqLykge1xuZXNjYXBlID0gZXNjYXBlIHx8IGZ1bmN0aW9uIChodG1sKXtcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxuICAgIC5yZXBsYWNlKC8mKD8hXFx3KzspL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufTtcbnZhciBidWYgPSBbXTtcbndpdGggKGxvY2FscyB8fCB7fSkgeyAoZnVuY3Rpb24oKXsgXG4gYnVmLnB1c2goJzxocj5cXG48cD5EaWQgeW91IGxpa2UgdGhpcyBwdXp6bGU/PC9wPlxcblxcbjxhIGNsYXNzPVwicHV6emxlLXJhdGluZy1idG5cIiBpZD1cImxpa2VcIiBkYXRhLXZhbHVlPVwiMVwiPlxcbiAgPHN2ZyB2ZXJzaW9uPVwiMS4xXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHg9XCIwcHhcIiB5PVwiMHB4XCJcXG4gICAgICB3aWR0aD1cIjI3cHhcIiBoZWlnaHQ9XCIyN3B4XCIgdmlld0JveD1cIjAgMCAyNi4wNTUgMjEuMDU4XCIgZW5hYmxlLWJhY2tncm91bmQ9XCJuZXcgMCAwIDI2LjA1NSAyMS4wNThcIiB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiIHZhbHVlPVwiMVwiPlxcbiAgICA8cGF0aCBkPVwiTTE0LjQyNiwyLjVjMC45ODYtMS4zNDgsMi44My0yLjUsNS4wOTItMi41YzMuNjEzLDAsNi41MzcsMy4wNDQsNi41MzcsNi41MzdcXG4gICAgICAgIGMwLDIuMzU3LTEuMDc2LDMuNzA5LTEuODk0LDQuNTI1Yy0wLjk0MSwwLjk0MS04LjA4Miw4LjA4Mi05LjExMyw5LjExM2MtMS4yNDQsMS4yNDMtMy4wMTksMS4xMzctNC4yNDYtMC4wOVxcbiAgICAgICAgYy0xLjMxNC0xLjMxNC03LjE1OC03LjE1OC05LjEzMS05LjEzMUMwLjQwOCw5LjY5MywwLDguMTEzLDAsNi41MzdDMCwyLjkyNiwzLjE5NywwLDYuNTM3LDBjMi40NTEsMCw0LjQzOCwxLjUwOCw1LjE4OCwyLjUzNVxcbiAgICAgICAgQzEyLjQsMy40NTksMTMuNjQzLDMuNTY0LDE0LjQyNiwyLjV6XCIvPlxcbiAgPC9zdmc+XFxuPC9hPlxcblxcbjxhIGNsYXNzPVwicHV6emxlLXJhdGluZy1idG5cIiBpZD1cImRpc2xpa2VcIiBkYXRhLXZhbHVlPVwiMFwiPlxcbiAgPHN2ZyB2ZXJzaW9uPVwiMS4xXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHg9XCIwcHhcIiB5PVwiMHB4XCJcXG4gICAgICB3aWR0aD1cIjI3cHhcIiBoZWlnaHQ9XCIyN3B4XCIgdmlld0JveD1cIjM4Mi4zMjEgMjkyLjgyIDI2LjM3IDI2LjM3MVwiIGVuYWJsZS1iYWNrZ3JvdW5kPVwibmV3IDM4Mi4zMjEgMjkyLjgyIDI2LjM3IDI2LjM3MVwiXFxuICAgICAgeG1sOnNwYWNlPVwicHJlc2VydmVcIj5cXG4gICAgPHBhdGggZD1cIk0zOTUuNTA2LDI5Mi44MmMtNy4yODIsMC4wMDItMTMuMTg0LDUuOTA0LTEzLjE4NSwxMy4xODVjMC4wMDEsNy4yODMsNS45MDIsMTMuMTg0LDEzLjE4NSwxMy4xODZcXG4gICAgICAgIGM3LjI4MS0wLjAwMiwxMy4xODMtNS45MDIsMTMuMTg1LTEzLjE4NkM0MDguNjg5LDI5OC43MjUsNDAyLjc4NywyOTIuODIyLDM5NS41MDYsMjkyLjgyeiBNNDAyLjUsMzEzXFxuICAgICAgICBjLTEuNzk1LDEuNzkzLTQuMjU3LDIuODk2LTYuOTk0LDIuODk4Yy0yLjczNy0wLjAwMi01LjE5OS0xLjEwNS02Ljk5NC0yLjg5OGMtMS43OTQtMS43OTUtMi44OTctNC4yNTgtMi44OTctNi45OTRcXG4gICAgICAgIHMxLjEwMy01LjE5OSwyLjg5Ny02Ljk5NGMxLjc5NS0xLjc5Myw0LjI1Ny0yLjg5Nyw2Ljk5NC0yLjg5N3M1LjE5OSwxLjEwNCw2Ljk5NCwyLjg5N2MxLjc5MiwxLjc5NSwyLjg5Niw0LjI1OCwyLjg5Niw2Ljk5NFxcbiAgICAgICAgUzQwNC4yOTIsMzExLjIwNSw0MDIuNSwzMTN6IE0zOTEuMzE3LDMwNC45NTFjMS4wNTQsMCwxLjkwNy0wLjg1NCwxLjkwNy0xLjkwNmMwLTEuMDUzLTAuODU0LTEuOTA2LTEuOTA3LTEuOTA2XFxuICAgICAgICBjLTEuMDU0LDAtMS45MDcsMC44NTQtMS45MDcsMS45MDZDMzg5LjQxLDMwNC4wOTgsMzkwLjI2NCwzMDQuOTUxLDM5MS4zMTcsMzA0Ljk1MXogTTM5OS42OTEsMzA0Ljk1MVxcbiAgICAgICAgYzEuMDUzLDAsMS45MDYtMC44NTQsMS45MDYtMS45MDZjMC0xLjA1My0wLjg1My0xLjkwNi0xLjkwNi0xLjkwNnMtMS45MDcsMC44NTQtMS45MDcsMS45MDZcXG4gICAgICAgIEMzOTcuNzg0LDMwNC4wOTgsMzk4LjYzOSwzMDQuOTUxLDM5OS42OTEsMzA0Ljk1MXogTTM5MS43NzMsMzExLjkyOGMxLjAzNy0xLjAzNSwyLjM3OS0xLjU0MywzLjczOS0xLjU0NVxcbiAgICAgICAgYzEuMzUyLDAuMDAyLDIuNjg5LDAuNTEyLDMuNzI0LDEuNTQ1YzAuNjQyLDAuNjQzLDEuNjg1LDAuNjQzLDIuMzI4LDBjMC42NDUtMC42NDMsMC42NDUtMS42ODYsMC0yLjMzXFxuICAgICAgICBjLTEuNjY1LTEuNjY2LTMuODY0LTIuNTEtNi4wNTItMi41MDhoLTAuMDA4Yy0yLjE4NSwwLTQuMzksMC44MzgtNi4wNiwyLjUxYy0wLjY0MiwwLjY0My0wLjY0MywxLjY4NiwwLDIuMzI4XFxuICAgICAgICBDMzkwLjA4OCwzMTIuNTcxLDM5MS4xMzEsMzEyLjU3MSwzOTEuNzczLDMxMS45Mjh6XCIvPlxcbiAgPC9zdmc+XFxuPC9hPlxcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsInZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xudmFyIHBhcnNlWG1sRWxlbWVudCA9IHJlcXVpcmUoJy4veG1sJykucGFyc2VFbGVtZW50O1xuXG52YXIgVGVzdFJlc3VsdHMgPSBjb25zdGFudHMuVGVzdFJlc3VsdHM7XG5cbi8vIFRPRE8gKGJyLXBhaXIpOiBjYW4gd2Ugbm90IHBhc3MgaW4gdGhlIHN0dWRpb0FwcFxudmFyIEZlZWRiYWNrQmxvY2tzID0gZnVuY3Rpb24ob3B0aW9ucywgbWlzc2luZ1JlcXVpcmVkQmxvY2tzLCBtaXNzaW5nUmVjb21tZW5kZWRCbG9ja3MsIHN0dWRpb0FwcCkge1xuICAvLyBDaGVjayB3aGV0aGVyIGJsb2NrcyBhcmUgZW1iZWRkZWQgaW4gdGhlIGhpbnQgcmV0dXJuZWQgZnJvbSBkYXNoYm9hcmQuXG4gIC8vIFNlZSBiZWxvdyBjb21tZW50IGZvciBmb3JtYXQuXG4gIHZhciBlbWJlZGRlZEJsb2NrcyA9IG9wdGlvbnMucmVzcG9uc2UgJiYgb3B0aW9ucy5yZXNwb25zZS5oaW50ICYmXG4gICAgICBvcHRpb25zLnJlc3BvbnNlLmhpbnQuaW5kZXhPZihcIlt7XCIpICE9PSAwO1xuICBpZiAoIWVtYmVkZGVkQmxvY2tzICYmXG4gICAgICBvcHRpb25zLmZlZWRiYWNrVHlwZSAhPT0gVGVzdFJlc3VsdHMuTUlTU0lOR19CTE9DS19VTkZJTklTSEVEICYmXG4gICAgICBvcHRpb25zLmZlZWRiYWNrVHlwZSAhPT0gVGVzdFJlc3VsdHMuTUlTU0lOR19CTE9DS19GSU5JU0hFRCAmJlxuICAgICAgb3B0aW9ucy5mZWVkYmFja1R5cGUgIT09IFRlc3RSZXN1bHRzLk1JU1NJTkdfUkVDT01NRU5ERURfQkxPQ0tfVU5GSU5JU0hFRCAmJlxuICAgICAgb3B0aW9ucy5mZWVkYmFja1R5cGUgIT09IFRlc3RSZXN1bHRzLk1JU1NJTkdfUkVDT01NRU5ERURfQkxPQ0tfRklOSVNIRUQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYmxvY2tzVG9EaXNwbGF5ID0gW107XG4gIGlmIChlbWJlZGRlZEJsb2Nrcykge1xuICAgIC8vIEhpbnQgc2hvdWxkIGJlIG9mIHRoZSBmb3JtOiBTT01FIFRFWFQgW3suLn0sIHsuLn0sIC4uXSBJR05PUkVELlxuICAgIC8vIEV4YW1wbGU6ICdUcnkgdGhlIGZvbGxvd2luZyBibG9jazogW3tcInR5cGVcIjogXCJtYXplX21vdmVGb3J3YXJkXCJ9XSdcbiAgICAvLyBOb3RlIHRoYXQgZG91YmxlIHF1b3RlcyBhcmUgcmVxdWlyZWQgYnkgdGhlIEpTT04gcGFyc2VyLlxuICAgIHZhciBwYXJ0cyA9IG9wdGlvbnMucmVzcG9uc2UuaGludC5tYXRjaCgvKC4qKShcXFsuKlxcXSkvKTtcbiAgICBpZiAoIXBhcnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9wdGlvbnMucmVzcG9uc2UuaGludCA9IHBhcnRzWzFdLnRyaW0oKTsgIC8vIFJlbW92ZSBibG9ja3MgZnJvbSBoaW50LlxuICAgIHRyeSB7XG4gICAgICBibG9ja3NUb0Rpc3BsYXkgPSBKU09OLnBhcnNlKHBhcnRzWzJdKTtcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgLy8gVGhlIGJsb2NrcyBjb3VsZCBub3QgYmUgcGFyc2VkLiAgSWdub3JlIHRoZW0uXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2UgaWYgKG1pc3NpbmdSZXF1aXJlZEJsb2Nrcy5ibG9ja3NUb0Rpc3BsYXkubGVuZ3RoKSB7XG4gICAgaGFuZGxlTWlzc2luZ0Jsb2NrcyhtaXNzaW5nUmVxdWlyZWRCbG9ja3MpO1xuICB9IGVsc2Uge1xuICAgIGhhbmRsZU1pc3NpbmdCbG9ja3MobWlzc2luZ1JlY29tbWVuZGVkQmxvY2tzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1pc3NpbmdCbG9ja3MoYmxvY2tzKSB7XG4gICAgYmxvY2tzVG9EaXNwbGF5ID0gYmxvY2tzLmJsb2Nrc1RvRGlzcGxheTtcbiAgICBpZiAoYmxvY2tzLm1lc3NhZ2UpIHtcbiAgICAgIG9wdGlvbnMubWVzc2FnZSA9IGJsb2Nrcy5tZXNzYWdlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChibG9ja3NUb0Rpc3BsYXkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy54bWwgPSB0aGlzLmdlbmVyYXRlWE1MRm9yQmxvY2tzXyhibG9ja3NUb0Rpc3BsYXkpO1xuXG4gIHRoaXMuZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZGl2LnNldEF0dHJpYnV0ZSgnaWQnLCAnZmVlZGJhY2tCbG9ja3MnKTtcblxuICAvLyBXaWxsIGJlIHNldCBieSB0aGlzLnJlbmRlcigpXG4gIHRoaXMuYmxvY2tTcGFjZUVkaXRvciA9IHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmVlZGJhY2tCbG9ja3M7XG5cbkZlZWRiYWNrQmxvY2tzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIE9ubHkgcmVuZGVyIGlmIHRoaXMuZGl2IGV4aXN0cyBpbiB0aGUgRE9NXG4gIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLmRpdikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFyc2VkWG1sID0gcGFyc2VYbWxFbGVtZW50KHRoaXMueG1sKTtcbiAgdmFyIGJsb2NrU3BhY2UgPSBCbG9ja2x5LkJsb2NrU3BhY2UuY3JlYXRlUmVhZE9ubHlCbG9ja1NwYWNlKHRoaXMuZGl2LCBwYXJzZWRYbWwpO1xuICB0aGlzLmJsb2NrU3BhY2VFZGl0b3IgPSBibG9ja1NwYWNlLmJsb2NrU3BhY2VFZGl0b3I7XG59O1xuXG5GZWVkYmFja0Jsb2Nrcy5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5kaXYuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xuICB0aGlzLmRpdi5zdHlsZS5oZWlnaHQgPSAnJztcbiAgaWYgKHRoaXMuYmxvY2tTcGFjZUVkaXRvcikge1xuICAgIHRoaXMuYmxvY2tTcGFjZUVkaXRvci5zdmdSZXNpemUoKTtcbiAgfVxufTtcblxuRmVlZGJhY2tCbG9ja3MucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kaXYuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICB0aGlzLmRpdi5zdHlsZS5oZWlnaHQgPSAnMHB4Jztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgWE1MIGZvciBibG9ja3MgdG8gYmUgZGlzcGxheWVkIGluIGEgcmVhZC1vbmx5IGZyYW1lLlxuICogQHBhcmFtIHtBcnJheX0gYmxvY2tzIEFuIGFycmF5IG9mIGJsb2NrcyB0byBkaXNwbGF5ICh3aXRoIG9wdGlvbmFsIGFyZ3MpLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZ2VuZXJhdGVkIHN0cmluZyBvZiBYTUwuXG4gKi9cbkZlZWRiYWNrQmxvY2tzLnByb3RvdHlwZS5nZW5lcmF0ZVhNTEZvckJsb2Nrc18gPSBmdW5jdGlvbihibG9ja3MpIHtcbiAgdmFyIGJsb2NrWE1MU3RyaW5ncyA9IFsnPHhtbD4nXTtcbiAgdmFyIGJsb2NrWCA9IDEwOyAgLy8gUHJldmVudCBsZWZ0IG91dHB1dCBwbHVncyBmcm9tIGJlaW5nIGN1dCBvZmYuXG4gIHZhciBibG9ja1kgPSAwO1xuICB2YXIgYmxvY2tYUGFkZGluZyA9IDIwMDtcbiAgdmFyIGJsb2NrWVBhZGRpbmcgPSAxMjA7XG4gIHZhciBibG9ja3NQZXJMaW5lID0gMjtcbiAgdmFyIGssIG5hbWU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJsb2NrID0gYmxvY2tzW2ldO1xuICAgIGlmIChibG9jay5ibG9ja0Rpc3BsYXlYTUwpIHtcbiAgICAgIGJsb2NrWE1MU3RyaW5ncy5wdXNoKGJsb2NrLmJsb2NrRGlzcGxheVhNTCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYmxvY2tYTUxTdHJpbmdzLnB1c2goJzxibG9jaycsICcgdHlwZT1cIicsIGJsb2NrLnR5cGUsICdcIiB4PVwiJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrWC50b1N0cmluZygpLCAnXCIgeT1cIicsIGJsb2NrWSwgJ1wiPicpO1xuICAgIGlmIChibG9jay50aXRsZXMpIHtcbiAgICAgIHZhciB0aXRsZU5hbWVzID0gT2JqZWN0LmtleXMoYmxvY2sudGl0bGVzKTtcbiAgICAgIGZvciAoayA9IDA7IGsgPCB0aXRsZU5hbWVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIG5hbWUgPSB0aXRsZU5hbWVzW2tdO1xuICAgICAgICBibG9ja1hNTFN0cmluZ3MucHVzaCgnPHRpdGxlIG5hbWU9XCInLCBuYW1lLCAnXCI+JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jay50aXRsZXNbbmFtZV0sICc8L3RpdGxlPicpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmxvY2sudmFsdWVzKSB7XG4gICAgICB2YXIgdmFsdWVOYW1lcyA9IE9iamVjdC5rZXlzKGJsb2NrLnZhbHVlcyk7XG4gICAgICBmb3IgKGsgPSAwOyBrIDwgdmFsdWVOYW1lcy5sZW5ndGg7IGsrKykge1xuICAgICAgICBuYW1lID0gdmFsdWVOYW1lc1trXTtcbiAgICAgICAgYmxvY2tYTUxTdHJpbmdzLnB1c2goJzx2YWx1ZSBuYW1lPVwiJywgbmFtZSwgJ1wiPicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sudmFsdWVzW25hbWVdLCAnPC92YWx1ZT4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJsb2NrLmV4dHJhKSB7XG4gICAgICBibG9ja1hNTFN0cmluZ3MucHVzaChibG9jay5leHRyYSk7XG4gICAgfVxuICAgIGJsb2NrWE1MU3RyaW5ncy5wdXNoKCc8L2Jsb2NrPicpO1xuICAgIGlmICgoaSArIDEpICUgYmxvY2tzUGVyTGluZSA9PT0gMCkge1xuICAgICAgYmxvY2tZICs9IGJsb2NrWVBhZGRpbmc7XG4gICAgICBibG9ja1ggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBibG9ja1ggKz0gYmxvY2tYUGFkZGluZztcbiAgICB9XG4gIH1cbiAgYmxvY2tYTUxTdHJpbmdzLnB1c2goJzwveG1sPicpO1xuICByZXR1cm4gYmxvY2tYTUxTdHJpbmdzLmpvaW4oJycpO1xufTtcbiIsIi8qIGdsb2JhbCBkYXNoYm9hcmQgKi9cbi8vIFRPRE8oZGF2ZSk6IE1lcmdlIHdpdGggdGhlIGNsaWVudCBBUEkgaW4gL3NoYXJlZC5cbi8vIFRPRE86IFRoZSBjbGllbnQgQVBJIHNob3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCB0aGUgY2hhbm5lbCBJRCwgaW5zdGVhZCBvZiBncmFiYmluZyBpdCBmcm9tIHRoZSBgZGFzaGJvYXJkLnByb2plY3RgIGdsb2JhbC5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFzc2V0czogY2xpZW50QXBpKCdhc3NldHMnKSxcbiAgc291cmNlczogY2xpZW50QXBpKCdzb3VyY2VzJylcbn07XG5cbmZ1bmN0aW9uIGNsaWVudEFwaShlbmRwb2ludCkge1xuICByZXR1cm4ge1xuICAgIGJhc2VQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgcmV0dXJuICcvdjMvJyArIGVuZHBvaW50ICsgJy8nICsgZGFzaGJvYXJkLnByb2plY3QuZ2V0Q3VycmVudElkKCkgKyAocGF0aCA/ICcvJyArIHBhdGggOiAnJyk7XG4gICAgfSxcbiAgICBhamF4OiBmdW5jdGlvbiAobWV0aG9kLCBmaWxlLCBzdWNjZXNzLCBlcnJvciwgZGF0YSkge1xuICAgICAgaWYgKCF3aW5kb3cuZGFzaGJvYXJkKSB7XG4gICAgICAgIGVycm9yKHtzdGF0dXM6IFwiTm8gZGFzaGJvYXJkXCJ9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh4aHIuc3RhdHVzID49IDQwMCkge1xuICAgICAgICAgIGVycm9yKHhocik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1Y2Nlc3MoeGhyKTtcbiAgICAgIH0pO1xuICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBlcnJvcih4aHIpO1xuICAgICAgfSk7XG5cbiAgICAgIHhoci5vcGVuKG1ldGhvZCwgdGhpcy5iYXNlUGF0aChmaWxlKSwgdHJ1ZSk7XG4gICAgICB4aHIuc2VuZChkYXRhKTtcbiAgICB9XG4gIH07XG59XG4iLCJ2YXIgeG1sID0gcmVxdWlyZSgnLi94bWwnKTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIHhtbCBmb3IgYSBsZXZlbCdzIHRvb2xib3hcbiAqIEBwYXJhbSB7c3RyaW5nfSBibG9ja3MgVGhlIHhtbCBvZiB0aGUgYmxvY2tzIHRvIGdvIGluIHRoZSB0b29sYm94XG4gKi9cbmV4cG9ydHMuY3JlYXRlVG9vbGJveCA9IGZ1bmN0aW9uKGJsb2Nrcykge1xuICByZXR1cm4gJzx4bWwgaWQ9XCJ0b29sYm94XCIgc3R5bGU9XCJkaXNwbGF5OiBub25lO1wiPicgKyBibG9ja3MgKyAnPC94bWw+Jztcbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSB4bWwgZm9yIGEgYmxvY2sgb2YgdGhlIGdpdmVuIHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBibG9ja1xuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxzdHJpbmc+fSBbdGl0bGVzXSBEaWN0aW9uYXJ5IG9mIHRpdGxlcyBtYXBwaW5nIG5hbWUgdG8gdmFsdWVcbiAqL1xuZXhwb3J0cy5ibG9ja09mVHlwZSA9IGZ1bmN0aW9uKHR5cGUsIHRpdGxlcykge1xuICB2YXIgdGl0bGVUZXh0ID0gJyc7XG4gIGlmICh0aXRsZXMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGl0bGVzKSB7XG4gICAgICB0aXRsZVRleHQgKz0gJzx0aXRsZSBuYW1lPVwiJyArIGtleSArICdcIj4nICsgdGl0bGVzW2tleV0gKyAnPC90aXRsZT4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxibG9jayB0eXBlPVwiJyArIHR5cGUgKyAnXCI+JyArIHRpdGxlVGV4dCArJzwvYmxvY2s+Jztcbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSB4bWwgZm9yIGEgYmxvY2sgb2YgdGhlIGdpdmVuIHR5cGUsIHdpdGggdGhlIHByb3ZpZGVkIGNoaWxkIG5lc3RlZFxuICogaW4gYSBuZXh0IGJsb2NrXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiB0aGUgYmxvY2tcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn0gW3RpdGxlc10gRGljdGlvbmFyeSBvZiB0aXRsZXMgbWFwcGluZyBuYW1lIHRvIHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hpbGQgWG1sIGZvciB0aGUgY2hpbGQgYmxvY2tcbiAqL1xuZXhwb3J0cy5ibG9ja1dpdGhOZXh0ID0gZnVuY3Rpb24gKHR5cGUsIHRpdGxlcywgY2hpbGQpIHtcbiAgdmFyIHRpdGxlVGV4dCA9ICcnO1xuICBpZiAodGl0bGVzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRpdGxlcykge1xuICAgICAgdGl0bGVUZXh0ICs9ICc8dGl0bGUgbmFtZT1cIicgKyBrZXkgKyAnXCI+JyArIHRpdGxlc1trZXldICsgJzwvdGl0bGU+JztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8YmxvY2sgdHlwZT1cIicgKyB0eXBlICsgJ1wiPicgKyB0aXRsZVRleHQgKyAnPG5leHQ+JyArIGNoaWxkICsgJzwvbmV4dD48L2Jsb2NrPic7XG59O1xuXG4vKipcbiAqIEdpdmUgYSBsaXN0IG9mIHR5cGVzLCByZXR1cm5zIHRoZSB4bWwgYXNzdW1pbmcgZWFjaCBibG9jayBpcyBhIGNoaWxkIG9mXG4gKiB0aGUgcHJldmlvdXMgYmxvY2suXG4gKi9cbmV4cG9ydHMuYmxvY2tzRnJvbUxpc3QgPSBmdW5jdGlvbiAodHlwZXMpIHtcbiAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0aGlzLmJsb2NrT2ZUeXBlKHR5cGVzWzBdKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmJsb2NrV2l0aE5leHQodHlwZXNbMF0sIHt9LCB0aGlzLmJsb2Nrc0Zyb21MaXN0KHR5cGVzLnNsaWNlKDEpKSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgeG1sIGZvciBhIGNhdGVnb3J5IGluIGEgdG9vbGJveFxuICovXG5leHBvcnRzLmNyZWF0ZUNhdGVnb3J5ID0gZnVuY3Rpb24obmFtZSwgYmxvY2tzLCBjdXN0b20pIHtcbiAgcmV0dXJuICc8Y2F0ZWdvcnkgbmFtZT1cIicgKyBuYW1lICsgJ1wiJyArXG4gICAgICAgICAgKGN1c3RvbSA/ICcgY3VzdG9tPVwiJyArIGN1c3RvbSArICdcIicgOiAnJykgK1xuICAgICAgICAgICc+JyArIGJsb2NrcyArICc8L2NhdGVnb3J5Pic7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc2ltcGxlIGJsb2NrIHdpdGggYSBwbGFpbiB0aXRsZSBhbmQgbmV4dC9wcmV2aW91cyBjb25uZWN0b3JzLlxuICovXG5leHBvcnRzLmdlbmVyYXRlU2ltcGxlQmxvY2sgPSBmdW5jdGlvbiAoYmxvY2tseSwgZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gIFsnbmFtZScsICd0aXRsZScsICd0b29sdGlwJywgJ2Z1bmN0aW9uTmFtZSddLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgaWYgKCFvcHRpb25zW3BhcmFtXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZW5lcmF0ZVNpbXBsZUJsb2NrIHJlcXVpcmVzIHBhcmFtIFwiJyArIHBhcmFtICsgJ1wiJyk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgdmFyIGhlbHBVcmwgPSBvcHRpb25zLmhlbHBVcmwgfHwgXCJcIjsgLy8gb3B0aW9uYWwgcGFyYW1cbiAgdmFyIHRpdGxlID0gb3B0aW9ucy50aXRsZTtcbiAgdmFyIHRpdGxlSW1hZ2UgPSBvcHRpb25zLnRpdGxlSW1hZ2U7XG4gIHZhciB0b29sdGlwID0gb3B0aW9ucy50b29sdGlwO1xuICB2YXIgZnVuY3Rpb25OYW1lID0gb3B0aW9ucy5mdW5jdGlvbk5hbWU7XG5cbiAgYmxvY2tseS5CbG9ja3NbbmFtZV0gPSB7XG4gICAgaGVscFVybDogaGVscFVybCxcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIE5vdGU6IGhhcyBhIGZpeGVkIEhTVi4gIENvdWxkIG1ha2UgdGhpcyBjdXN0b21pemFibGUgaWYgbmVlZCBiZVxuICAgICAgdGhpcy5zZXRIU1YoMTg0LCAxLjAwLCAwLjc0KTtcbiAgICAgIHZhciBpbnB1dCA9IHRoaXMuYXBwZW5kRHVtbXlJbnB1dCgpO1xuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIGlucHV0LmFwcGVuZFRpdGxlKHRpdGxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aXRsZUltYWdlKSB7XG4gICAgICAgIGlucHV0LmFwcGVuZFRpdGxlKG5ldyBibG9ja2x5LkZpZWxkSW1hZ2UodGl0bGVJbWFnZSkpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRQcmV2aW91c1N0YXRlbWVudCh0cnVlKTtcbiAgICAgIHRoaXMuc2V0TmV4dFN0YXRlbWVudCh0cnVlKTtcbiAgICAgIHRoaXMuc2V0VG9vbHRpcCh0b29sdGlwKTtcbiAgICB9XG4gIH07XG5cbiAgZ2VuZXJhdG9yW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gR2VuZXJhdGUgSmF2YVNjcmlwdCBmb3IgcHV0dGluZyBkaXJ0IG9uIHRvIGEgdGlsZS5cbiAgICByZXR1cm4gZnVuY3Rpb25OYW1lICsgJyhcXCdibG9ja19pZF8nICsgdGhpcy5pZCArICdcXCcpO1xcbic7XG4gIH07XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHNpbmdsZSBibG9jayBmcm9tIGEgPGJsb2NrLz4gRE9NIGVsZW1lbnQsIGFkZGluZyBpdCB0byB0aGUgbWFpbiB3b3Jrc3BhY2VcbiAqIEBwYXJhbSBibG9ja0RPTSB7RWxlbWVudH1cbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnRzLmRvbVRvQmxvY2sgPSBmdW5jdGlvbihibG9ja0RPTSkge1xuICByZXR1cm4gQmxvY2tseS5YbWwuZG9tVG9CbG9jayhCbG9ja2x5Lm1haW5CbG9ja1NwYWNlLCBibG9ja0RPTSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHNpbmdsZSBibG9jayBmcm9tIGEgYmxvY2sgWE1MIHN0cmluZ+KAlGUuZy4sIDxibG9jayB0eXBlPVwidGVzdEJsb2NrXCI+PC9ibG9jaz4sXG4gKiBhbmQgYWRkcyBpdCB0byB0aGUgbWFpbiB3b3Jrc3BhY2VcbiAqIEBwYXJhbSBibG9ja0RPTVN0cmluZ1xuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydHMuZG9tU3RyaW5nVG9CbG9jayA9IGZ1bmN0aW9uKGJsb2NrRE9NU3RyaW5nKSB7XG4gIHJldHVybiBleHBvcnRzLmRvbVRvQmxvY2soeG1sLnBhcnNlRWxlbWVudChibG9ja0RPTVN0cmluZykuZmlyc3RDaGlsZCk7XG59O1xuXG4vKipcbiAqIFRha2VzIGEgc2V0IG9mIHN0YXJ0IGJsb2NrcywgYW5kIHJldHVybnMgdGhlbSB3aXRoIGEgcGFydGljdWxhciB0b3AgbGV2ZWxcbiAqIGJsb2NrIGluc2VydGVkIGluIGZyb250IG9mIHRoZSBmaXJzdCBub24tZnVuY3Rpb24gYmxvY2suICBJZiB3ZSBhbHJlYWR5IGhhdmVcbiAqIHRoaXMgYmxvY2ssIGRvZXMgbm90aGluZy5cbiAqL1xuZXhwb3J0cy5mb3JjZUluc2VydFRvcEJsb2NrID0gZnVuY3Rpb24gKGlucHV0LCBibG9ja1R5cGUpIHtcbiAgaW5wdXQgPSBpbnB1dCB8fCAnJztcblxuICBpZiAoYmxvY2tUeXBlID09PSBudWxsIHx8IGlucHV0LmluZGV4T2YoYmxvY2tUeXBlKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICB2YXIgcm9vdCA9IHhtbC5wYXJzZUVsZW1lbnQoaW5wdXQpO1xuXG4gIC8vIEV4dHJhY3QgdGhlIGRvY3VtZW50IGZyb20gdGhlIHJvb3QuIFRoZSByZWFzb24gSSBkbyB0aGlzIGluc3RlYWQgb2YganVzdFxuICAvLyB1c2luZyBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGVsc2V3aGVyZSBpc1xuICB2YXIgZG9jID0gcm9vdC5wYXJlbnROb2RlO1xuXG4gIHZhciB0b3BCbG9jayA9IGRvYy5jcmVhdGVFbGVtZW50KCdibG9jaycpO1xuICB0b3BCbG9jay5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCBibG9ja1R5cGUpO1xuICB0b3BCbG9jay5zZXRBdHRyaWJ1dGUoJ21vdmFibGUnLCAnZmFsc2UnKTtcbiAgdG9wQmxvY2suc2V0QXR0cmlidXRlKCdkZWxldGFibGUnLCAnZmFsc2UnKTtcblxuICB2YXIgbnVtQ2hpbGRyZW4gPSByb290LmNoaWxkTm9kZXMgPyByb290LmNoaWxkTm9kZXMubGVuZ3RoIDogMDtcblxuICAvLyBmaW5kIHRoZSBmaXJzdCBub24tZnVuY3Rpb24gZGVmaW5pdGlvbiBibG9jayBhbmQgZXh0cmFjdCBpdFxuICB2YXIgZmlyc3RCbG9jayA9IG51bGwsIGkgPSAwO1xuICB3aGlsZSAoaSA8IG51bUNoaWxkcmVuICYmIGZpcnN0QmxvY2sgPT09IG51bGwpIHtcbiAgICB2YXIgY2hpbGQgPSByb290LmNoaWxkTm9kZXNbaV07XG4gICAgLy8gb25seSBsb29rIGF0IGVsZW1lbnQgbm9kZXNcbiAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIHZhciB0eXBlID0gY2hpbGQuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICBpZiAodHlwZSAhPT0gJ3Byb2NlZHVyZXNfZGVmbm9yZXR1cm4nICYmIHR5cGUgIT09ICdwcm9jZWR1cmVzX2RlZnJldHVybicpIHtcbiAgICAgICAgZmlyc3RCbG9jayA9IHJvb3QucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICBudW1DaGlsZHJlbi0tO1xuICAgICAgfVxuICAgIH1cbiAgICBpKys7XG4gIH1cblxuICBpZiAoZmlyc3RCbG9jayAhPT0gbnVsbCkge1xuICAgIC8vIHdoZW4gcnVuIC0+IG5leHQgLT4gZmlyc3RCbG9ja1xuICAgIHZhciBuZXh0O1xuICAgIGlmICgvXmZ1bmN0aW9uYWwvLnRlc3QoYmxvY2tUeXBlKSkge1xuICAgICAgbmV4dCA9IGRvYy5jcmVhdGVFbGVtZW50KCdmdW5jdGlvbmFsX2lucHV0Jyk7XG4gICAgICBuZXh0LnNldEF0dHJpYnV0ZSgnbmFtZScsICdBUkcxJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQgPSBkb2MuY3JlYXRlRWxlbWVudCgnbmV4dCcpO1xuICAgIH1cbiAgICBuZXh0LmFwcGVuZENoaWxkKGZpcnN0QmxvY2spO1xuICAgIHRvcEJsb2NrLmFwcGVuZENoaWxkKG5leHQpO1xuICB9XG5cbiAgaWYgKG51bUNoaWxkcmVuID4gMCkge1xuICAgIHJvb3QuaW5zZXJ0QmVmb3JlKHRvcEJsb2NrLCByb290LmNoaWxkTm9kZXNbMF0pO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuYXBwZW5kQ2hpbGQodG9wQmxvY2spO1xuICB9XG4gIHJldHVybiB4bWwuc2VyaWFsaXplKHJvb3QpO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgeG1sIGZvciBhIGJsb2NrIGZvciB0aGUgY2FsYyBhcHAuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlIGZvciB0aGlzIGJsb2NrXG4gKiBAcGFyYW0ge251bWJlcltdfHN0cmluZ1tdfSBhcmdzIExpc3Qgb2YgYXJncywgd2hlcmUgZWFjaCBhcmcgaXMgZWl0aGVyIHRoZVxuICogICB4bWwgZm9yIGEgY2hpbGQgYmxvY2ssIGEgbnVtYmVyLCBvciB0aGUgbmFtZSBvZiBhIHZhcmlhYmxlLlxuICovXG5leHBvcnRzLmNhbGNCbG9ja1htbCA9IGZ1bmN0aW9uICh0eXBlLCBhcmdzKSB7XG4gIHZhciBzdHIgPSAnPGJsb2NrIHR5cGU9XCInICsgdHlwZSArICdcIiBpbmxpbmU9XCJmYWxzZVwiPic7XG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBzdHIgKz0gJzxmdW5jdGlvbmFsX2lucHV0IG5hbWU9XCJBUkcnICsgaSArICdcIj4nO1xuICAgIHZhciBhcmcgPSBhcmdzW2kgLSAxXTtcbiAgICBpZiAodHlwZW9mKGFyZykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGFyZyA9ICc8YmxvY2sgdHlwZT1cImZ1bmN0aW9uYWxfbWF0aF9udW1iZXJcIj48dGl0bGUgbmFtZT1cIk5VTVwiPicgKyBhcmcgK1xuICAgICAgICAnPC90aXRsZT48L2Jsb2NrPic7XG4gICAgfSBlbHNlIGlmICgvXjxibG9jay8udGVzdChhcmcpKSB7XG4gICAgICAvLyB3ZSBoYXZlIHhtbCwgZG9udCBtYWtlIGFueSBjaGFuZ2VzXG4gICAgICBhcmcgPSBhcmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdlIHRoaW5rIHdlIGhhdmUgYSB2YXJpYWJsZVxuICAgICAgYXJnID0gZXhwb3J0cy5jYWxjQmxvY2tHZXRWYXIoYXJnKTtcbiAgICB9XG4gICAgc3RyICs9IGFyZztcbiAgICBzdHIgKz0gJzwvZnVuY3Rpb25hbF9pbnB1dD4nO1xuICB9XG4gIHN0ciArPSAnPC9ibG9jaz4nO1xuXG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHRoZSB4bWwgZm9yIGEgZnVuY3Rpb25hbF9wYXJhbWV0ZXJzX2dldCBibG9jayB3aXRoIHRoZSBnaXZlblxuICogICB2YXJpYWJsZU5hbWVcbiAqL1xuZXhwb3J0cy5jYWxjQmxvY2tHZXRWYXIgPSBmdW5jdGlvbiAodmFyaWFibGVOYW1lKSB7XG4gIHJldHVybiAnJyArXG4gICAgJzxibG9jayB0eXBlPVwiZnVuY3Rpb25hbF9wYXJhbWV0ZXJzX2dldFwiIHVzZXJ2aXNpYmxlPVwiZmFsc2VcIj4nICtcbiAgICAnICA8bXV0YXRpb24+JyArXG4gICAgJyAgICA8b3V0cHV0dHlwZT5OdW1iZXI8L291dHB1dHR5cGU+JyArXG4gICAgJyAgPC9tdXRhdGlvbj4nICtcbiAgICAnICA8dGl0bGUgbmFtZT1cIlZBUlwiPicgKyB2YXJpYWJsZU5hbWUgKyAnPC90aXRsZT4nICtcbiAgICAnPC9ibG9jaz4nO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgeG1sIGZvciBhIG1hdGggYmxvY2sgKGVpdGhlciBjYWxjIG9yIGV2YWwgYXBwcykuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlIGZvciB0aGlzIGJsb2NrXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLHN0cmluZ30gaW5wdXRzIERpY3Rpb25hcnkgbWFwcGluZyBpbnB1dCBuYW1lIHRvIHRoZVxuICAgICB4bWwgZm9yIHRoYXQgaW5wdXRcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcuc3RyaW5nPn0gW3RpdGxlc10gRGljdGlvbmFyeSBvZiB0aXRsZXMgbWFwcGluZyBuYW1lIHRvIHZhbHVlXG4gKi9cbmV4cG9ydHMubWF0aEJsb2NrWG1sID0gZnVuY3Rpb24gKHR5cGUsIGlucHV0cywgdGl0bGVzKSB7XG4gIHZhciBzdHIgPSAnPGJsb2NrIHR5cGU9XCInICsgdHlwZSArICdcIiBpbmxpbmU9XCJmYWxzZVwiPic7XG4gIGZvciAodmFyIHRpdGxlIGluIHRpdGxlcykge1xuICAgIHN0ciArPSAnPHRpdGxlIG5hbWU9XCInICsgdGl0bGUgKyAnXCI+JyArIHRpdGxlc1t0aXRsZV0gKyAnPC90aXRsZT4nO1xuICB9XG5cbiAgZm9yICh2YXIgaW5wdXQgaW4gaW5wdXRzKSB7XG4gICAgc3RyICs9ICc8ZnVuY3Rpb25hbF9pbnB1dCBuYW1lPVwiJyArIGlucHV0ICsgJ1wiPicgKyBpbnB1dHNbaW5wdXRdICsgJzwvZnVuY3Rpb25hbF9pbnB1dD4nO1xuICB9XG5cbiAgc3RyICs9ICc8L2Jsb2NrPic7XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgeG1sIGZvciBhIGZ1bmN0aW9uYWwgZGVmaW50aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBvdXRwdXRUeXBlIEZ1bmN0aW9uJ3Mgb3V0cHV0IHR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPltdfSBhcmdMaXN0IE5hbWUgYW5kIHR5cGUgZm9yIGVhY2ggYXJnXG4gKiBAcGFyYW0ge3N0cmluZ30gYmxvY2tYbWwgWG1sIGZvciB0aGUgYmxvY2tzIHRoYXQgYWN0dWFsbHkgZGVmaW5lIHRoZSBmdW5jdGlvblxuICovXG5leHBvcnRzLmZ1bmN0aW9uYWxEZWZpbml0aW9uWG1sID0gZnVuY3Rpb24gKG5hbWUsIG91dHB1dFR5cGUsIGFyZ0xpc3QsIGJsb2NrWG1sKSB7XG4gIHZhciBtdXRhdGlvbiA9ICc8bXV0YXRpb24+JztcbiAgYXJnTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChhcmdJbmZvKSB7XG4gICAgbXV0YXRpb24gKz0gJzxhcmcgbmFtZT1cIicgKyBhcmdJbmZvLm5hbWUgKyAnXCIgdHlwZT1cIicgKyBhcmdJbmZvLnR5cGUgKyAnXCI+PC9hcmc+JztcbiAgfSk7XG4gIG11dGF0aW9uICs9ICc8b3V0cHV0dHlwZT4nICsgb3V0cHV0VHlwZSArICc8L291dHB1dHR5cGU+PC9tdXRhdGlvbj4nO1xuXG4gIHJldHVybiAnPGJsb2NrIHR5cGU9XCJmdW5jdGlvbmFsX2RlZmluaXRpb25cIiBpbmxpbmU9XCJmYWxzZVwiPicrXG4gICAgICBtdXRhdGlvbiArXG4gICAgICAnPHRpdGxlIG5hbWU9XCJOQU1FXCI+JyArIG5hbWUgKyAnPC90aXRsZT4nICtcbiAgICAgJzxmdW5jdGlvbmFsX2lucHV0IG5hbWU9XCJTVEFDS1wiPicgKyBibG9ja1htbCArICc8L2Z1bmN0aW9uYWxfaW5wdXQ+JyArXG4gICAgJzwvYmxvY2s+Jztcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgeG1sIGZvciBhIGNhbGxpbmcgYSBmdW5jdGlvbmFsIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPltdfSBhcmdMaXN0IE5hbWUgYW5kIHR5cGUgZm9yIGVhY2ggYXJnXG4gKi9cbmV4cG9ydHMuZnVuY3Rpb25hbENhbGxYbWwgPSBmdW5jdGlvbiAobmFtZSwgYXJnTGlzdCwgaW5wdXRDb250ZW50cykge1xuICBpZiAoYXJnTGlzdC5sZW5ndGggIT09IGlucHV0Q29udGVudHMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IGRlZmluZSBjb250ZW50cyBmb3IgZWFjaCBhcmcnKTtcbiAgfVxuXG4gIHZhciBtdXRhdGlvbiA9ICc8bXV0YXRpb24gbmFtZT1cIicgKyBuYW1lICsgJ1wiPic7XG4gIGFyZ0xpc3QuZm9yRWFjaChmdW5jdGlvbiAoYXJnSW5mbykge1xuICAgIG11dGF0aW9uICs9ICc8YXJnIG5hbWU9XCInICsgYXJnSW5mby5uYW1lICsgJ1wiIHR5cGU9XCInICsgYXJnSW5mby50eXBlICsgJ1wiPjwvYXJnPic7XG4gIH0pO1xuICBtdXRhdGlvbiArPSAnPC9tdXRhdGlvbj4nO1xuXG4gIHZhciBjb250ZW50cyA9ICcnO1xuICBpbnB1dENvbnRlbnRzLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrWG1sLCBpbmRleCkge1xuICAgIGNvbnRlbnRzICs9ICc8ZnVuY3Rpb25hbF9pbnB1dCBuYW1lPVwiQVJHJyArIGluZGV4ICsgJ1wiPicgKyBibG9ja1htbCArICc8L2Z1bmN0aW9uYWxfaW5wdXQ+JztcbiAgfSk7XG5cbiAgcmV0dXJuICc8YmxvY2sgdHlwZT1cImZ1bmN0aW9uYWxfY2FsbFwiPicgK1xuICAgICAgbXV0YXRpb24gK1xuICAgICAgY29udGVudHMgK1xuICAgICc8L2Jsb2NrPic7XG59O1xuIiwidmFyIERyb3BsZXRGdW5jdGlvblRvb2x0aXAgPSByZXF1aXJlKCcuL0Ryb3BsZXRGdW5jdGlvblRvb2x0aXAnKTtcbnZhciBEcm9wbGV0QmxvY2tUb29sdGlwTWFuYWdlciA9IHJlcXVpcmUoJy4vRHJvcGxldEJsb2NrVG9vbHRpcE1hbmFnZXInKTtcbnZhciBEcm9wbGV0QXV0b2NvbXBsZXRlUG9wdXBUb29sdGlwTWFuYWdlciA9IHJlcXVpcmUoJy4vRHJvcGxldEF1dG9jb21wbGV0ZVBvcHVwVG9vbHRpcE1hbmFnZXInKTtcbnZhciBEcm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXIgPSByZXF1aXJlKCcuL0Ryb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlcicpO1xudmFyIGRyb3BsZXRVdGlscyA9IHJlcXVpcmUoJy4uL2Ryb3BsZXRVdGlscycpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWFuYWdlcyBhIHN0b3JlIG9mIGtub3duIGJsb2NrcyBhbmQgdG9vbHRpcHNcbiAqL1xuXG4vKipcbiAqIFN0b3JlIGZvciBmaW5kaW5nIHRvb2x0aXBzIGZvciBibG9ja3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBEcm9wbGV0VG9vbHRpcE1hbmFnZXIoYXBwTXNnLCBkcm9wbGV0Q29uZmlnLCBjb2RlRnVuY3Rpb25zLCBhdXRvY29tcGxldGVQYWxldHRlQXBpc09ubHkpIHtcbiAgLyoqXG4gICAqIEFwcC1zcGVjaWZpYyBzdHJpbmdzICh0byBvdmVycmlkZSBjb21tb24gbXNnKVxuICAgKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmcsIEZ1bmN0aW9uPn1cbiAgICovXG4gIHRoaXMuYXBwTXNnID0gYXBwTXNnIHx8IHt9O1xuICB0aGlzLnRvb2x0aXBzRW5hYmxlZCA9IHRydWU7XG5cbiAgLyoqXG4gICAqIERyb3BsZXQgY29uZmlnIGZvciB0aGlzIGFwcFxuICAgKi9cbiAgdGhpcy5kcm9wbGV0Q29uZmlnID0gZHJvcGxldENvbmZpZyB8fCB7fTtcblxuICAvKipcbiAgICogQ29kZSBmdW5jdGlvbnNcbiAgICogQHR5cGUge09iamVjdC48U3RyaW5nPn0gb3B0aW9uYWwgb2JqZWN0IHdpdGgga2V5cyB0byBtb2RpZnkgdGhlIGJsb2Nrc1xuICAgKi9cbiAgdGhpcy5jb2RlRnVuY3Rpb25zID0gY29kZUZ1bmN0aW9ucztcblxuICAvKipcbiAgICogRmxhZyB0byBsaW1pdCB0aGUgbnVtYmVyIG9mIEFQSXMgdGhhdCBzZWUgYXV0b2NvbXBsZXRlIGJlaGF2aW9yXG4gICAqL1xuICB0aGlzLmF1dG9jb21wbGV0ZVBhbGV0dGVBcGlzT25seSA9IGF1dG9jb21wbGV0ZVBhbGV0dGVBcGlzT25seTtcblxuICAvKipcbiAgICogTWFwIG9mIGJsb2NrIHR5cGVzIHRvIHRvb2x0aXAgb2JqZWN0c1xuICAgKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmcsIERyb3BsZXRGdW5jdGlvblRvb2x0aXA+fVxuICAgKi9cbiAgdGhpcy5ibG9ja1R5cGVUb1Rvb2x0aXBfID0ge307XG5cbiAgLyoqXG4gICAqIE1hcHMgZnVuYyBmcm9tIG9uZSBibG9jayB0eXBlIHRvIGFub3RoZXIsIHN1Y2ggdGhhdCB3ZSB1c2UgdGhlIHRhcmdldCBmb3JcbiAgICogZG9jdW1lbnRhdGlvbiBpbnN0ZWFkIG9mIHRoZSBzb3VyY2VcbiAgICogQHR5cGUge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fVxuICAgKi9cbiAgdGhpcy5kb2NGdW5jTWFwcGluZ18gPSB7fTtcblxuICAvKipcbiAgICogQHR5cGUge0Ryb3BsZXRCbG9ja1Rvb2x0aXBNYW5hZ2VyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5kcm9wbGV0QmxvY2tUb29sdGlwTWFuYWdlcl8gPSBuZXcgRHJvcGxldEJsb2NrVG9vbHRpcE1hbmFnZXIodGhpcyk7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtEcm9wbGV0QXV0b2NvbXBsZXRlUG9wdXBUb29sdGlwTWFuYWdlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuZHJvcGxldEF1dG9jb21wbGV0ZVBvcHVwVG9vbHRpcE1hbmFnZXJfID0gbmV3IERyb3BsZXRBdXRvY29tcGxldGVQb3B1cFRvb2x0aXBNYW5hZ2VyKHRoaXMpO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7RHJvcGxldEF1dG9jb21wbGV0ZVBvcHVwVG9vbHRpcE1hbmFnZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmRyb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlcl8gPSBuZXcgRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyKHRoaXMpO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBoYW5kbGVycyBmb3IgZHJvcGxldCBibG9jayB0b29sdGlwcy5cbiAqIEBwYXJhbSBkcm9wbGV0RWRpdG9yXG4gKi9cbkRyb3BsZXRUb29sdGlwTWFuYWdlci5wcm90b3R5cGUucmVnaXN0ZXJEcm9wbGV0QmxvY2tNb2RlSGFuZGxlcnMgPSBmdW5jdGlvbiAoZHJvcGxldEVkaXRvcikge1xuICB0aGlzLmRyb3BsZXRCbG9ja1Rvb2x0aXBNYW5hZ2VyXy5pbnN0YWxsVG9vbHRpcHNGb3JFZGl0b3JfKGRyb3BsZXRFZGl0b3IpO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgaGFuZGxlcnMgZm9yIEFDRSBtb2RlIHRvb2x0aXBzXG4gKiBAcGFyYW0gZHJvcGxldEVkaXRvclxuICovXG5Ecm9wbGV0VG9vbHRpcE1hbmFnZXIucHJvdG90eXBlLnJlZ2lzdGVyRHJvcGxldFRleHRNb2RlSGFuZGxlcnMgPSBmdW5jdGlvbiAoZHJvcGxldEVkaXRvcikge1xuICB0aGlzLmRyb3BsZXRBdXRvY29tcGxldGVQb3B1cFRvb2x0aXBNYW5hZ2VyXy5pbnN0YWxsVG9vbHRpcHNGb3JFZGl0b3JfKGRyb3BsZXRFZGl0b3IpO1xuICB0aGlzLmRyb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlcl8uaW5zdGFsbFRvb2x0aXBzRm9yRWRpdG9yXyhkcm9wbGV0RWRpdG9yKTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGJsb2NrIHRvb2x0aXBzIGZvciBibG9ja3MgYmFzZWQgb24gdGhlIGRyb3BsZXRCbG9ja3MgYW5kXG4gKiBjb2RlRnVuY3Rpb25zIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3JcbiAqL1xuRHJvcGxldFRvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS5yZWdpc3RlckJsb2NrcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJsb2NrcyA9IGRyb3BsZXRVdGlscy5nZXRBbGxBdmFpbGFibGVEcm9wbGV0QmxvY2tzKFxuICAgIHRoaXMuZHJvcGxldENvbmZpZyxcbiAgICB0aGlzLmNvZGVGdW5jdGlvbnMsXG4gICAgdGhpcy5hdXRvY29tcGxldGVQYWxldHRlQXBpc09ubHkpO1xuICBibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoZHJvcGxldEJsb2NrRGVmaW5pdGlvbikge1xuICAgIHZhciBrZXkgPSBkcm9wbGV0QmxvY2tEZWZpbml0aW9uLm1vZGVPcHRpb25OYW1lIHx8IGRyb3BsZXRCbG9ja0RlZmluaXRpb24uZnVuYztcbiAgICBpZiAoZHJvcGxldEJsb2NrRGVmaW5pdGlvbi5kb2NGdW5jKSB7XG4gICAgICAvLyBJZiBhIGRvY0Z1bmMgd2FzIHNwZWNpZmllZCwgdXBkYXRlIG91ciBtYXBwaW5nXG4gICAgICB0aGlzLmRvY0Z1bmNNYXBwaW5nX1trZXldID0gZHJvcGxldEJsb2NrRGVmaW5pdGlvbi5kb2NGdW5jO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJsb2NrVHlwZVRvVG9vbHRpcF9ba2V5XSA9XG4gICAgICAgIG5ldyBEcm9wbGV0RnVuY3Rpb25Ub29sdGlwKHRoaXMuYXBwTXNnLCBkcm9wbGV0QmxvY2tEZWZpbml0aW9uKTtcbiAgICB9XG4gIH0sIHRoaXMpO1xufTtcblxuRHJvcGxldFRvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS5nZXREb2NGb3IgPSBmdW5jdGlvbiAoZnVuY3Rpb25OYW1lKSB7XG4gIHZhciBkb2NGdW5jTmFtZSA9IHRoaXMuZG9jRnVuY01hcHBpbmdfW2Z1bmN0aW9uTmFtZV0gfHwgZnVuY3Rpb25OYW1lO1xuICByZXR1cm4gdGhpcy5ibG9ja1R5cGVUb1Rvb2x0aXBfW2RvY0Z1bmNOYW1lXTtcbn07XG5cbkRyb3BsZXRUb29sdGlwTWFuYWdlci5wcm90b3R5cGUuc2hvd0RvY0ZvciA9IGZ1bmN0aW9uIChmdW5jdGlvbk5hbWUpIHtcbiAgaWYgKCF0aGlzLnRvb2x0aXBzRW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICAkKCcudG9vbHRpcHN0ZXJlZCcpLnRvb2x0aXBzdGVyKCdoaWRlJyk7XG4gIHZhciBkaWFsb2cgPSBuZXcgd2luZG93LkRpYWxvZyh7XG4gICAgYm9keTogJCgnPGlmcmFtZT4nKVxuICAgICAgLmFkZENsYXNzKCdtYXJrZG93bi1pbnN0cnVjdGlvbnMtY29udGFpbmVyJylcbiAgICAgIC53aWR0aCgnMTAwJScpXG4gICAgICAuYXR0cignc3JjJywgdGhpcy5nZXREcm9wbGV0VG9vbHRpcChmdW5jdGlvbk5hbWUpLmdldEZ1bGxEb2N1bWVudGF0aW9uVVJMKCkpLFxuICAgIGF1dG9SZXNpemVTY3JvbGxhYmxlRWxlbWVudDogJy5tYXJrZG93bi1pbnN0cnVjdGlvbnMtY29udGFpbmVyJyxcbiAgICBpZDogJ2Jsb2NrLWRvY3VtZW50YXRpb24tbGlnaHRib3gnXG4gIH0pO1xuICBkaWFsb2cuc2hvdygpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gZnVuY3Rpb25OYW1lXG4gKiBAcmV0dXJucyB7RHJvcGxldEZ1bmN0aW9uVG9vbHRpcH1cbiAqL1xuRHJvcGxldFRvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS5nZXREcm9wbGV0VG9vbHRpcCA9IGZ1bmN0aW9uIChmdW5jdGlvbk5hbWUpIHtcbiAgdmFyIHRvb2x0aXAgPSB0aGlzLmdldERvY0ZvcihmdW5jdGlvbk5hbWUpO1xuICBpZiAoIXRvb2x0aXApIHtcbiAgICB0aHJvdyBcIkZ1bmN0aW9uIG5hbWUgXCIgKyBmdW5jdGlvbk5hbWUgKyBcIiBub3QgcmVnaXN0ZXJlZCBpbiBkb2N1bWVudGF0aW9uIG1hbmFnZXIuXCI7XG4gIH1cblxuICByZXR1cm4gdG9vbHRpcDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkIGlmIHRvb2x0aXBzIHNob3VsZCBiZSBlbmFibGVkLlxuICovXG5Ecm9wbGV0VG9vbHRpcE1hbmFnZXIucHJvdG90eXBlLnNldFRvb2x0aXBzRW5hYmxlZCA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gIHRoaXMudG9vbHRpcHNFbmFibGVkID0gISFlbmFibGVkO1xuICB0aGlzLmRyb3BsZXRBdXRvY29tcGxldGVQb3B1cFRvb2x0aXBNYW5hZ2VyXy5zZXRUb29sdGlwc0VuYWJsZWQoZW5hYmxlZCk7XG4gIHRoaXMuZHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyXy5zZXRUb29sdGlwc0VuYWJsZWQoZW5hYmxlZCk7XG4gIHRoaXMuZHJvcGxldEJsb2NrVG9vbHRpcE1hbmFnZXJfLnNldFRvb2x0aXBzRW5hYmxlZChlbmFibGVkKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRHJvcGxldFRvb2x0aXBNYW5hZ2VyO1xuIiwidmFyIERyb3BsZXRGdW5jdGlvblRvb2x0aXAgPSByZXF1aXJlKCcuL0Ryb3BsZXRGdW5jdGlvblRvb2x0aXAnKTtcbnZhciBEcm9wbGV0RnVuY3Rpb25Ub29sdGlwTWFya3VwID0gcmVxdWlyZSgnLi9Ecm9wbGV0RnVuY3Rpb25Ub29sdGlwLmh0bWwuZWpzJyk7XG52YXIgZG9tID0gcmVxdWlyZSgnLi4vZG9tJyk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXNwbGF5cyB0b29sdGlwcyBmb3IgRHJvcGxldCBibG9ja3NcbiAqL1xuXG4vKipcbiAqIEhhbmRsZXMgZGlzcGxheWluZyB0b29sdGlwcyBvbiBEcm9wbGV0IGJsb2Nrc1xuICogQHBhcmFtIHtEcm9wbGV0VG9vbHRpcE1hbmFnZXJ9IGRyb3BsZXRUb29sdGlwTWFuYWdlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEcm9wbGV0QmxvY2tUb29sdGlwTWFuYWdlciA9IGZ1bmN0aW9uIChkcm9wbGV0VG9vbHRpcE1hbmFnZXIpIHtcbiAgdGhpcy5kcm9wbGV0VG9vbHRpcE1hbmFnZXIgPSBkcm9wbGV0VG9vbHRpcE1hbmFnZXI7XG4gIHRoaXMuc2hvd0V4YW1wbGVzTGluayA9IGRyb3BsZXRUb29sdGlwTWFuYWdlci5kcm9wbGV0Q29uZmlnLnNob3dFeGFtcGxlc0xpbms7XG4gIHRoaXMudG9vbHRpcHNFbmFibGVkID0gdHJ1ZTtcbn07XG5cbnZhciBERUZBVUxUX1RPT0xUSVBfQ09ORklHID0ge1xuICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgc3BlZWQ6IDE1MCxcbiAgbWF4V2lkdGg6IDQ1MCxcbiAgcG9zaXRpb246ICdyaWdodCcsXG4gIGNvbnRlbnRBc0hUTUw6IHRydWUsXG4gIHRoZW1lOiAnZHJvcGxldC1ibG9jay10b29sdGlwc3RlcicsXG4gIG9mZnNldFk6IDIsXG4gIGRlbGF5OiA0MDBcbn07XG5cbi8qKlxuICogU2ltcGxlIGhlbHBlciBmdW5jdGlvbiB0aGF0IHdpbGwgc3dhbGxvdyBleGNlcHRpb25zLCBhbmQgbG9nIHRoZW0gYXNcbiAqIGNvbnNvbGUuZXJyb3IuIFRoaXMgaXMgZG9uZSBiZWNhdXNlIHRoZSB3YXkgdGhhdCBzb21lIG9mIG91ciBjYWxsYmFja3MgYXJlXG4gKiBjYWxsZWQgYnkgZHJvcGxldCwgZXhjZXB0aW9ucyB3b3VsZCBidWJibGUgZG93biB0byB0aGUgZHJvcGxldCBjb2RlLCBhbmRcbiAqIHByZXZlbnQgZGVzaXJlZCBiZWhhdmlvciAoaS5lLiB3ZSBmYWlsIHRvIHRyYW5zaXRpb24gYmFjayB0byBibG9jayBtb2RlKS5cbiAqL1xuZnVuY3Rpb24gc3dhbGxvd0Vycm9ycyhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICBmbigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHR5cGVvZihjb25zb2xlKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZGl0b3J9IGRyb3BsZXRFZGl0b3JcbiAqL1xuRHJvcGxldEJsb2NrVG9vbHRpcE1hbmFnZXIucHJvdG90eXBlLmluc3RhbGxUb29sdGlwc0ZvckVkaXRvcl8gPSBmdW5jdGlvbiAoZHJvcGxldEVkaXRvcikge1xuICB0aGlzLmluc3RhbGxUb29sdGlwc0ZvckN1cnJlbnRDYXRlZ29yeUJsb2Nrc18oKTtcbiAgdGhpcy5oaWRlVG9vbHRpcHNPbkJsb2NrUGlja18oZHJvcGxldEVkaXRvcik7XG5cbiAgZHJvcGxldEVkaXRvci5vbignY2hhbmdlcGFsZXR0ZScsXG4gICAgc3dhbGxvd0Vycm9ycyh0aGlzLmluc3RhbGxUb29sdGlwc0ZvckN1cnJlbnRDYXRlZ29yeUJsb2Nrc18uYmluZCh0aGlzKSkpO1xuICBkcm9wbGV0RWRpdG9yLm9uKCd0b2dnbGVkb25lJyxcbiAgICBzd2FsbG93RXJyb3JzKHRoaXMuaW5zdGFsbFRvb2x0aXBzSWZOb3RJbnN0YWxsZWRfLmJpbmQodGhpcykpKTtcbn07XG5cbkRyb3BsZXRCbG9ja1Rvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS5pbnN0YWxsVG9vbHRpcHNJZk5vdEluc3RhbGxlZF8gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghJCgnLmRyb3BsZXQtaG92ZXItZGl2JykuaGFzQ2xhc3MoJ3Rvb2x0aXBzdGVyZWQnKSkge1xuICAgIHRoaXMuaW5zdGFsbFRvb2x0aXBzRm9yQ3VycmVudENhdGVnb3J5QmxvY2tzXygpO1xuICB9XG59O1xuXG5Ecm9wbGV0QmxvY2tUb29sdGlwTWFuYWdlci5wcm90b3R5cGUuaW5zdGFsbFRvb2x0aXBzRm9yQ3VycmVudENhdGVnb3J5QmxvY2tzXyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnRvb2x0aXBzRW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gICQoJy5kcm9wbGV0LWhvdmVyLWRpdicpLmVhY2goZnVuY3Rpb24gKF8sIGJsb2NrSG92ZXJEaXYpIHtcbiAgICBpZiAoJChibG9ja0hvdmVyRGl2KS5oYXNDbGFzcygndG9vbHRpcHN0ZXJlZCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZ1bmNOYW1lID0gJChibG9ja0hvdmVyRGl2KS5hdHRyKCd0aXRsZScpO1xuXG4gICAgdmFyIGhvdmVyRGl2V2lkdGggPSAkKGJsb2NrSG92ZXJEaXYpLndpZHRoKCk7XG4gICAgdmFyIGhvdmVyRGl2TGVmdFRvVG9vbGJveFJpZ2h0ID0gJCgnLmRyb3BsZXQtcGFsZXR0ZS1jYW52YXMnKS53aWR0aCgpIC1cbiAgICAgIHBhcnNlSW50KGJsb2NrSG92ZXJEaXYuc3R5bGUubGVmdCwgMTApO1xuICAgIHZhciBkZXNpcmVkWFBvc2l0aW9uID0gTWF0aC5taW4oaG92ZXJEaXZXaWR0aCwgaG92ZXJEaXZMZWZ0VG9Ub29sYm94UmlnaHQpO1xuICAgIHZhciB0b29sdGlwT2Zmc2V0WCA9IGRlc2lyZWRYUG9zaXRpb24gLSBob3ZlckRpdldpZHRoO1xuXG4gICAgdmFyIGNvbmZpZ3VyYXRpb24gPSAkLmV4dGVuZCh7fSwgREVGQVVMVF9UT09MVElQX0NPTkZJRywge1xuICAgICAgY29udGVudDogdGhpcy5nZXRUb29sdGlwSFRNTChmdW5jTmFtZSksXG4gICAgICBvZmZzZXRYOiB0b29sdGlwT2Zmc2V0WCxcbiAgICAgIGZ1bmN0aW9uUmVhZHk6IGZ1bmN0aW9uIChfLCBjb250ZW50cykge1xuICAgICAgICBpZiAoIXRoaXMuc2hvd0V4YW1wbGVzTGluaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VlRXhhbXBsZXNMaW5rID0gY29udGVudHMuZmluZCgnLnRvb2x0aXAtZXhhbXBsZS1saW5rID4gYScpWzBdO1xuICAgICAgICAvLyBJbXBvcnRhbnQgdGhpcyBiaW5kcyB0byBtb3VzZURvd24vdG91Y2hEb3duIHJhdGhlciB0aGFuIGNsaWNrLCBuZWVkcyB0b1xuICAgICAgICAvLyBoYXBwZW4gYmVmb3JlIGBibHVyYCB3aGljaCB0cmlnZ2VycyB0aGUgYWNlIGVkaXRvciBjb21wbGV0ZXIgcG9wdXBcbiAgICAgICAgLy8gaGlkZSB3aGljaCBpbiB0dXJuIHdvdWxkIGhpZGUgdGhlIGxpbmsgYW5kIG5vdCBzaG93IHRoZSBkb2NzLlxuICAgICAgICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KHNlZUV4YW1wbGVzTGluaywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgdGhpcy5kcm9wbGV0VG9vbHRpcE1hbmFnZXIuc2hvd0RvY0ZvcihmdW5jTmFtZSk7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB9LmJpbmQodGhpcylcbiAgICB9KTtcblxuICAgIC8vIFN0b3JlIHRoZSB0aXRsZS9mdW5jTmFtZSBhcyBhIGJsb2NrIGlkIHNvIHdlIGNhbiBhdHRhY2ggY2FsbG91dHMgbGF0ZXI6XG4gICAgJChibG9ja0hvdmVyRGl2KS5hdHRyKCdpZCcsICdkcm9wbGV0X3BhbGV0dGVfYmxvY2tfJyArIGZ1bmNOYW1lKTtcbiAgICAkKGJsb2NrSG92ZXJEaXYpLnRvb2x0aXBzdGVyKGNvbmZpZ3VyYXRpb24pO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBUb29sdGlwc3RlcidzIGhpZGVPbkNsaWNrIHNldHRpbmcgZG9lcyBub3Qgd29yayB3aXRoIHRoZSBkcm9wbGV0IGhvdmVyXG4gKiBvdmVybGF5IGFzLWlzLiBIaWRlIHRoZSB0b29sdGlwIG9uIGJsb2NrIHBpY2tpbmcgZXhwbGljaXRseS5cbiAqL1xuRHJvcGxldEJsb2NrVG9vbHRpcE1hbmFnZXIucHJvdG90eXBlLmhpZGVUb29sdGlwc09uQmxvY2tQaWNrXyA9IGZ1bmN0aW9uIChkcm9wbGV0RWRpdG9yKSB7XG4gIGRyb3BsZXRFZGl0b3Iub24oJ3BpY2tibG9jaycsIGZ1bmN0aW9uICgpIHtcbiAgICAkKCcudG9vbHRpcHN0ZXJlZCcpLnRvb2x0aXBzdGVyKCdoaWRlJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBIVE1MIGZvciB0b29sdGlwXG4gKi9cbkRyb3BsZXRCbG9ja1Rvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS5nZXRUb29sdGlwSFRNTCA9IGZ1bmN0aW9uIChmdW5jdGlvbk5hbWUpIHtcbiAgdmFyIHRvb2x0aXBJbmZvID0gdGhpcy5kcm9wbGV0VG9vbHRpcE1hbmFnZXIuZ2V0RHJvcGxldFRvb2x0aXAoZnVuY3Rpb25OYW1lKTtcbiAgcmV0dXJuIERyb3BsZXRGdW5jdGlvblRvb2x0aXBNYXJrdXAoe1xuICAgIGZ1bmN0aW9uTmFtZTogdG9vbHRpcEluZm8uZnVuY3Rpb25OYW1lLFxuICAgIGlzUHJvcGVydHk6IHRvb2x0aXBJbmZvLmlzUHJvcGVydHksXG4gICAgdGlwUHJlZml4OiB0b29sdGlwSW5mby50aXBQcmVmaXgsXG4gICAgZnVuY3Rpb25TaG9ydERlc2NyaXB0aW9uOiB0b29sdGlwSW5mby5kZXNjcmlwdGlvbixcbiAgICBwYXJhbWV0ZXJzOiB0b29sdGlwSW5mby5wYXJhbWV0ZXJJbmZvcyxcbiAgICBzaWduYXR1cmVPdmVycmlkZTogdG9vbHRpcEluZm8uc2lnbmF0dXJlT3ZlcnJpZGUsXG4gICAgc2hvd0V4YW1wbGVzTGluazogdGhpcy5zaG93RXhhbXBsZXNMaW5rXG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgaWYgdG9vbHRpcHMgc2hvdWxkIGJlIGVuYWJsZWRcbiAqL1xuXG5Ecm9wbGV0QmxvY2tUb29sdGlwTWFuYWdlci5wcm90b3R5cGUuc2V0VG9vbHRpcHNFbmFibGVkID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgdGhpcy50b29sdGlwc0VuYWJsZWQgPSAhIWVuYWJsZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyb3BsZXRCbG9ja1Rvb2x0aXBNYW5hZ2VyO1xuIiwidmFyIG1zZyA9IHJlcXVpcmUoJy4uL2xvY2FsZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJlcHJlc2VudGF0aW9uIG9mIGEgZHJvcGxldCBmdW5jdGlvbi9ibG9jaydzIHRvb2x0aXBcbiAqL1xuXG52YXIgRFJPUExFVF9CTE9DS19JMThOX1BSRUZJWCA9IFwiZHJvcGxldEJsb2NrX1wiO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHBhcmFtZXRlckluZm9cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBuYW1lXG4gKiBAcHJvcGVydHkgez9TdHJpbmd9IGRlc2NyaXB0aW9uXG4gKi9cblxuLyoqXG4gKiBTdG9yZXMgYSBibG9jaydzIHRvb2x0aXAgaW5mb3JtYXRpb24gYW5kIGhlbHBzIHJlbmRlciBpdFxuICogR3JhYnMgbXVjaCBvZiB0aGUgdG9vbHRpcCdzIGluZm9ybWF0aW9uIGZyb20gZWl0aGVyIGFwcC1zcGVjaWZpYyBsb2NhbGVcbiAqIGZpbGUgKHBhc3NlZCBpbiBhcyBhcHBNc2cpIG9yLCBpZiBub3QgcHJlc2VudCwgdGhlICdjb21tb24nIGxvY2FsZSBmaWxlLFxuICogKGFwcHMvaTE4bi9jb21tb24vZW5fdXMuanNvbiksIGtleWVkIGJ5IHRoZSBmdW5jdGlvbiBuYW1lLlxuICpcbiAqIGUuZy4sXG4gKlxuICogXCJkcm9wbGV0QmxvY2tfcmVhZFJlY29yZHNfZGVzY3JpcHRpb25cIjogXCJSZWFkcyByZWNvcmRzIFsuLi5dLlwiLFxuICogXCJkcm9wbGV0QmxvY2tfcmVhZFJlY29yZHNfcGFyYW0wXCI6IFwidGFibGVcIixcbiAqIFwiZHJvcGxldEJsb2NrX3JlYWRSZWNvcmRzX3BhcmFtMVwiOiBcInNlYXJjaFBhcmFtc1wiLFxuICogXCJkcm9wbGV0QmxvY2tfcmVhZFJlY29yZHNfcGFyYW0yXCI6IFwib25TdWNjZXNzXCIsXG4gKlxuICogV2lsbCByZXN1bHQgaW4gYSB0b29sdGlwIHdpdGggdGhlIGNvbnRlbnRzOlxuICpcbiAqICAgIHJlYWRSZWNvcmRzKHRhYmxlLCBzZWFyY2hQYXJhbXMsIG9uU3VjY2VzcylcbiAqICAgIFJlYWRzIHJlY29yZHMgWy4uLl0uXG4gKiAgICBbUmVhZCBNb3JlXSAobGlua3MgdG8gYHJlYWRSZWNvcmRzYCBkb2MgZmlsZSlcbiAqXG4gKiBCbG9ja3Mgd2hpY2ggaGF2ZSBmdW5jdGlvbk5hbWVzIHRoYXQgc2hvdWxkIG5vdCBiZSB1c2VyLXZpc2libGUgY2FuIGRlZmluZVxuICogdGhlaXIgb3duIHNpZ25hdHVyZSBvdmVycmlkZS5cbiAqXG4gKiBlLmcuLFxuICpcbiAqIFwiZHJvcGxldEJsb2NrX2Z1bmN0aW9uUGFyYW1zX25fZGVzY3JpcHRpb25cIjogXCJEZWZpbmUgYSBmdW5jdGlvbiB3aXRoIGEgZ2l2ZW4gcGFyYW1ldGVyXCIsXG4gKiBcImRyb3BsZXRCbG9ja19mdW5jdGlvblBhcmFtc19uX3NpZ25hdHVyZU92ZXJyaWRlXCI6IFwiRnVuY3Rpb24gd2l0aCBhIFBhcmFtZXRlclwiLFxuICpcbiAqIFdpbGwgcmVzdWx0IGluIGEgdG9vbHRpcCB3aXRoIHRoZSBjb250ZW50czpcbiAqXG4gKiAgICBGdW5jdGlvbiB3aXRoIGEgUGFyYW1ldGVyIDwtLSBub3RlLCBubyAoKXNcbiAqICAgIERlZmluZSBhIGZ1bmN0aW9uIHdpdGggYSBnaXZlbiBwYXJhbWV0ZXIuXG4gKiAgICBbUmVhZCBNb3JlXSAobGlua3MgdG8gYGZ1bmN0aW9uUGFyYW1zX25gIGRvYyBmaWxlKVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRHJvcGxldEZ1bmN0aW9uVG9vbHRpcCA9IGZ1bmN0aW9uIChhcHBNc2csIGRlZmluaXRpb24pIHtcbiAgdGhpcy5hcHBNc2cgPSBhcHBNc2c7XG5cbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gIHRoaXMuZnVuY3Rpb25OYW1lID0gZGVmaW5pdGlvbi5mdW5jO1xuXG4gIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgdGhpcy5pc1Byb3BlcnR5ID0gZGVmaW5pdGlvbi50eXBlID09PSAncHJvcGVydHknO1xuXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICB0aGlzLnRpcFByZWZpeCA9IGRlZmluaXRpb24udGlwUHJlZml4O1xuXG4gIHZhciBkZXNjcmlwdGlvbiA9IHRoaXMuZ2V0TG9jYWxpemF0aW9uKHRoaXMuZGVzY3JpcHRpb25LZXkoKSk7XG4gIGlmIChkZXNjcmlwdGlvbikge1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbigpO1xuICB9XG5cbiAgdmFyIHNpZ25hdHVyZU92ZXJyaWRlID0gdGhpcy5nZXRMb2NhbGl6YXRpb24odGhpcy5zaWduYXR1cmVPdmVycmlkZUtleSgpKTtcbiAgaWYgKHNpZ25hdHVyZU92ZXJyaWRlKSB7XG4gICAgdGhpcy5zaWduYXR1cmVPdmVycmlkZSA9IHNpZ25hdHVyZU92ZXJyaWRlKCk7XG4gIH1cblxuICAvKiogQHR5cGUge0FycmF5LjxwYXJhbWV0ZXJJbmZvPn0gKi9cbiAgdGhpcy5wYXJhbWV0ZXJJbmZvcyA9IFtdO1xuXG4gIGZvciAodmFyIHBhcmFtSWQgPSAwOyA7IHBhcmFtSWQrKykge1xuICAgIHZhciBwYXJhbUluZm8gPSB7fTtcbiAgICAvKlxuICAgICAqIFBhcmFtZXRlciBuYW1lcyBjYW4gYmUgc3BlY2lmaWVkIGluIHRoZSBsb2NhbGl6YXRpb24gZmlsZSBpZiBkZXNpcmVkLFxuICAgICAqIGJ1dCB3aWxsIGFsc28gYmUgcHVsbGVkIGZyb20gdGhlIGJsb2NrIGRlZmluaXRpb24ncyBwYWxldHRlUGFyYW1zIGFycmF5LlxuICAgICAqL1xuICAgIHZhciBwYXJhbU5hbWUgPSB0aGlzLmdldExvY2FsaXphdGlvbih0aGlzLnBhcmFtZXRlck5hbWVLZXkocGFyYW1JZCkpO1xuICAgIGlmIChwYXJhbU5hbWUpIHtcbiAgICAgIHBhcmFtSW5mby5uYW1lID0gcGFyYW1OYW1lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmFtSW5mby5uYW1lID0gZGVmaW5pdGlvbi5wYWxldHRlUGFyYW1zICYmIGRlZmluaXRpb24ucGFsZXR0ZVBhcmFtc1twYXJhbUlkXTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbUluZm8ubmFtZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHBhcmFtRGVzYyA9IHRoaXMuZ2V0TG9jYWxpemF0aW9uKHRoaXMucGFyYW1ldGVyRGVzY3JpcHRpb25LZXkocGFyYW1JZCkpO1xuICAgIGlmIChwYXJhbURlc2MpIHtcbiAgICAgIHBhcmFtSW5mby5kZXNjcmlwdGlvbiA9IHBhcmFtRGVzYygpO1xuICAgIH1cbiAgICBpZiAoZGVmaW5pdGlvbi5hc3NldFRvb2x0aXApIHtcbiAgICAgIHBhcmFtSW5mby5hc3NldFRvb2x0aXAgPSBkZWZpbml0aW9uLmFzc2V0VG9vbHRpcFtwYXJhbUlkXTtcbiAgICB9XG4gICAgdGhpcy5wYXJhbWV0ZXJJbmZvcy5wdXNoKHBhcmFtSW5mbyk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5Ecm9wbGV0RnVuY3Rpb25Ub29sdGlwLnByb3RvdHlwZS5nZXRMb2NhbGl6YXRpb24gPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiB0aGlzLmFwcE1zZ1trZXldIHx8IG1zZ1trZXldO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5Ecm9wbGV0RnVuY3Rpb25Ub29sdGlwLnByb3RvdHlwZS5kZXNjcmlwdGlvbktleSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaTE4blByZWZpeCgpICsgXCJfZGVzY3JpcHRpb25cIjtcbn07XG5cbi8qKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuRHJvcGxldEZ1bmN0aW9uVG9vbHRpcC5wcm90b3R5cGUuc2lnbmF0dXJlT3ZlcnJpZGVLZXkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmkxOG5QcmVmaXgoKSArIFwiX3NpZ25hdHVyZU92ZXJyaWRlXCI7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbUluZGV4XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5Ecm9wbGV0RnVuY3Rpb25Ub29sdGlwLnByb3RvdHlwZS5wYXJhbWV0ZXJOYW1lS2V5ID0gZnVuY3Rpb24gKHBhcmFtSW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMuaTE4blByZWZpeCgpICsgXCJfcGFyYW1cIiArIHBhcmFtSW5kZXg7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbUluZGV4XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5Ecm9wbGV0RnVuY3Rpb25Ub29sdGlwLnByb3RvdHlwZS5wYXJhbWV0ZXJEZXNjcmlwdGlvbktleSA9IGZ1bmN0aW9uIChwYXJhbUluZGV4KSB7XG4gIHJldHVybiB0aGlzLmkxOG5QcmVmaXgoKSArIFwiX3BhcmFtXCIgKyBwYXJhbUluZGV4ICsgJ19kZXNjcmlwdGlvbic7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGkxOG4gZmlsZSBwcmVmaXggZm9yIHRoaXMgZnVuY3Rpb25cbiAqL1xuRHJvcGxldEZ1bmN0aW9uVG9vbHRpcC5wcm90b3R5cGUuaTE4blByZWZpeCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIERST1BMRVRfQkxPQ0tfSTE4Tl9QUkVGSVggKyB0aGlzLmZ1bmN0aW9uTmFtZTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge3N0cmluZ30gVVJMIGZvciBmdWxsIGRvYyBhYm91dCB0aGlzIGZ1bmN0aW9uXG4gKi9cbkRyb3BsZXRGdW5jdGlvblRvb2x0aXAucHJvdG90eXBlLmdldEZ1bGxEb2N1bWVudGF0aW9uVVJMID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJy8vJyArIHV0aWxzLmdldFBlZ2FzdXNIb3N0KCkgKyAnL2FwcGxhYi9kb2NzLycgKyB0aGlzLmZ1bmN0aW9uTmFtZSArICc/ZW1iZWRkZWQnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcm9wbGV0RnVuY3Rpb25Ub29sdGlwO1xuIiwidmFyIERyb3BsZXRGdW5jdGlvblRvb2x0aXBNYXJrdXAgPSByZXF1aXJlKCcuL0Ryb3BsZXRGdW5jdGlvblRvb2x0aXAuaHRtbC5lanMnKTtcbnZhciBkb20gPSByZXF1aXJlKCcuLi9kb20nKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpc3BsYXlzIHRvb2x0aXBzIGZvciBEcm9wbGV0IGJsb2Nrc1xuICovXG5cbi8qKlxuICogSGFuZGxlcyBkaXNwbGF5aW5nIHRvb2x0aXBzIG9uIERyb3BsZXQncyBBQ0UgZWRpdG9yIGF1dG9jb21wbGV0ZSBkcm9wZG93blxuICogQHBhcmFtIHtEcm9wbGV0VG9vbHRpcE1hbmFnZXJ9IGRyb3BsZXRUb29sdGlwTWFuYWdlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEcm9wbGV0QXV0b2NvbXBsZXRlUG9wdXBUb29sdGlwTWFuYWdlciA9IGZ1bmN0aW9uIChkcm9wbGV0VG9vbHRpcE1hbmFnZXIpIHtcbiAgdGhpcy5kcm9wbGV0VG9vbHRpcE1hbmFnZXIgPSBkcm9wbGV0VG9vbHRpcE1hbmFnZXI7XG4gIHRoaXMuc2hvd0V4YW1wbGVzTGluayA9IGRyb3BsZXRUb29sdGlwTWFuYWdlci5kcm9wbGV0Q29uZmlnLnNob3dFeGFtcGxlc0xpbms7XG4gIHRoaXMudG9vbHRpcHNFbmFibGVkID0gdHJ1ZTtcbn07XG5cbnZhciBERUZBVUxUX1RPT0xUSVBfQ09ORklHID0ge1xuICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgYXV0b0Nsb3NlOiBmYWxzZSxcbiAgdHJpZ2dlcjogJ2N1c3RvbScsXG4gIHNwZWVkOiAxMDAsXG4gIG1heFdpZHRoOiA0NTAsXG4gIHBvc2l0aW9uOiAnbGVmdCcsXG4gIGNvbnRlbnRBc0hUTUw6IHRydWUsXG4gIHRoZW1lOiAnZHJvcGxldC1ibG9jay10b29sdGlwc3RlcicsXG4gIG9mZnNldFk6IDIsXG4gIHJlc3RvcmF0aW9uOiAnbm9uZScsXG4gIHVwZGF0ZUFuaW1hdGlvbjogZmFsc2Vcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFZGl0b3J9IGRyb3BsZXRFZGl0b3JcbiAqL1xuRHJvcGxldEF1dG9jb21wbGV0ZVBvcHVwVG9vbHRpcE1hbmFnZXIucHJvdG90eXBlLmluc3RhbGxUb29sdGlwc0ZvckVkaXRvcl8gPSBmdW5jdGlvbiAoZHJvcGxldEVkaXRvcikge1xuICB2YXIgYWNlRWRpdG9yID0gZHJvcGxldEVkaXRvci5hY2VFZGl0b3I7XG5cbiAgdGhpcy5lZGl0b3JDaGFuZ2VkRXZlbnRIYW5kbGVyXyA9IHRoaXMuc2V0dXBPblBvcHVwU2hvd25fLmJpbmQodGhpcywgYWNlRWRpdG9yKTtcbiAgYWNlRWRpdG9yLmNvbW1hbmRzLm9uKFwiYWZ0ZXJFeGVjXCIsIHRoaXMuZWRpdG9yQ2hhbmdlZEV2ZW50SGFuZGxlcl8pO1xufTtcblxuLyoqXG4gKiBXaGVuIGFuIGF1dG9jb21wbGV0ZSBwb3B1cCBoYXMgYmVlbiBzaG93biB0aGUgZmlyc3QgdGltZSwgcmVnaXN0ZXIgZXZlbnRcbiAqIGhhbmRsZXJzIHRvIHNob3cgYW5kIGhpZGUgdG9vbHRpcHMgZHVyaW5nIGF1dG9jb21wbGV0ZSBwb3B1cCB1c2FnZS5cbiAqIEBwYXJhbSBhY2VFZGl0b3IgLSBhY2UgZWRpdG9yIGluc3RhbmNlXG4gKiBAcGFyYW0gY2hhbmdlRXZlbnQgLSBldmVudCBmcm9tIGFjZUVkaXRvci5jb21tYW5kcy5vbihcImFmdGVyRXhlY1wiKVxuICogQHByaXZhdGVcbiAqL1xuRHJvcGxldEF1dG9jb21wbGV0ZVBvcHVwVG9vbHRpcE1hbmFnZXIucHJvdG90eXBlLnNldHVwT25Qb3B1cFNob3duXyA9IGZ1bmN0aW9uIChhY2VFZGl0b3IsIGNoYW5nZUV2ZW50KSB7XG4gIGlmIChjaGFuZ2VFdmVudC5jb21tYW5kLm5hbWUgIT09ICdpbnNlcnRzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBvcHVwSGFzQmVlblNob3duT25jZSA9IGFjZUVkaXRvci5jb21wbGV0ZXIgJiYgYWNlRWRpdG9yLmNvbXBsZXRlci5wb3B1cDtcbiAgaWYgKCFwb3B1cEhhc0JlZW5TaG93bk9uY2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnNldHVwRm9yRWRpdG9yUG9wdXBfKGFjZUVkaXRvcik7XG5cbiAgYWNlRWRpdG9yLmNvbW1hbmRzLnJlbW92ZUxpc3RlbmVyKFwiYWZ0ZXJFeGVjXCIsIHRoaXMuZWRpdG9yQ2hhbmdlZEV2ZW50SGFuZGxlcl8pO1xuICB0aGlzLmVkaXRvckNoYW5nZWRFdmVudEhhbmRsZXJfID0gbnVsbDtcbn07XG5cbkRyb3BsZXRBdXRvY29tcGxldGVQb3B1cFRvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS5zZXR1cEZvckVkaXRvclBvcHVwXyA9IGZ1bmN0aW9uIChhY2VFZGl0b3IpIHtcbiAgYWNlRWRpdG9yLmNvbXBsZXRlci5wb3B1cC5zZXRTZWxlY3RPbkhvdmVyKHRydWUpO1xuXG4gIGFjZUVkaXRvci5jb21wbGV0ZXIucG9wdXAucmVuZGVyZXIub24oXCJhZnRlclJlbmRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy51cGRhdGVBdXRvY29tcGxldGVQb3B1cFRvb2x0aXAoYWNlRWRpdG9yKTtcbiAgfS5iaW5kKHRoaXMpKTtcblxuICBhY2VFZGl0b3IuY29tcGxldGVyLnBvcHVwLm9uKFwiaGlkZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZXN0cm95QXV0b2NvbXBsZXRlVG9vbHRpcHNfKCk7XG4gIH0uYmluZCh0aGlzKSk7XG59O1xuXG5Ecm9wbGV0QXV0b2NvbXBsZXRlUG9wdXBUb29sdGlwTWFuYWdlci5wcm90b3R5cGUudXBkYXRlQXV0b2NvbXBsZXRlUG9wdXBUb29sdGlwID0gZnVuY3Rpb24gKGFjZUVkaXRvcikge1xuICBpZiAoIXRoaXMudG9vbHRpcHNFbmFibGVkIHx8ICFhY2VFZGl0b3IuY29tcGxldGVyLmNvbXBsZXRpb25zKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGtleWJvYXJkUm93ID0gYWNlRWRpdG9yLmNvbXBsZXRlci5wb3B1cC5nZXRSb3coKTtcblxuICBpZiAoa2V5Ym9hcmRSb3cgPCAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGZpbHRlcmVkQ29tcGxldGlvbnMgPSBhY2VFZGl0b3IuY29tcGxldGVyLmNvbXBsZXRpb25zLmZpbHRlcmVkO1xuICB2YXIgZnVuY05hbWUgPSBmaWx0ZXJlZENvbXBsZXRpb25zW2tleWJvYXJkUm93XS5kb2NGdW5jIHx8IGZpbHRlcmVkQ29tcGxldGlvbnNba2V5Ym9hcmRSb3ddLnZhbHVlO1xuXG4gIHRoaXMuZGVzdHJveUF1dG9jb21wbGV0ZVRvb2x0aXBzXygpO1xuXG4gIGlmICghdGhpcy5kcm9wbGV0VG9vbHRpcE1hbmFnZXIuZ2V0RG9jRm9yKGZ1bmNOYW1lKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuYXR0YWNoVG9vbHRpcEZvckZ1bmN0aW9uKGZ1bmNOYW1lKTtcbn07XG5cbkRyb3BsZXRBdXRvY29tcGxldGVQb3B1cFRvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS5hdHRhY2hUb29sdGlwRm9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuY05hbWUpIHtcbiAgdmFyIHRvb2x0aXBET00gPSB0aGlzLmdldFRvb2x0aXBIVE1MKGZ1bmNOYW1lKTtcbiAgdmFyIGNvbmZpZ3VyYXRpb24gPSAkLmV4dGVuZCh7fSwgREVGQVVMVF9UT09MVElQX0NPTkZJRywge1xuICAgIGNvbnRlbnQ6IHRvb2x0aXBET00sXG4gICAgZnVuY3Rpb25SZWFkeTogZnVuY3Rpb24gKF8sIGNvbnRlbnRzKSB7XG4gICAgICBpZiAoIXRoaXMuc2hvd0V4YW1wbGVzTGluaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc2VlRXhhbXBsZXNMaW5rID0gY29udGVudHMuZmluZCgnLnRvb2x0aXAtZXhhbXBsZS1saW5rID4gYScpWzBdO1xuICAgICAgLy8gSW1wb3J0YW50IHRoaXMgYmluZHMgdG8gbW91c2VEb3duL3RvdWNoRG93biByYXRoZXIgdGhhbiBjbGljaywgbmVlZHMgdG9cbiAgICAgIC8vIGhhcHBlbiBiZWZvcmUgYGJsdXJgIHdoaWNoIHRyaWdnZXJzIHRoZSBhY2UgZWRpdG9yIGNvbXBsZXRlciBwb3B1cFxuICAgICAgLy8gaGlkZSB3aGljaCBpbiB0dXJuIHdvdWxkIGhpZGUgdGhlIGxpbmsgYW5kIG5vdCBzaG93IHRoZSBkb2NzLlxuICAgICAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChzZWVFeGFtcGxlc0xpbmssIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmRyb3BsZXRUb29sdGlwTWFuYWdlci5zaG93RG9jRm9yKGZ1bmNOYW1lKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0uYmluZCh0aGlzKVxuICB9KTtcblxuICB2YXIgcm93T3ZlcmxheURpdiA9ICQoJy5hY2Vfc2VsZWN0ZWQnKTtcbiAgcm93T3ZlcmxheURpdi50b29sdGlwc3Rlcihjb25maWd1cmF0aW9uKTtcbiAgcm93T3ZlcmxheURpdi50b29sdGlwc3Rlcignc2hvdycpO1xufTtcblxuRHJvcGxldEF1dG9jb21wbGV0ZVBvcHVwVG9vbHRpcE1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3lBdXRvY29tcGxldGVUb29sdGlwc18gPSBmdW5jdGlvbiAoKSB7XG4gICQoJy5hY2VfYXV0b2NvbXBsZXRlIC50b29sdGlwc3RlcmVkJykudG9vbHRpcHN0ZXIoJ2Rlc3Ryb3knKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge1N0cmluZ30gSFRNTCBmb3IgdG9vbHRpcFxuICovXG5Ecm9wbGV0QXV0b2NvbXBsZXRlUG9wdXBUb29sdGlwTWFuYWdlci5wcm90b3R5cGUuZ2V0VG9vbHRpcEhUTUwgPSBmdW5jdGlvbiAoZnVuY3Rpb25OYW1lKSB7XG4gIHZhciB0b29sdGlwSW5mbyA9IHRoaXMuZHJvcGxldFRvb2x0aXBNYW5hZ2VyLmdldERyb3BsZXRUb29sdGlwKGZ1bmN0aW9uTmFtZSk7XG4gIHZhciBkcm9wbGV0RnVuY3Rpb25Ub29sdGlwTWFya3VwID0gRHJvcGxldEZ1bmN0aW9uVG9vbHRpcE1hcmt1cCh7XG4gICAgZnVuY3Rpb25OYW1lOiB0b29sdGlwSW5mby5mdW5jdGlvbk5hbWUsXG4gICAgaXNQcm9wZXJ0eTogdG9vbHRpcEluZm8uaXNQcm9wZXJ0eSxcbiAgICB0aXBQcmVmaXg6IHRvb2x0aXBJbmZvLnRpcFByZWZpeCxcbiAgICBmdW5jdGlvblNob3J0RGVzY3JpcHRpb246IHRvb2x0aXBJbmZvLmRlc2NyaXB0aW9uLFxuICAgIHBhcmFtZXRlcnM6IHRvb2x0aXBJbmZvLnBhcmFtZXRlckluZm9zLFxuICAgIHNpZ25hdHVyZU92ZXJyaWRlOiB0b29sdGlwSW5mby5zaWduYXR1cmVPdmVycmlkZSxcbiAgICBzaG93RXhhbXBsZXNMaW5rOiB0aGlzLnNob3dFeGFtcGxlc0xpbmtcbiAgfSk7XG4gIHJldHVybiBkcm9wbGV0RnVuY3Rpb25Ub29sdGlwTWFya3VwO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgaWYgdG9vbHRpcHMgYXJlIGVuYWJsZWRcbiAqL1xuXG5Ecm9wbGV0QXV0b2NvbXBsZXRlUG9wdXBUb29sdGlwTWFuYWdlci5wcm90b3R5cGUuc2V0VG9vbHRpcHNFbmFibGVkID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgdGhpcy50b29sdGlwc0VuYWJsZWQgPSAhIWVuYWJsZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyb3BsZXRBdXRvY29tcGxldGVQb3B1cFRvb2x0aXBNYW5hZ2VyO1xuIiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCcnKTsxOyBmdW5jdGlvbiBnZXRQcmVmaXhlZE5hbWUgKCkge1xuICByZXR1cm4gdGlwUHJlZml4ID8gdGlwUHJlZml4ICsgZnVuY3Rpb25OYW1lIDogZnVuY3Rpb25OYW1lO1xufSA7IGJ1Zi5wdXNoKCdcXG48ZGl2IGNsYXNzPVwiZnVuY3Rpb24tbmFtZVwiPlxcbiAgJyk7NTsgaWYgKHNpZ25hdHVyZU92ZXJyaWRlKSB7OyBidWYucHVzaCgnICAgICcsIGVzY2FwZSgoNSwgIHNpZ25hdHVyZU92ZXJyaWRlICkpLCAnXFxuICAnKTs2OyB9IGVsc2UgaWYgKGlzUHJvcGVydHkpIHs7IGJ1Zi5wdXNoKCcgICAgJywgZXNjYXBlKCg2LCAgZ2V0UHJlZml4ZWROYW1lKCkgKSksICdcXG4gICcpOzc7IH0gZWxzZSB7XG4gICAgLyoqXG4gICAgICogVE9ETyhiam9yZGFuKTogd291bGQgYmUgbmljZSB0byBzcGxpdCB0aGUgZm9sbG93aW5nIGxpbmUgdXAsIGNhbid0IGZpZ3VyZVxuICAgICAqIG91dCBob3cgdG8gZG8gc28gd2l0aG91dCBpbnNlcnRpbmcgZXh0cmFuZW91cyBzcGFjZXMgYmV0d2VlbiBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgOyBidWYucHVzaCgnICAgICcsIGVzY2FwZSgoMTIsICBnZXRQcmVmaXhlZE5hbWUoKSApKSwgJygnKTsxMjsgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7OyBidWYucHVzaCgnJywgKDEyLCAgcGFyYW1ldGVyc1tpXS5uYW1lKSwgJycpOzEyOyBpZiAoaSA8IHBhcmFtZXRlcnMubGVuZ3RoIC0gMSkgezsgYnVmLnB1c2goJywgJyk7MTI7IH07IGJ1Zi5wdXNoKCcnKTsxMjsgfTsgYnVmLnB1c2goJykgICcpOzEyOyB9IDsgYnVmLnB1c2goJ1xcbjwvZGl2PlxcbicpOzE0OyBpZiAoZnVuY3Rpb25TaG9ydERlc2NyaXB0aW9uKSB7IDsgYnVmLnB1c2goJzxkaXY+JywgZXNjYXBlKCgxNCwgIGZ1bmN0aW9uU2hvcnREZXNjcmlwdGlvbiApKSwgJzwvZGl2PicpOzE0OyB9IDsgYnVmLnB1c2goJ1xcbicpOzE1OyBpZiAoc2hvd0V4YW1wbGVzTGluaykgeyA7IGJ1Zi5wdXNoKCdcXG4gIDxkaXYgY2xhc3M9XCJ0b29sdGlwLWV4YW1wbGUtbGlua1wiPlxcbiAgICA8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApO1wiPlNlZSBleGFtcGxlczwvYT5cXG4gIDwvZGl2PlxcbicpOzE5OyB9IDsgYnVmLnB1c2goJ1xcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIi8qIGdsb2JhbCBhY2UgKi9cbnZhciBEcm9wbGV0RnVuY3Rpb25Ub29sdGlwTWFya3VwID0gcmVxdWlyZSgnLi9Ecm9wbGV0UGFyYW1ldGVyVG9vbHRpcC5odG1sLmVqcycpO1xudmFyIHRvb2x0aXBVdGlscyA9IHJlcXVpcmUoJy4vdG9vbHRpcFV0aWxzLmpzJyk7XG52YXIgZG9tID0gcmVxdWlyZSgnLi4vZG9tJyk7XG52YXIgZHJvcGxldFV0aWxzID0gcmVxdWlyZSgnLi4vZHJvcGxldFV0aWxzJyk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXNwbGF5cyB0b29sdGlwcyBmb3IgRHJvcGxldCBibG9ja3NcbiAqL1xuXG4vKipcbiAqIEhhbmRsZXMgZGlzcGxheWluZyB0b29sdGlwcyBvbiBEcm9wbGV0J3MgQUNFIGVkaXRvciB3aGVuIGZpbGxpbmcgaW5cbiAqIGFuIGVtcHR5IHBhcmFtZXRlci5cbiAqIEFsc28gd2lsbCBhdWdtZW50IEFDRSBlZGl0b3IncyBMaXZlIGF1dG9jb21wbGV0ZSBieSBpbnZva2luZyBzY29wZWRcbiAqIGF1dG9jb21wbGV0ZSBkcm9wZG93bnMgZm9yIGVhY2ggcGFyYW1ldGVyLlxuICogQHBhcmFtIHtEcm9wbGV0VG9vbHRpcE1hbmFnZXJ9IGRyb3BsZXRUb29sdGlwTWFuYWdlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEcm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXIgPSBmdW5jdGlvbiAoZHJvcGxldFRvb2x0aXBNYW5hZ2VyKSB7XG4gIHRoaXMuZHJvcGxldFRvb2x0aXBNYW5hZ2VyID0gZHJvcGxldFRvb2x0aXBNYW5hZ2VyO1xuICB0aGlzLnNob3dFeGFtcGxlc0xpbmsgPSBkcm9wbGV0VG9vbHRpcE1hbmFnZXIuZHJvcGxldENvbmZpZy5zaG93RXhhbXBsZXNMaW5rO1xuICB0aGlzLnNob3dQYXJhbURyb3Bkb3ducyA9IGRyb3BsZXRUb29sdGlwTWFuYWdlci5kcm9wbGV0Q29uZmlnLnNob3dQYXJhbURyb3Bkb3ducztcbiAgdGhpcy50b29sdGlwQ29uZmlnID0ge1xuICAgIGludGVyYWN0aXZlOiB0cnVlLFxuICAgIGF1dG9DbG9zZTogZmFsc2UsXG4gICAgdHJpZ2dlcjogJ2N1c3RvbScsXG4gICAgc3BlZWQ6IDEwMCxcbiAgICBtYXhXaWR0aDogNDUwLFxuICAgIHBvc2l0aW9uOiB0aGlzLnNob3dQYXJhbURyb3Bkb3ducyA/ICd0b3AnIDogJ2JvdHRvbScsXG4gICAgY29udGVudEFzSFRNTDogdHJ1ZSxcbiAgICB0aGVtZTogJ2Ryb3BsZXQtYmxvY2stdG9vbHRpcHN0ZXInLFxuICAgIG9mZnNldFk6IDIsXG4gICAgcmVzdG9yYXRpb246ICdub25lJyxcbiAgICB1cGRhdGVBbmltYXRpb246IGZhbHNlLFxuICAgIHBvc2l0aW9uVHJhY2tlcjogdHJ1ZSxcbiAgICB0b29sdGlwc0VuYWJsZWQ6IHRydWVcbiAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFZGl0b3J9IGRyb3BsZXRFZGl0b3JcbiAqL1xuRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS5pbnN0YWxsVG9vbHRpcHNGb3JFZGl0b3JfID0gZnVuY3Rpb24gKGRyb3BsZXRFZGl0b3IpIHtcbiAgdmFyIGFjZUVkaXRvciA9IGRyb3BsZXRFZGl0b3IuYWNlRWRpdG9yO1xuXG4gIHZhciBjdXJzb3JNb3ZlbWVudEhhbmRsZXIgPSB0aGlzLm9uQ3Vyc29yTW92ZW1lbnRfLmJpbmQodGhpcywgYWNlRWRpdG9yKTtcbiAgYWNlRWRpdG9yLmNvbW1hbmRzLm9uKCdhZnRlckV4ZWMnLCBjdXJzb3JNb3ZlbWVudEhhbmRsZXIpO1xuICBhY2VFZGl0b3Iub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICB0aGlzLmdldEN1cnNvclRvb2x0aXBfKCkudG9vbHRpcHN0ZXIoJ2hpZGUnKTtcbiAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGVkaXRvciAtIGFjZSBlZGl0b3IgaW5zdGFuY2VcbiAqIEBwYXJhbSBjaGFuZ2VFdmVudCAtIGV2ZW50IGZyb20gYWNlRWRpdG9yLnNlc3Npb24uc2VsZWN0aW9uLm9uKCdjaGFuZ2VDdXJzb3InKVxuICogQHByaXZhdGVcbiAqL1xuRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS5vbkN1cnNvck1vdmVtZW50XyA9IGZ1bmN0aW9uIChlZGl0b3IsIGNoYW5nZUV2ZW50KSB7XG4gIHRoaXMuZ2V0Q3Vyc29yVG9vbHRpcF8oKS50b29sdGlwc3RlcignaGlkZScpO1xuXG4gIGlmICghZWRpdG9yLnNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3Vyc29yUG9zaXRpb24gPSBlZGl0b3Iuc2VsZWN0aW9uLmdldEN1cnNvcigpO1xuXG4gIHZhciBjdXJyZW50UGFyYW1ldGVySW5mbyA9IHRvb2x0aXBVdGlscy5maW5kRnVuY3Rpb25BbmRQYXJhbU51bWJlcihlZGl0b3IsIGN1cnNvclBvc2l0aW9uKTtcbiAgaWYgKCFjdXJyZW50UGFyYW1ldGVySW5mbykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLmJsb2NrRHJvcGRvd25zQW5kVG9vbHRpcHMgfHwgdGhpcy5zdGFydGluZ0F1dG9Db21wbGV0ZSkge1xuICAgIC8vIEd1YXJkIGFnYWluc3QgcmUtZW50cmFuY3kgdGhhdCBvY2N1cnMgaW5zaWRlIHRoZSBzaG93UGFyYW1Ecm9wZG93bklmTmVlZGVkXygpIGFuZCB0aGUgY2xpY2tcbiAgICAvLyBoYW5kbGVycyBiZWxvd1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChlZGl0b3IuY29tcGxldGVyICYmIHRoaXMuc2hvd1BhcmFtRHJvcGRvd25zKSB7XG4gICAgdGhpcy5zaG93UGFyYW1Ecm9wZG93bklmTmVlZGVkXyhlZGl0b3IsIGN1cnJlbnRQYXJhbWV0ZXJJbmZvKTtcbiAgfVxuXG4gIHRoaXMudXBkYXRlUGFyYW1ldGVyVG9vbHRpcF8oZWRpdG9yLCBjdXJyZW50UGFyYW1ldGVySW5mbyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBlZGl0b3IgLSBhY2UgZWRpdG9yIGluc3RhbmNlXG4gKiBAcGFyYW0gcGFyYW1JbmZvIC0gcGFyYW1ldGVyIGluZm8gYWxyZWFkeSByZXRyaWV2ZWQgYmFzZWQgb24gdGhlIGN1cnNvciBwb3NpdGlvblxuICogQHByaXZhdGVcbiAqL1xuRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS5zaG93UGFyYW1Ecm9wZG93bklmTmVlZGVkXyA9IGZ1bmN0aW9uIChlZGl0b3IsIHBhcmFtSW5mbykge1xuICAvLyBDaGVjayB0aGUgZHJvcGxldENvbmZpZyB0byBzZWUgaWYgd2UgY2FuIGZpbmQgZHJvcGRvd24gaW5mbyBmb3IgdGhpcyBwYXJhbWV0ZXJcbiAgdmFyIGRyb3Bkb3duTGlzdDtcbiAgZHJvcGxldFV0aWxzLmdldEFsbEF2YWlsYWJsZURyb3BsZXRCbG9ja3MoXG4gICAgdGhpcy5kcm9wbGV0VG9vbHRpcE1hbmFnZXIuZHJvcGxldENvbmZpZyxcbiAgICB0aGlzLmRyb3BsZXRUb29sdGlwTWFuYWdlci5jb2RlRnVuY3Rpb25zLFxuICAgIHRoaXMuYXV0b2NvbXBsZXRlUGFsZXR0ZUFwaXNPbmx5KS5mb3JFYWNoKGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgaWYgKCFibG9jay5kcm9wZG93biB8fFxuICAgICAgICAgIChibG9jay5mdW5jICE9PSBwYXJhbUluZm8uZnVuY05hbWUgJiYgYmxvY2suZnVuYyAhPT0gcGFyYW1JbmZvLmZ1bGxGdW5jTmFtZSkpIHtcbiAgICAgICAgLy8gTm90IHRoZSByaWdodCBibG9jayBvciBubyBkcm9wZG93biBzcGVjaWZpZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGJsb2NrLm5vQXV0b2NvbXBsZXRlKSB7XG4gICAgICAgIC8vIEJsb2NrIGRvZXNuJ3Qgd2FudCBhdXRvY29tcGxldGUsIHNvIGlnbm9yZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kcm9wbGV0VG9vbHRpcE1hbmFnZXIuYXV0b2NvbXBsZXRlUGFsZXR0ZUFwaXNPbmx5ICYmXG4gICAgICAgICAgdGhpcy5kcm9wbGV0VG9vbHRpcE1hbmFnZXIuY29kZUZ1bmN0aW9ucyAmJlxuICAgICAgICAgIHR5cGVvZiB0aGlzLmRyb3BsZXRUb29sdGlwTWFuYWdlci5jb2RlRnVuY3Rpb25zW2Jsb2NrLmZ1bmNdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBJbiBhdXRvY29tcGxldGVQYWxldHRlQXBpc09ubHkgbW9kZSBhbmQgYmxvY2sgaXMgbm90IGluIHRoZSBwYWxldHRlOlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGJsb2NrLmRyb3Bkb3duW3BhcmFtSW5mby5jdXJyZW50UGFyYW1ldGVySW5kZXhdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRyb3Bkb3duTGlzdCA9IGJsb2NrLmRyb3Bkb3duW3BhcmFtSW5mby5jdXJyZW50UGFyYW1ldGVySW5kZXhdKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkcm9wZG93bkxpc3QgPSBibG9jay5kcm9wZG93bltwYXJhbUluZm8uY3VycmVudFBhcmFtZXRlckluZGV4XTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRoaXMpO1xuXG4gIGlmIChkcm9wZG93bkxpc3QgJiYgIWVkaXRvci5jb21wbGV0ZXIuYWN0aXZhdGVkKSB7XG4gICAgLy8gVGhlIGN1cnNvciBpcyBwb3NpdGlvbmVkIHdoZXJlIGEgcGFyYW1ldGVyIHdpdGggYSBkcm9wZG93biBzaG91bGQgYXBwZWFyXG4gICAgLy8gYW5kIGF1dG9jb21wbGV0ZSBpcyBub3QgYWxyZWFkeSBhY3RpdmUsIHNvIGxldCdzIHBvcCB1cCBhIHNwZWNpYWwgZHJvcGRvd25cbiAgICAvLyBhdXRvY29tcGxldGVcblxuICAgIC8vIEZpcnN0LCBpbnN0YWxsIG91ciBob29rcyB0byBtb2RpZnkgdGhlIG5vcm1hbCBhY2UgQXV0b0NvbXBsZXRlICh0aGVzZSBhcmVcbiAgICAvLyBzYWZlIHRvIGxlYXZlIGluIHBsYWNlLCBhbmQgd2UgY2FuIGNhbGwgdGhpcyBtdWx0aXBsZSB0aW1lcyk6XG4gICAgdGhpcy5pbnN0YWxsQWNlQ29tcGxldGVySG9va3NfKGVkaXRvcik7XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgYWNlIGNvbXBsZXRlciBiYXNlZCBvbiB0aGUgZHJvcGRvd24gaW5mbyBhbmQgbWFyayBpdCBhcyB0aGVcbiAgICAvLyBcIm92ZXJyaWRlQ29tcGxldGVyXCIgd2hpY2ggd2lsbCBzdGF5IGluIHBsYWNlIGZvciB0aGUgbmV4dCBwb3B1cCBmcm9tXG4gICAgLy8gYXV0b2NvbXBsZXRlIG9ubHk6XG4gICAgdmFyIGRyb3Bkb3duQ29tcGxldGlvbnMgPSBbXTtcbiAgICBkcm9wZG93bkxpc3QuZm9yRWFjaChmdW5jdGlvbiAobGlzdFZhbHVlKSB7XG4gICAgICB2YXIgdmFsU3RyaW5nLCB2YWxDbGljaztcbiAgICAgIGlmICh0eXBlb2YgbGlzdFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWxTdHJpbmcgPSBsaXN0VmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdXBwb3J0IHRoZSB7IHRleHQ6IHgsIGRpc3BsYXk6IHggfSBmb3JtLCBidXQgaWdub3JlIHRoZSBkaXNwbGF5IGZpZWxkXG4gICAgICAgIHZhbFN0cmluZyA9IGxpc3RWYWx1ZS50ZXh0O1xuICAgICAgICAvLyBUYWNrIG9uIHRoZSBzcGVjaWFsIGNsaWNrIGhhbmRsZXIgaWYgcHJlc2VudFxuICAgICAgICB2YWxDbGljayA9IGxpc3RWYWx1ZS5jbGljaztcbiAgICAgIH1cbiAgICAgIGRyb3Bkb3duQ29tcGxldGlvbnMucHVzaCh7XG4gICAgICAgIG5hbWU6ICdkcm9wZG93bicsXG4gICAgICAgIHZhbHVlOiB2YWxTdHJpbmcsXG4gICAgICAgIGNsaWNrOiB2YWxDbGlja1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZWRpdG9yLmNvbXBsZXRlci5vdmVycmlkZUNvbXBsZXRlciA9IHtcbiAgICAgIGdldENvbXBsZXRpb25zOiBmdW5jdGlvbihlZGl0b3IsIHNlc3Npb24sIHBvcywgcHJlZml4LCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBkcm9wZG93bkNvbXBsZXRpb25zKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8vIE1hcmsgdGhlIHdlIGFyZSBzdGFydGluZyBhdXRvLWNvbXBsZXRlIHNvIHRoYXQgd2UgY2FuIGd1YXJkIGFnYWluc3RcbiAgICAvLyByZS1lbnRyYW5jeSB3aGVuIHdlIHNlZSBtb3JlIGN1cnNvciBtb3ZlbWVudCBldmVudHM6XG4gICAgdGhpcy5zdGFydGluZ0F1dG9Db21wbGV0ZSA9IHRydWU7XG4gICAgZWRpdG9yLmV4ZWNDb21tYW5kKFwic3RhcnRBdXRvY29tcGxldGVcIik7XG4gICAgdGhpcy5zdGFydGluZ0F1dG9Db21wbGV0ZSA9IGZhbHNlO1xuICB9XG59O1xuXG5Ecm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVBhcmFtZXRlclRvb2x0aXBfID0gZnVuY3Rpb24gKGFjZUVkaXRvciwgcGFyYW1JbmZvKSB7XG4gIGlmICghdGhpcy50b29sdGlwQ29uZmlnLnRvb2x0aXBzRW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkb2NGdW5jO1xuICBpZiAodGhpcy5kcm9wbGV0VG9vbHRpcE1hbmFnZXIuZ2V0RG9jRm9yKHBhcmFtSW5mby5mdW5jTmFtZSkpIHtcbiAgICBkb2NGdW5jID0gcGFyYW1JbmZvLmZ1bmNOYW1lO1xuICB9IGVsc2UgaWYgKHRoaXMuZHJvcGxldFRvb2x0aXBNYW5hZ2VyLmdldERvY0ZvcihwYXJhbUluZm8uZnVsbEZ1bmNOYW1lKSkge1xuICAgIGRvY0Z1bmMgPSBwYXJhbUluZm8uZnVsbEZ1bmNOYW1lO1xuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdG9vbHRpcEluZm8gPSB0aGlzLmRyb3BsZXRUb29sdGlwTWFuYWdlci5nZXREcm9wbGV0VG9vbHRpcChkb2NGdW5jKTtcblxuICB2YXIgaGFzVG9vbHRpcFBhcmFtcyA9IHRvb2x0aXBJbmZvLnBhcmFtZXRlckluZm9zLmxlbmd0aCA+IDA7XG4gIGlmICgoaGFzVG9vbHRpcFBhcmFtcyAmJiBwYXJhbUluZm8uY3VycmVudFBhcmFtZXRlckluZGV4ID49IHRvb2x0aXBJbmZvLnBhcmFtZXRlckluZm9zLmxlbmd0aCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3Vyc29yVG9vbHRpcCA9IHRoaXMuZ2V0Q3Vyc29yVG9vbHRpcF8oKTtcblxuICBjdXJzb3JUb29sdGlwLnRvb2x0aXBzdGVyKCdjb250ZW50JywgdGhpcy5nZXRUb29sdGlwSFRNTCh0b29sdGlwSW5mbywgcGFyYW1JbmZvLmN1cnJlbnRQYXJhbWV0ZXJJbmRleCkpO1xuICBjdXJzb3JUb29sdGlwLnRvb2x0aXBzdGVyKCdzaG93Jyk7XG5cbiAgaWYgKHRoaXMuc2hvd0V4YW1wbGVzTGluaykge1xuICAgIHZhciBzZWVFeGFtcGxlc0xpbmsgPSAkKGN1cnNvclRvb2x0aXAudG9vbHRpcHN0ZXIoJ2VsZW1lbnRUb29sdGlwJykpLmZpbmQoJy50b29sdGlwLWV4YW1wbGUtbGluayA+IGEnKVswXTtcbiAgICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KHNlZUV4YW1wbGVzTGluaywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB0aGlzLmRyb3BsZXRUb29sdGlwTWFuYWdlci5zaG93RG9jRm9yKGRvY0Z1bmMpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIGlmICghaGFzVG9vbHRpcFBhcmFtcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaG9vc2VBc3NldCA9IHRvb2x0aXBJbmZvLnBhcmFtZXRlckluZm9zW3BhcmFtSW5mby5jdXJyZW50UGFyYW1ldGVySW5kZXhdLmFzc2V0VG9vbHRpcDtcbiAgaWYgKGNob29zZUFzc2V0KSB7XG4gICAgdmFyIGNob29zZUFzc2V0TGluayA9ICQoY3Vyc29yVG9vbHRpcC50b29sdGlwc3RlcignZWxlbWVudFRvb2x0aXAnKSkuZmluZCgnLnRvb2x0aXAtY2hvb3NlLWxpbmsgPiBhJylbMF07XG4gICAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChjaG9vc2VBc3NldExpbmssIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBjdXJzb3JUb29sdGlwLnRvb2x0aXBzdGVyKCdoaWRlJyk7XG4gICAgICBjaG9vc2VBc3NldChmdW5jdGlvbihmaWxlbmFtZSkge1xuICAgICAgICBhY2VFZGl0b3Iub25UZXh0SW5wdXQoJ1wiJyArIGZpbGVuYW1lICsgJ1wiJyk7XG4gICAgICB9KTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH1cbn07XG5cbkRyb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlci5wcm90b3R5cGUuZ2V0Q3Vyc29yVG9vbHRpcF8gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5jdXJzb3JUb29sdGlwXykge1xuICAgIHRoaXMuY3Vyc29yVG9vbHRpcF8gPSAkKCcuZHJvcGxldC1hY2UgLmFjZV9jdXJzb3InKTtcbiAgICB0aGlzLmN1cnNvclRvb2x0aXBfLnRvb2x0aXBzdGVyKHRoaXMudG9vbHRpcENvbmZpZyk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY3Vyc29yVG9vbHRpcF87XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtTdHJpbmd9IEhUTUwgZm9yIHRvb2x0aXBcbiAqL1xuRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS5nZXRUb29sdGlwSFRNTCA9IGZ1bmN0aW9uICh0b29sdGlwSW5mbywgY3VycmVudFBhcmFtZXRlckluZGV4KSB7XG4gIHJldHVybiBEcm9wbGV0RnVuY3Rpb25Ub29sdGlwTWFya3VwKHtcbiAgICBmdW5jTmFtZTogdG9vbHRpcEluZm8uZnVuY3Rpb25OYW1lLFxuICAgIGZ1bmN0aW9uTmFtZTogdG9vbHRpcEluZm8uZnVuY3Rpb25OYW1lLFxuICAgIGlzUHJvcGVydHk6IHRvb2x0aXBJbmZvLmlzUHJvcGVydHksXG4gICAgdGlwUHJlZml4OiB0b29sdGlwSW5mby50aXBQcmVmaXgsXG4gICAgZnVuY3Rpb25TaG9ydERlc2NyaXB0aW9uOiB0b29sdGlwSW5mby5kZXNjcmlwdGlvbixcbiAgICBwYXJhbWV0ZXJzOiB0b29sdGlwSW5mby5wYXJhbWV0ZXJJbmZvcyxcbiAgICBzaWduYXR1cmVPdmVycmlkZTogdG9vbHRpcEluZm8uc2lnbmF0dXJlT3ZlcnJpZGUsXG4gICAgc2hvd0V4YW1wbGVzTGluayA6IHRoaXMuc2hvd0V4YW1wbGVzTGluayxcbiAgICBjdXJyZW50UGFyYW1ldGVySW5kZXg6IGN1cnJlbnRQYXJhbWV0ZXJJbmRleFxuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGVkaXRvciAtIGFjZSBlZGl0b3IgaW5zdGFuY2VcbiAqIEBwcml2YXRlXG4gKi9cbkRyb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlci5wcm90b3R5cGUuaW5zdGFsbEFjZUNvbXBsZXRlckhvb2tzXyA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgaWYgKGVkaXRvci5jb21wbGV0ZXIuc2hvd1BvcHVwICE9PSBEcm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXIuc2hvd1BvcHVwKSB7XG4gICAgRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyLm9yaWdpbmFsU2hvd1BvcHVwID0gZWRpdG9yLmNvbXBsZXRlci5zaG93UG9wdXA7XG4gICAgZWRpdG9yLmNvbXBsZXRlci5zaG93UG9wdXAgPSBEcm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXIuc2hvd1BvcHVwO1xuICB9XG4gIGlmIChlZGl0b3IuY29tcGxldGVyLmdhdGhlckNvbXBsZXRpb25zICE9PSBEcm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXIuZ2F0aGVyQ29tcGxldGlvbnMpIHtcbiAgICBEcm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXIub3JpZ2luYWxHYXRoZXJDb21wbGV0aW9ucyA9IGVkaXRvci5jb21wbGV0ZXIuZ2F0aGVyQ29tcGxldGlvbnM7XG4gICAgZWRpdG9yLmNvbXBsZXRlci5nYXRoZXJDb21wbGV0aW9ucyA9IERyb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlci5nYXRoZXJDb21wbGV0aW9ucztcbiAgfVxuICBpZiAoIWVkaXRvci5jb21wbGV0ZXIuaW5zZXJ0TWF0Y2hPdmVycmlkZSkge1xuICAgIGVkaXRvci5jb21wbGV0ZXIuaW5zZXJ0TWF0Y2hPdmVycmlkZSA9XG4gICAgICBEcm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXIuaW5zZXJ0TWF0Y2guYmluZChlZGl0b3IuY29tcGxldGVyLCB0aGlzKTtcbiAgfVxuICBpZiAoZWRpdG9yLmNvbXBsZXRlci5pbnNlcnRNYXRjaCAhPT0gZWRpdG9yLmNvbXBsZXRlci5pbnNlcnRNYXRjaE92ZXJyaWRlKSB7XG4gICAgRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyLm9yaWdpbmFsSW5zZXJ0TWF0Y2ggPSBlZGl0b3IuY29tcGxldGVyLmluc2VydE1hdGNoO1xuICAgIGVkaXRvci5jb21wbGV0ZXIuaW5zZXJ0TWF0Y2ggPSBlZGl0b3IuY29tcGxldGVyLmluc2VydE1hdGNoT3ZlcnJpZGU7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHRoaXMgY29tcGxldGVyIGluc3RhbmNlXG4gKiBAcGFyYW0gZWRpdG9yIGFjZSBlZGl0b3JcbiAqIEBwYXJhbSBjYWxsYmFjayB3ZSBwYXNzIHRoaXMgdGhyb3VnaFxuICovXG5Ecm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXIuZ2F0aGVyQ29tcGxldGlvbnMgPSBmdW5jdGlvbiAoZWRpdG9yLCBjYWxsYmFjaykge1xuICAvLyBPdmVycmlkZSBub3JtYWwgYWNlIEF1dG9Db21wbGV0ZSBiZWhhdmlvciBieSB1c2luZyBvbmx5IG92ZXJyaWRlQ29tcGxldGVyXG4gIC8vIGluc3RlYWQgb2YgdGhlIG5vcm1hbCBzZXQgb2YgY29tcGxldGVycyB3aGVuIG92ZXJyaWRlQ29tcGxldGVyIGlzIHNldFxuICBpZiAodGhpcy5vdmVycmlkZUNvbXBsZXRlcikge1xuICAgIHZhciBhbGxDb21wbGV0ZXJzID0gZWRpdG9yLmNvbXBsZXRlcnM7XG4gICAgZWRpdG9yLmNvbXBsZXRlcnMgPSBbIHRoaXMub3ZlcnJpZGVDb21wbGV0ZXIgXTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IGF1dG9JbnNlcnQgaXMgb2ZmIHNvIHdlIGRvbid0IGluc2VydCBpbW1lZGlhdGVseSB3aGVuIHRoZXJlIGlzIG9ubHkgb25lIG9wdGlvbjpcbiAgICBlZGl0b3IuY29tcGxldGVyLmF1dG9JbnNlcnQgPSBmYWxzZTtcblxuICAgIERyb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlci5vcmlnaW5hbEdhdGhlckNvbXBsZXRpb25zLmNhbGwodGhpcywgZWRpdG9yLCBjYWxsYmFjayk7XG4gICAgZWRpdG9yLmNvbXBsZXRlcnMgPSBhbGxDb21wbGV0ZXJzO1xuICB9IGVsc2Uge1xuICAgIERyb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlci5vcmlnaW5hbEdhdGhlckNvbXBsZXRpb25zLmNhbGwodGhpcywgZWRpdG9yLCBjYWxsYmFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHRoaXMgY29tcGxldGVyIGluc3RhbmNlXG4gKiBAcGFyYW0gZWRpdG9yIGFjZSBlZGl0b3JcbiAqL1xuRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyLnNob3dQb3B1cCA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgLy8gT3ZlcnJpZGUgbm9ybWFsIGFjZSBBdXRvQ29tcGxldGUgYmVoYXZpb3IgYnkgZ3VhcmFudGVlaW5nIHRoYXQgb3ZlcnJpZGVDb21wbGV0ZXIgaXMgcmVzZXRcbiAgLy8gYWZ0ZXIgZWFjaCBjYWxsIHRvIHNob3dQb3B1cCgpXG4gIERyb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlci5vcmlnaW5hbFNob3dQb3B1cC5jYWxsKHRoaXMsIGVkaXRvcik7XG4gIHRoaXMub3ZlcnJpZGVDb21wbGV0ZXIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gdGhpcyBjb21wbGV0ZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSBzZWxmIERyb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlciBpbnN0YW5jZVxuICogQHBhcmFtIGRhdGEgaW5mbyBwYXNzZWQgdG8gYWNlJ3MgaW5zZXJ0TWF0Y2hcbiAqL1xuRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyLmluc2VydE1hdGNoID0gZnVuY3Rpb24gKHNlbGYsIGRhdGEpIHtcbiAgLy8gTW9kaWZ5IG5vcm1hbCBhY2UgQXV0b0NvbXBsZXRlIGJlaGF2aW9yIGJ5IGNhbGxpbmcgb3VyIHNwZWNpYWwgJ2NsaWNrJyBoYW5kbGVyIHdoZW4gc3VwcGxpZWRcbiAgLy8gYW5kIHBhc3NpbmcgaXQgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgaW5zZXJ0TWF0Y2goKSB0byBiZSBjYWxsZWQgd2l0aGluXG4gIGlmICghZGF0YSkge1xuICAgIGRhdGEgPSB0aGlzLnBvcHVwLmdldERhdGEodGhpcy5wb3B1cC5nZXRSb3coKSk7XG4gIH1cbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGRhdGEuY2xpY2spIHtcbiAgICAvLyBFeGVjdXRlIGRldGFjaCgpIG1ldGhvZCBoZXJlIHRvIGVuc3VyZSB0aGF0IHRoZSBwb3B1cCBnb2VzXG4gICAgLy8gYXdheSBiZWZvcmUgd2UgY2FsbCB0aGUgY2xpY2soKSBtZXRob2RcbiAgICB0aGlzLmRldGFjaCgpO1xuXG4gICAgLy8gQW5kIGhpZGUgb3VyIGN1cnNvciB0b29sdGlwIGFzIHdlbGw6XG4gICAgc2VsZi5nZXRDdXJzb3JUb29sdGlwXygpLnRvb2x0aXBzdGVyKCdoaWRlJyk7XG5cbiAgICAvLyBOb3RlOiBzdG9wIGRyb3Bkb3ducyBhbmQgdG9vbHRpcHMgdW50aWwgdGhlIGNhbGxiYWNrIGlzIGNvbXBsZXRlLi4uXG4gICAgc2VsZi5ibG9ja0Ryb3Bkb3duc0FuZFRvb2x0aXBzID0gdHJ1ZTtcblxuICAgIHZhciBsYW5nID0gYWNlLnJlcXVpcmUoXCIuL2xpYi9sYW5nXCIpO1xuXG4gICAgLy8gVXNlIGRlbGF5ZWRDYWxsIHNvIHRoZSBwb3B1cCBhbmQgdG9vbHRpcCBkaXNhcHBlYXIgaW4gdGhlIGNhc2Ugd2hlcmUgdGhlXG4gICAgLy8gRW50ZXIga2V5IHdhcyBwcmVzc2VkIGJlZm9yZSB3ZSBjaG9vc2UgdGhpcyBhdXRvY29tcGxldGUgaXRlbVxuICAgIHZhciBjbGlja0Z1bmMgPSBsYW5nLmRlbGF5ZWRDYWxsKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFdlIGNyZWF0ZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIHRoZSBjbGljayBmdW5jdGlvbiB3aWxsIGNhbGwsIHBhc3NpbmcgYVxuICAgICAgLy8gc3RyaW5nIHdoaWNoIHdpbGwgYmUgaW5zZXJ0ZWQuXG4gICAgICBkYXRhLmNsaWNrKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLmV4ZWNDb21tYW5kKFwiaW5zZXJ0c3RyaW5nXCIsIGRhdGEpO1xuICAgICAgICBzZWxmLmJsb2NrRHJvcGRvd25zQW5kVG9vbHRpcHMgPSBmYWxzZTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIGNsaWNrRnVuYy5zY2hlZHVsZSgpO1xuICB9IGVsc2Uge1xuICAgIERyb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlci5vcmlnaW5hbEluc2VydE1hdGNoLmNhbGwodGhpcywgZGF0YSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgaWYgdG9vbHRpcHMgc2hvdWxkIGJlIGVuYWJsZWRcbiAqL1xuRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS5zZXRUb29sdGlwc0VuYWJsZWQgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICB0aGlzLnRvb2x0aXBDb25maWcudG9vbHRpcHNFbmFibGVkID0gISFlbmFibGVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXI7XG4iLCIvKiBnbG9iYWwgYWNlICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgXyA9IHV0aWxzLmdldExvZGFzaCgpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHBhcmFtZXRlclNsb3RJbmZvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZnVuY05hbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXJyZW50UGFyYW1ldGVySW5kZXhcbiAqL1xuXG52YXIgT05MWV9XSElURVNQQUNFX1JFR0VYUCA9IC9eXFxzKiQvO1xudmFyIEVORElOR19PRl9CTE9DS19DT01NRU5UID0gL1xcKlxcLyQvO1xudmFyIFNUQVJUX09GX0JMT0NLX0NPTU1FTlQgPSAvXlxcL1xcKi87XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGluc3RhbmNlcyBvZiBjaGFyYWN0ZXIgd2l0aGluIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGNoYXJhY3RlclxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gY291bnROdW1iZXJPZkNoYXJhY3RlcihzdHJpbmcsIGNoYXJhY3Rlcikge1xuICByZXR1cm4gc3RyaW5nLnNwbGl0KGNoYXJhY3RlcikubGVuZ3RoIC0gMTtcbn1cblxuZnVuY3Rpb24gb3BlbmVyTWF0Y2hlc0Nsb3NlcihvcGVuZXIsIGNsb3Nlcikge1xuICB2YXIgY2xvc2Vyc1RvT3BlbmVycyA9IHtcbiAgICAnfSc6ICd7JyxcbiAgICAnKSc6ICcoJyxcbiAgICAnXSc6ICdbJ1xuICB9O1xuICByZXR1cm4gY2xvc2Vyc1RvT3BlbmVyc1tjbG9zZXJdID09PSBvcGVuZXI7XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gYWNlIGVkaXRvciBhbmQgcm93L2NvbHVtbiBwb3NpdGlvbiwgcmV0dXJucyB0aGUgZnVuY3Rpb25cbiAqIG5hbWUgYW5kIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgZWRpdGVkIHBhcmFtZXRlci5cbiAqIElmIGEgcGFyYW1ldGVyIGlzIG5vdCBjdXJyZW50bHkgYmVpbmcgZmlsbGVkIGluLCByZXR1cm5zIG51bGwuXG4gKiBUT0RPKGJqb3JkYW4pOiBVbml0IHRlc3Qgb25jZSBhY2UucmVxdWlyZSBhdmFpbGFibGUgaW4gdXRpbGl0eSB0ZXN0c1xuICogQHBhcmFtIGVkaXRvclxuICogQHBhcmFtIHBvc2l0aW9uXG4gKiBAcmV0dXJucyB7cGFyYW1ldGVyU2xvdEluZm98bnVsbH1cbiAqL1xuZXhwb3J0cy5maW5kRnVuY3Rpb25BbmRQYXJhbU51bWJlciA9IGZ1bmN0aW9uIChlZGl0b3IsIHBvc2l0aW9uKSB7XG4gIHZhciBzZWVuQ2xvc2VyU3RhY2sgPSBbXTtcbiAgdmFyIHNhbWVEZXB0aFByZWNlZGluZ0NvbW1hQ291bnQgPSAwO1xuXG4gIHZhciBUb2tlbkl0ZXJhdG9yID0gYWNlLnJlcXVpcmUoXCIuL3Rva2VuX2l0ZXJhdG9yXCIpLlRva2VuSXRlcmF0b3I7XG4gIHZhciBpdGVyYXRvciA9IG5ldyBUb2tlbkl0ZXJhdG9yKGVkaXRvci5zZXNzaW9uLCBwb3NpdGlvbi5yb3csIHBvc2l0aW9uLmNvbHVtbik7XG5cbiAgdmFyIHRva2VuID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuKCk7XG5cbiAgLy8gU3BlY2lhbCBjYXNlcyBmb3IgZmlyc3QgdG9rZW5cblxuICBpZiAocG9zaXRpb24uY29sdW1uID09PSAwKSB7XG4gICAgLy8gQXQgYmVnaW5uaW5nIG9mIGEgbGluZS4gU3RlcCBiYWNrIG9uZSBmb3IgZmlyc3QgdG9rZW4uXG4gICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwQmFja3dhcmQoKTtcbiAgfSBlbHNlIGlmICh0b2tlbiAmJiB0b2tlbi50eXBlLm1hdGNoKC9eY29tbWVudC8pKSB7XG4gICAgdmFyIGlzQmxvY2tDb21tZW50ID0gdG9rZW4udHlwZSA9PT0gXCJjb21tZW50LmRvY1wiIHx8XG4gICAgICB0b2tlbi52YWx1ZS5tYXRjaChTVEFSVF9PRl9CTE9DS19DT01NRU5UKTtcbiAgICBpZiAoaXNCbG9ja0NvbW1lbnQpIHtcbiAgICAgIHZhciB0b2tlbklzRW5kT2ZEb2NDb21tZW50ID0gdG9rZW4udmFsdWUubWF0Y2goRU5ESU5HX09GX0JMT0NLX0NPTU1FTlQpO1xuICAgICAgdmFyIGN1cnNvcklzRW5kT2ZUb2tlbiA9ICh0b2tlbi5zdGFydCArIHRva2VuLnZhbHVlLmxlbmd0aCkgPT09IHBvc2l0aW9uLmNvbHVtbjtcbiAgICAgIHZhciBjdXJzb3JJc0VuZE9mQmxvY2tDb21tZW50ID0gKHRva2VuSXNFbmRPZkRvY0NvbW1lbnQgJiYgY3Vyc29ySXNFbmRPZlRva2VuKTtcbiAgICAgIGlmICghY3Vyc29ySXNFbmRPZkJsb2NrQ29tbWVudCkge1xuICAgICAgICAvLyBTdGFydGluZyB3aXRoaW4gYSBibG9jayBjb21tZW50XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGFydGluZyB3aXRoaW4gYSBjb21tZW50XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAodG9rZW4pIHtcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJwYXJlbi5ycGFyZW5cIjpcbiAgICAgICAgdmFyIGNsb3NlcnMgPSB0b2tlbi52YWx1ZS5zcGxpdCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gY2xvc2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBjdXJyZW50Q2xvc2VyID0gY2xvc2Vyc1tpXTtcbiAgICAgICAgICBzZWVuQ2xvc2VyU3RhY2sucHVzaChjdXJyZW50Q2xvc2VyKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwYXJlbi5scGFyZW5cIjpcbiAgICAgICAgdmFyIG9wZW5lcnMgPSB0b2tlbi52YWx1ZS5zcGxpdCgpO1xuICAgICAgICBmb3IgKHZhciBqID0gb3BlbmVycy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHZhciBjdXJyZW50T3BlbmVyID0gb3BlbmVyc1tqXTtcblxuICAgICAgICAgIHZhciBpc0JlZ2lubmluZ09mRnVuY3Rpb25DYWxsID1cbiAgICAgICAgICAgIHNlZW5DbG9zZXJTdGFjay5sZW5ndGggPT09IDAgJiYgY3VycmVudE9wZW5lciA9PT0gJygnO1xuICAgICAgICAgIGlmIChpc0JlZ2lubmluZ09mRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgICB2YXIgZnVuY05hbWUgPSBpdGVyYXRvci5zdGVwQmFja3dhcmQoKS52YWx1ZTtcbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgdGV4dCBcImZvby5iYXIoXCIsIHN0b3JlIFwiZm9vLmJhclwiIGFzIGZ1bGxGdW5jTmFtZSBhbmRcbiAgICAgICAgICAgIC8vIFwiKi5iYXJcIiBhcyBmdW5jTmFtZTpcbiAgICAgICAgICAgIHZhciBmdWxsRnVuY05hbWU7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNUb2tlbiA9IGl0ZXJhdG9yLnN0ZXBCYWNrd2FyZCgpO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzVG9rZW4gJiYgcHJldmlvdXNUb2tlbi52YWx1ZSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgIGZ1bGxGdW5jTmFtZSA9IGl0ZXJhdG9yLnN0ZXBCYWNrd2FyZCgpLnZhbHVlICsgJy4nICsgZnVuY05hbWU7XG4gICAgICAgICAgICAgIGZ1bmNOYW1lID0gJyouJyArIGZ1bmNOYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBmdW5jTmFtZTogZnVuY05hbWUsXG4gICAgICAgICAgICAgIGZ1bGxGdW5jTmFtZTogZnVsbEZ1bmNOYW1lLFxuICAgICAgICAgICAgICBjdXJyZW50UGFyYW1ldGVySW5kZXg6IHNhbWVEZXB0aFByZWNlZGluZ0NvbW1hQ291bnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGxhc3RDbG9zZXIgPSBzZWVuQ2xvc2VyU3RhY2sucG9wKCk7XG4gICAgICAgICAgaWYgKCFsYXN0Q2xvc2VyIHx8ICFvcGVuZXJNYXRjaGVzQ2xvc2VyKGN1cnJlbnRPcGVuZXIsIGxhc3RDbG9zZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicHVuY3R1YXRpb24ub3BlcmF0b3JcIjpcbiAgICAgICAgaWYgKHNlZW5DbG9zZXJTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAoXy5jb250YWlucyh0b2tlbi52YWx1ZSwgJzsnKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfLmNvbnRhaW5zKHRva2VuLnZhbHVlLCAnLCcpKSB7XG4gICAgICAgICAgICBzYW1lRGVwdGhQcmVjZWRpbmdDb21tYUNvdW50ICs9IGNvdW50TnVtYmVyT2ZDaGFyYWN0ZXIodG9rZW4udmFsdWUsICcsJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNvbW1lbnRcIjpcbiAgICAgIGNhc2UgXCJjb21tZW50LmRvY1wiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgIC8vIFdoaXRlc3BhY2Ugb3IgcmFuZG9tIG5vbi1pZGVudGlmaWVyIGNoYXJhY3RlcnNcbiAgICAgICAgaWYgKHNlZW5DbG9zZXJTdGFjay5sZW5ndGggIT09IDAgfHwgdG9rZW4udmFsdWUubWF0Y2goT05MWV9XSElURVNQQUNFX1JFR0VYUCkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGNhc2UgXCJzdG9yYWdlLnR5cGVcIjpcbiAgICAgIGNhc2UgXCJpZGVudGlmaWVyXCI6XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChzZWVuQ2xvc2VyU3RhY2subGVuZ3RoID09PSAwICYmIHNhbWVEZXB0aFByZWNlZGluZ0NvbW1hQ291bnQgPT09IDApIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc3Vic3RhbnRpYWwgYmV0d2VlbiBjdXJzb3IgYW5kIHN0YXJ0IG9mIHBhcmFtZXRlciBzbG90XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwQmFja3dhcmQoKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24gYW5vbnltb3VzKGxvY2FscywgZmlsdGVycywgZXNjYXBlXG4vKiovKSB7XG5lc2NhcGUgPSBlc2NhcGUgfHwgZnVuY3Rpb24gKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xudmFyIGJ1ZiA9IFtdO1xud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyBcbiBidWYucHVzaCgnPGRpdiBjbGFzcz1cImZ1bmN0aW9uLW5hbWVcIj5cXG4gICcpOzI7IGlmIChzaWduYXR1cmVPdmVycmlkZSkgezsgYnVmLnB1c2goJyAgICAnLCBlc2NhcGUoKDIsICBzaWduYXR1cmVPdmVycmlkZSApKSwgJ1xcbiAgJyk7MzsgfSBlbHNlIHtcbiAgICAvKipcbiAgICAgKiBUT0RPKGJqb3JkYW4pOiB3b3VsZCBiZSBuaWNlIHRvIHNwbGl0IHRoZSBmb2xsb3dpbmcgbGluZSB1cCwgY2FuJ3QgZmlndXJlXG4gICAgICogb3V0IGhvdyB0byBkbyBzbyB3aXRob3V0IGluc2VydGluZyBleHRyYW5lb3VzIHNwYWNlcyBiZXR3ZWVuIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICA7IGJ1Zi5wdXNoKCcgICAgJywgZXNjYXBlKCg4LCAgZnVuY3Rpb25OYW1lICkpLCAnKCcpOzg7IGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1ldGVycy5sZW5ndGg7IGkrKykgezsgYnVmLnB1c2goJzxzcGFuIGNsYXNzPVwidG9vbHRpcC1wYXJhbWV0ZXItbmFtZSAnKTs4OyBpZiAoaSA9PT0gY3VycmVudFBhcmFtZXRlckluZGV4KSB7IDsgYnVmLnB1c2goJyBjdXJyZW50LXRvb2x0aXAtcGFyYW1ldGVyLW5hbWUnKTs4OyB9IDsgYnVmLnB1c2goJ1wiPicsICg4LCAgcGFyYW1ldGVyc1tpXS5uYW1lKSwgJzwvc3Bhbj4nKTs4OyBpZiAoaSA8IHBhcmFtZXRlcnMubGVuZ3RoIC0gMSkgezsgYnVmLnB1c2goJywgJyk7ODsgfTsgYnVmLnB1c2goJycpOzg7IH07IGJ1Zi5wdXNoKCcpICAnKTs4OyB9IDsgYnVmLnB1c2goJ1xcbjwvZGl2PlxcbicpOzEwOyBpZiAocGFyYW1ldGVyc1tjdXJyZW50UGFyYW1ldGVySW5kZXhdICYmIHBhcmFtZXRlcnNbY3VycmVudFBhcmFtZXRlckluZGV4XS5kZXNjcmlwdGlvbikgeyA7IGJ1Zi5wdXNoKCc8ZGl2PicsIGVzY2FwZSgoMTAsICBwYXJhbWV0ZXJzW2N1cnJlbnRQYXJhbWV0ZXJJbmRleF0uZGVzY3JpcHRpb24gKSksICc8L2Rpdj4nKTsxMDsgfSA7IGJ1Zi5wdXNoKCdcXG4nKTsxMTsgaWYgKHBhcmFtZXRlcnNbY3VycmVudFBhcmFtZXRlckluZGV4XSAmJiBwYXJhbWV0ZXJzW2N1cnJlbnRQYXJhbWV0ZXJJbmRleF0uYXNzZXRUb29sdGlwKSB7IDsgYnVmLnB1c2goJ1xcbiAgPGRpdiBjbGFzcz1cInRvb2x0aXAtY2hvb3NlLWxpbmtcIj5cXG4gICAgPGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKTtcIj5DaG9vc2UuLi48L2E+XFxuICA8L2Rpdj5cXG4nKTsxNTsgfSA7IGJ1Zi5wdXNoKCdcXG4nKTsxNjsgaWYgKHNob3dFeGFtcGxlc0xpbmspIHsgOyBidWYucHVzaCgnXFxuICA8ZGl2IGNsYXNzPVwidG9vbHRpcC1leGFtcGxlLWxpbmtcIj5cXG4gICAgPGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKTtcIj5TZWUgZXhhbXBsZXM8L2E+XFxuICA8L2Rpdj5cXG4nKTsyMDsgfSA7IGJ1Zi5wdXNoKCdcXG4nKTsgfSkoKTtcbn0gXG5yZXR1cm4gYnVmLmpvaW4oJycpO1xufTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxvY2Fscykge1xuICAgIHJldHVybiB0KGxvY2FscywgcmVxdWlyZShcImVqc1wiKS5maWx0ZXJzKTtcbiAgfVxufSgpKTsiLCIvKipcbiAqIEBvdmVydmlldyBoZWxwZXIgY2xhc3MgdG8gbWFuYWdlIHRoZSBzdGF0ZSBvZiB0aGUgQXV0aG9yZWQgSGludCBVSS5cbiAqIFVzZWQgZXhjbHVzaXZlbHkgYnkgU3R1ZGlvQXBwLlxuICovXG5cbnZhciBkb20gPSByZXF1aXJlKCcuL2RvbScpO1xudmFyIG1zZyA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG52YXIgSGludFNlbGVjdCA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL0hpbnRTZWxlY3QuanN4Jyk7XG52YXIgSGludHNEaXNwbGF5ID0gcmVxdWlyZSgnLi90ZW1wbGF0ZXMvSGludHNEaXNwbGF5LmpzeCcpO1xudmFyIGF1dGhvcmVkSGludFV0aWxzID0gcmVxdWlyZSgnLi9hdXRob3JlZEhpbnRVdGlscycpO1xudmFyIGxpZ2h0YnVsYlNWRyA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL2xpZ2h0YnVsYi5zdmcuZWpzJykoKTtcbnZhciBsaWdodGJ1bGJEaW1TVkcgPSByZXF1aXJlKCcuL3RlbXBsYXRlcy9saWdodGJ1bGJfZGltLnN2Zy5lanMnKSgpO1xuXG52YXIgQXV0aG9yZWRIaW50cyA9IGZ1bmN0aW9uIChzdHVkaW9BcHApIHtcbiAgdGhpcy5zdHVkaW9BcHBfID0gc3R1ZGlvQXBwO1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBBdXRob3JlZEhpbnRcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRlbnRcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGhpbnRJZFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gaGludENsYXNzXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBoaW50VHlwZVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGFscmVhZHlTZWVuXG4gICAqL1xuICAvKipcbiAgICogQHR5cGUgeyFBdXRob3JlZEhpbnRbXX1cbiAgICovXG4gIHRoaXMuaGludHNfID0gW107XG4gIHRoaXMuY29udGV4dHVhbEhpbnRzXyA9IFtdO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5zY3JwdElkXyA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMubGV2ZWxJZF8gPSB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtFbGVtZW50fVxuICAgKi9cbiAgdGhpcy5saWdodGJ1bGIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5saWdodGJ1bGIuaWQgPSBcImxpZ2h0YnVsYlwiO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdXRob3JlZEhpbnRzO1xuXG4vKipcbiAqIEByZXR1cm4ge0F1dGhvcmVkSGludHNbXX1cbiAqL1xuQXV0aG9yZWRIaW50cy5wcm90b3R5cGUuZ2V0VW5zZWVuSGludHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoaW50cyA9IHRoaXMuY29udGV4dHVhbEhpbnRzXy5jb25jYXQodGhpcy5oaW50c18gfHwgW10pO1xuICByZXR1cm4gaGludHMuZmlsdGVyKGZ1bmN0aW9uIChoaW50KSB7XG4gICAgcmV0dXJuIGhpbnQuYWxyZWFkeVNlZW4gPT09IGZhbHNlO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7QXV0aG9yZWRIaW50c1tdfVxuICovXG5BdXRob3JlZEhpbnRzLnByb3RvdHlwZS5nZXRTZWVuSGludHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoaW50cyA9IHRoaXMuY29udGV4dHVhbEhpbnRzXy5jb25jYXQodGhpcy5oaW50c18gfHwgW10pO1xuICByZXR1cm4gaGludHMuZmlsdGVyKGZ1bmN0aW9uIChoaW50KSB7XG4gICAgcmV0dXJuIGhpbnQuYWxyZWFkeVNlZW4gPT09IHRydWU7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGNvbnRleHR1YWwgaGludHMgZm9yIHRoZSBzcGVjaWZpZWQgYmxvY2tzIGFuZCBhZGRzIHRoZW0gdG9cbiAqIHRoZSBxdWV1ZSBvZiBoaW50cyB0byBkaXNwbGF5LiBUcmlnZ2VycyBhbiBhbmltYXRpb24gb24gdGhlIGhpbnRcbiAqIGxpZ2h0YnVsYiBpZiB0aGUgcXVldWUgaGFzIGNoYW5nZWQuXG4gKiBAcGFyYW0ge09iamVjdFtdfSBibG9ja3MgQHNlZSBhdXRob3JlZEhpbnRVdGlscy5jcmVhdGVDb250ZXh0dWFsSGludHNGcm9tQmxvY2tzXG4gKi9cbkF1dGhvcmVkSGludHMucHJvdG90eXBlLmRpc3BsYXlNaXNzaW5nQmxvY2tIaW50cyA9IGZ1bmN0aW9uIChibG9ja3MpIHtcbiAgdmFyIG5ld0NvbnRleHR1YWxIaW50cyA9IGF1dGhvcmVkSGludFV0aWxzLmNyZWF0ZUNvbnRleHR1YWxIaW50c0Zyb21CbG9ja3MoYmxvY2tzKTtcblxuICAvLyBpZiB0aGUgc2V0IG9mIGNvbnRleHR1YWwgaGludHMgY3VycmVudGx5IGJlaW5nIHNob3duIGhhcyBjaGFuZ2VkLFxuICAvLyBhbmltYXRlIHRoZSBoaW50IGRpc3BsYXkgbGlnaHRidWxiIHdoZW4gd2UgdXBkYXRlIGl0LlxuICB2YXIgb2xkQ29udGV4dHVhbEhpbnRzID0gdGhpcy5jb250ZXh0dWFsSGludHNfLmZpbHRlcihmdW5jdGlvbiAoaGludCkge1xuICAgIHJldHVybiBoaW50LmFscmVhZHlTZWVuID09PSBmYWxzZTtcbiAgfSk7XG4gIHZhciBhbmltYXRlTGlnaHRidWxiID0gb2xkQ29udGV4dHVhbEhpbnRzLmxlbmd0aCAhPT0gbmV3Q29udGV4dHVhbEhpbnRzLmxlbmd0aDtcblxuICB0aGlzLmNvbnRleHR1YWxIaW50c18gPSBuZXdDb250ZXh0dWFsSGludHM7XG4gIHRoaXMudXBkYXRlTGlnaHRidWxiRGlzcGxheV8oYW5pbWF0ZUxpZ2h0YnVsYik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICovXG5BdXRob3JlZEhpbnRzLnByb3RvdHlwZS5maW5pc2hIaW50cyA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICBhdXRob3JlZEhpbnRVdGlscy5maW5pc2hIaW50cyh7XG4gICAgdGltZTogKChuZXcgRGF0ZSgpLmdldFRpbWUoKSkgLSB0aGlzLnN0dWRpb0FwcF8uaW5pdFRpbWUpLFxuICAgIGF0dGVtcHQ6IHRoaXMuc3R1ZGlvQXBwXy5hdHRlbXB0cyxcbiAgICB0ZXN0UmVzdWx0OiB0aGlzLnN0dWRpb0FwcF8ubGFzdFRlc3RSZXN1bHQsXG4gICAgYWN0aXZpdHlJZDogcmVzcG9uc2UgJiYgcmVzcG9uc2UuYWN0aXZpdHlfaWQsXG4gICAgbGV2ZWxTb3VyY2VJZDogcmVzcG9uc2UgJiYgcmVzcG9uc2UubGV2ZWxfc291cmNlX2lkLFxuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICovXG5BdXRob3JlZEhpbnRzLnByb3RvdHlwZS5zdWJtaXRIaW50cyA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgYXV0aG9yZWRIaW50VXRpbHMuc3VibWl0SGludHModXJsKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBdXRob3JlZEhpbnRbXX0gaGludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzY3JpcHRJZFxuICogQHBhcmFtIHtudW1iZXJ9IGxldmVsSWRcbiAqL1xuQXV0aG9yZWRIaW50cy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChoaW50cywgc2NyaXB0SWQsIGxldmVsSWQpIHtcbiAgdGhpcy5oaW50c18gPSBoaW50cztcbiAgdGhpcy5zY3JpcHRJZF8gPSBzY3JpcHRJZDtcbiAgdGhpcy5sZXZlbElkXyA9IGxldmVsSWQ7XG59O1xuXG4vKipcbiAqIFNldHMgdXAgdGhlIEF1dGhvcmVkIEhpbnRzIFVJOyBkZWNvcmF0ZXMgdGhlIHNwZWNpZmllZCBlbGVtZW50IHdpdGggYVxuICogbGlnaHRidWxiIGltYWdlIGFuZCBoaW50IGNvdW50ZXIsIGFuZCBhZGRzIGEgY2xpY2sgaGFuZGxlciB0byBzaG93XG4gKiBhIHF0aXAgZm9yIHRoZSBuZXh0IHVuc2VlbiBoaW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gcHJvbXB0SWNvbiAtIHRoZSBwYWdlIGVsZW1lbnQgdG8gXCJkZWNvcmF0ZVwiIHdpdGggdGhlXG4gKiAgICAgICAgbGlnaHRidWxiXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNsaWNrVGFyZ2V0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIGEgU3R1ZGlvQXBwIGZ1bmN0aW9uIHRvIGJlIHRyZWF0ZWQgYXNcbiAqICAgICAgICB0aGUgXCJkZWZhdWx0XCIgYWN0aW9uIHdoZW4gdGhlcmUgYXJlIG5vIHVuc2VlbiBoaW50cy4gXG4gKi9cbkF1dGhvcmVkSGludHMucHJvdG90eXBlLmRpc3BsYXkgPSBmdW5jdGlvbiAocHJvbXB0SWNvbiwgY2xpY2tUYXJnZXQsIGNhbGxiYWNrKSB7XG4gIHRoaXMucHJvbXB0SWNvbiA9IHByb21wdEljb247XG4gIHRoaXMudXBkYXRlTGlnaHRidWxiRGlzcGxheV8oKTtcbiAgY2xpY2tUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhpbnRzVG9TaG93ID0gdGhpcy5nZXRVbnNlZW5IaW50cygpO1xuICAgIGlmIChoaW50c1RvU2hvdy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNob3dIaW50XyhoaW50c1RvU2hvd1swXSwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogTW9zdGx5IGEgcGFzc3Rocm91Z2ggdG8gYXV0aG9yZWRIaW50VXRpbHMucmVjb3JkVW5maW5pc2hlZEhpbnQuIEFsc29cbiAqIG1hcmtzIHRoZSBnaXZlbiBoaW50IGFzIHNlZW4uXG4gKiBAcGFyYW0ge0F1dGhvcmVkSGludH0gaGludFxuICovXG5BdXRob3JlZEhpbnRzLnByb3RvdHlwZS5yZWNvcmRVc2VyVmlld2VkSGludF8gPSBmdW5jdGlvbiAoaGludCkge1xuICBoaW50LmFscmVhZHlTZWVuID0gdHJ1ZTtcbiAgdGhpcy51cGRhdGVMaWdodGJ1bGJEaXNwbGF5XygpO1xuXG4gIGF1dGhvcmVkSGludFV0aWxzLnJlY29yZFVuZmluaXNoZWRIaW50KHtcbiAgICAvLyBsZXZlbCBpbmZvXG4gICAgc2NyaXB0SWQ6IHRoaXMuc2NyaXB0SWRfLFxuICAgIGxldmVsSWQ6IHRoaXMubGV2ZWxJZF8sXG5cbiAgICAvLyBoaW50IGluZm9cbiAgICBoaW50SWQ6IGhpbnQuaGludElkLFxuICAgIGhpbnRDbGFzczogaGludC5oaW50Q2xhc3MsXG4gICAgaGludFR5cGU6IGhpbnQuaGludFR5cGUsXG4gIH0pO1xufTtcblxuLyoqXG4gKiBBZGp1c3RzIHRoZSBkaXNwbGF5ZWQgbnVtYmVyIG9mIHVuc2VlbiBoaW50cy4gRGltcyB0aGUgbGlnaHRidWxiXG4gKiBpbWFnZSBpZiB0aGVyZSBhcmUgbm8gaGludHMuIE9wdGlvbmFsbHkgcGxheXMgYSBzaW1wbGUgQ1NTIGFuaW1hdGlvblxuICogdG8gaGlnaGxpZ2h0IHRoZSB1cGRhdGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFuaW1hdGUgZGVmYXVsdHMgdG8gZmFsc2VcbiAqL1xuQXV0aG9yZWRIaW50cy5wcm90b3R5cGUudXBkYXRlTGlnaHRidWxiRGlzcGxheV8gPSBmdW5jdGlvbiAoYW5pbWF0ZSkge1xuICBhbmltYXRlID0gYW5pbWF0ZSB8fCBmYWxzZTtcblxuICB2YXIgaGludENvdW50ID0gdGhpcy5nZXRVbnNlZW5IaW50cygpLmxlbmd0aDsgXG5cbiAgLy8gSWYgd2UgaGF2ZSBoaW50cyB0byBzaG93LCBidXQgYXJlIG5vdCBpbiB0aGUgRE9NLCBpbnNlcnQgb3Vyc2VsdmVzXG4gIC8vIGludG8gdGhlIERPTS4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gY29udGV4dHVhbCBoaW50cyBhcHBlYXIgaW4gYVxuICAvLyBsZXZlbCB0aGF0IHdhcyBpbml0aWFsaXplZCB3aXRoIG5vIGhpbnRzLiBOb3RlIHRoYXQgd2UgY2FuIGJlIGluXG4gIC8vIHRoZSBET00gYW5kIGhhdmUgemVybyBoaW50cyB0byBzaG93LCBhbmQgdGhhdCdzIGp1c3QgZmluZS5cbiAgaWYgKGhpbnRDb3VudCA+IDAgJiYgIWRvY3VtZW50LmJvZHkuY29udGFpbnModGhpcy5saWdodGJ1bGIpKSB7XG4gICAgdGhpcy5wcm9tcHRJY29uLnBhcmVudE5vZGUuY2xhc3NOYW1lICs9ICcgYXV0aG9yZWRfaGludHMnO1xuICAgIHRoaXMucHJvbXB0SWNvbi5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmxpZ2h0YnVsYiwgdGhpcy5wcm9tcHRJY29uKTtcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGFyZSBtb3JlIHRoYW4gbmluZSBoaW50cywgc2ltcGx5IGRpc3BsYXkgXCI5K1wiXG4gIHZhciBoaW50VGV4dCA9IChoaW50Q291bnQgPiA5KSA/IFwiOStcIiA6IGhpbnRDb3VudDtcbiAgaWYgKGhpbnRDb3VudCA9PT0gMCkge1xuICAgIHRoaXMubGlnaHRidWxiLmlubmVySFRNTCA9IGxpZ2h0YnVsYkRpbVNWRztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxpZ2h0YnVsYi5pbm5lckhUTUwgPSBsaWdodGJ1bGJTVkc7XG4gICAgdGhpcy5saWdodGJ1bGIucXVlcnlTZWxlY3RvcignI2hpbnRDb3VudCcpLnRleHRDb250ZW50ID0gaGludFRleHQ7XG4gIH1cblxuICB2YXIgYnVsYiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYnVsYlwiKTtcbiAgaWYgKGFuaW1hdGUgJiYgYnVsYikge1xuICAgIGJ1bGIuc2V0QXR0cmlidXRlKCdjbGFzcycsICdhbmltYXRlLWhpbnQnKTtcbiAgfVxufTtcblxuQXV0aG9yZWRIaW50cy5wcm90b3R5cGUuZ2V0SGludHNEaXNwbGF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGludHNEaXNwbGF5ID0gUmVhY3QuY3JlYXRlRWxlbWVudChIaW50c0Rpc3BsYXksIHtcbiAgICBoaW50UmV2aWV3VGl0bGU6IG1zZy5oaW50UmV2aWV3VGl0bGUoKSxcbiAgICBzZWVuSGludHM6IHRoaXMuZ2V0U2VlbkhpbnRzKCksXG4gICAgdW5zZWVuSGludHM6IHRoaXMuZ2V0VW5zZWVuSGludHMoKSxcbiAgICBsaWdodGJ1bGJTVkc6IGxpZ2h0YnVsYlNWRyxcbiAgICBvblVzZXJWaWV3ZWRIaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmV4dEhpbnQgPSB0aGlzLmdldFVuc2VlbkhpbnRzKClbMF07XG4gICAgICB0aGlzLnJlY29yZFVzZXJWaWV3ZWRIaW50XyhuZXh0SGludCk7XG4gICAgfS5iaW5kKHRoaXMpXG4gIH0pO1xuXG4gIHJldHVybiBoaW50c0Rpc3BsYXk7XG59O1xuXG4vKipcbiAqIFJlbmRlciBhIHF0aXAgcG9wdXAgY29udGFpbmluZyBhbiBpbnRlcmZhY2Ugd2hpY2ggZ2l2ZXMgdGhlIHVzZXIgdGhlXG4gKiBvcHRpb24gb2Ygdmlld2luZyB0aGUgaW5zdHJ1Y3Rpb25zIGZvciB0aGUgbGV2ZWwgKGFsb25nIHdpdGggYWxsXG4gKiBwcmV2aW91c2x5LXZpZXdlZCBoaW50cykgb3Igdmlld2luZyBhIG5ldyBoaW50LlxuICogQHBhcmFtIHtBdXRob3JlZEhpbnR9IGhpbnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbkF1dGhvcmVkSGludHMucHJvdG90eXBlLnNob3dIaW50XyA9IGZ1bmN0aW9uIChoaW50LCBjYWxsYmFjaykge1xuICAkKCcjcHJvbXB0LWljb24nKS5xdGlwKHtcbiAgICBjb250ZW50OiB7XG4gICAgICB0ZXh0OiBmdW5jdGlvbihodG1sLCBhcGkpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgIHZhciBlbGVtZW50ID0gUmVhY3QuY3JlYXRlRWxlbWVudChIaW50U2VsZWN0LCB7XG4gICAgICAgICAgc2hvd0luc3RydWN0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXBpLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfS5iaW5kKHRoaXMpLFxuICAgICAgICAgIHNob3dIaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaGludC5ibG9jaykge1xuICAgICAgICAgICAgICB2YXIgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICBjb250ZW50LmlubmVySFRNTCA9IGhpbnQuY29udGVudDtcbiAgICAgICAgICAgICAgdmFyIGJsb2NrQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgIGJsb2NrQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICcxMDBweCc7XG4gICAgICAgICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoYmxvY2tDb250YWluZXIpO1xuICAgICAgICAgICAgICBhcGkuc2V0KCdjb250ZW50LnRleHQnLCBjb250ZW50KTtcblxuICAgICAgICAgICAgICBCbG9ja2x5LkJsb2NrU3BhY2UuY3JlYXRlUmVhZE9ubHlCbG9ja1NwYWNlKGJsb2NrQ29udGFpbmVyLCBoaW50LmJsb2NrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFwaS5zZXQoJ2NvbnRlbnQudGV4dCcsIGhpbnQuY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKGFwaS5lbGVtZW50cy5jb250ZW50KS5maW5kKCdpbWcnKS5vbignbG9hZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGFwaS5yZXBvc2l0aW9uKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlY29yZFVzZXJWaWV3ZWRIaW50XyhoaW50KTtcbiAgICAgICAgICB9LmJpbmQodGhpcyksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIFJlYWN0RE9NLnJlbmRlcihlbGVtZW50LCBjb250YWluZXIpO1xuXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgICB9LmJpbmQodGhpcyksXG4gICAgICB0aXRsZToge1xuICAgICAgICBidXR0b246ICQoJzxkaXYgY2xhc3M9XCJ0b29sdGlwLXgtY2xvc2VcIi8+JylcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0eWxlOiB7XG4gICAgICBjbGFzc2VzOiBcImNkby1xdGlwc1wiLFxuICAgICAgdGlwOiB7XG4gICAgICAgIHdpZHRoOiAyMCxcbiAgICAgICAgaGVpZ2h0OiAyMFxuICAgICAgfVxuICAgIH0sXG4gICAgcG9zaXRpb246IHtcbiAgICAgIG15OiBcImJvdHRvbSBsZWZ0XCIsXG4gICAgICBhdDogXCJ0b3AgcmlnaHRcIlxuICAgIH0sXG4gICAgaGlkZToge1xuICAgICAgZXZlbnQ6ICd1bmZvY3VzJ1xuICAgIH0sXG4gICAgc2hvdzogZmFsc2UgLy8gZG9uJ3Qgc2hvdyBvbiBtb3VzZW92ZXJcbiAgfSkucXRpcCgnc2hvdycpO1xufTtcblxuIiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCc8c3ZnIHZlcnNpb249XCIxLjFcIlxcblx0IGlkPVwic3ZnMzAxM1wiIGlua3NjYXBlOnZlcnNpb249XCIwLjQ4LjMuMSByOTg4NlwiIHNvZGlwb2RpOmRvY25hbWU9XCJsaWdodF9idWxiX2ZvbnRfYXdlc29tZS5zdmdcIiB4bWxuczppbmtzY2FwZT1cImh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGVcIiB4bWxuczpyZGY9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjXCIgeG1sbnM6c29kaXBvZGk9XCJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZFwiIHhtbG5zOmNjPVwiaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjXCIgeG1sbnM6c3ZnPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczpkYz1cImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXCJcXG5cdCB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeD1cIjBweFwiIHk9XCIwcHhcIiB3aWR0aD1cIjQwcHhcIiBoZWlnaHQ9XCI0MHB4XCJcXG5cdCB2aWV3Qm94PVwiMCAwIDYxMiA3OTJcIiBlbmFibGUtYmFja2dyb3VuZD1cIm5ldyAwIDAgNjEyIDc5MlwiIHhtbDpzcGFjZT1cInByZXNlcnZlXCI+XFxuPHNvZGlwb2RpOm5hbWVkdmlldyAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9XCIwXCIgaW5rc2NhcGU6d2luZG93LXdpZHRoPVwiNjQwXCIgaW5rc2NhcGU6cGFnZXNoYWRvdz1cIjJcIiBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PVwiNDgwXCIgaW5rc2NhcGU6d2luZG93LXg9XCIwXCIgaW5rc2NhcGU6d2luZG93LXk9XCIyNVwiIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9XCIwXCIgaW5rc2NhcGU6Y3VycmVudC1sYXllcj1cInN2ZzMwMTNcIiBndWlkZXRvbGVyYW5jZT1cIjEwXCIgcGFnZWNvbG9yPVwiI2ZmZmZmZlwiIG9iamVjdHRvbGVyYW5jZT1cIjEwXCIgZ3JpZHRvbGVyYW5jZT1cIjEwXCIgc2hvd2dyaWQ9XCJmYWxzZVwiIGlua3NjYXBlOmN4PVwiODk2XCIgaW5rc2NhcGU6Y3k9XCI4OTZcIiBib3JkZXJvcGFjaXR5PVwiMVwiIGJvcmRlcmNvbG9yPVwiIzY2NjY2NlwiIGlua3NjYXBlOnpvb209XCIwLjEzMTY5NjQzXCIgaWQ9XCJuYW1lZHZpZXczMDE5XCI+XFxuXHQ8L3NvZGlwb2RpOm5hbWVkdmlldz5cXG48cGF0aCBmaWxsPVwiI0M5QzlDOVwiIGQ9XCJNNDUzLjc3NSwzNTMuMTU2YzAsMjQuMDEyLTU3LjE4OSwxMjguOTQyLTYxLjQxNCwxMzIuMjY1Yy0xMi4zODQsOS43NDEtNDguNTE0LDE1LjMxOC04Mi44NjksMTYuNTE4XFxuXHRjLTguMzYyLDAuMjkyLTE2LjYxOSwwLjMyNS0yNC40MDMsMC4wOTZjLTIwLjcxNi0wLjYxMS0zOC4wODEtMy4wNzktNDUuMTU1LTcuNDY0Yy02Ljg5Ni00LjI3NC03NC40NzctMTE5LjI0LTc0LjQ3Ny0xNDEuNDE1XFxuXHRjMC04OS4xOTUsNjQuNTQyLTE2MS41MDIsMTQ0LjE1OS0xNjEuNTAyUzQ1My43NzUsMjYzLjk2MSw0NTMuNzc1LDM1My4xNTZ6XCIvPlxcbjxnIGlkPVwiZzMwMTVcIiB0cmFuc2Zvcm09XCJtYXRyaXgoMSwwLDAsLTEsMzc5LjY2MTAyLDEyOTMuMDE2OSlcIj5cXG5cdDxwYXRoIGlkPVwicGF0aDMwMTdcIiBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPVwiMFwiIGZpbGw9XCIjNUQ1RDVEXCIgZD1cIk03LjM1Nyw5ODAuODU3YzAtMi45Ni0xLjA4MS01LjUyMS0zLjI0NC03LjY4NFxcblx0XHRzLTQuNzI0LTMuMjQ0LTcuNjg0LTMuMjQ0cy01LjUyMSwxLjA4MS03LjY4NCwzLjI0NHMtMy4yNDQsNC43MjQtMy4yNDQsNy42ODRjMCwxMC40NzMtNi4xNDcsMTguNTU2LTE4LjQ0MiwyNC4yNDhcXG5cdFx0Yy0xMi4yOTUsNS42OTItMjQuMzYyLDguNTM4LTM2LjIwMSw4LjUzOGMtMi45NiwwLTUuNTIxLDEuMDgxLTcuNjg0LDMuMjQ0cy0zLjI0NCw0LjcyNC0zLjI0NCw3LjY4NFxcblx0XHRjMCwyLjk2LDEuMDgxLDUuNTIxLDMuMjQ0LDcuNjg0czQuNzI0LDMuMjQ0LDcuNjg0LDMuMjQ0YzExLjM4NCwwLDIyLjcxMS0xLjgyMSwzMy45ODEtNS40NjRzMjEuMTc0LTkuNzksMjkuNzEyLTE4LjQ0Mlxcblx0XHRTNy4zNTcsOTkyLjY5Niw3LjM1Nyw5ODAuODU3eiBNNjIsOTgwLjg1N2MwLDE2LjM5My0zLjkyNywzMS42NDctMTEuNzgyLDQ1Ljc2M3MtMTguMSwyNS42NzEtMzAuNzM3LDM0LjY2NFxcblx0XHRzLTI2LjYzOCwxNi4wNTEtNDIuMDA3LDIxLjE3NHMtMzAuOTA3LDcuNjg0LTQ2LjYxNyw3LjY4NHMtMzEuMjQ5LTIuNTYxLTQ2LjYxNy03LjY4NHMtMjkuMzcxLTEyLjE4MS00Mi4wMDctMjEuMTc0XFxuXHRcdGMtMTIuNjM2LTguOTkzLTIyLjg4Mi0yMC41NDgtMzAuNzM3LTM0LjY2NGMtNy44NTUtMTQuMTE2LTExLjc4Mi0yOS4zNzEtMTEuNzgyLTQ1Ljc2M2MwLTIyLjk5Niw3Ljc0MS00My40ODcsMjMuMjIzLTYxLjQ3M1xcblx0XHRjMi4yNzctMi41MDQsNS43NDktNi4yNjEsMTAuNDE2LTExLjI3YzQuNjY3LTUuMDA5LDguMTQtOC43NjYsMTAuNDE2LTExLjI3YzI5LjE0My0zNC44MzUsNDUuMTk0LTY4Ljc1OSw0OC4xNTQtMTAxLjc3Mmg3Ny44NjZcXG5cdFx0YzIuOTYsMzMuMDEzLDE5LjAxMSw2Ni45MzgsNDguMTU0LDEwMS43NzJjMi4yNzcsMi41MDQsNS43NDksNi4yNjEsMTAuNDE2LDExLjI3czguMTQsOC43NjYsMTAuNDE2LDExLjI3XFxuXHRcdEM1NC4yNTksOTM3LjM3LDYyLDk1Ny44NjIsNjIsOTgwLjg1N3ogTTEwNS43MTQsOTgwLjg1N2MwLTM1LjI5LTExLjcyNS02NS43OTktMzUuMTc2LTkxLjUyN1xcblx0XHRjLTEwLjI0Ni0xMS4xNTYtMTguNzI3LTIxLjA2LTI1LjQ0My0yOS43MTJzLTEzLjQ5LTE5LjUyMy0yMC4zMi0zMi42MTVjLTYuODMtMTMuMDkyLTEwLjcwMS0yNS4zMjktMTEuNjEyLTM2LjcxM1xcblx0XHRjMTAuNzAxLTYuMzc1LDE2LjA1MS0xNS43MSwxNi4wNTEtMjguMDA0YzAtOC40MjQtMi44NDYtMTUuNzEtOC41MzgtMjEuODU3YzUuNjkyLTYuMTQ3LDguNTM4LTEzLjQzMyw4LjUzOC0yMS44NTdcXG5cdFx0YzAtMTEuODM5LTUuMTIzLTIxLjA2LTE1LjM2OC0yNy42NjNjMi45Ni01LjIzNyw0LjQ0LTEwLjU4Nyw0LjQ0LTE2LjA1MWMwLTEwLjQ3My0zLjU4Ni0xOC41NTYtMTAuNzU4LTI0LjI0OFxcblx0XHRzLTE1Ljk5NC04LjUzOC0yNi40NjgtOC41MzhjLTQuNTU0LTEwLjAxOC0xMS4zODQtMTcuOTg3LTIwLjQ5MS0yMy45MDZjLTkuMTA3LTUuOTItMTkuMDExLTguODc5LTI5LjcxMi04Ljg3OVxcblx0XHRjLTEwLjcwMSwwLTIwLjYwNSwyLjk2LTI5LjcxMiw4Ljg3OWMtOS4xMDcsNS45Mi0xNS45MzgsMTMuODg4LTIwLjQ5MSwyMy45MDZjLTEwLjQ3MywwLTE5LjI5NiwyLjg0Ni0yNi40NjgsOC41MzhcXG5cdFx0cy0xMC43NTgsMTMuNzc1LTEwLjc1OCwyNC4yNDhjMCw1LjQ2NCwxLjQ4LDEwLjgxNSw0LjQ0LDE2LjA1MWMtMTAuMjQ2LDYuNjAzLTE1LjM2OCwxNS44MjQtMTUuMzY4LDI3LjY2M1xcblx0XHRjMCw4LjQyNCwyLjg0NiwxNS43MSw4LjUzOCwyMS44NTdjLTUuNjkyLDYuMTQ3LTguNTM4LDEzLjQzMy04LjUzOCwyMS44NTdjMCwxMi4yOTUsNS4zNSwyMS42MjksMTYuMDUxLDI4LjAwNFxcblx0XHRjLTAuOTExLDExLjM4NC00Ljc4MSwyMy42MjItMTEuNjEyLDM2LjcxM2MtNi44MywxMy4wOTEtMTMuNjA0LDIzLjk2My0yMC4zMiwzMi42MTVzLTE1LjE5OCwxOC41NTYtMjUuNDQzLDI5LjcxMlxcblx0XHRDLTIzMi4yNzUsOTE1LjA1OC0yNDQsOTQ1LjU2Ny0yNDQsOTgwLjg1N2MwLDIyLjU0LDUuMDY2LDQzLjU0NCwxNS4xOTgsNjMuMDFjMTAuMTMyLDE5LjQ2NywyMy40NTEsMzUuNjMyLDM5Ljk1OCw0OC40OTZcXG5cdFx0YzE2LjUwNywxMi44NjQsMzUuMTc2LDIyLjk5NSw1Ni4wMDksMzAuMzk1czQyLjA2NCwxMS4wOTksNjMuNjkzLDExLjA5OXM0Mi44Ni0zLjcsNjMuNjkzLTExLjA5OXMzOS41MDItMTcuNTMxLDU2LjAwOS0zMC4zOTVcXG5cdFx0YzE2LjUwNy0xMi44NjQsMjkuODI2LTI5LjAyOSwzOS45NTgtNDguNDk2QzEwMC42NDgsMTAyNC40MDEsMTA1LjcxNCwxMDAzLjM5NywxMDUuNzE0LDk4MC44NTd6XCIvPlxcbjwvZz5cXG48cGF0aCBmaWxsPVwiI0VGQjgzNFwiIGQ9XCJNMTUzOC43NzUtMTg3Ljg0NGMwLDI0LjAxMi01Ny4xODksMTI4Ljk0Mi02MS40MTQsMTMyLjI2NWMtMTIuMzg0LDkuNzQxLTQ4LjUxNCwxNS4zMTgtODIuODY5LDE2LjUxOFxcblx0Yy04LjM2MiwwLjI5Mi0xNi42MTksMC4zMjUtMjQuNDAzLDAuMDk2Yy0yMC43MTYtMC42MTEtMzguMDgxLTMuMDc5LTQ1LjE1NS03LjQ2NGMtNi44OTYtNC4yNzQtNzQuNDc3LTExOS4yNC03NC40NzctMTQxLjQxNVxcblx0YzAtODkuMTk1LDY0LjU0Mi0xNjEuNTAyLDE0NC4xNTktMTYxLjUwMlMxNTM4Ljc3NS0yNzcuMDM5LDE1MzguNzc1LTE4Ny44NDR6XCIvPlxcbjxnIGlkPVwiZzMwMTVfMV9cIiB0cmFuc2Zvcm09XCJtYXRyaXgoMSwwLDAsLTEsMzc5LjY2MTAyLDEyOTMuMDE2OSlcIj5cXG5cdDxwYXRoIGlkPVwicGF0aDMwMTdfMV9cIiBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPVwiMFwiIGZpbGw9XCIjNUQ1RDVEXCIgZD1cIk0xMDkyLjM1NywxNTIxLjg1N2MwLTIuOTYtMS4wODItNS41MjEtMy4yNDQtNy42ODRcXG5cdFx0Yy0yLjE2My0yLjE2My00LjcyNC0zLjI0NS03LjY4NC0zLjI0NXMtNS41MjEsMS4wODItNy42ODQsMy4yNDVjLTIuMTYzLDIuMTYzLTMuMjQ0LDQuNzI0LTMuMjQ0LDcuNjg0XFxuXHRcdGMwLDEwLjQ3My02LjE0NywxOC41NTYtMTguNDQyLDI0LjI0OGMtMTIuMjk1LDUuNjkyLTI0LjM2Miw4LjUzOC0zNi4yMDEsOC41MzhjLTIuOTYsMC01LjUyMSwxLjA4MS03LjY4NCwzLjI0NFxcblx0XHRjLTIuMTYzLDIuMTYzLTMuMjQ0LDQuNzI0LTMuMjQ0LDcuNjg0YzAsMi45NiwxLjA4MSw1LjUyMSwzLjI0NCw3LjY4NGMyLjE2MywyLjE2Myw0LjcyNCwzLjI0NCw3LjY4NCwzLjI0NFxcblx0XHRjMTEuMzg0LDAsMjIuNzExLTEuODIxLDMzLjk4MS01LjQ2NGMxMS4yNy0zLjY0MywyMS4xNzQtOS43OSwyOS43MTItMTguNDQyXFxuXHRcdEMxMDg4LjA4OCwxNTQzLjk0MiwxMDkyLjM1NywxNTMzLjY5NiwxMDkyLjM1NywxNTIxLjg1N3ogTTExNDcsMTUyMS44NTdjMCwxNi4zOTMtMy45MjcsMzEuNjQ3LTExLjc4Miw0NS43NjNcXG5cdFx0cy0xOC4xLDI1LjY3MS0zMC43MzcsMzQuNjY0Yy0xMi42MzYsOC45OTMtMjYuNjM4LDE2LjA1MS00Mi4wMDcsMjEuMTc0cy0zMC45MDcsNy42ODQtNDYuNjE3LDcuNjg0cy0zMS4yNDktMi41NjEtNDYuNjE3LTcuNjg0XFxuXHRcdGMtMTUuMzY4LTUuMTIzLTI5LjM3MS0xMi4xODEtNDIuMDA3LTIxLjE3NHMtMjIuODgyLTIwLjU0OC0zMC43MzctMzQuNjY0cy0xMS43ODItMjkuMzcxLTExLjc4Mi00NS43NjNcXG5cdFx0YzAtMjIuOTk1LDcuNzQxLTQzLjQ4NywyMy4yMjMtNjEuNDczYzIuMjc3LTIuNTA1LDUuNzQ5LTYuMjYxLDEwLjQxNi0xMS4yN3M4LjEzOS04Ljc2NiwxMC40MTYtMTEuMjdcXG5cdFx0YzI5LjE0My0zNC44MzUsNDUuMTk0LTY4Ljc1OSw0OC4xNTQtMTAxLjc3Mmg3Ny44NjZjMi45NiwzMy4wMTMsMTkuMDExLDY2LjkzOCw0OC4xNTQsMTAxLjc3Mlxcblx0XHRjMi4yNzcsMi41MDUsNS43NDksNi4yNjEsMTAuNDE2LDExLjI3YzQuNjY3LDUuMDA5LDguMTQsOC43NjYsMTAuNDE2LDExLjI3QzExMzkuMjU5LDE0NzguMzcsMTE0NywxNDk4Ljg2MiwxMTQ3LDE1MjEuODU3elxcblx0XHQgTTExOTAuNzE0LDE1MjEuODU3YzAtMzUuMjktMTEuNzI1LTY1Ljc5OS0zNS4xNzYtOTEuNTI3Yy0xMC4yNDUtMTEuMTU2LTE4LjcyNy0yMS4wNi0yNS40NDMtMjkuNzEyXFxuXHRcdGMtNi43MTctOC42NTItMTMuNDktMTkuNTI0LTIwLjMyLTMyLjYxNWMtNi44My0xMy4wOTItMTAuNzAxLTI1LjMyOS0xMS42MTItMzYuNzEzYzEwLjcwMS02LjM3NSwxNi4wNTEtMTUuNzEsMTYuMDUxLTI4LjAwNVxcblx0XHRjMC04LjQyNC0yLjg0Ni0xNS43MS04LjUzOC0yMS44NTdjNS42OTItNi4xNDcsOC41MzgtMTMuNDMzLDguNTM4LTIxLjg1N2MwLTExLjgzOS01LjEyMy0yMS4wNi0xNS4zNjgtMjcuNjYzXFxuXHRcdGMyLjk2LTUuMjM3LDQuNDQtMTAuNTg3LDQuNDQtMTYuMDUxYzAtMTAuNDczLTMuNTg2LTE4LjU1Ni0xMC43NTgtMjQuMjQ4Yy03LjE3Mi01LjY5Mi0xNS45OTUtOC41MzgtMjYuNDY4LTguNTM4XFxuXHRcdGMtNC41NTQtMTAuMDE4LTExLjM4NC0xNy45ODctMjAuNDkxLTIzLjkwNmMtOS4xMDctNS45Mi0xOS4wMTEtOC44NzktMjkuNzEyLTguODc5Yy0xMC43MDEsMC0yMC42MDUsMi45Ni0yOS43MTIsOC44NzlcXG5cdFx0Yy05LjEwNyw1LjkyLTE1LjkzOCwxMy44ODgtMjAuNDkxLDIzLjkwNmMtMTAuNDczLDAtMTkuMjk2LDIuODQ2LTI2LjQ2OCw4LjUzOGMtNy4xNzIsNS42OTItMTAuNzU4LDEzLjc3NS0xMC43NTgsMjQuMjQ4XFxuXHRcdGMwLDUuNDY0LDEuNDgsMTAuODE1LDQuNDQsMTYuMDUxYy0xMC4yNDUsNi42MDMtMTUuMzY4LDE1LjgyNC0xNS4zNjgsMjcuNjYzYzAsOC40MjQsMi44NDYsMTUuNzEsOC41MzgsMjEuODU3XFxuXHRcdGMtNS42OTIsNi4xNDctOC41MzgsMTMuNDMzLTguNTM4LDIxLjg1N2MwLDEyLjI5NSw1LjM1LDIxLjYzLDE2LjA1MSwyOC4wMDVjLTAuOTExLDExLjM4NC00Ljc4MSwyMy42MjItMTEuNjEyLDM2LjcxM1xcblx0XHRjLTYuODMsMTMuMDkxLTEzLjYwNCwyMy45NjMtMjAuMzIsMzIuNjE1Yy02LjcxNyw4LjY1Mi0xNS4xOTgsMTguNTU2LTI1LjQ0MywyOS43MTJjLTIzLjQ1MSwyNS43MjgtMzUuMTc2LDU2LjIzNy0zNS4xNzYsOTEuNTI3XFxuXHRcdGMwLDIyLjU0LDUuMDY2LDQzLjU0NCwxNS4xOTgsNjMuMDFjMTAuMTMyLDE5LjQ2NywyMy40NTEsMzUuNjMyLDM5Ljk1OCw0OC40OTZjMTYuNTA3LDEyLjg2NCwzNS4xNzYsMjIuOTk1LDU2LjAwOSwzMC4zOTVcXG5cdFx0czQyLjA2NCwxMS4wOTksNjMuNjkzLDExLjA5OWMyMS42MjksMCw0Mi44Ni0zLjcsNjMuNjkzLTExLjA5OWMyMC44MzMtNy40LDM5LjUwMi0xNy41MzEsNTYuMDA5LTMwLjM5NVxcblx0XHRjMTYuNTA3LTEyLjg2NCwyOS44MjYtMjkuMDI5LDM5Ljk1OC00OC40OTZDMTE4NS42NDgsMTU2NS40MDEsMTE5MC43MTQsMTU0NC4zOTcsMTE5MC43MTQsMTUyMS44NTd6XCIvPlxcbjwvZz5cXG48Zz5cXG5cdDxsaW5lIGZpbGw9XCIjRUZCODM0XCIgeDE9XCIxNTU4LjU4MlwiIHkxPVwiLTMzMi45XCIgeDI9XCIxNjQ1LjU3OFwiIHkyPVwiLTM4MS44NFwiLz5cXG5cdDxwYXRoIGZpbGw9XCIjRUZCODM0XCIgZD1cIk0xNTU4LjE0MS0zMzMuNjg1YzAsMCwxLjIyNS0xLjAwMywzLjM5Ni0yLjcxMWMxLjA4LTAuODY0LDIuNDAyLTEuODk0LDMuOTI1LTMuMDYzXFxuXHRcdGMxLjUyNS0xLjE2NywzLjIyNy0yLjUxNCw1LjExNy0zLjkyN2MxLjg4Ny0xLjQxOCwzLjkzMS0yLjk1NCw2LjA5Mi00LjU3OGMyLjE1OC0xLjYzMiw0LjQ2My0zLjMsNi44MzEtNS4wNTVcXG5cdFx0YzIuMzg2LTEuNzIzLDQuODQzLTMuNTE5LDcuMzcyLTUuMjg1YzIuNTE1LTEuNzkxLDUuMTA0LTMuNTUyLDcuNjc3LTUuMzQxYzIuNTc4LTEuNzc4LDUuMDY1LTMuNzIxLDcuNTAzLTUuNjQ4XFxuXHRcdGMxLjIyOC0wLjk0OCwyLjQzNi0xLjkwNywzLjY2NS0yLjc5MmMxLjIzMS0wLjg4MSwyLjQ3OC0xLjY5NSwzLjczNi0yLjQ0MmMyLjUyNy0xLjQ3Miw1LjEyLTIuNjI5LDcuNjU2LTMuNTg3XFxuXHRcdGMyLjUyOS0wLjk3MSw0Ljk5OC0xLjc1MSw3LjMzMS0yLjM3N2M0LjY1Ni0xLjI2OCw4Ljc5Ny0xLjg1OCwxMS44MS0yLjA2OWMxLjUwNC0wLjEwOSwyLjcxOC0wLjEzOCwzLjU3Mi0wLjExMVxcblx0XHRjMC44NDMsMC4wMDcsMS4zMTMsMC4wNDcsMS4zMTMsMC4wNDdsMC44ODIsMS41NjljMCwwLTAuMjEsMC40MjItMC42NDEsMS4xNDZjLTAuNDIsMC43NDQtMS4wNzUsMS43NjYtMS45NSwyLjk5NVxcblx0XHRjLTEuNzQ1LDIuNDY1LTQuNCw1LjY5OC03LjksOS4wMTljLTEuNzQ2LDEuNjY5LTMuNjk0LDMuMzc0LTUuODM4LDUuMDMxYy0yLjEzNiwxLjY3MS00LjQ3MSwzLjI4NS03LjA0MSw0LjY4MVxcblx0XHRjLTEuMjkxLDAuNjg3LTIuNjM1LDEuMzMxLTQuMDI3LDEuOTI1Yy0xLjM5NCwwLjU5MS0yLjg0MSwxLjEyNi00LjI4OSwxLjY4M2MtMi45MTQsMS4wODMtNS44NjUsMi4yLTguNzIzLDMuNDhcXG5cdFx0Yy0yLjg2NSwxLjI3LTUuNzEzLDIuNTY4LTguNTUsMy43ODhjLTIuODIzLDEuMjQ1LTUuNjMzLDIuNDEyLTguMzQ1LDMuNTU2Yy0yLjcyOSwxLjExMy01LjM1MiwyLjIxNy03Ljg2NywzLjIxM1xcblx0XHRjLTIuNTExLDEuMDA0LTQuODg1LDEuOTUzLTcuMDc2LDIuODNjLTIuMTg4LDAuODgxLTQuMjI0LDEuNjM3LTYuMDEzLDIuMzM0Yy0xLjc5LDAuNjk1LTMuMzU3LDEuMjktNC42NTYsMS43NjRcXG5cdFx0Yy0yLjU4NywwLjk2OC00LjA4LDEuNDk0LTQuMDgsMS40OTRMMTU1OC4xNDEtMzMzLjY4NXpcIi8+XFxuPC9nPlxcbjxnPlxcblx0PGxpbmUgZmlsbD1cIiNFRkI4MzRcIiB4MT1cIjE1NzcuMzQ4XCIgeTE9XCItMTMwLjk5MlwiIHgyPVwiMTY3NC41MDlcIiB5Mj1cIi0xMDguMTE3XCIvPlxcblx0PHBhdGggZmlsbD1cIiNFRkI4MzRcIiBkPVwiTTE1NzcuNTU1LTEzMS44NjhjMCwwLDEuNTgxLDAuMDkxLDQuMzM1LDAuMzAzYzEuMzgsMC4wOTUsMy4wNSwwLjIzMiw0Ljk2MiwwLjQwM1xcblx0XHRjMS45MTIsMC4xNzMsNC4wNzcsMC4zMzQsNi40MjQsMC41NzRjMi4zNDgsMC4yMzQsNC44OTIsMC40ODcsNy41ODMsMC43NTVjMi42OTMsMC4yNTksNS41MTksMC41OTIsOC40NSwwLjkwNFxcblx0XHRjMi45MjMsMC4zNDcsNS45NDcsMC42ODgsOS4wMDQsMS4xMDFjMy4wNjQsMC4zODQsNi4xNjEsMC44NDEsOS4yNjYsMS4yNjZjMy4xMDIsMC40MzcsNi4yNDYsMC42OTEsOS4zNDYsMC45MjJcXG5cdFx0YzEuNTQ2LDAuMTMzLDMuMDg0LDAuMjQ2LDQuNTg4LDAuNDI2YzEuNTAyLDAuMTg1LDIuOTcyLDAuNDMsNC40MDMsMC43MzJjMi44NTYsMC42MjgsNS41NDgsMS41MzEsOC4wNjQsMi41NDNcXG5cdFx0YzIuNTE5LDAuOTk4LDQuODY0LDIuMDk1LDcuMDA0LDMuMjEzYzQuMjg1LDIuMjE5LDcuNzMyLDQuNTg4LDEwLjA5Myw2LjQ3MmMxLjE4MSwwLjkzOCwyLjA5NCwxLjczOCwyLjcwNCwyLjMzN1xcblx0XHRjMC42MTUsMC41NzYsMC45MzQsMC45MjMsMC45MzQsMC45MjNsLTAuNDEyLDEuNzUyYzAsMC0wLjQ0LDAuMTY5LTEuMjQ4LDAuNDFjLTAuODEzLDAuMjYzLTEuOTg3LDAuNTcyLTMuNDYzLDAuODg1XFxuXHRcdGMtMi45NTMsMC42MzMtNy4wOTYsMS4yMTYtMTEuOTIsMS4yOWMtMi40MTQsMC4wNDYtNS4wMDMtMC4wMTgtNy43MDItMC4yNDljLTIuNzAzLTAuMjE2LTUuNTE1LTAuNjA5LTguMzUxLTEuMzIyXFxuXHRcdGMtMS40MTYtMC4zNjgtMi44NC0wLjgwNC00LjI2Ny0xLjMwOWMtMS40MjYtMC41MDktMi44NTMtMS4wOTUtNC4yOTYtMS42NjVjLTIuODc4LTEuMTc2LTUuODA1LTIuMzUxLTguNzc2LTMuMzQ0XFxuXHRcdGMtMi45NjgtMS4wMDQtNS45NDMtMS45NzctOC44NTctM2MtMi45Mi0wLjk5NS01Ljc3OS0yLjAzOC04LjU0OS0zLjAzMmMtMi43NjItMS4wMjktNS40NC0xLjk5Mi03Ljk2NS0yLjk2MVxcblx0XHRjLTIuNTI4LTAuOTYxLTQuOTE4LTEuODY5LTcuMTI0LTIuNzA4Yy0yLjIwNy0wLjgzMy00LjIxNy0xLjY1NS02LjAwNS0yLjM1M2MtMS43ODgtMC43LTMuMzQ0LTEuMzIzLTQuNjIxLTEuODU0XFxuXHRcdGMtMi41NTktMS4wMzktNC4wMTUtMS42NjMtNC4wMTUtMS42NjNMMTU3Ny41NTUtMTMxLjg2OHpcIi8+XFxuPC9nPlxcbjxnPlxcblx0PGxpbmUgZmlsbD1cIiNFRkI4MzRcIiB4MT1cIjE1ODcuNTU5XCIgeTE9XCItMjM5LjNcIiB4Mj1cIjE2ODcuMzdcIiB5Mj1cIi0yNDAuMzE1XCIvPlxcblx0PHBhdGggZmlsbD1cIiNFRkI4MzRcIiBkPVwiTTE1ODcuNTUtMjQwLjJjMCwwLDEuNTU3LTAuMjg5LDQuMjgyLTAuNzQyYzEuMzYyLTAuMjM3LDMuMDE3LTAuNTA0LDQuOTE1LTAuNzk1XFxuXHRcdGMxLjg5OC0wLjI4OSw0LjAzOS0wLjY1LDYuMzc1LTAuOTc5YzIuMzM2LTAuMzM0LDQuODY3LTAuNjk3LDcuNTQ0LTEuMDhjMi42NzctMC4zOTIsNS41LTAuNzQ0LDguNDIxLTEuMTQyXFxuXHRcdGMyLjkyMS0wLjM2Miw1LjkzOS0wLjc1Myw5LjAwNi0xLjA4NGMzLjA2Ny0wLjM1OSw2LjE4My0wLjY1Niw5LjI5OS0wLjk4NWMzLjExNi0wLjMxNyw2LjIzLTAuODIzLDkuMjk2LTEuMzM5XFxuXHRcdGMxLjUzMy0wLjI0LDMuMDUzLTAuNDk5LDQuNTU2LTAuNjgzYzEuNTAzLTAuMTgsMi45ODktMC4yOTMsNC40NS0wLjM0MmMyLjkyNC0wLjA3Myw1Ljc1MywwLjE2LDguNDM4LDAuNTQyXFxuXHRcdGMyLjY4NCwwLjM2Niw1LjIyNCwwLjg3MSw3LjU2OSwxLjQ0NmM0LjY5MSwxLjEzLDguNjA1LDIuNjA3LDExLjM0NywzLjg3MmMxLjM3MSwwLjYyOSwyLjQ0OSwxLjE4NywzLjE4NSwxLjYyMlxcblx0XHRjMC43MzUsMC40MTIsMS4xMjgsMC42NzMsMS4xMjgsMC42NzNsMC4wMTgsMS44YzAsMC0wLjM4NywwLjI2OS0xLjExNCwwLjY5NmMtMC43MjYsMC40NS0xLjc5MywxLjAzMS0zLjE1MSwxLjY4N1xcblx0XHRjLTIuNzE2LDEuMzIxLTYuNiwyLjg3Ny0xMS4yNjYsNC4xMDJjLTIuMzMzLDAuNjIyLTQuODYyLDEuMTc5LTcuNTM5LDEuNTk5Yy0yLjY3NiwwLjQzNi01LjUsMC43MjctOC40MjUsMC43MTNcXG5cdFx0Yy0xLjQ2Mi0wLjAxOS0yLjk1LTAuMTAyLTQuNDU2LTAuMjUxYy0xLjUwNi0wLjE1My0zLjAzMi0wLjM4MS00LjU2OS0wLjU5Yy0zLjA3NS0wLjQ1NC02LjE5OS0wLjg5NS05LjMyMS0xLjE0OVxcblx0XHRjLTMuMTIyLTAuMjY2LTYuMjQ0LTAuNDk5LTkuMzE4LTAuNzk2Yy0zLjA3My0wLjI2OC02LjA5OS0wLjU5OC05LjAyNi0wLjljLTIuOTI4LTAuMzM4LTUuNzU4LTAuNjM0LTguNDQyLTAuOTcxXFxuXHRcdGMtMi42ODQtMC4zMjktNS4yMjItMC42MzktNy41NjQtMC45MjZjLTIuMzQzLTAuMjgxLTQuNDktMC41OTktNi4zOTQtMC44NDljLTEuOTAzLTAuMjUzLTMuNTYzLTAuNDg2LTQuOTMtMC42OTVcXG5cdFx0Yy0yLjczNC0wLjM5Ny00LjI5Ni0wLjY1NS00LjI5Ni0wLjY1NUwxNTg3LjU1LTI0MC4yelwiLz5cXG48L2c+XFxuPGc+XFxuXHQ8bGluZSBmaWxsPVwiI0VGQjgzNFwiIHgxPVwiMTIyMC42NjFcIiB5MT1cIi0zMjguMjM2XCIgeDI9XCIxMTMzLjY2NVwiIHkyPVwiLTM3Ny4xNzZcIi8+XFxuXHQ8cGF0aCBmaWxsPVwiI0VGQjgzNFwiIGQ9XCJNMTIyMC4yMi0zMjcuNDUyYzAsMC0xLjQ5My0wLjUyNi00LjA4LTEuNDk0Yy0xLjI5OS0wLjQ3NC0yLjg2Ni0xLjA2OS00LjY1Ni0xLjc2NFxcblx0XHRjLTEuNzg5LTAuNjk3LTMuODI0LTEuNDUzLTYuMDEzLTIuMzM0Yy0yLjE5MS0wLjg3Ni00LjU2NS0xLjgyNi03LjA3Ni0yLjgzYy0yLjUxNS0wLjk5Ni01LjEzOC0yLjEtNy44NjctMy4yMTNcXG5cdFx0Yy0yLjcxMi0xLjE0NC01LjUyMi0yLjMxMi04LjM0NS0zLjU1NmMtMi44MzctMS4yMi01LjY4Ni0yLjUxOC04LjU1LTMuNzg4Yy0yLjg1OS0xLjI4LTUuODEtMi4zOTctOC43MjMtMy40OFxcblx0XHRjLTEuNDQ4LTAuNTU3LTIuODk1LTEuMDkyLTQuMjg5LTEuNjgzYy0xLjM5Mi0wLjU5NC0yLjczNi0xLjIzOC00LjAyNy0xLjkyNWMtMi41Ny0xLjM5Ni00LjkwNS0zLjAxLTcuMDQxLTQuNjgxXFxuXHRcdGMtMi4xNDMtMS42NTctNC4wOTItMy4zNjMtNS44MzgtNS4wMzFjLTMuNS0zLjMyLTYuMTU1LTYuNTU0LTcuOS05LjAxOWMtMC44NzUtMS4yMjktMS41My0yLjI1MS0xLjk1LTIuOTk1XFxuXHRcdGMtMC40MzEtMC43MjQtMC42NDEtMS4xNDYtMC42NDEtMS4xNDZsMC44ODMtMS41NjljMCwwLDAuNDctMC4wNCwxLjMxMy0wLjA0N2MwLjg1NC0wLjAyNywyLjA2OCwwLjAwMiwzLjU3MywwLjExMVxcblx0XHRjMy4wMTMsMC4yMTEsNy4xNTUsMC44MDEsMTEuODEsMi4wNjljMi4zMzIsMC42MjUsNC44MDIsMS40MDYsNy4zMzEsMi4zNzdjMi41MzcsMC45NTgsNS4xMjksMi4xMTUsNy42NTYsMy41ODdcXG5cdFx0YzEuMjU4LDAuNzQ2LDIuNTA1LDEuNTYxLDMuNzM2LDIuNDQyYzEuMjI5LDAuODg1LDIuNDM3LDEuODQ0LDMuNjY1LDIuNzkyYzIuNDM4LDEuOTI4LDQuOTI1LDMuODcsNy41MDMsNS42NDhcXG5cdFx0YzIuNTczLDEuNzg5LDUuMTYxLDMuNTQ5LDcuNjc3LDUuMzQxYzIuNTMsMS43NjYsNC45ODYsMy41NjIsNy4zNzIsNS4yODVjMi4zNjgsMS43NTUsNC42NzMsMy40MjMsNi44MzEsNS4wNTVcXG5cdFx0YzIuMTYyLDEuNjI1LDQuMjA2LDMuMTYsNi4wOTIsNC41NzhjMS44ODksMS40MTMsMy41OTIsMi43Niw1LjExNiwzLjkyN2MxLjUyMywxLjE2OSwyLjg0NSwyLjE5OSwzLjkyNSwzLjA2M1xcblx0XHRjMi4xNzEsMS43MDgsMy4zOTYsMi43MTEsMy4zOTYsMi43MTFMMTIyMC4yMi0zMjcuNDUyelwiLz5cXG48L2c+XFxuPGc+XFxuXHQ8bGluZSBmaWxsPVwiI0VGQjgzNFwiIHgxPVwiMTIwNS44OTVcIiB5MT1cIi0xMjkuMzI4XCIgeDI9XCIxMTA4LjczNFwiIHkyPVwiLTEwNi40NTNcIi8+XFxuXHQ8cGF0aCBmaWxsPVwiI0VGQjgzNFwiIGQ9XCJNMTIwNi4xMDEtMTI4LjQ1MmMwLDAtMS40NTUsMC42MjMtNC4wMTUsMS42NjNjLTEuMjc3LDAuNTMtMi44MzMsMS4xNTMtNC42MjEsMS44NTRcXG5cdFx0Yy0xLjc4OCwwLjY5OC0zLjc5OCwxLjUyLTYuMDA1LDIuMzUzYy0yLjIwNiwwLjgzOC00LjU5NiwxLjc0Ny03LjEyNCwyLjcwOGMtMi41MjYsMC45NjktNS4yMDMsMS45MzItNy45NjUsMi45NjFcXG5cdFx0Yy0yLjc3LDAuOTkzLTUuNjI5LDIuMDM3LTguNTQ5LDMuMDMyYy0yLjkxNCwxLjAyMy01Ljg4OSwxLjk5Ni04Ljg1NywzYy0yLjk3MSwwLjk5My01Ljg5OSwyLjE2OS04Ljc3NiwzLjM0NFxcblx0XHRjLTEuNDQzLDAuNTctMi44NywxLjE1Ni00LjI5NiwxLjY2NWMtMS40MjcsMC41MDUtMi44NTIsMC45NDEtNC4yNjcsMS4zMDljLTIuODM2LDAuNzEzLTUuNjQ4LDEuMTA1LTguMzUxLDEuMzIxXFxuXHRcdGMtMi43LDAuMjMxLTUuMjg4LDAuMjk1LTcuNzAzLDAuMjQ5Yy00LjgyNC0wLjA3NC04Ljk2Ny0wLjY1Ny0xMS45Mi0xLjI5Yy0xLjQ3Ni0wLjMxMy0yLjY1LTAuNjIxLTMuNDYzLTAuODg1XFxuXHRcdGMtMC44MDgtMC4yNDEtMS4yNDgtMC40MS0xLjI0OC0wLjQxbC0wLjQxMi0xLjc1MmMwLDAsMC4zMTktMC4zNDcsMC45MzQtMC45MjNjMC42MS0wLjU5OCwxLjUyMy0xLjM5OSwyLjcwNC0yLjMzN1xcblx0XHRjMi4zNi0xLjg4NCw1LjgwOC00LjI1NCwxMC4wOTMtNi40NzJjMi4xNC0xLjExOSw0LjQ4NS0yLjIxNiw3LjAwNC0zLjIxM2MyLjUxNi0xLjAxMiw1LjIwNy0xLjkxNSw4LjA2NC0yLjU0M1xcblx0XHRjMS40MzEtMC4zMDIsMi45MDEtMC41NDcsNC40MDMtMC43MzJjMS41MDMtMC4xODEsMy4wNDItMC4yOTMsNC41ODgtMC40MjZjMy4xLTAuMjMyLDYuMjQ1LTAuNDg2LDkuMzQ2LTAuOTIyXFxuXHRcdGMzLjEwNC0wLjQyNSw2LjIwMi0wLjg4Miw5LjI2Ni0xLjI2NmMzLjA1Ny0wLjQxMiw2LjA4MS0wLjc1NCw5LjAwNC0xLjEwMWMyLjkzMS0wLjMxMiw1Ljc1Ny0wLjY0NCw4LjQ1LTAuOTA0XFxuXHRcdGMyLjY5MS0wLjI2OCw1LjIzNS0wLjUyMSw3LjU4My0wLjc1NWMyLjM0Ny0wLjIzOSw0LjUxMi0wLjQsNi40MjQtMC41NzRjMS45MTMtMC4xNzEsMy41ODMtMC4zMDgsNC45NjItMC40MDNcXG5cdFx0YzIuNzU0LTAuMjEyLDQuMzM1LTAuMzAzLDQuMzM1LTAuMzAzTDEyMDYuMTAxLTEyOC40NTJ6XCIvPlxcbjwvZz5cXG48Zz5cXG5cdDxsaW5lIGZpbGw9XCIjRUZCODM0XCIgeDE9XCIxMTk3LjY4NFwiIHkxPVwiLTIzNC42MzZcIiB4Mj1cIjEwOTcuODczXCIgeTI9XCItMjM1LjY1MVwiLz5cXG5cdDxwYXRoIGZpbGw9XCIjRUZCODM0XCIgZD1cIk0xMTk3LjY3NS0yMzMuNzM2YzAsMC0xLjU2MiwwLjI1Ny00LjI5NiwwLjY1NWMtMS4zNjcsMC4yMS0zLjAyNiwwLjQ0My00LjkzLDAuNjk1XFxuXHRcdGMtMS45MDQsMC4yNS00LjA1MSwwLjU2OC02LjM5NCwwLjg0OWMtMi4zNDIsMC4yODctNC44OCwwLjU5OC03LjU2NCwwLjkyNmMtMi42ODQsMC4zMzctNS41MTQsMC42MzMtOC40NDIsMC45NzFcXG5cdFx0Yy0yLjkyOCwwLjMwMi01Ljk1MywwLjYzMi05LjAyNiwwLjljLTMuMDc0LDAuMjk3LTYuMTk1LDAuNTMtOS4zMTgsMC43OTZjLTMuMTIyLDAuMjU0LTYuMjQ2LDAuNjk2LTkuMzIxLDEuMTQ5XFxuXHRcdGMtMS41MzgsMC4yMDktMy4wNjMsMC40MzctNC41NjksMC41OWMtMS41MDYsMC4xNDktMi45OTQsMC4yMzItNC40NTYsMC4yNTFjLTIuOTI1LDAuMDE0LTUuNzQ5LTAuMjc3LTguNDI1LTAuNzEzXFxuXHRcdGMtMi42NzctMC40MjEtNS4yMDUtMC45NzctNy41MzktMS41OTljLTQuNjY3LTEuMjI1LTguNTUtMi43ODEtMTEuMjY2LTQuMTAyYy0xLjM1OC0wLjY1Ni0yLjQyNC0xLjIzNy0zLjE1MS0xLjY4N1xcblx0XHRjLTAuNzI3LTAuNDI3LTEuMTE0LTAuNjk2LTEuMTE0LTAuNjk2bDAuMDE4LTEuOGMwLDAsMC4zOTMtMC4yNjEsMS4xMjgtMC42NzNjMC43MzYtMC40MzUsMS44MTMtMC45OTQsMy4xODUtMS42MjJcXG5cdFx0YzIuNzQyLTEuMjY1LDYuNjU3LTIuNzQyLDExLjM0Ny0zLjg3MmMyLjM0NS0wLjU3NSw0Ljg4NS0xLjA3OSw3LjU3LTEuNDQ2YzIuNjg1LTAuMzgyLDUuNTE0LTAuNjE1LDguNDM4LTAuNTQyXFxuXHRcdGMxLjQ2MiwwLjA0OSwyLjk0NywwLjE2Miw0LjQ1LDAuMzQyYzEuNTAzLDAuMTg0LDMuMDI0LDAuNDQzLDQuNTU2LDAuNjgzYzMuMDY1LDAuNTE2LDYuMTgsMS4wMjEsOS4yOTYsMS4zMzlcXG5cdFx0YzMuMTE2LDAuMzI5LDYuMjMzLDAuNjI2LDkuMywwLjk4NWMzLjA2NywwLjMzLDYuMDg1LDAuNzIyLDkuMDA2LDEuMDg0YzIuOTIxLDAuMzk4LDUuNzQ0LDAuNzUsOC40MjEsMS4xNDJcXG5cdFx0YzIuNjc3LDAuMzgzLDUuMjA4LDAuNzQ1LDcuNTQ0LDEuMDhjMi4zMzYsMC4zMjksNC40NzcsMC42OSw2LjM3NSwwLjk3OWMxLjg5OCwwLjI5MSwzLjU1MiwwLjU1OCw0LjkxNSwwLjc5NVxcblx0XHRjMi43MjUsMC40NTMsNC4yODIsMC43NDIsNC4yODIsMC43NDJMMTE5Ny42NzUtMjMzLjczNnpcIi8+XFxuPC9nPlxcbjxwYXRoIGZpbGw9XCIjQzlDOUM5XCIgZD1cIk0yNjMzLjg4My00Ni4zMTljMCwyNC4wMTItNTcuMTg5LDEyOC45NDItNjEuNDE0LDEzMi4yNjVjLTEyLjM4NCw5Ljc0MS00OC41MTQsMTUuMzE4LTgyLjg2OSwxNi41MThcXG5cdGMtOC4zNjIsMC4yOTItMTYuNjE5LDAuMzI1LTI0LjQwMywwLjA5NmMtMjAuNzE2LTAuNjExLTM4LjA4MS0zLjA3OS00NS4xNTUtNy40NjRjLTYuODk2LTQuMjc0LTc0LjQ3Ny0xMTkuMjQtNzQuNDc3LTE0MS40MTVcXG5cdGMwLTg5LjE5NSw2NC41NDItMTYxLjUwMiwxNDQuMTU5LTE2MS41MDJDMjU2OS4zNDEtMjA3LjgyLDI2MzMuODgzLTEzNS41MTQsMjYzMy44ODMtNDYuMzE5elwiLz5cXG48ZyBpZD1cImczMDE1XzJfXCIgdHJhbnNmb3JtPVwibWF0cml4KDEsMCwwLC0xLDM3OS42NjEwMiwxMjkzLjAxNjkpXCI+XFxuXHQ8cGF0aCBpZD1cInBhdGgzMDE3XzJfXCIgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT1cIjBcIiBmaWxsPVwiIzVENUQ1RFwiIGQ9XCJNMjE4Ny40NjYsMTM4MC4zMzJjMC0yLjk2LTEuMDgyLTUuNTIxLTMuMjQ0LTcuNjg0XFxuXHRcdGMtMi4xNjMtMi4xNjMtNC43MjQtMy4yNDQtNy42ODQtMy4yNDRjLTIuOTYsMC01LjUyMSwxLjA4MS03LjY4NCwzLjI0NHMtMy4yNDQsNC43MjQtMy4yNDQsNy42ODRcXG5cdFx0YzAsMTAuNDczLTYuMTQ3LDE4LjU1Ni0xOC40NDIsMjQuMjQ4Yy0xMi4yOTUsNS42OTItMjQuMzYyLDguNTM4LTM2LjIwMSw4LjUzOGMtMi45NiwwLTUuNTIxLDEuMDgxLTcuNjg0LDMuMjQ0XFxuXHRcdGMtMi4xNjMsMi4xNjMtMy4yNDQsNC43MjQtMy4yNDQsNy42ODRzMS4wODIsNS41MjEsMy4yNDQsNy42ODRjMi4xNjMsMi4xNjMsNC43MjQsMy4yNDQsNy42ODQsMy4yNDRcXG5cdFx0YzExLjM4NCwwLDIyLjcxMS0xLjgyMSwzMy45ODEtNS40NjRjMTEuMjctMy42NDMsMjEuMTc0LTkuNzksMjkuNzEyLTE4LjQ0Mlxcblx0XHRDMjE4My4xOTcsMTQwMi40MTYsMjE4Ny40NjYsMTM5Mi4xNzEsMjE4Ny40NjYsMTM4MC4zMzJ6IE0yMjQyLjEwOCwxMzgwLjMzMmMwLDE2LjM5My0zLjkyNywzMS42NDctMTEuNzgyLDQ1Ljc2M1xcblx0XHRjLTcuODU1LDE0LjExNi0xOC4xLDI1LjY3MS0zMC43MzcsMzQuNjY0cy0yNi42MzgsMTYuMDUxLTQyLjAwNywyMS4xNzRjLTE1LjM2OCw1LjEyMy0zMC45MDcsNy42ODQtNDYuNjE3LDcuNjg0XFxuXHRcdGMtMTUuNzEsMC0zMS4yNDktMi41NjEtNDYuNjE3LTcuNjg0Yy0xNS4zNjgtNS4xMjMtMjkuMzcxLTEyLjE4MS00Mi4wMDctMjEuMTc0Yy0xMi42MzYtOC45OTMtMjIuODgyLTIwLjU0OC0zMC43MzctMzQuNjY0XFxuXHRcdGMtNy44NTUtMTQuMTE2LTExLjc4Mi0yOS4zNy0xMS43ODItNDUuNzYzYzAtMjIuOTk2LDcuNzQxLTQzLjQ4NywyMy4yMjMtNjEuNDczYzIuMjc3LTIuNTA1LDUuNzQ5LTYuMjYxLDEwLjQxNi0xMS4yN1xcblx0XHRjNC42NjctNS4wMDksOC4xNC04Ljc2NiwxMC40MTYtMTEuMjdjMjkuMTQzLTM0LjgzNSw0NS4xOTQtNjguNzU5LDQ4LjE1NC0xMDEuNzcyaDc3Ljg2Nlxcblx0XHRjMi45NiwzMy4wMTMsMTkuMDExLDY2LjkzOCw0OC4xNTQsMTAxLjc3MmMyLjI3NywyLjUwNCw1Ljc0OSw2LjI2MSwxMC40MTYsMTEuMjdjNC42NjcsNS4wMDksOC4xNCw4Ljc2NiwxMC40MTcsMTEuMjdcXG5cdFx0QzIyMzQuMzY3LDEzMzYuODQ1LDIyNDIuMTA4LDEzNTcuMzM2LDIyNDIuMTA4LDEzODAuMzMyeiBNMjI4NS44MjMsMTM4MC4zMzJjMC0zNS4yOS0xMS43MjYtNjUuNzk5LTM1LjE3Ny05MS41MjdcXG5cdFx0Yy0xMC4yNDUtMTEuMTU2LTE4LjcyNy0yMS4wNi0yNS40NDMtMjkuNzEycy0xMy40OS0xOS41MjMtMjAuMzItMzIuNjE1Yy02LjgzLTEzLjA5Mi0xMC43MDEtMjUuMzI5LTExLjYxMi0zNi43MTNcXG5cdFx0YzEwLjcwMS02LjM3NSwxNi4wNTItMTUuNzEsMTYuMDUyLTI4LjAwNWMwLTguNDI0LTIuODQ2LTE1LjcxLTguNTM4LTIxLjg1N2M1LjY5Mi02LjE0Nyw4LjUzOC0xMy40MzMsOC41MzgtMjEuODU3XFxuXHRcdGMwLTExLjgzOS01LjEyMy0yMS4wNi0xNS4zNjgtMjcuNjYzYzIuOTYtNS4yMzcsNC40NC0xMC41ODcsNC40NC0xNi4wNTFjMC0xMC40NzMtMy41ODYtMTguNTU2LTEwLjc1OC0yNC4yNDhcXG5cdFx0Yy03LjE3Mi01LjY5Mi0xNS45OTQtOC41MzgtMjYuNDY4LTguNTM4Yy00LjU1NC0xMC4wMTgtMTEuMzg0LTE3Ljk4Ny0yMC40OTEtMjMuOTA2Yy05LjEwNy01LjkyLTE5LjAxMS04Ljg3OS0yOS43MTItOC44NzlcXG5cdFx0Yy0xMC43MDEsMC0yMC42MDUsMi45Ni0yOS43MTIsOC44NzljLTkuMTA3LDUuOTItMTUuOTM4LDEzLjg4OC0yMC40OTEsMjMuOTA2Yy0xMC40NzMsMC0xOS4yOTYsMi44NDYtMjYuNDY4LDguNTM4XFxuXHRcdGMtNy4xNzIsNS42OTItMTAuNzU4LDEzLjc3NS0xMC43NTgsMjQuMjQ4YzAsNS40NjQsMS40OCwxMC44MTUsNC40NCwxNi4wNTFjLTEwLjI0Niw2LjYwMy0xNS4zNjgsMTUuODI0LTE1LjM2OCwyNy42NjNcXG5cdFx0YzAsOC40MjQsMi44NDYsMTUuNzEsOC41MzgsMjEuODU3Yy01LjY5Miw2LjE0Ny04LjUzOCwxMy40MzMtOC41MzgsMjEuODU3YzAsMTIuMjk1LDUuMzUsMjEuNjMsMTYuMDUxLDI4LjAwNVxcblx0XHRjLTAuOTExLDExLjM4NC00Ljc4MSwyMy42MjItMTEuNjEyLDM2LjcxM3MtMTMuNjA0LDIzLjk2My0yMC4zMiwzMi42MTVzLTE1LjE5OCwxOC41NTYtMjUuNDQzLDI5LjcxMlxcblx0XHRjLTIzLjQ1MSwyNS43MjgtMzUuMTc2LDU2LjIzNy0zNS4xNzYsOTEuNTI3YzAsMjIuNTQsNS4wNjYsNDMuNTQzLDE1LjE5OCw2My4wMXMyMy40NTEsMzUuNjMyLDM5Ljk1OCw0OC40OTVcXG5cdFx0YzE2LjUwNywxMi44NjQsMzUuMTc2LDIyLjk5Niw1Ni4wMDksMzAuMzk1YzIwLjgzMyw3LjQsNDIuMDYzLDExLjA5OSw2My42OTMsMTEuMDk5YzIxLjYyOSwwLDQyLjg2LTMuNyw2My42OTMtMTEuMDk5XFxuXHRcdGMyMC44MzMtNy40LDM5LjUwMi0xNy41MzEsNTYuMDA5LTMwLjM5NWMxNi41MDctMTIuODY0LDI5LjgyNi0yOS4wMjksMzkuOTU4LTQ4LjQ5NVxcblx0XHRDMjI4MC43NTcsMTQyMy44NzUsMjI4NS44MjMsMTQwMi44NzIsMjI4NS44MjMsMTM4MC4zMzJ6XCIvPlxcbjwvZz5cXG48L3N2Zz5cXG4nKTsgfSkoKTtcbn0gXG5yZXR1cm4gYnVmLmpvaW4oJycpO1xufTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxvY2Fscykge1xuICAgIHJldHVybiB0KGxvY2FscywgcmVxdWlyZShcImVqc1wiKS5maWx0ZXJzKTtcbiAgfVxufSgpKTsiLCJtb2R1bGUuZXhwb3J0cz0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IGZ1bmN0aW9uIGFub255bW91cyhsb2NhbHMsIGZpbHRlcnMsIGVzY2FwZVxuLyoqLykge1xuZXNjYXBlID0gZXNjYXBlIHx8IGZ1bmN0aW9uIChodG1sKXtcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxuICAgIC5yZXBsYWNlKC8mKD8hXFx3KzspL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufTtcbnZhciBidWYgPSBbXTtcbndpdGggKGxvY2FscyB8fCB7fSkgeyAoZnVuY3Rpb24oKXsgXG4gYnVmLnB1c2goJzxzdmcgdmVyc2lvbj1cIjEuMVwiXFxuXHQgaWQ9XCJzdmczMDEzXCIgeG1sbnM6c29kaXBvZGk9XCJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZFwiIHhtbG5zOnN2Zz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6cmRmPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zI1wiIHhtbG5zOmlua3NjYXBlPVwiaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZVwiIHhtbG5zOmRjPVwiaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS9cIiB4bWxuczpjYz1cImh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zI1wiIHNvZGlwb2RpOmRvY25hbWU9XCJsaWdodF9idWxiX2ZvbnRfYXdlc29tZS5zdmdcIiBpbmtzY2FwZTp2ZXJzaW9uPVwiMC40OC4zLjEgcjk4ODZcIlxcblx0IHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4PVwiMHB4XCIgeT1cIjBweFwiIHdpZHRoPVwiNDBweFwiIGhlaWdodD1cIjQwcHhcIlxcblx0IHZpZXdCb3g9XCIwIDAgNjEyIDc5MlwiIGVuYWJsZS1iYWNrZ3JvdW5kPVwibmV3IDAgMCA2MTIgNzkyXCIgeG1sOnNwYWNlPVwicHJlc2VydmVcIj5cXG48ZyBpZD1cImJ1bGJcIj5cXG4gIDxwYXRoIGZpbGw9XCIjRUZCODM0XCIgZD1cIk00NTMuNzc1LDM1My4xNTZjMCwyNC4wMTItNTcuMTg5LDEyOC45NDItNjEuNDE0LDEzMi4yNjVjLTEyLjM4NCw5Ljc0MS00OC41MTQsMTUuMzE4LTgyLjg2OSwxNi41MThcXG4gICAgYy04LjM2MiwwLjI5Mi0xNi42MTksMC4zMjUtMjQuNDAzLDAuMDk2Yy0yMC43MTYtMC42MTEtMzguMDgxLTMuMDc5LTQ1LjE1NS03LjQ2NGMtNi44OTYtNC4yNzQtNzQuNDc3LTExOS4yNC03NC40NzctMTQxLjQxNVxcbiAgICBjMC04OS4xOTUsNjQuNTQyLTE2MS41MDIsMTQ0LjE1OS0xNjEuNTAyUzQ1My43NzUsMjYzLjk2MSw0NTMuNzc1LDM1My4xNTZ6XCIvPlxcbiAgPGcgaWQ9XCJnMzAxNVwiIHRyYW5zZm9ybT1cIm1hdHJpeCgxLDAsMCwtMSwzNzkuNjYxMDIsMTI5My4wMTY5KVwiPlxcbiAgICA8cGF0aCBpZD1cInBhdGgzMDE3XCIgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT1cIjBcIiBmaWxsPVwiIzVENUQ1RFwiIGQ9XCJNNy4zNTcsOTgwLjg1N2MwLTIuOTYtMS4wODEtNS41MjEtMy4yNDQtNy42ODRcXG4gICAgICBzLTQuNzI0LTMuMjQ0LTcuNjg0LTMuMjQ0cy01LjUyMSwxLjA4MS03LjY4NCwzLjI0NHMtMy4yNDQsNC43MjQtMy4yNDQsNy42ODRjMCwxMC40NzMtNi4xNDcsMTguNTU2LTE4LjQ0MiwyNC4yNDhcXG4gICAgICBjLTEyLjI5NSw1LjY5Mi0yNC4zNjIsOC41MzgtMzYuMjAxLDguNTM4Yy0yLjk2LDAtNS41MjEsMS4wODEtNy42ODQsMy4yNDRzLTMuMjQ0LDQuNzI0LTMuMjQ0LDcuNjg0XFxuICAgICAgYzAsMi45NiwxLjA4MSw1LjUyMSwzLjI0NCw3LjY4NHM0LjcyNCwzLjI0NCw3LjY4NCwzLjI0NGMxMS4zODQsMCwyMi43MTEtMS44MjEsMzMuOTgxLTUuNDY0czIxLjE3NC05Ljc5LDI5LjcxMi0xOC40NDJcXG4gICAgICBTNy4zNTcsOTkyLjY5Niw3LjM1Nyw5ODAuODU3eiBNNjIsOTgwLjg1N2MwLDE2LjM5My0zLjkyNywzMS42NDctMTEuNzgyLDQ1Ljc2M3MtMTguMSwyNS42NzEtMzAuNzM3LDM0LjY2NFxcbiAgICAgIHMtMjYuNjM4LDE2LjA1MS00Mi4wMDcsMjEuMTc0cy0zMC45MDcsNy42ODQtNDYuNjE3LDcuNjg0cy0zMS4yNDktMi41NjEtNDYuNjE3LTcuNjg0cy0yOS4zNzEtMTIuMTgxLTQyLjAwNy0yMS4xNzRcXG4gICAgICBjLTEyLjYzNi04Ljk5My0yMi44ODItMjAuNTQ4LTMwLjczNy0zNC42NjRjLTcuODU1LTE0LjExNi0xMS43ODItMjkuMzcxLTExLjc4Mi00NS43NjNjMC0yMi45OTYsNy43NDEtNDMuNDg3LDIzLjIyMy02MS40NzNcXG4gICAgICBjMi4yNzctMi41MDQsNS43NDktNi4yNjEsMTAuNDE2LTExLjI3YzQuNjY3LTUuMDA5LDguMTQtOC43NjYsMTAuNDE2LTExLjI3YzI5LjE0My0zNC44MzUsNDUuMTk0LTY4Ljc1OSw0OC4xNTQtMTAxLjc3Mmg3Ny44NjZcXG4gICAgICBjMi45NiwzMy4wMTMsMTkuMDExLDY2LjkzOCw0OC4xNTQsMTAxLjc3MmMyLjI3NywyLjUwNCw1Ljc0OSw2LjI2MSwxMC40MTYsMTEuMjdzOC4xNCw4Ljc2NiwxMC40MTYsMTEuMjdcXG4gICAgICBDNTQuMjU5LDkzNy4zNyw2Miw5NTcuODYyLDYyLDk4MC44NTd6IE0xMDUuNzE0LDk4MC44NTdjMC0zNS4yOS0xMS43MjUtNjUuNzk5LTM1LjE3Ni05MS41MjdcXG4gICAgICBjLTEwLjI0Ni0xMS4xNTYtMTguNzI3LTIxLjA2LTI1LjQ0My0yOS43MTJzLTEzLjQ5LTE5LjUyMy0yMC4zMi0zMi42MTVjLTYuODMtMTMuMDkyLTEwLjcwMS0yNS4zMjktMTEuNjEyLTM2LjcxM1xcbiAgICAgIGMxMC43MDEtNi4zNzUsMTYuMDUxLTE1LjcxLDE2LjA1MS0yOC4wMDRjMC04LjQyNC0yLjg0Ni0xNS43MS04LjUzOC0yMS44NTdjNS42OTItNi4xNDcsOC41MzgtMTMuNDMzLDguNTM4LTIxLjg1N1xcbiAgICAgIGMwLTExLjgzOS01LjEyMy0yMS4wNi0xNS4zNjgtMjcuNjYzYzIuOTYtNS4yMzcsNC40NC0xMC41ODcsNC40NC0xNi4wNTFjMC0xMC40NzMtMy41ODYtMTguNTU2LTEwLjc1OC0yNC4yNDhcXG4gICAgICBzLTE1Ljk5NC04LjUzOC0yNi40NjgtOC41MzhjLTQuNTU0LTEwLjAxOC0xMS4zODQtMTcuOTg3LTIwLjQ5MS0yMy45MDZjLTkuMTA3LTUuOTItMTkuMDExLTguODc5LTI5LjcxMi04Ljg3OVxcbiAgICAgIGMtMTAuNzAxLDAtMjAuNjA1LDIuOTYtMjkuNzEyLDguODc5Yy05LjEwNyw1LjkyLTE1LjkzOCwxMy44ODgtMjAuNDkxLDIzLjkwNmMtMTAuNDczLDAtMTkuMjk2LDIuODQ2LTI2LjQ2OCw4LjUzOFxcbiAgICAgIHMtMTAuNzU4LDEzLjc3NS0xMC43NTgsMjQuMjQ4YzAsNS40NjQsMS40OCwxMC44MTUsNC40NCwxNi4wNTFjLTEwLjI0Niw2LjYwMy0xNS4zNjgsMTUuODI0LTE1LjM2OCwyNy42NjNcXG4gICAgICBjMCw4LjQyNCwyLjg0NiwxNS43MSw4LjUzOCwyMS44NTdjLTUuNjkyLDYuMTQ3LTguNTM4LDEzLjQzMy04LjUzOCwyMS44NTdjMCwxMi4yOTUsNS4zNSwyMS42MjksMTYuMDUxLDI4LjAwNFxcbiAgICAgIGMtMC45MTEsMTEuMzg0LTQuNzgxLDIzLjYyMi0xMS42MTIsMzYuNzEzYy02LjgzLDEzLjA5MS0xMy42MDQsMjMuOTYzLTIwLjMyLDMyLjYxNXMtMTUuMTk4LDE4LjU1Ni0yNS40NDMsMjkuNzEyXFxuICAgICAgQy0yMzIuMjc1LDkxNS4wNTgtMjQ0LDk0NS41NjctMjQ0LDk4MC44NTdjMCwyMi41NCw1LjA2Niw0My41NDQsMTUuMTk4LDYzLjAxYzEwLjEzMiwxOS40NjcsMjMuNDUxLDM1LjYzMiwzOS45NTgsNDguNDk2XFxuICAgICAgYzE2LjUwNywxMi44NjQsMzUuMTc2LDIyLjk5NSw1Ni4wMDksMzAuMzk1czQyLjA2NCwxMS4wOTksNjMuNjkzLDExLjA5OXM0Mi44Ni0zLjcsNjMuNjkzLTExLjA5OXMzOS41MDItMTcuNTMxLDU2LjAwOS0zMC4zOTVcXG4gICAgICBjMTYuNTA3LTEyLjg2NCwyOS44MjYtMjkuMDI5LDM5Ljk1OC00OC40OTZDMTAwLjY0OCwxMDI0LjQwMSwxMDUuNzE0LDEwMDMuMzk3LDEwNS43MTQsOTgwLjg1N3pcIi8+XFxuICA8L2c+XFxuICA8Zz5cXG4gICAgPGxpbmUgZmlsbD1cIiNFRkI4MzRcIiB4MT1cIjQ3My41ODJcIiB5MT1cIjIwOC4xXCIgeDI9XCI1NjAuNTc4XCIgeTI9XCIxNTkuMTZcIi8+XFxuICAgIDxwYXRoIGZpbGw9XCIjRUZCODM0XCIgZD1cIk00NzMuMTQxLDIwNy4zMTVjMCwwLDEuMjI1LTEuMDAzLDMuMzk2LTIuNzExYzEuMDgtMC44NjQsMi40MDItMS44OTQsMy45MjUtMy4wNjNcXG4gICAgICBjMS41MjUtMS4xNjcsMy4yMjctMi41MTQsNS4xMTctMy45MjdjMS44ODctMS40MTgsMy45MzEtMi45NTQsNi4wOTItNC41NzhjMi4xNTgtMS42MzIsNC40NjItMy4zLDYuODMxLTUuMDU1XFxuICAgICAgYzIuMzg2LTEuNzIzLDQuODQzLTMuNTE5LDcuMzcyLTUuMjg1YzIuNTE1LTEuNzkxLDUuMTA0LTMuNTUyLDcuNjc3LTUuMzQxYzIuNTc4LTEuNzc4LDUuMDY1LTMuNzIxLDcuNTAzLTUuNjQ4XFxuICAgICAgYzEuMjI4LTAuOTQ4LDIuNDM2LTEuOTA3LDMuNjY1LTIuNzkyYzEuMjMxLTAuODgxLDIuNDc4LTEuNjk1LDMuNzM2LTIuNDQyYzIuNTI3LTEuNDcyLDUuMTItMi42MjksNy42NTYtMy41ODdcXG4gICAgICBjMi41MjktMC45NzEsNC45OTgtMS43NTEsNy4zMzEtMi4zNzdjNC42NTUtMS4yNjgsOC43OTctMS44NTgsMTEuODEtMi4wNjljMS41MDQtMC4xMDksMi43MTgtMC4xMzgsMy41NzItMC4xMTFcXG4gICAgICBjMC44NDMsMC4wMDcsMS4zMTMsMC4wNDcsMS4zMTMsMC4wNDdsMC44ODMsMS41NjljMCwwLTAuMjEsMC40MjItMC42NDEsMS4xNDZjLTAuNDIsMC43NDQtMS4wNzUsMS43NjYtMS45NSwyLjk5NVxcbiAgICAgIGMtMS43NDUsMi40NjUtNC40LDUuNjk4LTcuOSw5LjAxOWMtMS43NDYsMS42NjktMy42OTQsMy4zNzQtNS44MzgsNS4wMzFjLTIuMTM2LDEuNjcxLTQuNDcxLDMuMjg1LTcuMDQxLDQuNjgxXFxuICAgICAgYy0xLjI5MSwwLjY4Ny0yLjYzNSwxLjMzMS00LjAyNywxLjkyNWMtMS4zOTQsMC41OTEtMi44NDEsMS4xMjYtNC4yODksMS42ODNjLTIuOTE0LDEuMDgzLTUuODY1LDIuMi04LjcyMywzLjQ4XFxuICAgICAgYy0yLjg2NSwxLjI3LTUuNzEzLDIuNTY4LTguNTUsMy43ODhjLTIuODIzLDEuMjQ1LTUuNjMzLDIuNDEyLTguMzQ1LDMuNTU2Yy0yLjcyOSwxLjExMy01LjM1MiwyLjIxNy03Ljg2NywzLjIxM1xcbiAgICAgIGMtMi41MTEsMS4wMDQtNC44ODUsMS45NTMtNy4wNzYsMi44M2MtMi4xODksMC44ODEtNC4yMjQsMS42MzctNi4wMTMsMi4zMzRjLTEuNzksMC42OTUtMy4zNTcsMS4yOS00LjY1NiwxLjc2NFxcbiAgICAgIGMtMi41ODcsMC45NjgtNC4wOCwxLjQ5NC00LjA4LDEuNDk0TDQ3My4xNDEsMjA3LjMxNXpcIi8+XFxuICA8L2c+XFxuICA8Zz5cXG4gICAgPGxpbmUgZmlsbD1cIiNFRkI4MzRcIiB4MT1cIjQ5Mi4zNDhcIiB5MT1cIjQxMC4wMDhcIiB4Mj1cIjU4OS41MDlcIiB5Mj1cIjQzMi44ODNcIi8+XFxuICAgIDxwYXRoIGZpbGw9XCIjRUZCODM0XCIgZD1cIk00OTIuNTU1LDQwOS4xMzJjMCwwLDEuNTgxLDAuMDkxLDQuMzM1LDAuMzAzYzEuMzgsMC4wOTUsMy4wNSwwLjIzMiw0Ljk2MiwwLjQwM1xcbiAgICAgIGMxLjkxMiwwLjE3Myw0LjA3NywwLjMzNCw2LjQyNCwwLjU3NGMyLjM0OCwwLjIzNCw0Ljg5MiwwLjQ4Nyw3LjU4MywwLjc1NWMyLjY5MywwLjI1OSw1LjUxOSwwLjU5Miw4LjQ1LDAuOTA0XFxuICAgICAgYzIuOTIzLDAuMzQ3LDUuOTQ3LDAuNjg4LDkuMDA0LDEuMTAxYzMuMDY0LDAuMzg0LDYuMTYxLDAuODQxLDkuMjY2LDEuMjY2YzMuMTAyLDAuNDM3LDYuMjQ3LDAuNjkxLDkuMzQ2LDAuOTIyXFxuICAgICAgYzEuNTQ2LDAuMTMzLDMuMDg0LDAuMjQ2LDQuNTg4LDAuNDI2YzEuNTAyLDAuMTg1LDIuOTcyLDAuNDMsNC40MDMsMC43MzJjMi44NTcsMC42MjgsNS41NDgsMS41MzEsOC4wNjQsMi41NDNcXG4gICAgICBjMi41MTksMC45OTgsNC44NjQsMi4wOTUsNy4wMDQsMy4yMTNjNC4yODUsMi4yMTksNy43MzIsNC41ODgsMTAuMDkzLDYuNDcyYzEuMTgxLDAuOTM4LDIuMDk0LDEuNzM4LDIuNzA0LDIuMzM3XFxuICAgICAgYzAuNjE1LDAuNTc2LDAuOTM0LDAuOTIzLDAuOTM0LDAuOTIzbC0wLjQxMiwxLjc1MmMwLDAtMC40NCwwLjE2OS0xLjI0OCwwLjQxYy0wLjgxMywwLjI2My0xLjk4NywwLjU3Mi0zLjQ2MywwLjg4NVxcbiAgICAgIGMtMi45NTMsMC42MzMtNy4wOTYsMS4yMTYtMTEuOTIsMS4yOWMtMi40MTQsMC4wNDYtNS4wMDMtMC4wMTgtNy43MDItMC4yNDljLTIuNzAzLTAuMjE2LTUuNTE1LTAuNjA5LTguMzUxLTEuMzIyXFxuICAgICAgYy0xLjQxNS0wLjM2OC0yLjg0LTAuODA0LTQuMjY3LTEuMzA5Yy0xLjQyNi0wLjUwOS0yLjg1My0xLjA5NS00LjI5Ni0xLjY2NWMtMi44NzgtMS4xNzYtNS44MDUtMi4zNTEtOC43NzYtMy4zNDRcXG4gICAgICBjLTIuOTY4LTEuMDA0LTUuOTQ0LTEuOTc3LTguODU3LTNjLTIuOTItMC45OTUtNS43NzktMi4wMzgtOC41NDktMy4wMzJjLTIuNzYyLTEuMDI5LTUuNDQtMS45OTItNy45NjUtMi45NjFcXG4gICAgICBjLTIuNTI4LTAuOTYxLTQuOTE4LTEuODY5LTcuMTI0LTIuNzA4Yy0yLjIwNy0wLjgzMy00LjIxNy0xLjY1NS02LjAwNS0yLjM1M2MtMS43ODgtMC43LTMuMzQ0LTEuMzIzLTQuNjIxLTEuODU0XFxuICAgICAgYy0yLjU1OS0xLjAzOS00LjAxNS0xLjY2My00LjAxNS0xLjY2M0w0OTIuNTU1LDQwOS4xMzJ6XCIvPlxcbiAgPC9nPlxcbiAgPGc+XFxuICAgIDxsaW5lIGZpbGw9XCIjRUZCODM0XCIgeDE9XCI1MDIuNTU5XCIgeTE9XCIzMDEuN1wiIHgyPVwiNjAyLjM3XCIgeTI9XCIzMDAuNjg1XCIvPlxcbiAgICA8cGF0aCBmaWxsPVwiI0VGQjgzNFwiIGQ9XCJNNTAyLjU1LDMwMC44YzAsMCwxLjU1Ny0wLjI4OSw0LjI4Mi0wLjc0MmMxLjM2Mi0wLjIzNywzLjAxNy0wLjUwNCw0LjkxNS0wLjc5NVxcbiAgICAgIGMxLjg5OC0wLjI4OSw0LjAzOS0wLjY1LDYuMzc1LTAuOTc5YzIuMzM2LTAuMzM0LDQuODY3LTAuNjk3LDcuNTQ0LTEuMDhjMi42NzctMC4zOTIsNS41LTAuNzQ0LDguNDIxLTEuMTQyXFxuICAgICAgYzIuOTIxLTAuMzYyLDUuOTM5LTAuNzUzLDkuMDA2LTEuMDg0YzMuMDY3LTAuMzU5LDYuMTgzLTAuNjU2LDkuMy0wLjk4NWMzLjExNi0wLjMxNyw2LjIzLTAuODIzLDkuMjk2LTEuMzM5XFxuICAgICAgYzEuNTMzLTAuMjQsMy4wNTMtMC40OTksNC41NTYtMC42ODNjMS41MDMtMC4xOCwyLjk4OS0wLjI5Myw0LjQ1LTAuMzQyYzIuOTI0LTAuMDczLDUuNzUzLDAuMTYsOC40MzgsMC41NDJcXG4gICAgICBjMi42ODUsMC4zNjYsNS4yMjQsMC44NzEsNy41NywxLjQ0NmM0LjY5MSwxLjEzLDguNjA1LDIuNjA3LDExLjM0NywzLjg3MmMxLjM3MSwwLjYyOSwyLjQ0OSwxLjE4NywzLjE4NSwxLjYyMlxcbiAgICAgIGMwLjczNSwwLjQxMiwxLjEyOCwwLjY3MywxLjEyOCwwLjY3M2wwLjAxOCwxLjhjMCwwLTAuMzg3LDAuMjY5LTEuMTE0LDAuNjk2Yy0wLjcyNywwLjQ1LTEuNzkzLDEuMDMxLTMuMTUxLDEuNjg3XFxuICAgICAgYy0yLjcxNiwxLjMyMS02LjYsMi44NzctMTEuMjY2LDQuMTAyYy0yLjMzMywwLjYyMi00Ljg2MiwxLjE3OS03LjUzOSwxLjU5OWMtMi42NzYsMC40MzYtNS41LDAuNzI3LTguNDI1LDAuNzEzXFxuICAgICAgYy0xLjQ2Mi0wLjAxOS0yLjk1LTAuMTAyLTQuNDU2LTAuMjUxYy0xLjUwNi0wLjE1My0zLjAzMi0wLjM4MS00LjU2OS0wLjU5Yy0zLjA3NS0wLjQ1NC02LjE5OS0wLjg5NS05LjMyMS0xLjE0OVxcbiAgICAgIGMtMy4xMjItMC4yNjYtNi4yNDQtMC40OTktOS4zMTgtMC43OTZjLTMuMDczLTAuMjY4LTYuMDk5LTAuNTk4LTkuMDI2LTAuOWMtMi45MjgtMC4zMzgtNS43NTgtMC42MzQtOC40NDItMC45NzFcXG4gICAgICBjLTIuNjg0LTAuMzI5LTUuMjIyLTAuNjM5LTcuNTY0LTAuOTI2Yy0yLjM0Mi0wLjI4MS00LjQ5LTAuNTk5LTYuMzk0LTAuODQ5Yy0xLjkwMy0wLjI1My0zLjU2My0wLjQ4Ni00LjkzLTAuNjk1XFxuICAgICAgYy0yLjczNC0wLjM5Ny00LjI5Ni0wLjY1NS00LjI5Ni0wLjY1NUw1MDIuNTUsMzAwLjh6XCIvPlxcbiAgPC9nPlxcbiAgPGc+XFxuICAgIDxsaW5lIGZpbGw9XCIjRUZCODM0XCIgeDE9XCIxMzUuNjYxXCIgeTE9XCIyMTIuNzY0XCIgeDI9XCI0OC42NjVcIiB5Mj1cIjE2My44MjRcIi8+XFxuICAgIDxwYXRoIGZpbGw9XCIjRUZCODM0XCIgZD1cIk0xMzUuMjIsMjEzLjU0OGMwLDAtMS40OTMtMC41MjYtNC4wOC0xLjQ5NGMtMS4yOTktMC40NzQtMi44NjYtMS4wNjktNC42NTYtMS43NjRcXG4gICAgICBjLTEuNzg5LTAuNjk3LTMuODI0LTEuNDUzLTYuMDEzLTIuMzM0Yy0yLjE5MS0wLjg3Ni00LjU2NS0xLjgyNi03LjA3Ni0yLjgzYy0yLjUxNS0wLjk5Ni01LjEzOC0yLjEtNy44NjctMy4yMTNcXG4gICAgICBjLTIuNzEyLTEuMTQ0LTUuNTIyLTIuMzEyLTguMzQ1LTMuNTU2Yy0yLjgzNy0xLjIyLTUuNjg2LTIuNTE4LTguNTUtMy43ODhjLTIuODU5LTEuMjgtNS44MS0yLjM5Ny04LjcyMy0zLjQ4XFxuICAgICAgYy0xLjQ0OC0wLjU1Ny0yLjg5NS0xLjA5Mi00LjI4OS0xLjY4M2MtMS4zOTItMC41OTQtMi43MzYtMS4yMzgtNC4wMjctMS45MjVjLTIuNTctMS4zOTYtNC45MDUtMy4wMS03LjA0MS00LjY4MVxcbiAgICAgIGMtMi4xNDMtMS42NTctNC4wOTItMy4zNjMtNS44MzgtNS4wMzFjLTMuNS0zLjMyLTYuMTU1LTYuNTU0LTcuOS05LjAxOWMtMC44NzQtMS4yMjktMS41My0yLjI1MS0xLjk1LTIuOTk1XFxuICAgICAgYy0wLjQzMS0wLjcyNC0wLjY0MS0xLjE0Ni0wLjY0MS0xLjE0NmwwLjg4My0xLjU2OWMwLDAsMC40Ny0wLjA0LDEuMzEzLTAuMDQ3YzAuODU0LTAuMDI3LDIuMDY4LDAuMDAyLDMuNTcyLDAuMTExXFxuICAgICAgYzMuMDEzLDAuMjExLDcuMTU1LDAuODAxLDExLjgxLDIuMDY5YzIuMzMyLDAuNjI1LDQuODAxLDEuNDA2LDcuMzMxLDIuMzc3YzIuNTM3LDAuOTU4LDUuMTI5LDIuMTE1LDcuNjU2LDMuNTg3XFxuICAgICAgYzEuMjU4LDAuNzQ2LDIuNTA1LDEuNTYxLDMuNzM2LDIuNDQyYzEuMjI5LDAuODg1LDIuNDM3LDEuODQ0LDMuNjY1LDIuNzkyYzIuNDM4LDEuOTI4LDQuOTI1LDMuODcsNy41MDMsNS42NDhcXG4gICAgICBjMi41NzMsMS43ODksNS4xNjEsMy41NDksNy42NzcsNS4zNDFjMi41MjksMS43NjYsNC45ODYsMy41NjIsNy4zNzIsNS4yODVjMi4zNjgsMS43NTUsNC42NzMsMy40MjMsNi44MzEsNS4wNTVcXG4gICAgICBjMi4xNjIsMS42MjUsNC4yMDYsMy4xNiw2LjA5Miw0LjU3OGMxLjg4OSwxLjQxMywzLjU5MiwyLjc2LDUuMTE3LDMuOTI3YzEuNTIzLDEuMTY5LDIuODQ1LDIuMTk5LDMuOTI1LDMuMDYzXFxuICAgICAgYzIuMTcsMS43MDgsMy4zOTYsMi43MTEsMy4zOTYsMi43MTFMMTM1LjIyLDIxMy41NDh6XCIvPlxcbiAgPC9nPlxcbiAgPGc+XFxuICAgIDxsaW5lIGZpbGw9XCIjRUZCODM0XCIgeDE9XCIxMjAuODk1XCIgeTE9XCI0MTEuNjcyXCIgeDI9XCIyMy43MzRcIiB5Mj1cIjQzNC41NDdcIi8+XFxuICAgIDxwYXRoIGZpbGw9XCIjRUZCODM0XCIgZD1cIk0xMjEuMTAxLDQxMi41NDhjMCwwLTEuNDU2LDAuNjIzLTQuMDE1LDEuNjYzYy0xLjI3NywwLjUzLTIuODMzLDEuMTUzLTQuNjIxLDEuODU0XFxuICAgICAgYy0xLjc4OCwwLjY5OC0zLjc5OCwxLjUyLTYuMDA1LDIuMzUzYy0yLjIwNiwwLjgzOC00LjU5NiwxLjc0Ny03LjEyNCwyLjcwOGMtMi41MjYsMC45NjktNS4yMDMsMS45MzItNy45NjUsMi45NjFcXG4gICAgICBjLTIuNzcsMC45OTMtNS42MjksMi4wMzctOC41NDksMy4wMzJjLTIuOTE0LDEuMDIzLTUuODg5LDEuOTk2LTguODU3LDNjLTIuOTcxLDAuOTkzLTUuODk5LDIuMTY5LTguNzc2LDMuMzQ0XFxuICAgICAgYy0xLjQ0MywwLjU3LTIuODcsMS4xNTYtNC4yOTYsMS42NjVjLTEuNDI3LDAuNTA1LTIuODUyLDAuOTQxLTQuMjY3LDEuMzA5Yy0yLjgzNiwwLjcxMy01LjY0OCwxLjEwNS04LjM1MSwxLjMyMVxcbiAgICAgIGMtMi42OTksMC4yMzEtNS4yODgsMC4yOTUtNy43MDIsMC4yNDljLTQuODI0LTAuMDc0LTguOTY3LTAuNjU3LTExLjkyLTEuMjljLTEuNDc2LTAuMzEzLTIuNjUtMC42MjEtMy40NjMtMC44ODVcXG4gICAgICBjLTAuODA4LTAuMjQxLTEuMjQ4LTAuNDEtMS4yNDgtMC40MWwtMC40MTMtMS43NTJjMCwwLDAuMzE5LTAuMzQ3LDAuOTM0LTAuOTIzYzAuNjEtMC41OTgsMS41MjMtMS4zOTksMi43MDQtMi4zMzdcXG4gICAgICBjMi4zNi0xLjg4NCw1LjgwOC00LjI1NCwxMC4wOTMtNi40NzJjMi4xNC0xLjExOSw0LjQ4NS0yLjIxNiw3LjAwNC0zLjIxM2MyLjUxNi0xLjAxMiw1LjIwNy0xLjkxNSw4LjA2NC0yLjU0M1xcbiAgICAgIGMxLjQzMS0wLjMwMiwyLjktMC41NDcsNC40MDMtMC43MzJjMS41MDMtMC4xODEsMy4wNDItMC4yOTMsNC41ODgtMC40MjZjMy4xLTAuMjMyLDYuMjQ1LTAuNDg2LDkuMzQ2LTAuOTIyXFxuICAgICAgYzMuMTA0LTAuNDI1LDYuMjAxLTAuODgyLDkuMjY1LTEuMjY2YzMuMDU3LTAuNDEyLDYuMDgxLTAuNzU0LDkuMDA0LTEuMTAxYzIuOTMxLTAuMzEyLDUuNzU3LTAuNjQ0LDguNDUtMC45MDRcXG4gICAgICBjMi42OTEtMC4yNjgsNS4yMzUtMC41MjEsNy41ODMtMC43NTVjMi4zNDctMC4yMzksNC41MTItMC40LDYuNDI0LTAuNTc0YzEuOTEzLTAuMTcxLDMuNTgzLTAuMzA4LDQuOTYyLTAuNDAzXFxuICAgICAgYzIuNzU0LTAuMjEyLDQuMzM1LTAuMzAzLDQuMzM1LTAuMzAzTDEyMS4xMDEsNDEyLjU0OHpcIi8+XFxuICA8L2c+XFxuICA8Zz5cXG4gICAgPGxpbmUgZmlsbD1cIiNFRkI4MzRcIiB4MT1cIjExMi42ODRcIiB5MT1cIjMwNi4zNjRcIiB4Mj1cIjEyLjg3M1wiIHkyPVwiMzA1LjM0OVwiLz5cXG4gICAgPHBhdGggZmlsbD1cIiNFRkI4MzRcIiBkPVwiTTExMi42NzUsMzA3LjI2NGMwLDAtMS41NjIsMC4yNTctNC4yOTYsMC42NTVjLTEuMzY3LDAuMjEtMy4wMjYsMC40NDMtNC45MywwLjY5NVxcbiAgICAgIGMtMS45MDQsMC4yNS00LjA1MSwwLjU2OC02LjM5NCwwLjg0OWMtMi4zNDMsMC4yODctNC44OCwwLjU5OC03LjU2NCwwLjkyNmMtMi42ODQsMC4zMzctNS41MTQsMC42MzMtOC40NDIsMC45NzFcXG4gICAgICBjLTIuOTI4LDAuMzAyLTUuOTUzLDAuNjMyLTkuMDI2LDAuOWMtMy4wNzQsMC4yOTctNi4xOTUsMC41My05LjMxOCwwLjc5NmMtMy4xMjIsMC4yNTQtNi4yNDYsMC42OTYtOS4zMjEsMS4xNDlcXG4gICAgICBjLTEuNTM3LDAuMjA5LTMuMDYzLDAuNDM3LTQuNTY5LDAuNTljLTEuNTA2LDAuMTQ5LTIuOTk0LDAuMjMyLTQuNDU2LDAuMjUxYy0yLjkyNSwwLjAxNC01Ljc0OS0wLjI3Ny04LjQyNS0wLjcxM1xcbiAgICAgIGMtMi42NzYtMC40MjEtNS4yMDUtMC45NzctNy41MzktMS41OTljLTQuNjY3LTEuMjI1LTguNTUtMi43ODEtMTEuMjY2LTQuMTAyYy0xLjM1OC0wLjY1Ni0yLjQyNC0xLjIzNy0zLjE1MS0xLjY4N1xcbiAgICAgIGMtMC43MjctMC40MjctMS4xMTQtMC42OTYtMS4xMTQtMC42OTZsMC4wMTgtMS44YzAsMCwwLjM5My0wLjI2MSwxLjEyOC0wLjY3M2MwLjczNi0wLjQzNSwxLjgxNC0wLjk5NCwzLjE4NS0xLjYyMlxcbiAgICAgIGMyLjc0Mi0xLjI2NSw2LjY1Ny0yLjc0MiwxMS4zNDctMy44NzJjMi4zNDUtMC41NzUsNC44ODUtMS4wNzksNy41Ny0xLjQ0NmMyLjY4NS0wLjM4Miw1LjUxNC0wLjYxNSw4LjQzOC0wLjU0MlxcbiAgICAgIGMxLjQ2MiwwLjA0OSwyLjk0NywwLjE2Miw0LjQ1LDAuMzQyYzEuNTAzLDAuMTg0LDMuMDI0LDAuNDQzLDQuNTU2LDAuNjgzYzMuMDY1LDAuNTE2LDYuMTgsMS4wMjEsOS4yOTYsMS4zMzlcXG4gICAgICBjMy4xMTYsMC4zMjksNi4yMzIsMC42MjYsOS4yOTksMC45ODVjMy4wNjcsMC4zMyw2LjA4NSwwLjcyMiw5LjAwNiwxLjA4NGMyLjkyLDAuMzk4LDUuNzQ0LDAuNzUsOC40MjEsMS4xNDJcXG4gICAgICBjMi42NzcsMC4zODMsNS4yMDgsMC43NDUsNy41NDQsMS4wOGMyLjMzNiwwLjMyOSw0LjQ3NywwLjY5LDYuMzc1LDAuOTc5YzEuODk4LDAuMjkxLDMuNTUyLDAuNTU4LDQuOTE1LDAuNzk1XFxuICAgICAgYzIuNzI1LDAuNDUzLDQuMjgyLDAuNzQyLDQuMjgyLDAuNzQyTDExMi42NzUsMzA3LjI2NHpcIi8+XFxuICA8L2c+XFxuPC9nPlxcbjxnIGlkPVwiY291bnRcIj5cXG4gIDx0ZXh0IHg9XCI0MDBcIiB5PVwiNzAwXCIgaWQ9XCJoaW50Q291bnRcIj48L3RleHQ+XFxuPC9nPlxcbjwvc3ZnPlxcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsInZhciBtc2cgPSByZXF1aXJlKCcuLi9sb2NhbGUnKTtcbnZhciBIaW50ID0gcmVxdWlyZSgnLi9IaW50LmpzeCcpO1xuXG4vKipcbiAqIEBvdmVydmlldyBSZWFjdCBDb21wb25lbnQgZm9yIGRpc3BsYXlpbmcgQXV0aG9yZWQgSGludHMgaW4gdGhlXG4gKiBJbnN0cnVjdGlvbnMgZGlhbG9nLiBBbnkgaGludHMgdGhlIHVzZXIgaGFzIGFscmVhZHkgcmVxdWVzdGVkIHRvIHNlZVxuICogYXJlIGxpc3RlZCwgYWxvbmcgd2l0aCBhIGJ1dHRvbiB0byBzZWUgdGhlIG5leHQgaGludC5cbiAqIFByZXNzaW5nIHRoZSBidXR0b24gYWRkcyB0aGUgbmV4dCBoaW50IChvciB0aGUgZmlyc3QgaGludCBpZiBub25lXG4gKiBoYXZlIHByZXZpb3VzbHkgYmVlbiB2aWV3ZWQpIHRvIHRoZSBsaXN0IG9mIGhpbnRzIGFuZCByZW1vdmVzIHRoZVxuICogYnV0dG9uLlxuICogQ2xvc2luZyB0aGUgaW5zdHJ1Y3Rpb25zIGFuZCByZS1vcGVuaW5nIHRoZW0gd2lsbCByZXNldCB0aGlzXG4gKiBDb21wb25lbnQsIGFsbG93aW5nIHRoZSBidXR0b24gdG8gYmUgcHJlc3NlZCBvbmNlIG1vcmUuXG4gKi9cbnZhciBIaW50c0Rpc3BsYXkgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgaGludFJldmlld1RpdGxlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgc2VlbkhpbnRzOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZihSZWFjdC5Qcm9wVHlwZXMub2JqZWN0KS5pc1JlcXVpcmVkLFxuICAgIHVuc2VlbkhpbnRzOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZihSZWFjdC5Qcm9wVHlwZXMub2JqZWN0KS5pc1JlcXVpcmVkLFxuICAgIG9uVXNlclZpZXdlZEhpbnQ6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgbGlnaHRidWxiU1ZHOiBSZWFjdC5Qcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLFxuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzaG93TmV4dFVuc2VlbkhpbnQ6IGZhbHNlXG4gICAgfTtcbiAgfSxcblxuICB2aWV3SGludDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucHJvcHMub25Vc2VyVmlld2VkSGludCgpO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc2hvd05leHRVbnNlZW5IaW50OiB0cnVlXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1hbnkgb2Ygb3VyIGhpbnRzIGluY2x1ZGUgQmxvY2tseSBibG9ja3MuIFVuZm9ydHVuYXRlbHksIEJsb2NrbHlcbiAgICogQmxvY2tTcGFjZXMgaGF2ZSBhIHJlYWwgcHJvYmxlbSB3aXRoIGJlaW5nIGNyZWF0ZWQgYmVmb3JlIHRoZXkgYXJlXG4gICAqIGluIHRoZSBET00sIHNvIHdlIG5lZWQgdG8gaW5qZWN0IHRoaXMgQmxvY2tTcGFjZSBvdXRzaWRlIG9mIG91clxuICAgKiBSZWFjdCByZW5kZXIgbWV0aG9kIG9uY2Ugd2UncmUgY29uZmlkZW50IHRoYXQgdGhpcyBjb21wb25lbnQgaXMgaW5cbiAgICogdGhlIERPTS5cbiAgICovXG4gIGluamVjdEJsb2NrbHlIaW50OiBmdW5jdGlvbiAoaGludCkge1xuICAgIHZhciByZWYgPSB0aGlzLnJlZnNbaGludC5oaW50SWRdO1xuICAgIHJlZi5pbmplY3RCbG9ja2x5SGludCgpO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gbm93IHRoYXQgd2UncmUgaW4gdGhlIERPTSwgd2UgY2FuIHJlbmRlciBvdXIgQmxvY2tseSBibG9ja3MgZm9yXG4gICAgLy8gdGhvc2UgaGludHMgdGhhdCBoYXZlIHRoZW1cbiAgICB0aGlzLnByb3BzLnNlZW5IaW50cy5maWx0ZXIoZnVuY3Rpb24gKGhpbnQpIHtcbiAgICAgIHJldHVybiBoaW50LmJsb2NrO1xuICAgIH0pLmZvckVhY2godGhpcy5pbmplY3RCbG9ja2x5SGludCk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gaWYgb3VyIHVwZGF0ZSBoYXMgdXMgc2hvd2luZyBhIG5ldyBoaW50LCBtYWtlIHN1cmUgdG8gcmVuZGVyIHRoZVxuICAgIC8vIGJsb2NrIGlmIGl0IGhhcyBvbmVcbiAgICBpZiAodGhpcy5zdGF0ZS5zaG93TmV4dFVuc2VlbkhpbnQgJiYgdGhpcy5wcm9wcy51bnNlZW5IaW50c1swXS5ibG9jaykge1xuICAgICAgdGhpcy5pbmplY3RCbG9ja2x5SGludCh0aGlzLnByb3BzLnVuc2VlbkhpbnRzWzBdKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhpbnRzVG9TaG93ID0gdGhpcy5wcm9wcy5zZWVuSGludHM7XG4gICAgaWYgKHRoaXMuc3RhdGUuc2hvd05leHRVbnNlZW5IaW50KSB7XG4gICAgICBoaW50c1RvU2hvdyA9IGhpbnRzVG9TaG93LmNvbmNhdCh0aGlzLnByb3BzLnVuc2VlbkhpbnRzWzBdKTtcbiAgICB9XG5cbiAgICB2YXIgc2VlbkhpbnRzO1xuICAgIGlmIChoaW50c1RvU2hvdyAmJiBoaW50c1RvU2hvdy5sZW5ndGgpIHtcbiAgICAgIHNlZW5IaW50cyA9IFtcbiAgICAgICAgICA8aDEga2V5PVwiaGludC1yZXZpZXctdGl0bGVcIj57IHRoaXMucHJvcHMuaGludFJldmlld1RpdGxlIH08L2gxPixcbiAgICAgICAgICA8dWwga2V5PVwiaGludHMtdG8tc2hvd1wiPlxuICAgICAgICAgICAge2hpbnRzVG9TaG93Lm1hcChmdW5jdGlvbiAoaGludCkge1xuICAgICAgICAgICAgICByZXR1cm4gPEhpbnQgaGludD17aGludH0ga2V5PXtoaW50LmhpbnRJZH0gcmVmPXtoaW50LmhpbnRJZH0gLz47XG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICA8L3VsPlxuICAgICAgXTtcbiAgICB9XG5cbiAgICB2YXIgdmlld0hpbnRCdXR0b247XG4gICAgaWYgKCF0aGlzLnN0YXRlLnNob3dOZXh0VW5zZWVuSGludCAmJiB0aGlzLnByb3BzLnVuc2VlbkhpbnRzICYmIHRoaXMucHJvcHMudW5zZWVuSGludHMubGVuZ3RoKSB7XG4gICAgICB2aWV3SGludEJ1dHRvbiA9IChcbiAgICAgICAgPGJ1dHRvbiBpZD1cImhpbnQtYnV0dG9uXCIgb25DbGljaz17IHRoaXMudmlld0hpbnQgfSBjbGFzc05hbWU9XCJsaWdodGJ1bGItYnV0dG9uXCI+XG4gICAgICAgICAgPHNwYW4gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiB0aGlzLnByb3BzLmxpZ2h0YnVsYlNWRyB9fSAvPlxuICAgICAgICAgIHttc2cuaGludFNlbGVjdE5ld0hpbnQoKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImF1dGhvcmVkLWhpbnRzXCI+XG4gICAgICB7c2VlbkhpbnRzfVxuICAgICAge3ZpZXdIaW50QnV0dG9ufVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IEhpbnRzRGlzcGxheTtcbiIsIm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gIHByb3BUeXBlczoge1xuICAgIGhpbnQ6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxuICB9LFxuXG4gIC8qKlxuICAgKiBAc2VlIEhpbnRzRGlzcGxheS5pbmplY3RCbG9ja2x5SGludFxuICAgKi9cbiAgaW5qZWN0QmxvY2tseUhpbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMucmVmcy5oaW50QmxvY2s7XG4gICAgLy8gT25seSByZW5kZXIgaWYgdGhlIG5vZGUgZXhpc3RzIGluIHRoZSBET01cbiAgICBpZiAobm9kZSAmJiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgICBCbG9ja2x5LkJsb2NrU3BhY2UuY3JlYXRlUmVhZE9ubHlCbG9ja1NwYWNlKG5vZGUsIHRoaXMucHJvcHMuaGludC5ibG9jayk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBoaW50QmxvY2s7XG4gICAgaWYgKHRoaXMucHJvcHMuaGludC5ibG9jaykge1xuICAgICAgaGludEJsb2NrID0gKDxkaXYgY2xhc3NOYW1lPVwiYmxvY2staGludFwiIHJlZj1cImhpbnRCbG9ja1wiIGlkPXsgdGhpcy5wcm9wcy5oaW50LmhpbnRJZCB9IHN0eWxlPXt7IG1heEhlaWdodDogJzEwMHB4JyB9fSAvPik7XG4gICAgfVxuICAgIHJldHVybiAoPGxpIHN0eWxlPXt7IG1hcmdpbkJvdHRvbTogJzEycHgnIH19PlxuICAgICAgPGRpdiBkYW5nZXJvdXNseVNldElubmVySFRNTD17eyBfX2h0bWwgOiB0aGlzLnByb3BzLmhpbnQuY29udGVudCB9fSAvPlxuICAgICAge2hpbnRCbG9ja31cbiAgICA8L2xpPik7XG4gIH0sXG59KTtcblxuIiwidmFyIG1zZyA9IHJlcXVpcmUoJy4uL2xvY2FsZScpO1xuXG52YXIgSGludFNlbGVjdCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgcHJvcFR5cGVzOiB7XG4gICAgc2hvd0luc3RydWN0aW9uczogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBzaG93SGludDogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdj5cbiAgICAgICAgPGg0Pnttc2cuaGludFByb21wdCgpfTwvaDQ+XG4gICAgICAgIDxhIGNsYXNzTmFtZT0nYnRuIGJ0bi1saW5rIHNob3ctaW5zdHJ1Y3Rpb25zJyBvbkNsaWNrPXt0aGlzLnByb3BzLnNob3dJbnN0cnVjdGlvbnN9Pnttc2cuaGludFNlbGVjdEluc3RydWN0aW9ucygpfTwvYT5cbiAgICAgICAgPGEgY2xhc3NOYW1lPSdidG4gYnRuLWxpbmsgc2hvdy1oaW50JyBvbkNsaWNrPXt0aGlzLnByb3BzLnNob3dIaW50fT57bXNnLmhpbnRTZWxlY3ROZXdIaW50KCl9PC9hPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IEhpbnRTZWxlY3Q7XG4iLCIvKiBnbG9iYWwgbWFya2VkICovXG52YXIgcGFyc2VYbWxFbGVtZW50ID0gcmVxdWlyZSgnLi94bWwnKS5wYXJzZUVsZW1lbnQ7XG52YXIgbXNnID0gcmVxdWlyZSgnLi9sb2NhbGUnKTtcblxuLyoqXG4gKiBAb3ZlcnZpZXcgQSBoZWxwZXIgY2xhc3MgZm9yIGFsbCBhY3Rpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGUgQXV0aG9yZWRcbiAqIEhpbnQgdmlld2luZyBhbmQgbG9nZ2luZyBzeXN0ZW0uXG4gKlxuICogVGhlIGdlbmVyYWwgcGF0dGVybiBmb3IgdXNhZ2UgaXMgc3RyYWlnaHRmb3J3YXJkOlxuICpcbiAqIEV2ZXJ5IHRpbWUgYSB1c2VyIHJlcXVlc3RzIHRvIHZpZXcgYSBuZXcgaGludCwgd2UgbG9nIGluZm9ybWF0aW9uXG4gKiBhYm91dCB0aGF0IGhpbnQgYXMgd2VsbCBhcyB0aGUgbW9zdCByZWNlbnQgYXR0ZW1wdC5cbiAqXG4gKiBFdmVyeSB0aW1lIGEgdXNlciBtYWtlcyBhbiBcImF0dGVtcHRcIiBhdCB0aGUgbGV2ZWwgYW5kIHNlbmQgYW4gYXR0ZW1wdFxuICogcmVwb3J0LCB3ZSBzYXZlIHNvbWUgaW5mb3JtYXRpb24gYWJvdXQgdGhhdCBtb3N0IHJlY2VudCBhdHRlbXB0LCBhbmRcbiAqIGFkZCB0aGF0IGluZm9ybWF0aW9uIHRvIGFsbCBoaW50IHZpZXdzIGZyb20gdGhlIHByZXZpb3VzIGF0dGVtcHQuXG4gKlxuICogRmluYWxseSwgd2hlbiB0aGUgdXNlciBuYXZpZ2F0ZXMgdG8gYSBuZXcgcGFnZSAoZWl0aGVyIGJ5IGNvbXBsZXRpbmdcbiAqIHRoZSBsZXZlbCBhbmQgbW92aW5nIG9uIG9yIGJ5IGxlYXZpbmcgdGhlIGxldmVsIGFuZCBjb21pbmcgYmFja1xuICogbGF0ZXIpLCB3ZSByZWNvcmQgZm9yIGFsbCBoaW50cyB0aGUgXCJmaW5hbFwiIGF0dGVtcHQgaW4gdGhhdCBzZXNzaW9uXG4gKiBhbmQgcG9zdCB0aGUgcmVzdWx0cyB0byB0aGUgc2VydmVyLlxuICpcbiAqIFRodXMsIGVhY2ggaGludCBoYXMgdGhyZWUgYXR0ZW1wdCByZWNvcmRzIGJ5IHRoZSBlbmQgb2YgdGhlXG4gKiBsaWZlY3ljbGU6XG4gKiAgMSkgYSBcInByZXZpb3VzXCIgYXR0ZW1wdCAoY2FuIGJlIGVtcHR5KVxuICogIDIpIGEgXCJuZXh0XCIgYXR0ZW1wdFxuICogIDMpIGEgXCJmaW5hbFwiIGF0dGVtcHRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEhpbnREYXRhXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2NyaXB0SWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZXZlbElkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaGludElkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaGludENsYXNzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaGludFR5cGVcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBVbmZpbmlzaGVkSGludFxuICogQGF1Z21lbnRzIEhpbnREYXRhXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3ByZXZUaW1lXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwcmV2QXR0ZW1wdF1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcHJldlRlc3RSZXN1bHRdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3ByZXZBY3Rpdml0eUlkXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwcmV2TGV2ZWxTb3VyY2VJZF1cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGaW5pc2hlZEhpbnRcbiAqIEBhdWdtZW50cyBVbmZpbmlzaGVkSGludFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG5leHRUaW1lXG4gKiBAcHJvcGVydHkge251bWJlcn0gbmV4dEF0dGVtcHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZXh0VGVzdFJlc3VsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG5leHRBY3Rpdml0eUlkXG4gKiBAcHJvcGVydHkge251bWJlcn0gbmV4dExldmVsU291cmNlSWRcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGaW5hbGl6ZWRIaW50XG4gKiBAYXVnbWVudHMgRmluaXNoZWRIaW50XG4gKiBAcHJvcGVydHkge251bWJlcn0gZmluYWxUaW1lXG4gKiBAcHJvcGVydHkge251bWJlcn0gZmluYWxBdHRlbXB0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZmluYWxUZXN0UmVzdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZmluYWxBY3Rpdml0eUlkXG4gKiBAcHJvcGVydHkge251bWJlcn0gZmluYWxMZXZlbFNvdXJjZUlkXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQXR0ZW1wdFJlY29yZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhdHRlbXB0XG4gKiBAcHJvcGVydHkge251bWJlcn0gdGVzdFJlc3VsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGFjdGl2aXR5SWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZXZlbFNvdXJjZUlkXG4gKi9cblxudmFyIGF1dGhvcmVkSGludFV0aWxzID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gYXV0aG9yZWRIaW50VXRpbHM7XG5cbmF1dGhvcmVkSGludFV0aWxzLmdldEZyb21Mb2NhbFN0b3JhZ2VfID0gZnVuY3Rpb24gKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICB0cnkge1xuICAgIHJlc3VsdCA9IHJlc3VsdCA/IEpTT04ucGFyc2UocmVzdWx0KSA6IGRlZmF1bHRWYWx1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlc3VsdCA9IGRlZmF1bHRWYWx1ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtVbmZpbmlzaGVkSGludFtdfVxuICovXG5hdXRob3JlZEhpbnRVdGlscy5nZXRVbmZpbmlzaGVkSGludHNfID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gYXV0aG9yZWRIaW50VXRpbHMuZ2V0RnJvbUxvY2FsU3RvcmFnZV8oJ3VuZmluaXNoZWRfYXV0aG9yZWRfaGludF92aWV3cycsIFtdKTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7RmluaXNoZWRIaW50W119XG4gKi9cbmF1dGhvcmVkSGludFV0aWxzLmdldEZpbmlzaGVkSGludHNfID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gYXV0aG9yZWRIaW50VXRpbHMuZ2V0RnJvbUxvY2FsU3RvcmFnZV8oJ2ZpbmlzaGVkX2F1dGhvcmVkX2hpbnRfdmlld3MnLCBbXSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge0F0dGVtcHRSZWNvcmR9XG4gKi9cbmF1dGhvcmVkSGludFV0aWxzLmdldExhc3RBdHRlbXB0UmVjb3JkXyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGF1dGhvcmVkSGludFV0aWxzLmdldEZyb21Mb2NhbFN0b3JhZ2VfKCdsYXN0X2F0dGVtcHRfcmVjb3JkJywgdW5kZWZpbmVkKTtcbn07XG5cbi8qKlxuICogQXBwZW5kcyB0aGUgZ2l2ZW4gaGludHMgdG8gdGhlIGFycmF5IG9mIGV4aXN0aW5nIEZpbmlzaGVkSGludHNcbiAqIEBwYXJhbSB7RmluaXNoZWRIaW50W119IGhpbnRzXG4gKi9cbmF1dGhvcmVkSGludFV0aWxzLnJlY29yZEZpbmlzaGVkSGludHNfID0gZnVuY3Rpb24gKGhpbnRzKSB7XG4gIHZhciBmaW5pc2hlZEhpbnRWaWV3cyA9IGF1dGhvcmVkSGludFV0aWxzLmdldEZpbmlzaGVkSGludHNfKCk7XG4gIGZpbmlzaGVkSGludFZpZXdzID0gZmluaXNoZWRIaW50Vmlld3MuY29uY2F0KGhpbnRzKTtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2ZpbmlzaGVkX2F1dGhvcmVkX2hpbnRfdmlld3MnLCBKU09OLnN0cmluZ2lmeShmaW5pc2hlZEhpbnRWaWV3cykpO1xufTtcblxuYXV0aG9yZWRIaW50VXRpbHMuY2xlYXJVbmZpbmlzaGVkSGludHMgPSBmdW5jdGlvbiAoKSB7XG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1bmZpbmlzaGVkX2F1dGhvcmVkX2hpbnRfdmlld3MnLCBKU09OLnN0cmluZ2lmeShbXSkpO1xufTtcblxuYXV0aG9yZWRIaW50VXRpbHMuY2xlYXJGaW5pc2hlZEhpbnRzXyA9IGZ1bmN0aW9uICgpIHtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2ZpbmlzaGVkX2F1dGhvcmVkX2hpbnRfdmlld3MnLCBKU09OLnN0cmluZ2lmeShbXSkpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtGaW5hbGl6ZWRIaW50c1tdfVxuICovXG5hdXRob3JlZEhpbnRVdGlscy5maW5hbGl6ZUhpbnRzXyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGZpbmFsQXR0ZW1wdFJlY29yZCA9IGF1dGhvcmVkSGludFV0aWxzLmdldExhc3RBdHRlbXB0UmVjb3JkXygpO1xuICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnbGFzdF9hdHRlbXB0X3JlY29yZCcpO1xuICB2YXIgaGludHMgPSBhdXRob3JlZEhpbnRVdGlscy5nZXRGaW5pc2hlZEhpbnRzXygpO1xuICBpZiAoZmluYWxBdHRlbXB0UmVjb3JkKSB7XG4gICAgaGludHMgPSBoaW50cy5tYXAoZnVuY3Rpb24oaGludCl7XG4gICAgICBoaW50ID0gJC5leHRlbmQoe1xuICAgICAgICBmaW5hbFRpbWU6IGZpbmFsQXR0ZW1wdFJlY29yZC50aW1lLFxuICAgICAgICBmaW5hbEF0dGVtcHQ6IGZpbmFsQXR0ZW1wdFJlY29yZC5hdHRlbXB0LFxuICAgICAgICBmaW5hbFRlc3RSZXN1bHQ6IGZpbmFsQXR0ZW1wdFJlY29yZC50ZXN0UmVzdWx0LFxuICAgICAgICBmaW5hbEFjdGl2aXR5SWQ6IGZpbmFsQXR0ZW1wdFJlY29yZC5hY3Rpdml0eUlkLFxuICAgICAgICBmaW5hbExldmVsU291cmNlSWQ6IGZpbmFsQXR0ZW1wdFJlY29yZC5sZXZlbFNvdXJjZUlkLFxuICAgICAgfSwgaGludCk7XG4gICAgICByZXR1cm4gaGludDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaGludHM7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBoaW50IHRvIHRoZSBsaXN0IG9mIFwidW5maW5pc2hlZFwiIGhpbnRzIGZvciB0aGUgYXR0ZW1wdFxuICogY3VycmVudGx5IGluIHByb2dyZXNzLiBJZiB0aGlzIGlzIG5vdCB0aGUgZmlyc3QgYXR0ZW1wdCBvZiB0aGVcbiAqIHNlc3Npb24sIHNhdmUgYWxvbmcgd2l0aCB0aGUgaGludCBhIHJlY29yZCBvZiB0aGUgbW9zdCByZWNlbnRcbiAqIGF0dGVtcHQuXG4gKlxuICogQHBhcmFtIHtIaW50RGF0YX0gaGludFxuICovXG5hdXRob3JlZEhpbnRVdGlscy5yZWNvcmRVbmZpbmlzaGVkSGludCA9IGZ1bmN0aW9uIChoaW50KSB7XG4gIHZhciBsYXN0QXR0ZW1wdFJlY29yZCA9IGF1dGhvcmVkSGludFV0aWxzLmdldExhc3RBdHRlbXB0UmVjb3JkXygpO1xuICBpZiAobGFzdEF0dGVtcHRSZWNvcmQpIHtcbiAgICBoaW50ID0gJC5leHRlbmQoe1xuICAgICAgcHJldlRpbWU6IGxhc3RBdHRlbXB0UmVjb3JkLnRpbWUsXG4gICAgICBwcmV2QXR0ZW1wdDogbGFzdEF0dGVtcHRSZWNvcmQuYXR0ZW1wdCxcbiAgICAgIHByZXZUZXN0UmVzdWx0OiBsYXN0QXR0ZW1wdFJlY29yZC50ZXN0UmVzdWx0LFxuICAgICAgcHJldkFjdGl2aXR5SWQ6IGxhc3RBdHRlbXB0UmVjb3JkLmFjdGl2aXR5SWQsXG4gICAgICBwcmV2TGV2ZWxTb3VyY2VJZDogbGFzdEF0dGVtcHRSZWNvcmQubGV2ZWxTb3VyY2VJZCxcbiAgICB9LCBoaW50KTtcbiAgfVxuICB2YXIgdW5maW5pc2hlZEhpbnRWaWV3cyA9IGF1dGhvcmVkSGludFV0aWxzLmdldFVuZmluaXNoZWRIaW50c18oKTtcbiAgdW5maW5pc2hlZEhpbnRWaWV3cy5wdXNoKGhpbnQpO1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndW5maW5pc2hlZF9hdXRob3JlZF9oaW50X3ZpZXdzJywgSlNPTi5zdHJpbmdpZnkodW5maW5pc2hlZEhpbnRWaWV3cykpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0F0dGVtcHRSZWNvcmR9IG5leHRBdHRlbXB0UmVjb3JkXG4gKi9cbmF1dGhvcmVkSGludFV0aWxzLmZpbmlzaEhpbnRzID0gZnVuY3Rpb24gKG5leHRBdHRlbXB0UmVjb3JkKSB7XG4gIGlmICghbmV4dEF0dGVtcHRSZWNvcmQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2xhc3RfYXR0ZW1wdF9yZWNvcmQnLCBKU09OLnN0cmluZ2lmeShuZXh0QXR0ZW1wdFJlY29yZCkpO1xuICB2YXIgdW5maW5pc2hlZEhpbnRWaWV3cyA9IGF1dGhvcmVkSGludFV0aWxzLmdldFVuZmluaXNoZWRIaW50c18oKTtcbiAgYXV0aG9yZWRIaW50VXRpbHMuY2xlYXJVbmZpbmlzaGVkSGludHMoKTtcbiAgdmFyIGZpbmlzaGVkSGludFZpZXdzID0gdW5maW5pc2hlZEhpbnRWaWV3cy5tYXAoZnVuY3Rpb24oaGludCl7XG4gICAgaGludCA9ICQuZXh0ZW5kKHtcbiAgICAgIG5leHRUaW1lOiBuZXh0QXR0ZW1wdFJlY29yZC50aW1lLFxuICAgICAgbmV4dEF0dGVtcHQ6IG5leHRBdHRlbXB0UmVjb3JkLmF0dGVtcHQsXG4gICAgICBuZXh0VGVzdFJlc3VsdDogbmV4dEF0dGVtcHRSZWNvcmQudGVzdFJlc3VsdCxcbiAgICAgIG5leHRBY3Rpdml0eUlkOiBuZXh0QXR0ZW1wdFJlY29yZC5hY3Rpdml0eUlkLFxuICAgICAgbmV4dExldmVsU291cmNlSWQ6IG5leHRBdHRlbXB0UmVjb3JkLmxldmVsU291cmNlSWQsXG4gICAgfSwgaGludCk7XG4gICAgcmV0dXJuIGhpbnQ7XG4gIH0pO1xuICBhdXRob3JlZEhpbnRVdGlscy5yZWNvcmRGaW5pc2hlZEhpbnRzXyhmaW5pc2hlZEhpbnRWaWV3cyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqL1xuYXV0aG9yZWRIaW50VXRpbHMuc3VibWl0SGludHMgPSBmdW5jdGlvbiAodXJsKSB7XG4gIC8vIGZpcnN0LCBmaW5pc2ggYWxsIHVuZmluaXNoZWQgaGludHNcbiAgdmFyIHVuZmluaXNoZWRIaW50cyA9IGF1dGhvcmVkSGludFV0aWxzLmdldFVuZmluaXNoZWRIaW50c18oKTtcbiAgaWYgKHVuZmluaXNoZWRIaW50cyAmJiB1bmZpbmlzaGVkSGludHMubGVuZ3RoKSB7XG4gICAgdmFyIGZpbmFsSGludCA9IHVuZmluaXNoZWRIaW50c1t1bmZpbmlzaGVkSGludHMubGVuZ3RoLTFdO1xuICAgIGF1dGhvcmVkSGludFV0aWxzLmZpbmlzaEhpbnRzKHtcbiAgICAgIHRpbWU6IGZpbmFsSGludC5wcmV2VGltZSxcbiAgICAgIGF0dGVtcHQ6IGZpbmFsSGludC5wcmV2QXR0ZW1wdCxcbiAgICAgIHRlc3RSZXN1bHQ6IGZpbmFsSGludC5wcmV2VGVzdFJlc3VsdCxcbiAgICAgIGFjdGl2aXR5SWQ6IGZpbmFsSGludC5wcmV2QWN0aXZpdHlJZCxcbiAgICAgIGxldmVsU291cmNlSWQ6IGZpbmFsSGludC5wcmV2TGV2ZWxTb3VyY2VJZCxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHRoZW4sIGZpbmFsaXplIGFsbCBoaW50c1xuICB2YXIgaGludHMgPSBhdXRob3JlZEhpbnRVdGlscy5maW5hbGl6ZUhpbnRzXygpO1xuXG4gIC8vIG5vdywgYWxsIGhpbnRzIHNob3VsZCBiZSBmaW5pc2hlZCBhbmQgZmluYWxpemVkLiBTbyBzdWJtaXQgdGhlbSBhbGxcbiAgaWYgKGhpbnRzICYmIGhpbnRzLmxlbmd0aCkge1xuICAgICQuYWpheCh7XG4gICAgICB1cmw6IHVybCxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KHtoaW50czogaGludHN9KSxcbiAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGF1dGhvcmVkSGludFV0aWxzLmNsZWFyRmluaXNoZWRIaW50c18oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgY29udGV4dHVhbCBoaW50cyBhcyB1c2VkIGJ5IFN0dWRpb0FwcCBmcm9tIEJsb2NrbHkgWE1MXG4gKiBAcGFyYW0ge09iamVjdFtdfSBibG9ja3MgQW4gYXJyYXkgb2Ygb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlXG4gKiAgICAgICAgbWlzc2luZyByZWNvbW1lbmRlZCBCbG9ja2x5IEJsb2NrcyBmb3Igd2hpY2ggd2Ugd2FudCB0b1xuICogICAgICAgIGNyZWF0ZSBoaW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBibG9ja3NbXS5ibG9ja0Rpc3BsYXlYTUxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYmxvY2tzW10uYWxyZWFkeVNlZW5cbiAqIEByZXR1cm4ge0F1dGhvcmVkSGludFtdfVxuICovXG5hdXRob3JlZEhpbnRVdGlscy5jcmVhdGVDb250ZXh0dWFsSGludHNGcm9tQmxvY2tzID0gZnVuY3Rpb24gKGJsb2Nrcykge1xuICB2YXIgaGludHMgPSBibG9ja3MubWFwKGZ1bmN0aW9uIChibG9jaykge1xuICAgIHZhciB4bWxCbG9jayA9IHBhcnNlWG1sRWxlbWVudChibG9jay5ibG9ja0Rpc3BsYXlYTUwpO1xuICAgIHZhciBibG9ja1R5cGUgPSB4bWxCbG9jay5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcInR5cGVcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnQ6IG1hcmtlZChtc2cucmVjb21tZW5kZWRCbG9ja0NvbnRleHR1YWxIaW50VGl0bGUoKSksXG4gICAgICBibG9jazogeG1sQmxvY2ssXG4gICAgICBoaW50SWQ6IFwicmVjb21tZW5kZWRfYmxvY2tfXCIgKyBibG9ja1R5cGUsXG4gICAgICBoaW50Q2xhc3M6ICdyZWNvbW1lbmRlZCcsXG4gICAgICBoaW50VHlwZTogJ2NvbnRleHR1YWwnLFxuICAgICAgYWxyZWFkeVNlZW46IGJsb2NrLmFscmVhZHlTZWVuXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiBoaW50cztcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGF1dGhvcmVkIGhpbnRzIGFzIHVzZWQgYnkgU3R1ZGlvQXBwIGZyb20gbGV2ZWxidWlsZGVyIEpTT04uXG4gKiBAcGFyYW0ge3N0cmluZ30gLSBKU09OIHJlcHJlc2VudGluZyBhbiBhcnJheSBvZiBoaW50c1xuICogQHJldHVybiB7QXV0aG9yZWRIaW50W119XG4gKi9cbmF1dGhvcmVkSGludFV0aWxzLmdlbmVyYXRlQXV0aG9yZWRIaW50cyA9IGZ1bmN0aW9uIChsZXZlbEJ1aWxkZXJBdXRob3JlZEhpbnRzKSB7XG4gIGlmICghbWFya2VkKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBoaW50cztcbiAgdHJ5IHtcbiAgICBoaW50cyA9IEpTT04ucGFyc2UobGV2ZWxCdWlsZGVyQXV0aG9yZWRIaW50cyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoaW50cyA9IFtdO1xuICB9XG4gIHJldHVybiBoaW50cy5tYXAoZnVuY3Rpb24gKGhpbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudDogbWFya2VkKGhpbnQuaGludF9tYXJrZG93biksXG4gICAgICBoaW50SWQ6IGhpbnQuaGludF9pZCxcbiAgICAgIGhpbnRDbGFzczogaGludC5oaW50X2NsYXNzLFxuICAgICAgaGludFR5cGU6IGhpbnQuaGludF90eXBlLFxuICAgICAgYWxyZWFkeVNlZW46IGZhbHNlXG4gICAgfTtcbiAgfSk7XG59O1xuXG4iLCIvLyBTZXJpYWxpemVzIGFuIFhNTCBET00gbm9kZSB0byBhIHN0cmluZy5cbmV4cG9ydHMuc2VyaWFsaXplID0gZnVuY3Rpb24obm9kZSkge1xuICB2YXIgc2VyaWFsaXplciA9IG5ldyBYTUxTZXJpYWxpemVyKCk7XG4gIHJldHVybiBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKG5vZGUpO1xufTtcblxuLy8gUGFyc2VzIGEgc2luZ2xlIHJvb3QgZWxlbWVudCBzdHJpbmcsIHdyYXBwaW5nIGl0IGluIGFuIDx4bWwvPiBlbGVtZW50XG5leHBvcnRzLnBhcnNlRWxlbWVudCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgdmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgdGV4dCA9IHRleHQudHJpbSgpO1xuICB2YXIgZG9tID0gdGV4dC5pbmRleE9mKCc8eG1sJykgPT09IDAgP1xuICAgICAgcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh0ZXh0LCAndGV4dC94bWwnKSA6XG4gICAgICBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKCc8eG1sPicgKyB0ZXh0ICsgJzwveG1sPicsICd0ZXh0L3htbCcpO1xuICB2YXIgZXJyb3JzID0gZG9tLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFyc2VyZXJyb3JcIik7XG4gIHZhciBlbGVtZW50ID0gZG9tLmZpcnN0Q2hpbGQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90aGluZyBwYXJzZWQnKTtcbiAgfVxuICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5zZXJpYWxpemUoZXJyb3JzWzBdKSk7XG4gIH1cbiAgaWYgKGVsZW1lbnQgIT09IGRvbS5sYXN0Q2hpbGQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlZCBtdWx0aXBsZSBlbGVtZW50cycpO1xuICB9XG4gIHJldHVybiBlbGVtZW50O1xufTtcbiIsIi8vIEZvciBwcm94eWluZyBub24taHR0cHMgYXNzZXRzXG52YXIgTUVESUFfUFJPWFkgPSAnLy8nICsgbG9jYXRpb24uaG9zdCArICcvbWVkaWE/dT0nO1xuXG4vLyBzdGFydHMgd2l0aCBodHRwIG9yIGh0dHBzXG52YXIgQUJTT0xVVEVfUkVHRVhQID0gbmV3IFJlZ0V4cCgnXmh0dHBzPzovLycsICdpJyk7XG5cbnZhciBhc3NldFBhdGhQcmVmaXggPSBcIi92My9hc3NldHMvXCI7XG52YXIgY2hhbm5lbElkO1xuXG5tb2R1bGUuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmFzc2V0UGF0aFByZWZpeCkge1xuICAgIGFzc2V0UGF0aFByZWZpeCA9IGNvbmZpZy5hc3NldFBhdGhQcmVmaXg7XG4gIH1cbiAgaWYgKGNvbmZpZy5jaGFubmVsKSB7XG4gICAgY2hhbm5lbElkID0gY29uZmlnLmNoYW5uZWw7XG4gIH1cbn07XG5cbi8qKlxuICogSWYgdGhlIGZpbGVuYW1lIGlzIHJlbGF0aXZlIChjb250YWlucyBubyBzbGFzaGVzKSwgdGhlbiBwcmVwZW5kXG4gKiB0aGUgcGF0aCB0byB0aGUgYXNzZXRzIGRpcmVjdG9yeSBmb3IgdGhpcyBwcm9qZWN0IHRvIHRoZSBmaWxlbmFtZS5cbiAqXG4gKiBJZiB0aGUgZmlsZW5hbWUgVVJMIGlzIGFic29sdXRlLCByb3V0ZSBpdCB0aHJvdWdoIHRoZSBNRURJQV9QUk9YWS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xubW9kdWxlLmV4cG9ydHMuZml4UGF0aCA9IGZ1bmN0aW9uIChmaWxlbmFtZSkge1xuXG4gIGlmIChBQlNPTFVURV9SRUdFWFAudGVzdChmaWxlbmFtZSkpIHtcbiAgICAvLyBXZSB3YW50IHRvIGJlIGFibGUgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIG91ciBmaWxlbmFtZSBjb250YWlucyBhXG4gICAgLy8gc3BhY2UsIGkuZS4gXCJ3d3cuZXhhbXBsZS5jb20vaW1hZ2VzL2ZvbyBiYXIucG5nXCIsIGV2ZW4gdGhvdWdoIHRoaXMgaXMgYVxuICAgIC8vIHRlY2huaWNhbGx5IGludmFsaWQgVVJMLiBlbmNvZGVVUklDb21wb25lbnQgd2lsbCByZXBsYWNlIHNwYWNlIHdpdGggJTIwXG4gICAgLy8gZm9yIHVzLCBidXQgYXMgc29vbiBhcyBpdCdzIGRlY29kZWQsIHdlIGFnYWluIGhhdmUgYW4gaW52YWxpZCBVUkwuIEZvclxuICAgIC8vIHRoaXMgcmVhc29uIHdlIGZpcnN0IHJlcGxhY2Ugc3BhY2Ugd2l0aCAlMjAgb3Vyc2VsdmVzLCBzdWNoIHRoYXQgd2Ugbm93XG4gICAgLy8gaGF2ZSBhIHZhbGlkIFVSTCwgYW5kIHRoZW4gY2FsbCBlbmNvZGVVUklDb21wb25lbnQgb24gdGhlIHJlc3VsdC5cbiAgICByZXR1cm4gTUVESUFfUFJPWFkgKyBlbmNvZGVVUklDb21wb25lbnQoZmlsZW5hbWUucmVwbGFjZSgvIC9nLCAnJTIwJykpO1xuICB9XG5cbiAgZmlsZW5hbWUgPSBmaWxlbmFtZSB8fCAnJztcbiAgaWYgKGZpbGVuYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnL2Jsb2NrbHkvbWVkaWEvMXgxLmdpZic7XG4gIH1cblxuICBpZiAoZmlsZW5hbWUuaW5kZXhPZignLycpICE9PSAtMSB8fCAhY2hhbm5lbElkKSB7XG4gICAgcmV0dXJuIGZpbGVuYW1lO1xuICB9XG5cbiAgcmV0dXJuIGFzc2V0UGF0aFByZWZpeCArIGNoYW5uZWxJZCArICcvJyArIGZpbGVuYW1lO1xufTtcbiIsInZhciBhc3NldHMgPSBbXTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlc2V0OiBmdW5jdGlvbiAobGlzdCkge1xuICAgIGFzc2V0cyA9IGxpc3Quc2xpY2UoKTtcbiAgfSxcblxuICBhZGQ6IGZ1bmN0aW9uIChhc3NldCkge1xuICAgIGFzc2V0cy5wdXNoKGFzc2V0KTtcbiAgICByZXR1cm4gYXNzZXRzLnNsaWNlKCk7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoZmlsZW5hbWUpIHtcbiAgICBhc3NldHMgPSBhc3NldHMuZmlsdGVyKGZ1bmN0aW9uIChhc3NldCkge1xuICAgICAgcmV0dXJuIGFzc2V0LmZpbGVuYW1lICE9PSBmaWxlbmFtZTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXNzZXRzLnNsaWNlKCk7XG4gIH0sXG5cbiAgbGlzdDogZnVuY3Rpb24gKHR5cGVGaWx0ZXIpIHtcbiAgICByZXR1cm4gdHlwZUZpbHRlciA/IGFzc2V0cy5maWx0ZXIoZnVuY3Rpb24gKGFzc2V0KSB7XG4gICAgICByZXR1cm4gYXNzZXQuY2F0ZWdvcnkgPT09IHR5cGVGaWx0ZXI7XG4gICAgfSkgOiBhc3NldHMuc2xpY2UoKTtcbiAgfVxufTtcbiIsIi8qIGdsb2JhbCBhY2UgKi9cbnZhciBkcm9wbGV0VXRpbHMgPSByZXF1aXJlKCcuLi9kcm9wbGV0VXRpbHMnKTtcbnZhciBhbm5vdGF0aW9uTGlzdCA9IHJlcXVpcmUoJy4vYW5ub3RhdGlvbkxpc3QnKTtcblxuZXhwb3J0cy5kZWZpbmVGb3JBY2UgPSBmdW5jdGlvbiAoZHJvcGxldENvbmZpZywgdW51c2VkQ29uZmlnLCBkcm9wbGV0RWRpdG9yKSB7XG4gIC8vIGRlZmluZSBvdXJzZWx2ZXMgZm9yIGFjZSwgc28gdGhhdCBpdCBrbm93cyB3aGVyZSB0byBnZXQgdXNcbiAgYWNlLmRlZmluZShcImFjZS9tb2RlL2phdmFzY3JpcHRfY29kZW9yZ1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9tb2RlL2phdmFzY3JpcHRcIixcImFjZS9tb2RlL2phdmFzY3JpcHRfaGlnaGxpZ2h0X3J1bGVzXCIsXCJhY2Uvd29ya2VyL3dvcmtlcl9jbGllbnRcIixcImFjZS9tb2RlL21hdGNoaW5nX2JyYWNlX291dGRlbnRcIixcImFjZS9tb2RlL2JlaGF2aW91ci9jc3R5bGVcIixcImFjZS9tb2RlL2ZvbGRpbmcvY3N0eWxlXCIsXCJhY2UvY29uZmlnXCIsXCJhY2UvbGliL25ldFwiLFwiYWNlL2V4dC9zZWFyY2hib3hcIl0sIGZ1bmN0aW9uKGFjZXJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gICAgdmFyIG9vcCA9IGFjZXJlcXVpcmUoXCJhY2UvbGliL29vcFwiKTtcbiAgICB2YXIgSmF2YVNjcmlwdE1vZGUgPSBhY2VyZXF1aXJlKFwiYWNlL21vZGUvamF2YXNjcmlwdFwiKS5Nb2RlO1xuICAgIHZhciBKYXZhU2NyaXB0SGlnaGxpZ2h0UnVsZXMgPSBhY2VyZXF1aXJlKFwiYWNlL21vZGUvamF2YXNjcmlwdF9oaWdobGlnaHRfcnVsZXNcIikuSmF2YVNjcmlwdEhpZ2hsaWdodFJ1bGVzO1xuICAgIHZhciBXb3JrZXJNb2R1bGUgPSBhY2VyZXF1aXJlKFwiYWNlL3dvcmtlci93b3JrZXJfY2xpZW50XCIpO1xuICAgIHZhciBXb3JrZXJDbGllbnQgPSBXb3JrZXJNb2R1bGUuV29ya2VyQ2xpZW50O1xuICAgIGlmICghd2luZG93Lldvcmtlcikge1xuICAgICAgLy8gSWYgd2UgZG9uJ3Qgc3VwcG9ydCB3ZWIgd29ya2VycywgZG8gZXZlcnl0aGluZyBvbiB0aGUgVUkgdGhyZWFkXG4gICAgICBXb3JrZXJDbGllbnQgPSBXb3JrZXJNb2R1bGUuVUlXb3JrZXJDbGllbnQ7XG4gICAgICB3aW5kb3cuV29ya2VyID0gV29ya2VyQ2xpZW50O1xuICAgIH1cblxuICAgIHZhciBNYXRjaGluZ0JyYWNlT3V0ZGVudCA9IGFjZXJlcXVpcmUoXCIuL21hdGNoaW5nX2JyYWNlX291dGRlbnRcIikuTWF0Y2hpbmdCcmFjZU91dGRlbnQ7XG4gICAgdmFyIENzdHlsZUJlaGF2aW91ciA9IGFjZXJlcXVpcmUoXCIuL2JlaGF2aW91ci9jc3R5bGVcIikuQ3N0eWxlQmVoYXZpb3VyO1xuICAgIHZhciBDU3R5bGVGb2xkTW9kZSA9IGFjZXJlcXVpcmUoXCIuL2ZvbGRpbmcvY3N0eWxlXCIpLkZvbGRNb2RlO1xuXG4gICAgdmFyIE1vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5IaWdobGlnaHRSdWxlcyA9IEphdmFTY3JpcHRIaWdobGlnaHRSdWxlcztcbiAgICAgICAgdGhpcy4kb3V0ZGVudCA9IG5ldyBNYXRjaGluZ0JyYWNlT3V0ZGVudCgpO1xuICAgICAgICB0aGlzLiRiZWhhdmlvdXIgPSBuZXcgQ3N0eWxlQmVoYXZpb3VyKCk7XG4gICAgICAgIHRoaXMuZm9sZGluZ1J1bGVzID0gbmV3IENTdHlsZUZvbGRNb2RlKCk7XG4gICAgfTtcbiAgICBvb3AuaW5oZXJpdHMoTW9kZSwgSmF2YVNjcmlwdE1vZGUpO1xuXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gTWFudWFsbHkgY3JlYXRlIG91ciBoaWdobGlnaHQgcnVsZXMgc28gdGhhdCB3ZSBjYW4gbW9kaWZ5IGl0XG4gICAgICB0aGlzLiRoaWdobGlnaHRSdWxlcyA9IG5ldyBKYXZhU2NyaXB0SGlnaGxpZ2h0UnVsZXMoKTtcblxuICAgICAgLy8gV2UgbmV2ZXIgd2FudCB0byBzaG93IGFueSBvZiB0aGUgYnVpbHRpbiBrZXl3b3JkcyBpbiBhdXRvY29tcGxldGVcbiAgICAgIHRoaXMuJGhpZ2hsaWdodFJ1bGVzLiRrZXl3b3JkTGlzdCA9IFtdO1xuXG4gICAgICB0aGlzLmNyZWF0ZVdvcmtlciA9IGZ1bmN0aW9uKHNlc3Npb24pIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXJDbGllbnQoW1wiYWNlXCJdLCBcImFjZS9tb2RlL2phdmFzY3JpcHRfd29ya2VyXCIsIFwiSmF2YVNjcmlwdFdvcmtlclwiKTtcbiAgICAgICAgd29ya2VyLmF0dGFjaFRvRG9jdW1lbnQoc2Vzc2lvbi5nZXREb2N1bWVudCgpKTtcbiAgICAgICAgdmFyIG5ld09wdGlvbnMgPSB7XG4gICAgICAgICAgdW51c2VkOiB0cnVlLFxuICAgICAgICAgIHVuZGVmOiB0cnVlLFxuICAgICAgICAgIG1heGVycjogMTAwMCxcbiAgICAgICAgICBwcmVkZWY6IHtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGV4cG9ydGVkOiB7XG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTWFyayBhbGwgb2Ygb3VyIGJsb2NrcyBhcyBwcmVkZWZpbmVkIHNvIHRoYXQgbGludGVyIGRvZXNudCBjb21wbGFpbiBhYm91dFxuICAgICAgICAvLyB1c2luZyB1bmRlZmluZWQgdmFyaWFibGVzXG4gICAgICAgIGRyb3BsZXRVdGlscy5nZXRBbGxBdmFpbGFibGVEcm9wbGV0QmxvY2tzKGRyb3BsZXRDb25maWcpLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgICAgbmV3T3B0aW9ucy5wcmVkZWZbYmxvY2suZnVuY10gPSBmYWxzZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRyb3BsZXRDb25maWcuYWRkaXRpb25hbFByZWRlZlZhbHVlcykge1xuICAgICAgICAgIGRyb3BsZXRDb25maWcuYWRkaXRpb25hbFByZWRlZlZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIG5ld09wdGlvbnMucHJlZGVmW3ZhbF0gPSBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvIHRoZSBzYW1lIHdpdGggdW51c2VkQ29uZmlnIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAodW51c2VkQ29uZmlnKSB7XG4gICAgICAgICAgdW51c2VkQ29uZmlnLmZvckVhY2goZnVuY3Rpb24gKHVudXNlZFZhcikge1xuICAgICAgICAgICAgbmV3T3B0aW9ucy5leHBvcnRlZFt1bnVzZWRWYXJdID0gZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBhbm5vdGF0aW9uTGlzdC5hdHRhY2hUb1Nlc3Npb24oc2Vzc2lvbiwgZHJvcGxldEVkaXRvcik7XG5cbiAgICAgICAgd29ya2VyLnNlbmQoXCJjaGFuZ2VPcHRpb25zXCIsIFtuZXdPcHRpb25zXSk7XG5cbiAgICAgICAgd29ya2VyLm9uKFwianNsaW50XCIsIGFubm90YXRpb25MaXN0LnNldEpTTGludEFubm90YXRpb25zKTtcblxuICAgICAgICB3b3JrZXIub24oXCJ0ZXJtaW5hdGVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2Vzc2lvbi5jbGVhckFubm90YXRpb25zKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB3b3JrZXI7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFubm90YXRpb25MaXN0LmRldGFjaEZyb21TZXNzaW9uKCk7XG4gICAgICB9O1xuICAgIH0pLmNhbGwoTW9kZS5wcm90b3R5cGUpO1xuXG4gIGV4cG9ydHMuTW9kZSA9IE1vZGU7XG4gIH0pO1xufTtcbiIsInZhciBlcnJvck1hcHBlciA9IHJlcXVpcmUoJy4vZXJyb3JNYXBwZXInKTtcblxudmFyIGxpbnRBbm5vdGF0aW9ucyA9IFtdO1xudmFyIHJ1bnRpbWVBbm5vdGF0aW9ucyA9IFtdO1xudmFyIGFjZVNlc3Npb247XG52YXIgZHJvcGxldEVkaXRvcjtcblxuLyoqXG4gKiBVcGRhdGUgZ3V0dGVyIHdpdGggb3VyIGFubm90YXRpb24gbGlzdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlR3V0dGVyKCkge1xuICBpZiAoIWFjZVNlc3Npb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZHJvcGxldEVkaXRvcikge1xuICAgIC8vIERyb3BsZXQgd2lsbCBjYWxsIGFjZVNlc3Npb24uc2V0QW5ub3RhdGlvbnMoKSB1bmRlciB0aGUgaG9vZFxuICAgIC8vIGZvciB1c1xuICAgIGRyb3BsZXRFZGl0b3Iuc2V0QW5ub3RhdGlvbnMobGludEFubm90YXRpb25zLmNvbmNhdChydW50aW1lQW5ub3RhdGlvbnMpKTtcbiAgfVxuICBlbHNlIHtcbiAgICBhY2VTZXNzaW9uLnNldEFubm90YXRpb25zKGxpbnRBbm5vdGF0aW9ucy5jb25jYXQocnVudGltZUFubm90YXRpb25zKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBPYmplY3QgZm9yIHRyYWNraW5nIGFubm90YXRpb25zIHBsYWNlZCBpbiBndXR0ZXIuIEdlbmVyYWwgZGVzaWduIGlzIGFzXG4gKiBmb2xsb3dzOlxuICogV2hlbiBqc2xpbnQgcnVucyAoaS5lLiBjb2RlIGNoYW5nZXMpIGRpc3BsYXkganVzdCBqc2xpbnQgZXJyb3JzXG4gKiBXaGVuIGNvZGUgcnVucywgZGlzcGxheSBqc2xpbnQgZXJyb3JzIGFuZCBydW50aW1lIGVycm9ycy4gUnVudGltZSBlcnJvcnMgd2lsbFxuICogZ28gYXdheSB0aGUgbmV4dCB0aW1lIGpzdGxpbnQgZ2V0cyBydW4gKHdoZW4gY29kZSBjaGFuZ2VzKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGV0YWNoRnJvbVNlc3Npb246IGZ1bmN0aW9uICgpIHtcbiAgICBhY2VTZXNzaW9uID0gbnVsbDtcbiAgICBkcm9wbGV0RWRpdG9yID0gbnVsbDtcbiAgfSxcblxuICBhdHRhY2hUb1Nlc3Npb246IGZ1bmN0aW9uIChzZXNzaW9uLCBlZGl0b3IpIHtcbiAgICBpZiAoYWNlU2Vzc2lvbiAmJiBzZXNzaW9uICE9PSBhY2VTZXNzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FscmVhZHkgYXR0YWNoZWQgdG8gYWNlIHNlc3Npb24nKTtcbiAgICB9XG4gICAgYWNlU2Vzc2lvbiA9IHNlc3Npb247XG4gICAgZHJvcGxldEVkaXRvciA9IGVkaXRvcjtcbiAgfSxcblxuICBzZXRKU0xpbnRBbm5vdGF0aW9uczogZnVuY3Rpb24gKGpzbGludFJlc3VsdHMpIHtcbiAgICBlcnJvck1hcHBlci5wcm9jZXNzUmVzdWx0cyhqc2xpbnRSZXN1bHRzKTtcbiAgICAvLyBjbG9uZSBhbm5vdGF0aW9ucyBpbiBjYXNlIGFueW9uZSBlbHNlIGhhcyBhIHJlZmVyZW5jZSB0byBkYXRhXG4gICAgbGludEFubm90YXRpb25zID0ganNsaW50UmVzdWx0cy5kYXRhLnNsaWNlKCk7XG4gICAgdXBkYXRlR3V0dGVyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZXZlbFxuICAgKiBAcGFyYW0ge251bWJlcn0gbGluZU51bWJlciBPbmUgaW5kZXggbGluZSBudW1iZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgRXJyb3Igc3RyaW5nXG4gICAqL1xuICBhZGRSdW50aW1lQW5ub3RhdGlvbjogZnVuY3Rpb24gKGxldmVsLCBsaW5lTnVtYmVyLCB0ZXh0KSB7XG4gICAgdmFyIGFubm90YXRpb24gPSB7XG4gICAgICByb3c6IGxpbmVOdW1iZXIgLSAxLFxuICAgICAgY29sOiAwLFxuICAgICAgcmF3OiB0ZXh0LFxuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIHR5cGU6IGxldmVsLnRvTG93ZXJDYXNlKClcbiAgICB9O1xuICAgIHJ1bnRpbWVBbm5vdGF0aW9ucy5wdXNoKGFubm90YXRpb24pO1xuICAgIHVwZGF0ZUd1dHRlcigpO1xuICB9LFxuXG4gIGNsZWFyUnVudGltZUFubm90YXRpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJ1bnRpbWVBbm5vdGF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcnVudGltZUFubm90YXRpb25zID0gW107XG4gICAgdXBkYXRlR3V0dGVyKCk7XG4gIH0sXG59O1xuIiwidmFyIGVycm9yTWFwID0gW1xuICB7XG4gICAgb3JpZ2luYWw6IC9Bc3NpZ25tZW50IGluIGNvbmRpdGlvbmFsIGV4cHJlc3Npb24vLFxuICAgIHJlcGxhY2VtZW50OiBcIkZvciBjb25kaXRpb25hbHMsIHVzZSB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoPT09KSB0byBjaGVjayBpZiB0d28gdGhpbmdzIGFyZSBlcXVhbC5cIlxuICB9LFxuICB7XG4gICAgb3JpZ2luYWw6IC8oLiopXFxzaXMgZGVmaW5lZCBidXQgbmV2ZXIgdXNlZC4vLFxuICAgIHJlcGxhY2VtZW50OiBcIiQxIGlzIGRlZmluZWQsIGJ1dCBpdCdzIG5vdCBjYWxsZWQgaW4geW91ciBwcm9ncmFtLlwiXG4gIH0sXG4gIHtcbiAgICBvcmlnaW5hbDogLyguKilcXHNpcyBub3QgZGVmaW5lZC4vLFxuICAgIHJlcGxhY2VtZW50OiBcIiQxIGhhc24ndCBiZWVuIGRlY2xhcmVkIHlldC5cIlxuICB9XG5dO1xuXG4vKipcbiAqIFRha2VzIHRoZSByZXN1bHRzIG9mIGEgSlNMaW50IHBhc3MsIGFuZCBtb2RpZmllcyB0aGUgZXJyb3IgdGV4dCBhY2NvcmRpbmcgdG9cbiAqIG91ciBtYXBwaW5nLiBOb3RlIHRoaXMgbWFrZXMgY2hhbmdlcyBpbiBwbGFjZSB0byB0aGUgcGFzc2VkIGluIHJlc3VsdHNcbiAqIG9iamVjdC5cbiAqL1xubW9kdWxlLmV4cG9ydHMucHJvY2Vzc1Jlc3VsdHMgPSBmdW5jdGlvbiAocmVzdWx0cykge1xuICByZXN1bHRzLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtLnR5cGUgPT09ICdpbmZvJykge1xuICAgICAgaXRlbS50eXBlID0gJ3dhcm5pbmcnO1xuICAgIH1cblxuICAgIGVycm9yTWFwLmZvckVhY2goZnVuY3Rpb24gKGVycm9yTWFwcGluZykge1xuICAgICAgaWYgKCFlcnJvck1hcHBpbmcub3JpZ2luYWwudGVzdChpdGVtLnRleHQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXRlbS50ZXh0ID0gaXRlbS50ZXh0LnJlcGxhY2UoZXJyb3JNYXBwaW5nLm9yaWdpbmFsLCBlcnJvck1hcHBpbmcucmVwbGFjZW1lbnQpO1xuICAgIH0pO1xuICB9KTtcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCBNYXJjIEouIFNjaG1pZHQuIFNlZSB0aGUgTElDRU5TRSBmaWxlIGF0IHRoZSB0b3AtbGV2ZWxcbiAqIGRpcmVjdG9yeSBvZiB0aGlzIGRpc3RyaWJ1dGlvbiBhbmQgYXRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJjai9jc3MtZWxlbWVudC1xdWVyaWVzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UuXG4gKi9cblxuICAgIC8qKlxuICAgICAqIENsYXNzIGZvciBkaW1lbnNpb24gY2hhbmdlIGRldGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudHxFbGVtZW50W118RWxlbWVudHN8alF1ZXJ5fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gRXZlbnRRdWV1ZSgpIHtcbiAgICAgICAgICAgIHRoaXMucSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5hZGQgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgICAgIHRoaXMucS5wdXNoKGV2KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBpLCBqO1xuICAgICAgICAgICAgdGhpcy5jYWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IHRoaXMucS5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xW2ldLmNhbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgcHJvcFxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfE51bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgcHJvcCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY3VycmVudFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuY3VycmVudFN0eWxlW3Byb3BdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5zdHlsZVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259ICAgIHJlc2l6ZWRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGF0dGFjaFJlc2l6ZUV2ZW50KGVsZW1lbnQsIHJlc2l6ZWQpIHtcbiAgICAgICAgICAgIGlmICghZWxlbWVudC5yZXNpemVkQXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZCA9IG5ldyBFdmVudFF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZXNpemVkQXR0YWNoZWQuYWRkKHJlc2l6ZWQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVzaXplZEF0dGFjaGVkLmFkZChyZXNpemVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsZW1lbnQucmVzaXplU2Vuc29yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBlbGVtZW50LnJlc2l6ZVNlbnNvci5jbGFzc05hbWUgPSAncmVzaXplLXNlbnNvcic7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSAncG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAwOyB0b3A6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IG92ZXJmbG93OiBzY3JvbGw7IHotaW5kZXg6IC0xOyB2aXNpYmlsaXR5OiBoaWRkZW47JztcbiAgICAgICAgICAgIHZhciBzdHlsZUNoaWxkID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwOyc7XG5cbiAgICAgICAgICAgIGVsZW1lbnQucmVzaXplU2Vuc29yLnN0eWxlLmNzc1RleHQgPSBzdHlsZTtcbiAgICAgICAgICAgIGVsZW1lbnQucmVzaXplU2Vuc29yLmlubmVySFRNTCA9XG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJyZXNpemUtc2Vuc29yLWV4cGFuZFwiIHN0eWxlPVwiJyArIHN0eWxlICsgJ1wiPicgK1xuICAgICAgICAgICAgICAgICAgICAnPGRpdiBzdHlsZT1cIicgKyBzdHlsZUNoaWxkICsgJ1wiPjwvZGl2PicgK1xuICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInJlc2l6ZS1zZW5zb3Itc2hyaW5rXCIgc3R5bGU9XCInICsgc3R5bGUgKyAnXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IHN0eWxlPVwiJyArIHN0eWxlQ2hpbGQgKyAnIHdpZHRoOiAyMDAlOyBoZWlnaHQ6IDIwMCVcIj48L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAnPC9kaXY+JztcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbWVudC5yZXNpemVTZW5zb3IpO1xuXG4gICAgICAgICAgICBpZiAoJ2Fic29sdXRlJyAhPT0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCAncG9zaXRpb24nKSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZXhwYW5kID0gZWxlbWVudC5yZXNpemVTZW5zb3IuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgICAgIHZhciBleHBhbmRDaGlsZCA9IGV4cGFuZC5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgdmFyIHNocmluayA9IGVsZW1lbnQucmVzaXplU2Vuc29yLmNoaWxkTm9kZXNbMV07XG4gICAgICAgICAgICB2YXIgc2hyaW5rQ2hpbGQgPSBzaHJpbmsuY2hpbGROb2Rlc1swXTtcblxuICAgICAgICAgICAgdmFyIGxhc3RXaWR0aCwgbGFzdEhlaWdodDtcblxuICAgICAgICAgICAgdmFyIHJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZXhwYW5kQ2hpbGQuc3R5bGUud2lkdGggPSBleHBhbmQub2Zmc2V0V2lkdGggKyAxMCArICdweCc7XG4gICAgICAgICAgICAgICAgZXhwYW5kQ2hpbGQuc3R5bGUuaGVpZ2h0ID0gZXhwYW5kLm9mZnNldEhlaWdodCArIDEwICsgJ3B4JztcbiAgICAgICAgICAgICAgICBleHBhbmQuc2Nyb2xsTGVmdCA9IGV4cGFuZC5zY3JvbGxXaWR0aDtcbiAgICAgICAgICAgICAgICBleHBhbmQuc2Nyb2xsVG9wID0gZXhwYW5kLnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgICAgICBzaHJpbmsuc2Nyb2xsTGVmdCA9IHNocmluay5zY3JvbGxXaWR0aDtcbiAgICAgICAgICAgICAgICBzaHJpbmsuc2Nyb2xsVG9wID0gc2hyaW5rLnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgICAgICBsYXN0V2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIGxhc3RIZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlc2V0KCk7XG5cbiAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZXNpemVkQXR0YWNoZWQuY2FsbCgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGFkZEV2ZW50ID0gZnVuY3Rpb24oZWwsIG5hbWUsIGNiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBuYW1lLCBjYik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgYWRkRXZlbnQoZXhwYW5kLCAnc2Nyb2xsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQub2Zmc2V0V2lkdGggPiBsYXN0V2lkdGggfHwgZWxlbWVudC5vZmZzZXRIZWlnaHQgPiBsYXN0SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhZGRFdmVudChzaHJpbmssICdzY3JvbGwnLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm9mZnNldFdpZHRoIDwgbGFzdFdpZHRoIHx8IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IDwgbGFzdEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuY29uc3RydWN0b3IgPT09IEFycmF5IHx8XG4gICAgICAgICAgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgalF1ZXJ5ICYmIGVsZW1lbnQgaW5zdGFuY2VvZiBqUXVlcnkpIHx8IC8vanF1ZXJ5XG4gICAgICAgICAgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgRWxlbWVudHMgJiYgZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnRzKSAvL21vb3Rvb2xzXG4gICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGkgPSAwLCBqID0gZWxlbWVudC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgIGF0dGFjaFJlc2l6ZUV2ZW50KGVsZW1lbnRbaV0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF0dGFjaFJlc2l6ZUV2ZW50KGVsZW1lbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4iLCIvKiogQGZpbGUgVGhlIG1hZXN0cm8hIEhlbHBlciB0aGF0IGtub3dzIHdoaWNoIG11c2ljIHRyYWNrcyBjYW4gYmUgcGxheWVkLCBhbmRcbiAqICAgICAgICB3aGljaCBvbmUgaXMgcGxheWluZyBub3csIGFuZCBzZWxlY3RzIGFuZCBwbGF5cyB0aGVtIGFwcHJvcHJpYXRlbHkuICovXG4vLyBTdHJpY3QgbGludGluZzogQWJzb3JiIGludG8gZ2xvYmFsIGNvbmZpZyB3aGVuIHBvc3NpYmxlXG4vKiBqc2hpbnRcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuIG1heGxlbjogMTIwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIF8gPSB1dGlscy5nZXRMb2Rhc2goKTtcblxudmFyIGRlYnVnTG9nZ2luZyA9IGZhbHNlO1xuZnVuY3Rpb24gZGVidWcobXNnKSB7XG4gIGlmIChkZWJ1Z0xvZ2dpbmcgJiYgY29uc29sZSAmJiBjb25zb2xlLmluZm8pIHtcbiAgICBjb25zb2xlLmluZm8oKG5ldyBEYXRlKCkpLmdldFRpbWUoKSArICc6IE11c2ljQ29udHJvbGxlcjogJyArIG1zZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNdXNpY1RyYWNrRGVmaW5pdGlvblxuICogRXh0ZXJuYWwgdHJhY2sgcmVwcmVzZW50YXRpb24sIHVzZWQgdG8gZGVmaW5lIHRyYWNrIGluZm8gaW4gc2tpbnMuanMuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBjb3JyZXNwb25kcyB0byBtdXNpYyBmaWxlbmFtZXNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB2b2x1bWUgLSBvbiBhIDAuLjEgc2NhbGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGFzT2dnIC0gd2hldGhlciBhIC5vZ2cgdmVyc2lvbiBvZiB0aGUgZmlsZSBzaG91bGQgYWxzb1xuICogICAgICAgICAgIGF2YWlsYWJsZSBpbiBhZGRpdGlvbiB0byB0aGUgLm1wM1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTXVzaWNUcmFja1xuICogSW50ZXJuYWwgdHJhY2sgcmVwcmVzZW50YXRpb24sIGluY2x1ZGVzIHRyYWNrIG1ldGFkYXRhIGFuZCByZWZlcmVuY2VzIHRvXG4gKiBsb2FkZWQgc291bmQgb2JqZWN0LlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBhc3NldFVybHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB2b2x1bWVcbiAqIEBwcm9wZXJ0eSB7U291bmR9IHNvdW5kXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzTG9hZGVkXG4gKi9cblxuLyoqXG4gKiBBIGhlbHBlciBjbGFzcyB0aGF0IGhhbmRsZXMgbG9hZGluZywgY2hvb3NpbmcsIHBsYXlpbmcgYW5kIHN0b3BwaW5nXG4gKiBiYWNrZ3JvdW5kIG11c2ljIGZvciBjZXJ0YWluIHN0dWRpbyBhcHBzIChlLmcuIHBsYXlsYWIsIGNyYWZ0KS5cbiAqXG4gKiBAcGFyYW0ge0F1ZGlvUGxheWVyfSBhdWRpb1BsYXllciAtIFJlZmVyZW5jZSB0byB0aGUgU291bmRzIG9iamVjdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGFzc2V0VXJsIC0gRnVuY3Rpb24gZm9yIGdlbmVyYXRpbmcgcGF0aHMgdG8gc3RhdGljIGFzc2V0c1xuICogICAgICAgIGZvciB0aGUgY3VycmVudCBza2luLlxuICogQHBhcmFtIHtNdXNpY1RyYWNrRGVmaW5pdGlvbltdfSBbdHJhY2tEZWZpbml0aW9uc10gLSBMaXN0IG9mIG11c2ljIGFzc2V0cyBhbmRcbiAqICAgICAgICBnZW5lcmFsIGluZm8gYWJvdXQgaG93IHRoZXkgc2hvdWxkIGJlIHBsYXllZC4gQ2FuIGJlIG9taXR0ZWQgb3IgZW1wdHlcbiAqICAgICAgICBpZiBubyBtdXNpYyBzaG91bGQgYmUgcGxheWVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtsb29wUmFuZG9tV2l0aERlbGF5XSAtIGlmIHNwZWNpZmllZCwgYWZ0ZXIgYSBzb25nIGlzXG4gKiAgICAgICAgY29tcGxldGVkLCB3aWxsIHBsYXkgYSByYW5kb20gdHJhY2sgYWZ0ZXIgZ2l2ZW4gZHVyYXRpb24gKGluIG1zKS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTXVzaWNDb250cm9sbGVyID0gZnVuY3Rpb24gKGF1ZGlvUGxheWVyLCBhc3NldFVybCwgdHJhY2tEZWZpbml0aW9ucyxcbiAgICBsb29wUmFuZG9tV2l0aERlbGF5KSB7XG4gIC8qKiBAcHJpdmF0ZSB7QXVkaW9QbGF5ZXJ9ICovXG4gIHRoaXMuYXVkaW9QbGF5ZXJfID0gYXVkaW9QbGF5ZXI7XG5cbiAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbn0gKi9cbiAgdGhpcy5hc3NldFVybF8gPSBhc3NldFVybDtcblxuICAvKiogQHByaXZhdGUge011c2ljVHJhY2tbXX0gKi9cbiAgdGhpcy50cmFja0xpc3RfID0gYnVpbGRUcmFja0RhdGEodHJhY2tEZWZpbml0aW9ucywgYXNzZXRVcmwpO1xuXG4gIC8qKiBAcHJpdmF0ZSB7c3RyaW5nfSAqL1xuICB0aGlzLm5vd1BsYXlpbmdfID0gbnVsbDtcblxuICAvKiogQHByaXZhdGUge3N0cmluZ30gTmFtZSBvZiB0cmFjayB0byBwbGF5IG9uIGxvYWQgKi9cbiAgdGhpcy5wbGF5T25Mb2FkXyA9IG51bGw7XG5cblxuICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgdGhpcy5sb29wUmFuZG9tV2l0aERlbGF5XyA9IGxvb3BSYW5kb21XaXRoRGVsYXk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlIHtib29sZWFufSB3aGV0aGVyIHdlIHN0b3BwZWQgcGxheWluZyBtdXNpYyBkdWUgdG8gdmlkZW8gYmVpbmdcbiAgICogICAgICAgICAgc2hvd25cbiAgICovXG4gIHRoaXMud2FzUGxheWluZ1doZW5WaWRlb1Nob3duXyA9IGZhbHNlO1xuXG4gIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSBzZXRUaW1lb3V0IGNhbGxiYWNrIGlkZW50aWZpZXIgZm9yIHVuLWJpbmRpbmcgcmVwZWF0ICovXG4gIHRoaXMuYmV0d2VlblRyYWNrVGltZW91dF8gPSBudWxsO1xuXG4gIC8vIElmIHRoZSB2aWRlbyBwbGF5ZXIgZ2V0cyBwdWxsZWQgdXAsIG1ha2Ugc3VyZSB3ZSBzdG9wIHRoZSBtdXNpYy5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlkZW9TaG93bicsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1ZyhcInZpZGVvIHNob3duXCIpO1xuICAgIGlmICh0aGlzLm5vd1BsYXlpbmdfIHx8IHRoaXMuYmV0d2VlblRyYWNrVGltZW91dF8pIHtcbiAgICAgIHRoaXMud2FzUGxheWluZ1doZW5WaWRlb1Nob3duXyA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLmJldHdlZW5UcmFja1RpbWVvdXRfKSB7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5iZXR3ZWVuVHJhY2tUaW1lb3V0Xyk7XG4gICAgICAgIHRoaXMuYmV0d2VlblRyYWNrVGltZW91dF8gPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5mYWRlT3V0KCk7XG4gICAgfVxuICB9LmJpbmQodGhpcykpO1xuXG4gIC8vIElmIHRoZSB2aWRlbyBwbGF5ZXIgZ2V0cyBjbG9zZWQsIG1ha2Ugc3VyZSB3ZSByZS1zdGFydCB0aGUgbXVzaWMuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3ZpZGVvSGlkZGVuJywgZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLndhc1BsYXlpbmdXaGVuVmlkZW9TaG93bl8gJiZcbiAgICAgICAgdGhpcy5sb29wUmFuZG9tV2l0aERlbGF5XyAmJlxuICAgICAgICAhdGhpcy5ub3dQbGF5aW5nXykge1xuICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfVxuICAgIHRoaXMud2FzUGxheWluZ1doZW5WaWRlb1Nob3duXyA9IGZhbHNlO1xuICB9LmJpbmQodGhpcykpO1xuXG4gIGRlYnVnKCdjb25zdHJ1Y3RlZCcpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gTXVzaWNDb250cm9sbGVyO1xuXG4vKipcbiAqIEJ1aWxkIHVwIGluaXRpYWwgaW50ZXJuYWwgdHJhY2sgbWV0YWRhdGEuXG4gKiBAcGFyYW0ge011c2ljVHJhY2tEZWZpbml0aW9uW119IHRyYWNrRGVmaW5pdGlvbnNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGFzc2V0VXJsXG4gKiBAcmV0dXJuIHtNdXNpY1RyYWNrW119XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkVHJhY2tEYXRhKHRyYWNrRGVmaW5pdGlvbnMsIGFzc2V0VXJsKSB7XG4gIHRyYWNrRGVmaW5pdGlvbnMgPSB1dGlscy52YWx1ZU9yKHRyYWNrRGVmaW5pdGlvbnMsIFtdKTtcbiAgcmV0dXJuIHRyYWNrRGVmaW5pdGlvbnMubWFwKGZ1bmN0aW9uICh0cmFja0RlZikge1xuXG4gICAgdmFyIGFzc2V0VXJscyA9IFtdO1xuICAgIGFzc2V0VXJscy5wdXNoKGFzc2V0VXJsKHRyYWNrRGVmLm5hbWUgKyAnLm1wMycpKTtcbiAgICBpZiAodHJhY2tEZWYuaGFzT2dnKSB7XG4gICAgICBhc3NldFVybHMucHVzaChhc3NldFVybCh0cmFja0RlZi5uYW1lICsgJy5vZ2cnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRyYWNrRGVmLm5hbWUsXG4gICAgICBhc3NldFVybHM6IGFzc2V0VXJscyxcbiAgICAgIHZvbHVtZTogdXRpbHMudmFsdWVPcih0cmFja0RlZi52b2x1bWUsIDEpLFxuICAgICAgc291bmQ6IG51bGwsXG4gICAgICBpc0xvYWRlZDogZmFsc2VcbiAgICB9O1xuICB9KTtcbn1cblxuLyoqXG4gKiBQcmVsb2FkIGFsbCBtdXNpYyBhc3NldHNcbiAqL1xuTXVzaWNDb250cm9sbGVyLnByb3RvdHlwZS5wcmVsb2FkID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuYXVkaW9QbGF5ZXJfKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy50cmFja0xpc3RfLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgdHJhY2suc291bmQgPSB0aGlzLmF1ZGlvUGxheWVyXy5yZWdpc3RlckJ5RmlsZW5hbWVzQW5kSUQoXG4gICAgICAgIHRyYWNrLmFzc2V0VXJscywgdHJhY2submFtZSk7XG4gICAgdHJhY2suc291bmQub25Mb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgZGVidWcoJ2RvbmUgbG9hZGluZyAnICsgdHJhY2submFtZSk7XG4gICAgICB0cmFjay5pc0xvYWRlZCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5wbGF5T25Mb2FkXyA9PT0gdHJhY2submFtZSkge1xuICAgICAgICB0aGlzLnBsYXkodHJhY2submFtZSk7XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpO1xuICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogQmVnaW5zIHBsYXlpbmcgYSBwYXJ0aWN1bGFyIHBpZWNlIG9mIG11c2ljIGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtzdHJpbmd9IHRyYWNrTmFtZVxuICovXG5NdXNpY0NvbnRyb2xsZXIucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAodHJhY2tOYW1lKSB7XG4gIGRlYnVnKCdwbGF5ICcgKyB0cmFja05hbWUpO1xuICBpZiAoIXRoaXMuYXVkaW9QbGF5ZXJfKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRyYWNrO1xuICBpZiAodHJhY2tOYW1lKSB7XG4gICAgdHJhY2sgPSB0aGlzLmdldFRyYWNrQnlOYW1lXyh0cmFja05hbWUpO1xuICB9IGVsc2Uge1xuICAgIHRyYWNrID0gdGhpcy5nZXRSYW5kb21UcmFja18oKTtcbiAgfVxuXG4gIGlmICghdHJhY2spIHtcbiAgICAvLyBObyB0cmFjayB0byBwbGF5IC0gdGhyb3cgYW4gZXhjZXB0aW9uP1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0cmFjay5zb3VuZCAmJiB0cmFjay5pc0xvYWRlZCkge1xuICAgIGRlYnVnKCdwbGF5aW5nIG5vdycpO1xuICAgIHZhciBjYWxsYmFjayA9IHRoaXMud2hlbk11c2ljU3RvcHBlZF8uYmluZCh0aGlzLCB0cmFjay5uYW1lKTtcbiAgICB0cmFjay5zb3VuZC5wbGF5KHsgdm9sdW1lOiB0cmFjay52b2x1bWUsIG9uRW5kZWQ6IGNhbGxiYWNrIH0pO1xuICAgIHRoaXMubm93UGxheWluZ18gPSB0cmFjay5uYW1lO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdub3QgZG9uZSBsb2FkaW5nLCBwbGF5aW5nIGFmdGVyIGxvYWQnKTtcbiAgICB0aGlzLnBsYXlPbkxvYWRfID0gdHJhY2submFtZTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdG9wcyBwbGF5aW5nIHdoYXRldmVyIG11c2ljIGlzIGN1cnJlbnRseSBwbGF5aW5nLCBpbW1lZGlhdGVseS5cbiAqL1xuTXVzaWNDb250cm9sbGVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMubm93UGxheWluZ18pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc291bmQgPSB0aGlzLmF1ZGlvUGxheWVyXy5nZXQodGhpcy5ub3dQbGF5aW5nXyk7XG4gIGlmIChzb3VuZCkge1xuICAgIHNvdW5kLnN0b3AoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGYWRlcyBtdXNpYyB0byBub3RoaW5nLCB0aGVuIHN0b3BzIGl0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvblNlY29uZHNdIGluIHNlY29uZHMuICBEZWZhdWx0IDMuXG4gKi9cbk11c2ljQ29udHJvbGxlci5wcm90b3R5cGUuZmFkZU91dCA9IGZ1bmN0aW9uIChkdXJhdGlvblNlY29uZHMpIHtcbiAgaWYgKCF0aGlzLm5vd1BsYXlpbmdfKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZHVyYXRpb25TZWNvbmRzID0gdXRpbHMudmFsdWVPcihkdXJhdGlvblNlY29uZHMsIDMpO1xuXG4gIC8vIFRyaWdnZXIgYSBmYWRlXG4gIHZhciBzb3VuZCA9IHRoaXMuYXVkaW9QbGF5ZXJfLmdldCh0aGlzLm5vd1BsYXlpbmdfKTtcbiAgaWYgKHNvdW5kKSB7XG4gICAgc291bmQuZmFkZVRvR2FpbigwLCBkdXJhdGlvblNlY29uZHMpO1xuICB9XG5cbiAgLy8gU3RvcCB0aGUgYXVkaW8gYWZ0ZXIgdGhlIGZhZGUuXG4gIC8vIEFkZCBhIHNtYWxsIG1hcmdpbiBkdWUgdG8gcG9vciBmYWRlIGdyYW51bGFyaXR5IG9uIGZhbGxiYWNrIHBsYXllci5cbiAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3RvcCgpO1xuICB9LmJpbmQodGhpcyksIDEwMDAgKiBkdXJhdGlvblNlY29uZHMgKyAxMDApO1xufTtcblxuLyoqXG4gKiBDYWxsYmFjayBmb3Igd2hlbiBtdXNpYyBzdG9wcywgdG8gdXBkYXRlIGludGVybmFsIHN0YXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IG11c2ljTmFtZSB0aGF0IHdhcyBwbGF5aW5nLiAgU2hvdWxkIGJlIGJvdW5kIHdoZW4gbXVzaWNcbiAqICAgICAgICBpcyBzdGFydGVkLlxuICogQHByaXZhdGVcbiAqL1xuTXVzaWNDb250cm9sbGVyLnByb3RvdHlwZS53aGVuTXVzaWNTdG9wcGVkXyA9IGZ1bmN0aW9uIChtdXNpY05hbWUpIHtcbiAgaWYgKHRoaXMubm93UGxheWluZ18gPT09IG11c2ljTmFtZSkge1xuICAgIHRoaXMubm93UGxheWluZ18gPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLmxvb3BSYW5kb21XaXRoRGVsYXlfICYmICF0aGlzLndhc1BsYXlpbmdXaGVuVmlkZW9TaG93bl8pIHtcbiAgICB0aGlzLmJldHdlZW5UcmFja1RpbWVvdXRfID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5iZXR3ZWVuVHJhY2tUaW1lb3V0XyA9IG51bGw7XG4gICAgICBpZiAoIXRoaXMubm93UGxheWluZ18gJiYgIXRoaXMud2FzUGxheWluZ1doZW5WaWRlb1Nob3duXykge1xuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcyksIHRoaXMubG9vcFJhbmRvbVdpdGhEZWxheV8pO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7TXVzaWNUcmFja3x1bmRlZmluZWR9XG4gKiBAcHJpdmF0ZVxuICovXG5NdXNpY0NvbnRyb2xsZXIucHJvdG90eXBlLmdldFRyYWNrQnlOYW1lXyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBfLmZpbmQodGhpcy50cmFja0xpc3RfLCBmdW5jdGlvbiAodHJhY2spIHtcbiAgICByZXR1cm4gdHJhY2submFtZSA9PT0gbmFtZTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtNdXNpY1RyYWNrfHVuZGVmaW5lZH1cbiAqIEBwcml2YXRlXG4gKi9cbk11c2ljQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0UmFuZG9tVHJhY2tfID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHJhY2tJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHRoaXMudHJhY2tMaXN0Xy5sZW5ndGgpO1xuICByZXR1cm4gdGhpcy50cmFja0xpc3RfW3RyYWNrSW5kZXhdO1xufTtcbiIsIi8qKiBAZmlsZSBPYnNlcnZlcyBhIEpTSW50ZXJwcmV0ZXIgYW5kIGxvZ3MgdG8gdGhlIGRlc2lnbmF0ZWQgYnJvd3NlciBjb25zb2xlLiAqL1xuLy8gU3RyaWN0IGxpbnRpbmc6IEFic29yYiBpbnRvIGdsb2JhbCBjb25maWcgd2hlbiBwb3NzaWJsZVxuLyoganNoaW50XG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcbiBtYXhsZW46IDEyMFxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBPYnNlcnZlciA9IHJlcXVpcmUoJy4vT2JzZXJ2ZXInKTtcblxuLyoqXG4gKiBPYnNlcnZlciByZXNwb25zaWJsZSBmb3IgbG9nZ2luZyB0byB0aGUgcHJvdmlkZWQgYnJvd3NlciBjb25zb2xlIHdoZW5cbiAqIHRoZSBpbnRlcnByZXRlciBpdCBpcyBvYnNlcnZpbmcgcmFpc2VzIGxvZy13b3J0aHkgZXZlbnRzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0NvbnNvbGV9IHdpbmRvdyBjb25zb2xlIEFQSVxuICovXG52YXIgSnNJbnRlcnByZXRlckxvZ2dlciA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG91dHB1dENvbnNvbGUpIHtcbiAgLyoqIEBwcml2YXRlIHtDb25zb2xlfSAqL1xuICB0aGlzLm91dHB1dENvbnNvbGVfID0gb3V0cHV0Q29uc29sZTtcblxuICAvKiogQHByaXZhdGUge09ic2VydmVyfSAqL1xuICB0aGlzLm9ic2VydmVyXyA9IG5ldyBPYnNlcnZlcigpO1xufTtcblxuLyoqXG4gKiBBdHRhY2ggdGhlIGxvZ2dlciB0byBhIHBhcnRpY3VsYXIgSlNJbnRlcnByZXRlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7SlNJbnRlcnByZXRlcn0ganNJbnRlcnByZXRlclxuICovXG5Kc0ludGVycHJldGVyTG9nZ2VyLnByb3RvdHlwZS5hdHRhY2hUbyA9IGZ1bmN0aW9uIChqc0ludGVycHJldGVyKSB7XG4gIHRoaXMub2JzZXJ2ZXJfLm9ic2VydmUoanNJbnRlcnByZXRlci5vbkV4ZWN1dGlvbldhcm5pbmcsXG4gICAgICB0aGlzLmxvZy5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogRGV0YWNoIHRoZSBsb2dnZXIgZnJvbSB3aGF0ZXZlciBpbnRlcnByZXRlciBpbnN0YW5jZSBpdCBpcyBjdXJyZW50bHlcbiAqIGF0dGFjaGVkIHRvLCB1bnJlZ2lzdGVyaW5nIGhhbmRsZXJzLlxuICogU2FmZSB0byBjYWxsIHdoZW4gdGhlIGxvZ2dlciBpcyBhbHJlYWR5IGRldGFjaGVkLlxuICovXG5Kc0ludGVycHJldGVyTG9nZ2VyLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMub2JzZXJ2ZXJfLnVub2JzZXJ2ZUFsbCgpO1xufTtcblxuLyoqXG4gKiBMb2cgdG8gdGhlIGNvbnNvbGUgb2JqZWN0IHdlIHdlcmUgY29uc3RydWN0ZWQgd2l0aC5cbiAqIEBwYXJhbSB7Kn0gYXJndW1lbnRzLi4uXG4gKiBAc2VlIENvbnNvbGUubG9nXG4gKi9cbkpzSW50ZXJwcmV0ZXJMb2dnZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMub3V0cHV0Q29uc29sZV8gJiYgdGhpcy5vdXRwdXRDb25zb2xlXy5sb2cpIHtcbiAgICB0aGlzLm91dHB1dENvbnNvbGVfLmxvZy5hcHBseSh0aGlzLm91dHB1dENvbnNvbGVfLCBhcmd1bWVudHMpO1xuICB9XG59O1xuIiwiLyoqIEBmaWxlIERlYnVnZ2VyIGNvbnRyb2xzIGFuZCBkZWJ1ZyBjb25zb2xlIHVzZWQgaW4gb3VyIHJpY2ggSmF2YVNjcmlwdCBJREVzICovXG4vLyBTdHJpY3QgbGludGluZzogQWJzb3JiIGludG8gZ2xvYmFsIGNvbmZpZyB3aGVuIHBvc3NpYmxlXG4vKiBqc2hpbnRcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuIG1heGxlbjogMTIwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIENvbW1hbmRIaXN0b3J5ID0gcmVxdWlyZSgnLi9Db21tYW5kSGlzdG9yeScpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG52YXIgRGVidWdBcmVhID0gcmVxdWlyZSgnLi9EZWJ1Z0FyZWEnKTtcbnZhciBkb20gPSByZXF1aXJlKCcuL2RvbScpO1xudmFyIEpTSW50ZXJwcmV0ZXIgPSByZXF1aXJlKCcuL0pTSW50ZXJwcmV0ZXInKTtcbnZhciBPYnNlcnZlciA9IHJlcXVpcmUoJy4vT2JzZXJ2ZXInKTtcbnZhciBTbGlkZXIgPSByZXF1aXJlKCcuL3NsaWRlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgS2V5Q29kZXMgPSBjb25zdGFudHMuS2V5Q29kZXM7XG52YXIgU3RlcFR5cGUgPSBKU0ludGVycHJldGVyLlN0ZXBUeXBlO1xuXG4vKiogQGNvbnN0IHtudW1iZXJ9ICovXG52YXIgTUlOX0RFQlVHX0FSRUFfSEVJR0hUID0gMTIwO1xuLyoqIEBjb25zdCB7bnVtYmVyfSAqL1xudmFyIE1BWF9ERUJVR19BUkVBX0hFSUdIVCA9IDQwMDtcblxuLyoqXG4gKiBEZWJ1Z2dlciBjb250cm9scyBhbmQgZGVidWcgY29uc29sZSB1c2VkIGluIG91ciByaWNoIEphdmFTY3JpcHQgSURFcywgbGlrZVxuICogQXBwIExhYiwgR2FtZSBMYWIsIGV0Yy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBydW5BcHAgLSBjYWxsYmFjayBmb3IgXCJsYXVuY2hpbmdcIiB0aGUgYXBwLCB3aGljaCBpcyB1c2VkXG4gKiAgICAgICAgYnkgdGhlIFwiU3RlcCBJblwiIGJ1dHRvbiB3aGVuIHRoZSBhcHAgaXNuJ3QgcnVubmluZy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgSnNEZWJ1Z2dlclVpID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocnVuQXBwKSB7XG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gY3VycmVudGx5IGF0dGFjaGVkIEpTSW50ZXJwcmV0ZXIsIG51bGwgaWYgdW5hdHRhY2hlZC5cbiAgICogQHByaXZhdGUge0pTSW50ZXJwcmV0ZXJ9XG4gICAqL1xuICB0aGlzLmpzSW50ZXJwcmV0ZXJfID0gbnVsbDtcblxuICAvKiogQHByaXZhdGUge09ic2VydmVyfSAqL1xuICB0aGlzLm9ic2VydmVyXyA9IG5ldyBPYnNlcnZlcigpO1xuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3IgXCJsYXVuY2hpbmdcIiB0aGUgYXBwLCB1c2VkIGJ5IHRoZSBcIlN0ZXAgSW5cIiBidXR0b24gd2hlbiB0aGUgYXBwXG4gICAqIGlzbid0IGN1cnJlbnRseSBydW5uaW5nLlxuICAgKiBAcHJpdmF0ZSB7ZnVuY3Rpb259XG4gICAqL1xuICB0aGlzLnJ1bkFwcF8gPSBydW5BcHA7XG5cbiAgLyoqXG4gICAqIEJyb3dzZWFibGUgaGlzdG9yeSBvZiBjb21tYW5kcyBlbnRlcmVkIGludG8gdGhlIGRlYnVnIGNvbnNvbGUuXG4gICAqIEBwcml2YXRlIHtDb21tYW5kSGlzdG9yeX1cbiAgICovXG4gIHRoaXMuaGlzdG9yeV8gPSBuZXcgQ29tbWFuZEhpc3RvcnkoKTtcblxuICAvKipcbiAgICogSGVscGVyIHRoYXQgaGFuZGxlcyBvcGVuL3NodXQgYWN0aW9ucyBmb3IgZGVidWdnZXIgVUlcbiAgICogQHByaXZhdGUge0RlYnVnQXJlYX1cbiAgICovXG4gIHRoaXMuZGVidWdPcGVuU2h1dENvbnRyb2xsZXJfID0gbnVsbDtcblxuICAvKipcbiAgICogUm9vdCBlbGVtZW50IGZvciBkZWJ1ZyBVSTogZGl2I2RlYnVnLWFyZWFcbiAgICogQHByaXZhdGUge0hUTUxEaXZFbGVtZW50fVxuICAgKi9cbiAgdGhpcy5yb290RGl2XyA9IG51bGw7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIERPTSBlbGVtZW50IG1hcmt1cCBmcm9tIGFuIGVqcyBmaWxlIGZvciB0aGUgZGVidWcgYXJlYS5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBhc3NldFVybCAtIEhlbHBlciBmb3IgZ2V0dGluZyBhc3NldCBVUkxzLlxuICogQHBhcmFtIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0geyFib29sZWFufSBvcHRpb25zLnNob3dCdXR0b25zIC0gV2hldGhlciB0byBzaG93IHRoZSBkZWJ1ZyBidXR0b25zXG4gKiBAcGFyYW0geyFib29sZWFufSBvcHRpb25zLnNob3dDb25zb2xlIC0gV2hldGhlciB0byBzaG93IHRoZSBkZWJ1ZyBjb25zb2xlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBvZiBIVE1MIG1hcmt1cCB0byBiZSBlbWJlZGRlZCBpbiBjb2RlV29ya3NwYWNlLmh0bWwuZWpzXG4gKi9cbkpzRGVidWdnZXJVaS5wcm90b3R5cGUuZ2V0TWFya3VwID0gZnVuY3Rpb24gKGFzc2V0VXJsLCBvcHRpb25zKSB7XG4gIHJldHVybiByZXF1aXJlKCcuL0pzRGVidWdnZXJVaS5odG1sLmVqcycpKHtcbiAgICBhc3NldFVybDogYXNzZXRVcmwsXG4gICAgZGVidWdCdXR0b25zOiBvcHRpb25zLnNob3dCdXR0b25zLFxuICAgIGRlYnVnQ29uc29sZTogb3B0aW9ucy5zaG93Q29uc29sZVxuICB9KTtcbn07XG5cbi8qKlxuICogQXR0YWNoIHRoZSBkZWJ1Z2dlciB0byBhIHBhcnRpY3VsYXIgSlNJbnRlcnByZXRlciBpbnN0YW5jZS4gIFJlaW5pdGlhbGl6ZXNcbiAqIHRoZSBVSSBzdGF0ZSBhbmQgYmVnaW5zIGxpc3RlbmluZyBmb3IgaW50ZXJwcmV0ZXIgZXZlbnRzLlxuICogQHBhcmFtIHtKU0ludGVycHJldGVyfSBqc0ludGVycHJldGVyXG4gKi9cbkpzRGVidWdnZXJVaS5wcm90b3R5cGUuYXR0YWNoVG8gPSBmdW5jdGlvbiAoanNJbnRlcnByZXRlcikge1xuICB0aGlzLmpzSW50ZXJwcmV0ZXJfID0ganNJbnRlcnByZXRlcjtcbiAgdGhpcy5vYnNlcnZlcl8ub2JzZXJ2ZShqc0ludGVycHJldGVyLm9uTmV4dFN0ZXBDaGFuZ2VkLFxuICAgICAgdGhpcy51cGRhdGVQYXVzZVVpU3RhdGUuYmluZCh0aGlzKSk7XG4gIHRoaXMub2JzZXJ2ZXJfLm9ic2VydmUoanNJbnRlcnByZXRlci5vblBhdXNlLFxuICAgICAgdGhpcy5vblBhdXNlQ29udGludWVCdXR0b24uYmluZCh0aGlzKSk7XG4gIHRoaXMub2JzZXJ2ZXJfLm9ic2VydmUoanNJbnRlcnByZXRlci5vbkV4ZWN1dGlvbldhcm5pbmcsXG4gICAgICB0aGlzLmxvZy5iaW5kKHRoaXMpKTtcblxuICB0aGlzLnVwZGF0ZVBhdXNlVWlTdGF0ZSgpO1xuICB0aGlzLmNsZWFyRGVidWdPdXRwdXQoKTtcbiAgdGhpcy5jbGVhckRlYnVnSW5wdXQoKTtcbn07XG5cbi8qKlxuICogRGV0YWNoIHRoZSBkZWJ1Z2dlciBmcm9tIHdoYXRldmVyIGludGVycHJldGVyIGluc3RhbmNlIGl0IGlzIGN1cnJlbnRseVxuICogYXR0YWNoZWQgdG8sIHVucmVnaXN0ZXJpbmcgaGFuZGxlcnMgYW5kIHJlc2V0dGluZyB0aGUgY29udHJvbHMgdG8gYVxuICogJ2RldGFjaGVkJyBzdGF0ZS5cbiAqIFNhZmUgdG8gY2FsbCB3aGVuIHRoZSBkZWJ1Z2dlciBpcyBhbHJlYWR5IGRldGFjaGVkLlxuICovXG5Kc0RlYnVnZ2VyVWkucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5vYnNlcnZlcl8udW5vYnNlcnZlQWxsKCk7XG4gIHRoaXMuanNJbnRlcnByZXRlcl8gPSBudWxsO1xuXG4gIHRoaXMucmVzZXREZWJ1Z0NvbnRyb2xzXygpO1xufTtcblxuLyoqXG4gKiBFbGVtZW50IGdldHRlciBmb3IgZWxlbWVudHMgd2l0aGluIHRoZSBkZWJ1Z2dlciBVSS5cbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAqL1xuSnNEZWJ1Z2dlclVpLnByb3RvdHlwZS5nZXRFbGVtZW50XyA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICB2YXIgcm9vdERpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZWJ1Zy1hcmVhJyk7XG4gIGlmIChyb290RGl2KSB7XG4gICAgcmV0dXJuIHJvb3REaXYucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogUG9zdC1ET00gaW5pdGlhbGl6YXRpb24sIHdoaWNoIGFsbG93cyB0aGlzIGNvbnRyb2xsZXIgdG8gZ3JhYiBhbGwgdGhlIERPTVxuICogcmVmZXJlbmNlcyBpdCBuZWVkcywgYmluZCBoYW5kbGVycywgYW5kIGNyZWF0ZSBhbnkgc3Vib3JkaW5hdGUgY29udHJvbGxlcnMuXG4gKiBAcGFyYW0geyFPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kZWZhdWx0U3RlcFNwZWVkXSBpbiByYW5nZSAwLi4xXG4gKi9cbkpzRGVidWdnZXJVaS5wcm90b3R5cGUuaW5pdGlhbGl6ZUFmdGVyRG9tQ3JlYXRlZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIC8vIEdldCByZWZlcmVuY2VzIHRvIGltcG9ydGFudCBlbGVtZW50cyBvZiB0aGUgRE9NXG4gIHRoaXMucm9vdERpdl8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGVidWctYXJlYScpO1xuXG4gIC8vIENyZWF0ZSBjb250cm9sbGVyIGZvciBvcGVuL3NodXQgYmVoYXZpb3Igb2YgZGVidWcgYXJlYVxuICB0aGlzLmRlYnVnT3BlblNodXRDb250cm9sbGVyXyA9IG5ldyBEZWJ1Z0FyZWEoXG4gICAgICB0aGlzLnJvb3REaXZfLFxuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvZGVUZXh0Ym94JykpO1xuXG4gIC8vIEluaXRpYWxpemUgZGVidWcgc3BlZWQgc2xpZGVyXG4gIHZhciBzbGlkZXIgPSB0aGlzLnJvb3REaXZfLnF1ZXJ5U2VsZWN0b3IoJyNzcGVlZC1zbGlkZXInKTtcbiAgaWYgKHNsaWRlcikge1xuICAgIHZhciBzbGlkZXJYT2Zmc2V0ID0gMTAsXG4gICAgICAgIHNsaWRlcllPZmZzZXQgPSAyMixcbiAgICAgICAgc2xpZGVyV2lkdGggPSAxMzA7XG4gICAgdGhpcy5zcGVlZFNsaWRlcl8gPSBuZXcgU2xpZGVyKHNsaWRlclhPZmZzZXQsIHNsaWRlcllPZmZzZXQsIHNsaWRlcldpZHRoLFxuICAgICAgICBzbGlkZXIpO1xuXG4gICAgLy8gQ2hhbmdlIGRlZmF1bHQgc3BlZWQgKGVnIFNwZWVkIHVwIGxldmVscyB0aGF0IGhhdmUgbG90cyBvZiBzdGVwcykuXG4gICAgaWYgKG9wdGlvbnMuZGVmYXVsdFN0ZXBTcGVlZCkge1xuICAgICAgdGhpcy5zZXRTdGVwU3BlZWQob3B0aW9ucy5kZWZhdWx0U3RlcFNwZWVkKTtcbiAgICB9XG4gIH1cblxuICAvLyBBdHRhY2gga2V5ZG93biBoYW5kbGVyIGZvciBkZWJ1ZyBjb25zb2xlIGlucHV0IGFyZWFcbiAgdmFyIGRlYnVnSW5wdXQgPSB0aGlzLnJvb3REaXZfLnF1ZXJ5U2VsZWN0b3IoJyNkZWJ1Zy1pbnB1dCcpO1xuICBpZiAoZGVidWdJbnB1dCkge1xuICAgIGRlYnVnSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25EZWJ1Z0lucHV0S2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8vIEF0dGFjaCBjbGljayBoYW5kbGVyIGZvciBmb2N1c2luZyBvbiBjb25zb2xlIGlucHV0IHdoZW4gY2xpY2tpbmcgb3V0cHV0XG4gIHZhciBkZWJ1Z091dHB1dCA9IHRoaXMucm9vdERpdl8ucXVlcnlTZWxlY3RvcignI2RlYnVnLW91dHB1dCcpO1xuICBpZiAoZGVidWdPdXRwdXQpIHtcbiAgICBkZWJ1Z091dHB1dC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbkRlYnVnT3V0cHV0TW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8vIEF0dGFjaCBoYW5kbGVycyBmb3IgdGhlIGRlYnVnIGFyZWEgcmVzaXplIGNvbnRyb2xcbiAgdmFyIHJlc2l6ZUJhciA9IHRoaXMuZ2V0RWxlbWVudF8oJyNkZWJ1Z1Jlc2l6ZUJhcicpO1xuICBpZiAocmVzaXplQmFyKSB7XG4gICAgZG9tLmFkZE1vdXNlRG93blRvdWNoRXZlbnQocmVzaXplQmFyLCB0aGlzLm9uTW91c2VEb3duRGVidWdSZXNpemVCYXIuYmluZCh0aGlzKSk7XG5cbiAgICAvLyBDYW4ndCB1c2UgZG9tLmFkZE1vdXNlVXBUb3VjaEV2ZW50KCkgYmVjYXVzZSBpdCB3aWxsIHByZXZlbnREZWZhdWx0IG9uXG4gICAgLy8gYWxsIHRvdWNoZW5kIGV2ZW50cyBvbiB0aGUgcGFnZSwgYnJlYWtpbmcgY2xpY2sgZXZlbnRzLi4uXG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJyxcbiAgICAgICAgdGhpcy5vbk1vdXNlVXBEZWJ1Z1Jlc2l6ZUJhci5iaW5kKHRoaXMpKTtcbiAgICB2YXIgbW91c2VVcFRvdWNoRXZlbnROYW1lID0gZG9tLmdldFRvdWNoRXZlbnROYW1lKCdtb3VzZXVwJyk7XG4gICAgaWYgKG1vdXNlVXBUb3VjaEV2ZW50TmFtZSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKG1vdXNlVXBUb3VjaEV2ZW50TmFtZSxcbiAgICAgICAgICB0aGlzLm9uTW91c2VVcERlYnVnUmVzaXplQmFyLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEF0dGFjaCBoYW5kbGVyIGZvciBjb25zb2xlIGNsZWFyIGJ1dHRvblxuICB2YXIgY2xlYXJCdXR0b24gPSB0aGlzLnJvb3REaXZfLnF1ZXJ5U2VsZWN0b3IoJyNjbGVhci1jb25zb2xlLWhlYWRlcicpO1xuICBpZiAoY2xlYXJCdXR0b24pIHtcbiAgICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KGNsZWFyQnV0dG9uLCB0aGlzLmNsZWFyRGVidWdPdXRwdXQuYmluZCh0aGlzKSk7XG4gIH1cblxuXG4gIC8vIEF0dGFjaCBoYW5kbGVycyBmb3IgZGVidWdnZXIgY29udHJvbHNcbiAgdmFyIHBhdXNlQnV0dG9uID0gdGhpcy5nZXRFbGVtZW50XygnI3BhdXNlQnV0dG9uJyk7XG4gIHZhciBjb250aW51ZUJ1dHRvbiA9IHRoaXMuZ2V0RWxlbWVudF8oJyNjb250aW51ZUJ1dHRvbicpO1xuICB2YXIgc3RlcEluQnV0dG9uID0gdGhpcy5nZXRFbGVtZW50XygnI3N0ZXBJbkJ1dHRvbicpO1xuICB2YXIgc3RlcE92ZXJCdXR0b24gPSB0aGlzLmdldEVsZW1lbnRfKCcjc3RlcE92ZXJCdXR0b24nKTtcbiAgdmFyIHN0ZXBPdXRCdXR0b24gPSB0aGlzLmdldEVsZW1lbnRfKCcjc3RlcE91dEJ1dHRvbicpO1xuICBpZiAocGF1c2VCdXR0b24gJiYgY29udGludWVCdXR0b24gJiYgc3RlcEluQnV0dG9uICYmIHN0ZXBPdmVyQnV0dG9uICYmIHN0ZXBPdXRCdXR0b24pIHtcbiAgICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KHBhdXNlQnV0dG9uLCB0aGlzLm9uUGF1c2VDb250aW51ZUJ1dHRvbi5iaW5kKHRoaXMpKTtcbiAgICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KGNvbnRpbnVlQnV0dG9uLCB0aGlzLm9uUGF1c2VDb250aW51ZUJ1dHRvbi5iaW5kKHRoaXMpKTtcbiAgICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KHN0ZXBJbkJ1dHRvbiwgdGhpcy5vblN0ZXBJbkJ1dHRvbi5iaW5kKHRoaXMpKTtcbiAgICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KHN0ZXBPdmVyQnV0dG9uLCB0aGlzLm9uU3RlcE92ZXJCdXR0b24uYmluZCh0aGlzKSk7XG4gICAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChzdGVwT3V0QnV0dG9uLCB0aGlzLm9uU3RlcE91dEJ1dHRvbi5iaW5kKHRoaXMpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHN0ZXAgZGVsYXkgaW4gbWlsbGlzZWNvbmRzIGZyb20gdGhlIHNwZWVkIHNsaWRlciBpbiB0aGUgZGVidWdnZXIgVUkuXG4gKiBJZiBubyBzcGVlZCBzbGlkZXIgaXMgcHJlc2VudCwgcmV0dXJucyB1bmRlZmluZWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfVxuICovXG5Kc0RlYnVnZ2VyVWkucHJvdG90eXBlLmdldFN0ZXBEZWxheSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3BlZWRTbGlkZXJfKSB7XG4gICAgcmV0dXJuIEpzRGVidWdnZXJVaS5zdGVwRGVsYXlGcm9tU3RlcFNwZWVkKHRoaXMuc3BlZWRTbGlkZXJfLmdldFZhbHVlKCkpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc3BlZWQgc2xpZGVyIHBvc2l0aW9uLlxuICogQHBhcmFtIHshbnVtYmVyfSBzcGVlZCAtIGluIHJhbmdlIDAuLjFcbiAqL1xuSnNEZWJ1Z2dlclVpLnByb3RvdHlwZS5zZXRTdGVwU3BlZWQgPSBmdW5jdGlvbiAoc3BlZWQpIHtcbiAgaWYgKHRoaXMuc3BlZWRTbGlkZXJfKSB7XG4gICAgdGhpcy5zcGVlZFNsaWRlcl8uc2V0VmFsdWUoc3BlZWQpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4cG9uZW50aWFsIGNvbnZlcnNpb24gZnJvbSBzdGVwIHNwZWVkIChhcyBzbGlkZXIgcG9zaXRpb24sIHJhbmdlIDAuLjEpIHRvXG4gKiBhIHN0ZXAgZGVsYXkgaW4gbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHshbnVtYmVyfSBzdGVwU3BlZWQgaW4gcmFuZ2UgMC4uMVxuICogQHJldHVybnMge251bWJlcn0gc3RlcCBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuSnNEZWJ1Z2dlclVpLnN0ZXBEZWxheUZyb21TdGVwU3BlZWQgPSBmdW5jdGlvbiAoc3RlcFNwZWVkKSB7XG4gIHJldHVybiAzMDAgKiBNYXRoLnBvdygxIC0gc3RlcFNwZWVkLCAyKTtcbn07XG5cbi8qKlxuICogR2l2ZW4gc29tZSBvYmplY3Qgb3IgbWVzc2FnZSwgYXR0ZW1wdCB0byBsb2cgaXQgYm90aCB0byB0aGUgYnJvd3NlciBjb25zb2xlXG4gKiBhbmQgdG8gdGhlIHVzZXItZmFjaW5nIGRlYnVnIGNvbnNvbGUuXG4gKiBAcGFyYW0geyp9IG91dHB1dFxuICovXG5Kc0RlYnVnZ2VyVWkucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChvdXRwdXQpIHtcbiAgdmFyIGRlYnVnT3V0cHV0RGl2ID0gdGhpcy5nZXRFbGVtZW50XygnI2RlYnVnLW91dHB1dCcpO1xuICBpZiAoZGVidWdPdXRwdXREaXYpIHtcbiAgICBpZiAoZGVidWdPdXRwdXREaXYudGV4dENvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgZGVidWdPdXRwdXREaXYudGV4dENvbnRlbnQgKz0gJ1xcbic7XG4gICAgfVxuICAgIGRlYnVnT3V0cHV0RGl2LnRleHRDb250ZW50ICs9IHN0cmluZ2lmeU5vblN0cmluZ3Mob3V0cHV0KTtcblxuICAgIGRlYnVnT3V0cHV0RGl2LnNjcm9sbFRvcCA9IGRlYnVnT3V0cHV0RGl2LnNjcm9sbEhlaWdodDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5Tm9uU3RyaW5ncyhvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdzdHJpbmcnIHx8IG9iamVjdCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iamVjdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBrZXkgZXZlbnRzIGluIHRoZSBkZWJ1ZyBjb25zb2xlIGlucHV0IGJveC5cbiAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZVxuICovXG5Kc0RlYnVnZ2VyVWkucHJvdG90eXBlLm9uRGVidWdJbnB1dEtleURvd24gPSBmdW5jdGlvbiAoZSkge1xuICB2YXIgaW5wdXQgPSBlLnRhcmdldC50ZXh0Q29udGVudDtcbiAgaWYgKGUua2V5Q29kZSA9PT0gS2V5Q29kZXMuRU5URVIpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5oaXN0b3J5Xy5wdXNoKGlucHV0KTtcbiAgICBlLnRhcmdldC50ZXh0Q29udGVudCA9ICcnO1xuICAgIHRoaXMubG9nKCc+ICcgKyBpbnB1dCk7XG4gICAgdmFyIGpzSW50ZXJwcmV0ZXIgPSB0aGlzLmpzSW50ZXJwcmV0ZXJfO1xuICAgIGlmIChqc0ludGVycHJldGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ganNJbnRlcnByZXRlci5ldmFsSW5DdXJyZW50U2NvcGUoaW5wdXQpO1xuICAgICAgICB0aGlzLmxvZygnPCAnICsgU3RyaW5nKHJlc3VsdCkpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMubG9nKCc8ICcgKyBTdHJpbmcoZXJyKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nKCc8IChub3QgcnVubmluZyknKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09PSBLZXlDb2Rlcy5VUCkge1xuICAgIGUudGFyZ2V0LnRleHRDb250ZW50ID0gdGhpcy5oaXN0b3J5Xy5nb0JhY2soaW5wdXQpO1xuICAgIG1vdmVDYXJldFRvRW5kT2ZEaXYoZS50YXJnZXQpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gQmxvY2sgZGVmYXVsdCBIb21lL0VuZC1saWtlIGJlaGF2aW9yIGluIENocm9tZVxuICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gS2V5Q29kZXMuRE9XTikge1xuICAgIGUudGFyZ2V0LnRleHRDb250ZW50ID0gdGhpcy5oaXN0b3J5Xy5nb0ZvcndhcmQoaW5wdXQpO1xuICAgIG1vdmVDYXJldFRvRW5kT2ZEaXYoZS50YXJnZXQpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gQmxvY2sgZGVmYXVsdCBIb21lL0VuZC1saWtlIGJlaGF2aW9yIGluIENocm9tZVxuICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY3Vyc29yIHBvc2l0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIHRleHQgY29udGVudCBpbiBhIGRpdiBlbGVtZW50LlxuICogQHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82MjQ5NDQwLzUwMDAxMjlcbiAqIEBwYXJhbSB7IUhUTUxEaXZFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIG1vdmVDYXJldFRvRW5kT2ZEaXYoZWxlbWVudCkge1xuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBpZiAoZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJhbmdlLnNldFN0YXJ0KGVsZW1lbnQubGFzdENoaWxkLCBlbGVtZW50Lmxhc3RDaGlsZC5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG5cbiAgLy8gQ2hhbmdlIHdpbmRvdyBzZWxlY3Rpb24gdG8gbmV3IHJhbmdlIHRvIHNldCBjdXJzb3IgcG9zaXRpb25cbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xufVxuXG4vKipcbiAqIE9uIG1vdXNldXAgb3ZlciB0aGUgY29uc29sZSBvdXRwdXQsIGlmIHRoZSB1c2VyIGhhc24ndCBqdXN0IHNlbGVjdGVkIHNvbWVcbiAqIHRleHQsIHBsYWNlIHRoZSBmb2N1cyBpbiB0aGUgY29uc29sZSBpbnB1dCBib3guXG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcbiAqL1xuSnNEZWJ1Z2dlclVpLnByb3RvdHlwZS5vbkRlYnVnT3V0cHV0TW91c2VVcCA9IGZ1bmN0aW9uIChlKSB7XG4gIHZhciBkZWJ1Z0lucHV0ID0gdGhpcy5nZXRFbGVtZW50XygnI2RlYnVnLWlucHV0Jyk7XG4gIGlmIChkZWJ1Z0lucHV0ICYmIGUudGFyZ2V0LnRhZ05hbWUgPT09IFwiRElWXCIgJiZcbiAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpLmxlbmd0aCA9PT0gMCkge1xuICAgIGRlYnVnSW5wdXQuZm9jdXMoKTtcbiAgfVxufTtcblxuLyoqIEB0eXBlIHtib29sZWFufSAqL1xudmFyIGRyYWdnaW5nRGVidWdSZXNpemVCYXIgPSBmYWxzZTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbn0gKi9cbnZhciBib3VuZE1vdXNlTW92ZUhhbmRsZXI7XG5cbi8qKiBAdHlwZSB7c3RyaW5nfSAqL1xudmFyIG1vdXNlTW92ZVRvdWNoRXZlbnROYW1lO1xuXG5Kc0RlYnVnZ2VyVWkucHJvdG90eXBlLm9uTW91c2VEb3duRGVidWdSZXNpemVCYXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgLy8gV2hlbiB3ZSBzZWUgYSBtb3VzZSBkb3duIGluIHRoZSByZXNpemUgYmFyLCBzdGFydCB0cmFja2luZyBtb3VzZSBtb3ZlczpcbiAgdmFyIGV2ZW50U291cmNlRWxtID0gZXZlbnQuc3JjRWxlbWVudCB8fCBldmVudC50YXJnZXQ7XG4gIGlmIChldmVudFNvdXJjZUVsbS5pZCA9PT0gJ2RlYnVnUmVzaXplQmFyJykge1xuICAgIGRyYWdnaW5nRGVidWdSZXNpemVCYXIgPSB0cnVlO1xuICAgIGJvdW5kTW91c2VNb3ZlSGFuZGxlciA9IHRoaXMub25Nb3VzZU1vdmVEZWJ1Z1Jlc2l6ZUJhci5iaW5kKHRoaXMpO1xuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgYm91bmRNb3VzZU1vdmVIYW5kbGVyKTtcbiAgICBtb3VzZU1vdmVUb3VjaEV2ZW50TmFtZSA9IGRvbS5nZXRUb3VjaEV2ZW50TmFtZSgnbW91c2Vtb3ZlJyk7XG4gICAgaWYgKG1vdXNlTW92ZVRvdWNoRXZlbnROYW1lKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIobW91c2VNb3ZlVG91Y2hFdmVudE5hbWUsXG4gICAgICAgICAgYm91bmRNb3VzZU1vdmVIYW5kbGVyKTtcbiAgICB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59O1xuXG4vKipcbiAqICBIYW5kbGUgbW91c2UgbW92ZXMgd2hpbGUgZHJhZ2dpbmcgdGhlIGRlYnVnIHJlc2l6ZSBiYXIuXG4gKi9cbkpzRGVidWdnZXJVaS5wcm90b3R5cGUub25Nb3VzZU1vdmVEZWJ1Z1Jlc2l6ZUJhciA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgY29kZUFwcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb2RlQXBwJyk7XG4gIHZhciBjb2RlVGV4dGJveCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb2RlVGV4dGJveCcpO1xuXG4gIHZhciByZXNpemVCYXIgPSB0aGlzLmdldEVsZW1lbnRfKCcjZGVidWdSZXNpemVCYXInKTtcbiAgdmFyIHJlY3QgPSByZXNpemVCYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBvZmZzZXQgPSAocGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoY29kZUFwcCkuYm90dG9tLCAxMCkgfHwgMCkgLVxuICAgICAgcmVjdC5oZWlnaHQgLyAyO1xuICB2YXIgbmV3RGJnSGVpZ2h0ID0gTWF0aC5tYXgoTUlOX0RFQlVHX0FSRUFfSEVJR0hULFxuICAgICAgTWF0aC5taW4oTUFYX0RFQlVHX0FSRUFfSEVJR0hULFxuICAgICAgICAgICh3aW5kb3cuaW5uZXJIZWlnaHQgLSBldmVudC5wYWdlWSkgLSBvZmZzZXQpKTtcblxuICBpZiAodGhpcy5kZWJ1Z09wZW5TaHV0Q29udHJvbGxlcl8uaXNTaHV0KCkpIHtcbiAgICB0aGlzLmRlYnVnT3BlblNodXRDb250cm9sbGVyXy5zbmFwT3BlbigpO1xuICB9XG5cbiAgY29kZVRleHRib3guc3R5bGUuYm90dG9tID0gbmV3RGJnSGVpZ2h0ICsgJ3B4JztcbiAgdGhpcy5yb290RGl2Xy5zdHlsZS5oZWlnaHQgPSBuZXdEYmdIZWlnaHQgKyAncHgnO1xuXG4gIC8vIEZpcmUgcmVzaXplIHNvIGJsb2NrbHkgYW5kIGRyb3BsZXQgaGFuZGxlIHRoaXMgdHlwZSBvZiByZXNpemUgcHJvcGVybHk6XG4gIHV0aWxzLmZpcmVSZXNpemVFdmVudCgpO1xufTtcblxuSnNEZWJ1Z2dlclVpLnByb3RvdHlwZS5vbk1vdXNlVXBEZWJ1Z1Jlc2l6ZUJhciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gSWYgd2UgaGF2ZSBiZWVuIHRyYWNraW5nIG1vdXNlIG1vdmVzLCByZW1vdmUgdGhlIGhhbmRsZXIgbm93OlxuICBpZiAoZHJhZ2dpbmdEZWJ1Z1Jlc2l6ZUJhcikge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgYm91bmRNb3VzZU1vdmVIYW5kbGVyKTtcbiAgICBpZiAobW91c2VNb3ZlVG91Y2hFdmVudE5hbWUpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihtb3VzZU1vdmVUb3VjaEV2ZW50TmFtZSxcbiAgICAgICAgICBib3VuZE1vdXNlTW92ZUhhbmRsZXIpO1xuICAgIH1cbiAgICBkcmFnZ2luZ0RlYnVnUmVzaXplQmFyID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogRW1wdHkgdGhlIGNvbnRlbnRzIG9mIHRoZSBkZWJ1ZyBjb25zb2xlIHNjcm9sbGJhY2sgYXJlYS5cbiAqL1xuSnNEZWJ1Z2dlclVpLnByb3RvdHlwZS5jbGVhckRlYnVnT3V0cHV0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGVidWdPdXRwdXREaXYgPSB0aGlzLmdldEVsZW1lbnRfKCcjZGVidWctb3V0cHV0Jyk7XG4gIGlmIChkZWJ1Z091dHB1dERpdikge1xuICAgIGRlYnVnT3V0cHV0RGl2LnRleHRDb250ZW50ID0gJyc7XG4gIH1cbn07XG5cbi8qKlxuICogRW1wdHkgdGhlIGRlYnVnIGNvbnNvbGUgaW5wdXQgYXJlYS5cbiAqL1xuSnNEZWJ1Z2dlclVpLnByb3RvdHlwZS5jbGVhckRlYnVnSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkZWJ1Z0lucHV0ID0gdGhpcy5nZXRFbGVtZW50XygnI2RlYnVnLWlucHV0Jyk7XG4gIGlmIChkZWJ1Z0lucHV0KSB7XG4gICAgZGVidWdJbnB1dC50ZXh0Q29udGVudCA9ICcnO1xuICB9XG59O1xuXG5Kc0RlYnVnZ2VyVWkucHJvdG90eXBlLm9uUGF1c2VDb250aW51ZUJ1dHRvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIganNJbnRlcnByZXRlciA9IHRoaXMuanNJbnRlcnByZXRlcl87XG4gIGlmIChqc0ludGVycHJldGVyKSB7XG4gICAgLy8gV2UgaGF2ZSBjb2RlIGFuZCBhcmUgZWl0aGVyIHJ1bm5pbmcgb3IgcGF1c2VkXG4gICAgaWYgKGpzSW50ZXJwcmV0ZXIucGF1c2VkICYmXG4gICAgICAgIGpzSW50ZXJwcmV0ZXIubmV4dFN0ZXAgPT09IFN0ZXBUeXBlLlJVTikge1xuICAgICAganNJbnRlcnByZXRlci5wYXVzZWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAganNJbnRlcnByZXRlci5wYXVzZWQgPSB0cnVlO1xuICAgICAganNJbnRlcnByZXRlci5uZXh0U3RlcCA9IFN0ZXBUeXBlLlJVTjtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVBhdXNlVWlTdGF0ZSgpO1xuICB9XG59O1xuXG5Kc0RlYnVnZ2VyVWkucHJvdG90eXBlLnVwZGF0ZVBhdXNlVWlTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIganNJbnRlcnByZXRlciA9IHRoaXMuanNJbnRlcnByZXRlcl87XG4gIGlmICghanNJbnRlcnByZXRlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYXVzZUJ1dHRvbiA9IHRoaXMuZ2V0RWxlbWVudF8oJyNwYXVzZUJ1dHRvbicpO1xuICB2YXIgY29udGludWVCdXR0b24gPSB0aGlzLmdldEVsZW1lbnRfKCcjY29udGludWVCdXR0b24nKTtcbiAgdmFyIHNwaW5uZXIgPSB0aGlzLmdldEVsZW1lbnRfKCcjcnVubmluZy1zcGlubmVyJyk7XG4gIHZhciBwYXVzZWRJY29uID0gdGhpcy5nZXRFbGVtZW50XygnI3BhdXNlZC1pY29uJyk7XG4gIGlmIChwYXVzZUJ1dHRvbiAmJiBjb250aW51ZUJ1dHRvbiAmJiBzcGlubmVyICYmIHBhdXNlZEljb24pIHtcbiAgICBpZiAoanNJbnRlcnByZXRlci5wYXVzZWQgJiYganNJbnRlcnByZXRlci5uZXh0U3RlcCA9PT0gU3RlcFR5cGUuUlVOKSB7XG4gICAgICBwYXVzZUJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICBjb250aW51ZUJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgIGNvbnRpbnVlQnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICBzcGlubmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBwYXVzZWRJY29uLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICB9IGVsc2Uge1xuICAgICAgcGF1c2VCdXR0b24uc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICBwYXVzZUJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgY29udGludWVCdXR0b24uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgc3Bpbm5lci5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgICBwYXVzZWRJY29uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ZXBJbkJ1dHRvbiA9IHRoaXMuZ2V0RWxlbWVudF8oJyNzdGVwSW5CdXR0b24nKTtcbiAgdmFyIHN0ZXBPdmVyQnV0dG9uID0gdGhpcy5nZXRFbGVtZW50XygnI3N0ZXBPdmVyQnV0dG9uJyk7XG4gIHZhciBzdGVwT3V0QnV0dG9uID0gdGhpcy5nZXRFbGVtZW50XygnI3N0ZXBPdXRCdXR0b24nKTtcbiAgaWYgKHN0ZXBJbkJ1dHRvbiAmJiBzdGVwT3ZlckJ1dHRvbiAmJiBzdGVwT3V0QnV0dG9uKSB7XG4gICAgc3RlcEluQnV0dG9uLmRpc2FibGVkID0gIWpzSW50ZXJwcmV0ZXIucGF1c2VkO1xuICAgIHN0ZXBPdmVyQnV0dG9uLmRpc2FibGVkID0gIWpzSW50ZXJwcmV0ZXIucGF1c2VkO1xuICAgIHN0ZXBPdXRCdXR0b24uZGlzYWJsZWQgPSAhanNJbnRlcnByZXRlci5wYXVzZWQ7XG4gIH1cbn07XG5cbi8qKlxuICogUHV0IHRoZSBkZWJ1ZyBjb250cm9scyBiYWNrIGludG8gYSBkZXRhY2hlZCBzdGF0ZS5cbiAqIEBwcml2YXRlXG4gKi9cbkpzRGVidWdnZXJVaS5wcm90b3R5cGUucmVzZXREZWJ1Z0NvbnRyb2xzXyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNwaW5uZXIgPSB0aGlzLmdldEVsZW1lbnRfKCcjcnVubmluZy1zcGlubmVyJyk7XG4gIGlmIChzcGlubmVyKSB7XG4gICAgc3Bpbm5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG5cbiAgdmFyIHBhdXNlZEljb24gPSB0aGlzLmdldEVsZW1lbnRfKCcjcGF1c2VkLWljb24nKTtcbiAgaWYgKHBhdXNlZEljb24pIHtcbiAgICBwYXVzZWRJY29uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cblxuICB2YXIgcGF1c2VCdXR0b24gPSB0aGlzLmdldEVsZW1lbnRfKCcjcGF1c2VCdXR0b24nKTtcbiAgdmFyIGNvbnRpbnVlQnV0dG9uID0gdGhpcy5nZXRFbGVtZW50XygnI2NvbnRpbnVlQnV0dG9uJyk7XG4gIHZhciBzdGVwSW5CdXR0b24gPSB0aGlzLmdldEVsZW1lbnRfKCcjc3RlcEluQnV0dG9uJyk7XG4gIHZhciBzdGVwT3ZlckJ1dHRvbiA9IHRoaXMuZ2V0RWxlbWVudF8oJyNzdGVwT3ZlckJ1dHRvbicpO1xuICB2YXIgc3RlcE91dEJ1dHRvbiA9IHRoaXMuZ2V0RWxlbWVudF8oJyNzdGVwT3V0QnV0dG9uJyk7XG4gIGlmIChwYXVzZUJ1dHRvbiAmJiBjb250aW51ZUJ1dHRvbiAmJiBzdGVwSW5CdXR0b24gJiZcbiAgICAgIHN0ZXBPdmVyQnV0dG9uICYmIHN0ZXBPdXRCdXR0b24pIHtcbiAgICBwYXVzZUJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICBwYXVzZUJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgY29udGludWVCdXR0b24uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIHN0ZXBJbkJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIHN0ZXBPdmVyQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICBzdGVwT3V0QnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgfVxufTtcblxuSnNEZWJ1Z2dlclVpLnByb3RvdHlwZS5vblN0ZXBPdmVyQnV0dG9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBqc0ludGVycHJldGVyID0gdGhpcy5qc0ludGVycHJldGVyXztcbiAgaWYgKGpzSW50ZXJwcmV0ZXIpIHtcbiAgICBqc0ludGVycHJldGVyLnBhdXNlZCA9IHRydWU7XG4gICAganNJbnRlcnByZXRlci5uZXh0U3RlcCA9IFN0ZXBUeXBlLk9WRVI7XG4gICAgdGhpcy51cGRhdGVQYXVzZVVpU3RhdGUoKTtcbiAgfVxufTtcblxuSnNEZWJ1Z2dlclVpLnByb3RvdHlwZS5vblN0ZXBJbkJ1dHRvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIganNJbnRlcnByZXRlciA9IHRoaXMuanNJbnRlcnByZXRlcl87XG4gIGlmICghanNJbnRlcnByZXRlcikge1xuICAgIHRoaXMucnVuQXBwXygpO1xuICAgIHRoaXMub25QYXVzZUNvbnRpbnVlQnV0dG9uKCk7XG4gICAganNJbnRlcnByZXRlciA9IHRoaXMuanNJbnRlcnByZXRlcl87XG4gIH1cbiAganNJbnRlcnByZXRlci5wYXVzZWQgPSB0cnVlO1xuICBqc0ludGVycHJldGVyLm5leHRTdGVwID0gU3RlcFR5cGUuSU47XG4gIHRoaXMudXBkYXRlUGF1c2VVaVN0YXRlKCk7XG59O1xuXG5Kc0RlYnVnZ2VyVWkucHJvdG90eXBlLm9uU3RlcE91dEJ1dHRvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIganNJbnRlcnByZXRlciA9IHRoaXMuanNJbnRlcnByZXRlcl87XG4gIGlmIChqc0ludGVycHJldGVyKSB7XG4gICAganNJbnRlcnByZXRlci5wYXVzZWQgPSB0cnVlO1xuICAgIGpzSW50ZXJwcmV0ZXIubmV4dFN0ZXAgPSBTdGVwVHlwZS5PVVQ7XG4gICAgdGhpcy51cGRhdGVQYXVzZVVpU3RhdGUoKTtcbiAgfVxufTtcbiIsIi8qKlxuICogQmxvY2tseSBBcHBzOiBTVkcgU2xpZGVyXG4gKlxuICogQ29weXJpZ2h0IDIwMTIgR29vZ2xlIEluYy5cbiAqIGh0dHA6Ly9ibG9ja2x5Lmdvb2dsZWNvZGUuY29tL1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEEgc2xpZGVyIGNvbnRyb2wgaW4gU1ZHLlxuICogQGF1dGhvciBmcmFzZXJAZ29vZ2xlLmNvbSAoTmVpbCBGcmFzZXIpXG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBTVkdfTlMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLlNWR19OUztcbnZhciBkb20gPSByZXF1aXJlKCcuL2RvbScpO1xuXG4vKipcbiAqIE9iamVjdCByZXByZXNlbnRpbmcgYSBob3Jpem9udGFsIHNsaWRlciB3aWRnZXQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgaG9yaXpvbnRhbCBvZmZzZXQgb2YgdGhlIHNsaWRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSB2ZXJ0aWNhbCBvZmZzZXQgb2YgdGhlIHNsaWRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBUaGUgdG90YWwgd2lkdGggb2YgdGhlIHNsaWRlci5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IHN2Z1BhcmVudCBUaGUgU1ZHIGVsZW1lbnQgdG8gYXBwZW5kIHRoZSBzbGlkZXIgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRfY2hhbmdlRnVuYyBPcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmVcbiAqICAgICBjYWxsZWQgd2hlbiB0aGUgc2xpZGVyIGlzIG1vdmVkLiAgVGhlIGN1cnJlbnQgdmFsdWUgaXMgcGFzc2VkLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTbGlkZXIgPSBmdW5jdGlvbih4LCB5LCB3aWR0aCwgc3ZnUGFyZW50LCBvcHRfY2hhbmdlRnVuYykge1xuICB0aGlzLktOT0JfWV8gPSB5IC0gMTI7XG4gIHRoaXMuS05PQl9NSU5fWF8gPSB4ICsgODtcbiAgdGhpcy5LTk9CX01BWF9YXyA9IHggKyB3aWR0aCAtIDg7XG4gIHRoaXMudmFsdWVfID0gMC41O1xuICB0aGlzLmNoYW5nZUZ1bmNfID0gb3B0X2NoYW5nZUZ1bmM7XG4gIHRoaXMuaXNBbmRyb2lkXyA9IGRvbS5pc0FuZHJvaWQoKTtcbiAgdGhpcy5pc0lPU18gPSBkb20uaXNJT1MoKTtcbiAgdGhpcy5pc1dpbmRvd3NUb3VjaF8gPSBkb20uaXNXaW5kb3dzVG91Y2goKTtcblxuICAvLyBEcmF3IHRoZSBzbGlkZXIuXG4gIC8qXG4gIDxsaW5lIGNsYXNzPVwic2xpZGVyVHJhY2tcIiB4MT1cIjEwXCIgeTE9XCIzNVwiIHgyPVwiMTQwXCIgeTI9XCIzNVwiIC8+XG4gIDxwYXRoIGlkPVwia25vYlwiXG4gICAgICB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoNjcsIDIzKVwiXG4gICAgICBkPVwibSA4LDAgbCAtOCw4IHYgMTIgaCAxNiB2IC0xMiB6XCIgLz5cbiAgKi9cbiAgdmFyIHRyYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgJ2xpbmUnKTtcbiAgdHJhY2suc2V0QXR0cmlidXRlKCdjbGFzcycsICdzbGlkZXJUcmFjaycpO1xuICB0cmFjay5zZXRBdHRyaWJ1dGUoJ3gxJywgeCk7XG4gIHRyYWNrLnNldEF0dHJpYnV0ZSgneTEnLCB5KTtcbiAgdHJhY2suc2V0QXR0cmlidXRlKCd4MicsIHggKyB3aWR0aCk7XG4gIHRyYWNrLnNldEF0dHJpYnV0ZSgneTInLCB5KTtcbiAgc3ZnUGFyZW50LmFwcGVuZENoaWxkKHRyYWNrKTtcbiAgdGhpcy50cmFja18gPSB0cmFjaztcbiAgdmFyIGtub2IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCAncGF0aCcpO1xuICBrbm9iLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2xpZGVyS25vYicpO1xuICBrbm9iLnNldEF0dHJpYnV0ZSgnZCcsICdtIDAsMCBsIC04LDggdiAxMiBoIDE2IHYgLTEyIHonKTtcbiAgc3ZnUGFyZW50LmFwcGVuZENoaWxkKGtub2IpO1xuICB0aGlzLmtub2JfID0ga25vYjtcbiAgdGhpcy5zZXRWYWx1ZSgwLjUpO1xuXG4gIC8vIEZpbmQgdGhlIHJvb3QgU1ZHIG9iamVjdC5cbiAgd2hpbGUgKHN2Z1BhcmVudCAmJiBzdmdQYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPSAnc3ZnJykge1xuICAgIHN2Z1BhcmVudCA9IHN2Z1BhcmVudC5wYXJlbnROb2RlO1xuICB9XG4gIHRoaXMuU1ZHXyA9IHN2Z1BhcmVudDtcblxuICAvLyBCaW5kIHRoZSBldmVudHMgdG8gdGhpcyBzbGlkZXIuXG4gIHZhciB0aGlzU2xpZGVyID0gdGhpcztcbiAgZG9tLmFkZE1vdXNlRG93blRvdWNoRXZlbnQodGhpcy5rbm9iXywgZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiB0aGlzU2xpZGVyLmtub2JNb3VzZURvd25fKGUpO1xuICB9KTtcbiAgZG9tLmFkZE1vdXNlRG93blRvdWNoRXZlbnQodGhpcy50cmFja18sIGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gdGhpc1NsaWRlci50cmFja01vdXNlRG93bl8oZSk7XG4gIH0pO1xuICBkb20uYWRkTW91c2VVcFRvdWNoRXZlbnQodGhpcy5TVkdfLCBTbGlkZXIua25vYk1vdXNlVXBfKTtcbiAgZG9tLmFkZE1vdXNlTW92ZVRvdWNoRXZlbnQodGhpcy5TVkdfLCBTbGlkZXIua25vYk1vdXNlTW92ZV8pO1xuICAvLyBEb24ndCBhZGQgdG91Y2ggZXZlbnRzIGZvciBtb3VzZW92ZXIuIFRoZSBVWCBpcyBiZXR0ZXIgb24gQW5kcm9pZFxuICAvLyBhbmQgaU9TIGlmIHRoZSBkcmFnIGFjdGlvbiBpcyBhbGxvd2VkIHRvIGNvbnRpbnVlIHdoZW4gdGhlXG4gIC8vIHRvdWNobW92ZSB0YXJnZXQgbW92ZXMgYWJvdmUgb3IgYmVsb3cgdGhlIFNWRyBlbGVtZW50LlxuICBTbGlkZXIuYmluZEV2ZW50Xyhkb2N1bWVudCwgJ21vdXNlb3ZlcicsIFNsaWRlci5tb3VzZU92ZXJfKTtcbn07XG5cblNsaWRlci5hY3RpdmVTbGlkZXJfID0gbnVsbDtcblNsaWRlci5zdGFydE1vdXNlWF8gPSAwO1xuU2xpZGVyLnN0YXJ0S25vYlhfID0gMDtcblxuLyoqXG4gKiBTdGFydCBhIGRyYWcgd2hlbiBjbGlja2luZyBkb3duIG9uIHRoZSBrbm9iLlxuICogQHBhcmFtIHshRXZlbnR9IGUgTW91c2UtZG93biBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cblNsaWRlci5wcm90b3R5cGUua25vYk1vdXNlRG93bl8gPSBmdW5jdGlvbihlKSB7XG4gIHRoaXMuYmVnaW5EcmFnXyh0aGlzLm1vdXNlVG9TdmdfKGUpKTtcblxuICAvLyBTdG9wIGJyb3dzZXIgZnJvbSBhdHRlbXB0aW5nIHRvIGRyYWcgdGhlIGtub2IuXG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBTbmFwIHRoZSBrbm9iIHRvIHRoZSBtb3VzZSBsb2NhdGlvbiBhbmQgc3RhcnQgYSBkcmFnXG4gKiB3aGVuIGNsaWNraW5nIG9uIHRoZSB0cmFjayAoYnV0IG5vdCBvbiB0aGUga25vYikuXG4gKiBAcGFyYW0geyFFdmVudH0gZSBNb3VzZS1kb3duIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuU2xpZGVyLnByb3RvdHlwZS50cmFja01vdXNlRG93bl8gPSBmdW5jdGlvbihlKSB7XG4gIHZhciBtb3VzZVNWR1Bvc2l0aW9uID0gdGhpcy5tb3VzZVRvU3ZnXyhlKTtcbiAgdGhpcy5zbmFwVG9Qb3NpdGlvbl8obW91c2VTVkdQb3NpdGlvbi54KTtcbiAgdGhpcy5iZWdpbkRyYWdfKG1vdXNlU1ZHUG9zaXRpb24pO1xuXG4gIC8vIFN0b3AgYnJvd3NlciBmcm9tIGF0dGVtcHRpbmcgdG8gZHJhZyB0aGUgdHJhY2suXG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBTdGFydCBkcmFnZ2luZyB0aGUgc2xpZGVyIGtub2IuXG4gKiBAcGFyYW0geyFPYmplY3R9IG1vdXNlU3RhcnRTVkcgTW91c2Ugc3RhcnQgcG9zaXRpb24gaW4gU1ZHIHNwYWNlXG4gKiBAcHJpdmF0ZVxuICovXG5TbGlkZXIucHJvdG90eXBlLmJlZ2luRHJhZ18gPSBmdW5jdGlvbihzdGFydE1vdXNlU1ZHKSB7XG4gIFNsaWRlci5hY3RpdmVTbGlkZXJfID0gdGhpcztcbiAgU2xpZGVyLnN0YXJ0TW91c2VYXyA9IHN0YXJ0TW91c2VTVkcueDtcbiAgU2xpZGVyLnN0YXJ0S25vYlhfID0gMDtcbiAgdmFyIHRyYW5zZm9ybSA9IHRoaXMua25vYl8uZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKTtcbiAgaWYgKHRyYW5zZm9ybSkge1xuICAgIHZhciByID0gdHJhbnNmb3JtLm1hdGNoKC90cmFuc2xhdGVcXChcXHMqKFstXFxkLl0rKS8pO1xuICAgIGlmIChyKSB7XG4gICAgICBTbGlkZXIuc3RhcnRLbm9iWF8gPSBOdW1iZXIoclsxXSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFNuYXAgdGhlIHNsaWRlciBrbm9iIHRvIHRoZSBjbGlja2VkIHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHhQb3NpdGlvbiBTVkcgeC1jb29yZGluYXRlXG4gKiBAcHJpdmF0ZVxuICovXG5TbGlkZXIucHJvdG90eXBlLnNuYXBUb1Bvc2l0aW9uXyA9IGZ1bmN0aW9uKHhQb3NpdGlvbikge1xuICB2YXIgeCA9IE1hdGgubWluKE1hdGgubWF4KHhQb3NpdGlvbiwgXG4gICAgICAgIHRoaXMuS05PQl9NSU5fWF8pLCB0aGlzLktOT0JfTUFYX1hfKTtcbiAgdGhpcy5rbm9iXy5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsXG4gICAgICAndHJhbnNsYXRlKCcgKyB4ICsgJywnICsgdGhpcy5LTk9CX1lfICsgJyknKTtcblxuICB0aGlzLnZhbHVlXyA9ICh4IC0gdGhpcy5LTk9CX01JTl9YXykgL1xuICAgICAgKHRoaXMuS05PQl9NQVhfWF8gLSB0aGlzLktOT0JfTUlOX1hfKTtcbiAgaWYgKHRoaXMuY2hhbmdlRnVuY18pIHtcbiAgICB0aGlzLmNoYW5nZUZ1bmNfKHRoaXMudmFsdWVfKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdG9wIGEgZHJhZyB3aGVuIGNsaWNraW5nIHVwIGFueXdoZXJlLlxuICogQHBhcmFtIHtFdmVudH0gZSBNb3VzZS11cCBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cblNsaWRlci5rbm9iTW91c2VVcF8gPSBmdW5jdGlvbihlKSB7XG4gIFNsaWRlci5hY3RpdmVTbGlkZXJfID0gbnVsbDtcbn07XG5cbi8qKlxuICogU3RvcCBhIGRyYWcgd2hlbiB0aGUgbW91c2UgZW50ZXJzIGEgbm9kZSBub3QgcGFydCBvZiB0aGUgU1ZHLlxuICogQHBhcmFtIHtFdmVudH0gZSBNb3VzZS11cCBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cblNsaWRlci5tb3VzZU92ZXJfID0gZnVuY3Rpb24oZSkge1xuICBpZiAoIVNsaWRlci5hY3RpdmVTbGlkZXJfKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIEZpbmQgdGhlIHJvb3QgU1ZHIG9iamVjdC5cbiAgZm9yICh2YXIgbm9kZSA9IGUudGFyZ2V0OyBub2RlOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgaWYgKG5vZGUgPT0gU2xpZGVyLmFjdGl2ZVNsaWRlcl8uU1ZHXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBTbGlkZXIua25vYk1vdXNlVXBfKGUpO1xufTtcblxuLyoqXG4gKiBEcmFnIHRoZSBrbm9iIHRvIGZvbGxvdyB0aGUgbW91c2UuXG4gKiBAcGFyYW0geyFFdmVudH0gZSBNb3VzZS1tb3ZlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuU2xpZGVyLmtub2JNb3VzZU1vdmVfID0gZnVuY3Rpb24oZSkge1xuICB2YXIgdGhpc1NsaWRlciA9IFNsaWRlci5hY3RpdmVTbGlkZXJfO1xuICBpZiAoIXRoaXNTbGlkZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHggPSB0aGlzU2xpZGVyLm1vdXNlVG9TdmdfKGUpLnggLSBTbGlkZXIuc3RhcnRNb3VzZVhfICtcbiAgICAgIFNsaWRlci5zdGFydEtub2JYXztcbiAgdGhpc1NsaWRlci5zbmFwVG9Qb3NpdGlvbl8oeCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHNsaWRlcidzIHZhbHVlICgwLjAgLSAxLjApLlxuICogQHJldHVybiB7bnVtYmVyfSBDdXJyZW50IHZhbHVlLlxuICovXG5TbGlkZXIucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnZhbHVlXztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgc2xpZGVyJ3MgdmFsdWUgKDAuMCAtIDEuMCkuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgTmV3IHZhbHVlLlxuICovXG5TbGlkZXIucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy52YWx1ZV8gPSBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgMCksIDEpO1xuICB2YXIgeCA9IHRoaXMuS05PQl9NSU5fWF8gK1xuICAgICAgKHRoaXMuS05PQl9NQVhfWF8gLSB0aGlzLktOT0JfTUlOX1hfKSAqIHRoaXMudmFsdWVfO1xuICB0aGlzLmtub2JfLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyxcbiAgICAgICd0cmFuc2xhdGUoJyArIHggKyAnLCcgKyB0aGlzLktOT0JfWV8gKyAnKScpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBtb3VzZSBjb29yZGluYXRlcyBpbnRvIFNWRyBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7IU9iamVjdH0gZSBPYmplY3Qgd2l0aCB4IGFuZCB5IG1vdXNlIGNvb3JkaW5hdGVzLlxuICogQHJldHVybiB7IU9iamVjdH0gT2JqZWN0IHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzIGluIFNWRyBjb29yZGluYXRlcy5cbiAqIEBwcml2YXRlXG4gKi9cblNsaWRlci5wcm90b3R5cGUubW91c2VUb1N2Z18gPSBmdW5jdGlvbihlKSB7XG4gIHZhciBzdmdQb2ludCA9IHRoaXMuU1ZHXy5jcmVhdGVTVkdQb2ludCgpO1xuICAvLyBNb3N0IGJyb3dzZXJzIHByb3ZpZGUgY2xpZW50WC9ZLiBpT1Mgb25seSBwcm92aWRlcyBwYWdlWC9ZLlxuICAvLyBBbmRyb2lkIENocm9tZSBvbmx5IHByb3ZpZGVzIGNvb3JkaW5hdGVzIHdpdGhpbiBlLmNoYW5nZWRUb3VjaGVzLlxuICBpZiAodGhpcy5pc1dpbmRvd3NUb3VjaF8pIHtcbiAgICAvLyBPbmx5IHNjcmVlblgvWSBwcm9wZXJseSBhY2NvdW50cyBmb3Igem9vbWluZyBpbiBvbiB3aW5kb3dzIHRvdWNoLlxuICAgIHN2Z1BvaW50LnggPSBlLnNjcmVlblg7XG4gICAgc3ZnUG9pbnQueSA9IGUuc2NyZWVuWTtcbiAgfSBlbHNlIGlmICh0aGlzLmlzQW5kcm9pZF8pIHtcbiAgICBzdmdQb2ludC54ID0gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWDtcbiAgICBzdmdQb2ludC55ID0gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcbiAgfSBlbHNlIGlmICh0aGlzLmlzSU9TXykge1xuICAgIHN2Z1BvaW50LnggPSBlLnBhZ2VYO1xuICAgIHN2Z1BvaW50LnkgPSBlLnBhZ2VZO1xuICB9IGVsc2Uge1xuICAgIHN2Z1BvaW50LnggPSBlLmNsaWVudFg7XG4gICAgc3ZnUG9pbnQueSA9IGUuY2xpZW50WTtcbiAgfVxuICB2YXIgbWF0cml4ID0gdGhpcy5TVkdfLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKTtcbiAgcmV0dXJuIHN2Z1BvaW50Lm1hdHJpeFRyYW5zZm9ybShtYXRyaXgpO1xufTtcblxuLyoqXG4gKiBCaW5kIGFuIGV2ZW50IHRvIGEgZnVuY3Rpb24gY2FsbC5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB1cG9uIHdoaWNoIHRvIGxpc3Rlbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEV2ZW50IG5hbWUgdG8gbGlzdGVuIHRvIChlLmcuICdtb3VzZWRvd24nKS5cbiAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBmdW5jIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBldmVudCBpcyB0cmlnZ2VyZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5TbGlkZXIuYmluZEV2ZW50XyA9IGZ1bmN0aW9uKGVsZW1lbnQsIG5hbWUsIGZ1bmMpIHtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmMsIGZhbHNlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2xpZGVyO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbnN0YW50cyB1c2VkIGluIHByb2R1Y3Rpb24gY29kZSBhbmQgdGVzdHMuXG4gKi9cblxuLyoqXG4gKiBFbnVtZXJhdGlvbiBvZiB1c2VyIHByb2dyYW0gZXhlY3V0aW9uIG91dGNvbWVzLlxuICogVGhlc2UgYXJlIGRldGVybWluZWQgYnkgZWFjaCBhcHAuXG4gKi9cbmV4cG9ydHMuUmVzdWx0VHlwZSA9IHtcbiAgVU5TRVQ6IDAsICAgICAgIC8vIFRoZSByZXN1bHQgaGFzIG5vdCB5ZXQgYmVlbiBjb21wdXRlZC5cbiAgU1VDQ0VTUzogMSwgICAgIC8vIFRoZSBwcm9ncmFtIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHksIGFjaGlldmluZyB0aGUgZ29hbC5cbiAgRkFJTFVSRTogLTEsICAgIC8vIFRoZSBwcm9ncmFtIHJhbiB3aXRob3V0IGVycm9yIGJ1dCBkaWQgbm90IGFjaGlldmUgZ29hbC5cbiAgVElNRU9VVDogMiwgICAgIC8vIFRoZSBwcm9ncmFtIGRpZCBub3QgY29tcGxldGUgKGxpa2VseSBpbmZpbml0ZSBsb29wKS5cbiAgRVJST1I6IC0yICAgICAgIC8vIFRoZSBwcm9ncmFtIGdlbmVyYXRlZCBhbiBlcnJvci5cbn07XG5cbi8qKlxuICogRW51bWVyYXRpb24gb2YgdGVzdCByZXN1bHRzLlxuICogRU1QVFlfQkxPQ0tfRkFJTCBhbmQgRU1QVFlfRlVOQ1RJT05fQkxPQ0tfRkFJTCBjYW4gb25seSBvY2N1ciBpZlxuICogU3R1ZGlvQXBwLmNoZWNrRm9yRW1wdHlCbG9ja3NfIGlzIHRydWUuXG4gKiBOT1RFOiBXZSBzdG9yZSB0aGUgcmVzdWx0cyBmb3IgdXNlciBhdHRlbXB0cyBpbiBvdXIgZGIsIHNvIGNoYW5naW5nIHRoZXNlXG4gKiB2YWx1ZXMgd291bGQgbmVjZXNzaXRhdGUgYSBtaWdyYXRpb25cbiAqL1xuZXhwb3J0cy5UZXN0UmVzdWx0cyA9IHtcbiAgLy8gRGVmYXVsdCB2YWx1ZSBiZWZvcmUgYW55IHRlc3RzIGFyZSBydW4uXG4gIE5PX1RFU1RTX1JVTjogLTEsXG5cbiAgLy8gVGhlIGxldmVsIHdhcyBub3Qgc29sdmVkLlxuICBFTVBUWV9CTE9DS19GQUlMOiAxLCAgICAgICAgICAgICAgICAvLyBBbiBcImlmXCIgb3IgXCJyZXBlYXRcIiBibG9jayB3YXMgZW1wdHkuXG4gIFRPT19GRVdfQkxPQ0tTX0ZBSUw6IDIsICAgICAgICAgICAgIC8vIEZld2VyIHRoYW4gdGhlIGlkZWFsIG51bWJlciBvZiBibG9ja3MgdXNlZC5cbiAgTEVWRUxfSU5DT01QTEVURV9GQUlMOiAzLCAgICAgICAgICAgLy8gRGVmYXVsdCBmYWlsdXJlIHRvIGNvbXBsZXRlIGEgbGV2ZWwuXG4gIE1JU1NJTkdfQkxPQ0tfVU5GSU5JU0hFRDogNCwgICAgICAgIC8vIEEgcmVxdWlyZWQgYmxvY2sgd2FzIG5vdCB1c2VkLlxuICBFWFRSQV9UT1BfQkxPQ0tTX0ZBSUw6IDUsICAgICAgICAgICAvLyBUaGVyZSB3YXMgbW9yZSB0aGFuIG9uZSB0b3AtbGV2ZWwgYmxvY2suXG4gIFJVTlRJTUVfRVJST1JfRkFJTDogNiwgICAgICAgICAgICAgIC8vIFRoZXJlIHdhcyBhIHJ1bnRpbWUgZXJyb3IgaW4gdGhlIHByb2dyYW0uXG4gIFNZTlRBWF9FUlJPUl9GQUlMOiA3LCAgICAgICAgICAgICAgIC8vIFRoZXJlIHdhcyBhIHN5bnRheCBlcnJvciBpbiB0aGUgcHJvZ3JhbS5cbiAgTUlTU0lOR19CTE9DS19GSU5JU0hFRDogMTAsICAgICAgICAgLy8gVGhlIGxldmVsIHdhcyBzb2x2ZWQgd2l0aG91dCByZXF1aXJlZCBibG9jay5cbiAgQVBQX1NQRUNJRklDX0ZBSUw6IDExLCAgICAgICAgICAgICAgLy8gQXBwbGljYXRpb24tc3BlY2lmaWMgZmFpbHVyZS5cbiAgRU1QVFlfRlVOQ1RJT05fQkxPQ0tfRkFJTDogMTIsICAgICAgLy8gQSBcImZ1bmN0aW9uXCIgYmxvY2sgd2FzIGVtcHR5XG4gIFVOVVNFRF9QQVJBTTogMTMsICAgICAgICAgICAgICAgICAgIC8vIFBhcmFtIGRlY2xhcmVkIGJ1dCBub3QgdXNlZCBpbiBmdW5jdGlvbi5cbiAgVU5VU0VEX0ZVTkNUSU9OOiAxNCwgICAgICAgICAgICAgICAgLy8gRnVuY3Rpb24gZGVjbGFyZWQgYnV0IG5vdCB1c2VkIGluIHdvcmtzcGFjZS5cbiAgUEFSQU1fSU5QVVRfVU5BVFRBQ0hFRDogMTUsICAgICAgICAgLy8gRnVuY3Rpb24gbm90IGNhbGxlZCB3aXRoIGVub3VnaCBwYXJhbXMuXG4gIElOQ09NUExFVEVfQkxPQ0tfSU5fRlVOQ1RJT046IDE2LCAgIC8vIEluY29tcGxldGUgYmxvY2sgaW5zaWRlIGEgZnVuY3Rpb24uXG4gIFFVRVNUSU9OX01BUktTX0lOX05VTUJFUl9GSUVMRDogMTcsIC8vIEJsb2NrIGhhcyA/Pz8gaW5zdGVhZCBvZiBhIHZhbHVlLlxuICBFTVBUWV9GVU5DVElPTkFMX0JMT0NLOiAxOCwgICAgICAgICAvLyBUaGVyZSdzIGEgZnVuY3Rpb25hbCBibG9jayB3aXRoIGFuIG9wZW4gaW5wdXRcbiAgRVhBTVBMRV9GQUlMRUQ6IDE5LCAgICAgICAgICAgICAgICAgLy8gT25lIG9mIG91ciBleGFtcGxlcyBkaWRuJ3QgbWF0Y2ggdGhlIGRlZmluaXRpb25cblxuICAvLyBzdGFydCB1c2luZyBuZWdhdGl2ZSB2YWx1ZXMsIHNpbmNlIHdlIGNvbnNpZGVyID49IDIwIHRvIGJlIFwic29sdmVkXCJcbiAgTkVTVEVEX0ZPUl9TQU1FX1ZBUklBQkxFOiAtMiwgICAgICAgLy8gV2UgaGF2ZSBuZXN0ZWQgZm9yIGxvb3BzIGVhY2ggdXNpbmcgdGhlIHNhbWUgY291bnRlciB2YXJpYWJsZVxuICAvLyBOT1RFOiBmb3Igc21vZSBwZXJpb2Qgb2YgdGltZSwgdGhpcyB3YXMgLTEgYW5kIGNvbmZsaWN0ZWQgd2l0aCBOT19URVNUU19SVU5cbiAgRU1QVFlfRlVOQ1RJT05fTkFNRTogLTMsICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHZhcmlhYmxlIG9yIGZ1bmN0aW9uIHdpdGggdGhlIG5hbWUgXCJcIlxuICBNSVNTSU5HX1JFQ09NTUVOREVEX0JMT0NLX1VORklOSVNIRUQ6IC00LCAvLyBUaGUgbGV2ZWwgd2FzIGF0dGVtcHRlZCBidXQgbm90IHNvbHZlZCB3aXRob3V0IGEgcmVjb21tZW5kZWQgYmxvY2tcbiAgRVhUUkFfRlVOQ1RJT05fRkFJTDogLTUsICAgICAgICAgICAgLy8gVGhlIHByb2dyYW0gY29udGFpbnMgYSBKYXZhU2NyaXB0IGZ1bmN0aW9uIHdoZW4gaXQgc2hvdWxkIG5vdFxuICBMT0NBTF9GVU5DVElPTl9GQUlMOiAtNiwgICAgICAgICAgICAvLyBUaGUgcHJvZ3JhbSBjb250YWlucyBhbiB1bmV4cGVjdGVkIEphdmFTY3JpcHQgbG9jYWwgZnVuY3Rpb25cblxuICAvLyBUaGUgbGV2ZWwgd2FzIHNvbHZlZCBpbiBhIG5vbi1vcHRpbWFsIHdheS4gIFVzZXIgbWF5IGFkdmFuY2Ugb3IgcmV0cnkuXG4gIFRPT19NQU5ZX0JMT0NLU19GQUlMOiAyMCwgICAgICAgICAgICAgICAvLyBNb3JlIHRoYW4gdGhlIGlkZWFsIG51bWJlciBvZiBibG9ja3Mgd2VyZSB1c2VkLlxuICBBUFBfU1BFQ0lGSUNfQUNDRVBUQUJMRV9GQUlMOiAyMSwgICAgICAgLy8gQXBwbGljYXRpb24tc3BlY2lmaWMgYWNjZXB0YWJsZSBmYWlsdXJlLlxuICBNSVNTSU5HX1JFQ09NTUVOREVEX0JMT0NLX0ZJTklTSEVEOiAyMiwgLy8gVGhlIGxldmVsIHdhcyBzb2x2ZWQgd2l0aG91dCBhIHJlY29tbWVuZGVkIGJsb2NrXG5cbiAgLy8gT3RoZXIuXG4gIEZSRUVfUExBWTogMzAsICAgLy8gVGhlIHVzZXIgaXMgaW4gZnJlZS1wbGF5IG1vZGUuXG4gIEVESVRfQkxPQ0tTOiA3MCwgLy8gVGhlIHVzZXIgaXMgY3JlYXRpbmcvZWRpdGluZyBhIG5ldyBsZXZlbC5cblxuICAvLyBUaGUgbGV2ZWwgd2FzIHNvbHZlZCBpbiB0aGUgaWRlYWwgbWFubmVyLlxuICBBTExfUEFTUzogMTAwXG59O1xuXG5leHBvcnRzLkJlZVRlcm1pbmF0aW9uVmFsdWUgPSB7XG4gIEZBSUxVUkU6IGZhbHNlLFxuICBTVUNDRVNTOiB0cnVlLFxuICBJTkZJTklURV9MT09QOiBJbmZpbml0eSxcbiAgTk9UX0FUX0ZMT1dFUjogMSwgICAgIC8vIFRyaWVkIHRvIGdldCBuZWN0YXIgd2hlbiBub3QgYXQgZmxvd2VyLlxuICBGTE9XRVJfRU1QVFk6IDIsICAgICAgLy8gVHJpZWQgdG8gZ2V0IG5lY3RhciB3aGVuIGZsb3dlciBlbXB0eS5cbiAgTk9UX0FUX0hPTkVZQ09NQjogMywgIC8vIFRyaWVkIHRvIG1ha2UgaG9uZXkgd2hlbiBub3QgYXQgaG9uZXljb21iLlxuICBIT05FWUNPTUJfRlVMTDogNCwgICAgLy8gVHJpZWQgdG8gbWFrZSBob25leSwgYnV0IG5vIHJvb20gYXQgaG9uZXljb21iLlxuICBVTkNIRUNLRURfQ0xPVUQ6IDUsICAgIC8vIEZpbmlzaGVkIHB1enpsZSwgYnV0IGRpZG4ndCBjaGVjayBldmVyeSBjbG91ZGVkIGl0ZW1cbiAgVU5DSEVDS0VEX1BVUlBMRTogNiwgICAvLyBGaW5pc2hlZCBwdXp6bGUsIGJ1dCBkaWRuJ3QgY2hlY2sgZXZlcnkgcHVycGxlIGZsb3dlclxuICBJTlNVRkZJQ0lFTlRfTkVDVEFSOiA3LC8vIERpZG4ndCBjb2xsZWN0IGFsbCBuZWN0YXIgYnkgZmluaXNoXG4gIElOU1VGRklDSUVOVF9IT05FWTogOCwgLy8gRGlkbid0IG1ha2UgYWxsIGhvbmV5IGJ5IGZpbmlzaFxuICBESURfTk9UX0NPTExFQ1RfRVZFUllUSElORzogOSAvLyBGb3IgcXVhbnR1bSBsZXZlbHMsIGRpZG4ndCB0cnkgdG8gY29sbGVjdCBhbGwgYXZhaWxhYmxlIGhvbmV5L25lY3RhclxufTtcblxuZXhwb3J0cy5LZXlDb2RlcyA9IHtcbiAgQkFDS1NQQUNFOiA4LFxuICBFTlRFUjogMTMsXG4gIFNQQUNFOiAzMixcbiAgTEVGVDogMzcsXG4gIFVQOiAzOCxcbiAgUklHSFQ6IDM5LFxuICBET1dOOiA0MCxcbiAgREVMRVRFOiAxMjdcbn07XG5cbi8qKiBAY29uc3Qge3N0cmluZ30gU1ZHIGVsZW1lbnQgbmFtZXNwYWNlICovXG5leHBvcnRzLlNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4iLCIvKiogQGZpbGUgSGVscGVyIGZvciBjb25zdW1pbmcgT2JzZXJ2YWJsZUV2ZW50cy4gKi9cbi8vIFN0cmljdCBsaW50aW5nOiBBYnNvcmIgaW50byBnbG9iYWwgY29uZmlnIHdoZW4gcG9zc2libGVcbi8qIGpzaGludFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG4gbWF4bGVuOiAxMjBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEhlbHBlciBvYmplY3QgZm9yIGNvbnN1bWluZyBPYnNlcnZhYmxlRXZlbnRzLCBkZXNpZ25lZCBmb3IgY29tcG9zaXRpb24gaW50b1xuICogb3RoZXIgY2xhc3Nlcy4gIFJlbWVtYmVycyB3aGF0IGl0J3Mgb2JzZXJ2aW5nIGFuZCBwcm92aWRlcyBzYWZlciB3YXlzIHRvXG4gKiBzdG9wIG9ic2VydmluZyB0aG9zZSB0aGluZ3MuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE9ic2VydmVyID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZSB7QXJyYXkuPE9iamVjdD59IGV2ZW50LWtleSBwYWlycyBvZiBvYnNlcnZlZCBldmVudHMsIGZvciBlYXN5XG4gICAqICAgICAgICAgIHVucmVnaXN0ZXJpbmcgbGF0ZXIuXG4gICAqL1xuICB0aGlzLm9ic2VydmVkXyA9IFtdO1xufTtcblxuLyoqXG4gKiBCZWdpbiBvYnNlcnZpbmcgdGhlIGdpdmVuIGV2ZW50LCBmb3J3YXJkaW5nIGl0IHRvIHRoZSBwcm92aWRlZCBjYWxsYmFja1xuICogd2hlbmV2ZXIgdGhlIGV2ZW50IG9jY3Vycy5cbiAqIEBwYXJhbSB7IU9ic2VydmFibGVFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFja1xuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgdmFyIGtleSA9IGV2ZW50LnJlZ2lzdGVyKGNhbGxiYWNrKTtcbiAgdGhpcy5vYnNlcnZlZF8ucHVzaCh7XG4gICAgZXZlbnQ6IGV2ZW50LFxuICAgIGtleToga2V5XG4gIH0pO1xufTtcblxuLyoqXG4gKiBVbnJlZ2lzdGVyIGFsbCBjYWxsYmFja3MgZnJvbSBhbGwgb2JzZXJ2ZWQgZXZlbnRzLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUudW5vYnNlcnZlQWxsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm9ic2VydmVkXy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZhYmxlKSB7XG4gICAgb2JzZXJ2YWJsZS5ldmVudC51bnJlZ2lzdGVyKG9ic2VydmFibGUua2V5KTtcbiAgfSk7XG4gIHRoaXMub2JzZXJ2ZWRfLmxlbmd0aCA9IDA7XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCcnKTsxOyB2YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7IDsgYnVmLnB1c2goJ1xcblxcbjxkaXYgaWQ9XCJkZWJ1Zy1hcmVhXCI+XFxuICA8ZGl2IGlkPVwiZGVidWdSZXNpemVCYXJcIiBjbGFzcz1cImZhIGZhLWVsbGlwc2lzLWhcIj48L2Rpdj5cXG4gIDxkaXYgaWQ9XCJkZWJ1Zy1hcmVhLWhlYWRlclwiPlxcbiAgICA8c3BhbiBjbGFzcz1cImhlYWRlci10ZXh0XCI+JywgZXNjYXBlKCg2LCAgaTE4bi5kZWJ1Z0NvbnNvbGVIZWFkZXIoKSApKSwgJzwvc3Bhbj5cXG4gICAgPGkgaWQ9XCJzaG93LWhpZGUtZGVidWctaWNvblwiIGNsYXNzPVwiZmEgZmEtY2hldnJvbi1jaXJjbGUtZG93blwiPjwvaT5cXG4gICAgJyk7ODsgaWYgKGRlYnVnQnV0dG9ucykgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgPGRpdiBpZD1cImRlYnVnLWNvbW1hbmRzLWhlYWRlclwiIGNsYXNzPVwid29ya3NwYWNlLWhlYWRlclwiPlxcbiAgICAgIDxpIGlkPVwicnVubmluZy1zcGlubmVyXCIgc3R5bGU9XCJkaXNwbGF5OiBub25lO1wiIGNsYXNzPVwiZmEgZmEtc3Bpbm5lciBmYS1zcGluXCI+PC9pPlxcbiAgICAgIDxpIGlkPVwicGF1c2VkLWljb25cIiBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCIgY2xhc3M9XCJmYSBmYS1wYXVzZVwiPjwvaT5cXG4gICAgICA8c3BhbiBjbGFzcz1cImhlYWRlci10ZXh0XCI+JywgZXNjYXBlKCgxMiwgIGkxOG4uZGVidWdDb21tYW5kc0hlYWRlcldoZW5PcGVuKCkgKSksICc8L3NwYW4+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGlkPVwiY2xlYXItY29uc29sZS1oZWFkZXJcIiBjbGFzcz1cIndvcmtzcGFjZS1oZWFkZXIgd29ya3NwYWNlLWhlYWRlci1idXR0b25cIj48c3Bhbj48aSBjbGFzcz1cImZhIGZhLWVyYXNlclwiPjwvaT5DbGVhcjwvc3Bhbj48L2Rpdj5cXG4gICAgJyk7MTU7IH0gOyBidWYucHVzaCgnXFxuICAgIDxkaXYgaWQ9XCJzbGlkZXItY2VsbFwiIHN0eWxlPVwibWFyZ2luLWxlZnQ6ICcsIGVzY2FwZSgoMTYsICBkZWJ1Z0J1dHRvbnMgPyAwIDogNDAgKSksICdweFwiPlxcbiAgICAgIDxzdmcgaWQ9XCJzcGVlZC1zbGlkZXJcIlxcbiAgICAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXFxuICAgICAgICAgICB4bWxuczpzdmc9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXFxuICAgICAgICAgICB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIlxcbiAgICAgICAgICAgdmVyc2lvbj1cIjEuMVwiXFxuICAgICAgICAgICB3aWR0aD1cIjE1MFwiXFxuICAgICAgICAgICBoZWlnaHQ9XCIyOFwiPlxcbiAgICAgICAgICA8IS0tIFNsb3cgaWNvbi4gLS0+XFxuICAgICAgICAgIDxjbGlwUGF0aCBpZD1cInNsb3dDbGlwUGF0aFwiPlxcbiAgICAgICAgICAgIDxyZWN0IHdpZHRoPTI2IGhlaWdodD0xMiB4PTUgeT02IC8+XFxuICAgICAgICAgIDwvY2xpcFBhdGg+XFxuICAgICAgICAgIDxpbWFnZSB4bGluazpocmVmPVwiJywgZXNjYXBlKCgyOCwgIGFzc2V0VXJsKCdtZWRpYS90dXJ0bGVfaWNvbnMucG5nJykgKSksICdcIiBoZWlnaHQ9NDIgd2lkdGg9ODQgeD0tMjEgeT0tMThcXG4gICAgICAgICAgICAgIGNsaXAtcGF0aD1cInVybCgjc2xvd0NsaXBQYXRoKVwiIC8+XFxuICAgICAgICAgIDwhLS0gRmFzdCBpY29uLiAtLT5cXG4gICAgICAgICAgPGNsaXBQYXRoIGlkPVwiZmFzdENsaXBQYXRoXCI+XFxuICAgICAgICAgICAgPHJlY3Qgd2lkdGg9MjYgaGVpZ2h0PTE2IHg9MTIwIHk9MiAvPlxcbiAgICAgICAgICA8L2NsaXBQYXRoPlxcbiAgICAgICAgICA8aW1hZ2UgeGxpbms6aHJlZj1cIicsIGVzY2FwZSgoMzQsICBhc3NldFVybCgnbWVkaWEvdHVydGxlX2ljb25zLnBuZycpICkpLCAnXCIgaGVpZ2h0PTQyIHdpZHRoPTg0IHg9MTIwIHk9LTE5XFxuICAgICAgICAgICAgICBjbGlwLXBhdGg9XCJ1cmwoI2Zhc3RDbGlwUGF0aClcIiAvPlxcbiAgICAgIDwvc3ZnPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcblxcbiAgJyk7NDA7IGlmIChkZWJ1Z0J1dHRvbnMpIHsgOyBidWYucHVzaCgnXFxuICA8ZGl2IGlkPVwiZGVidWctY29tbWFuZHNcIiBjbGFzcz1cImRlYnVnLWNvbW1hbmRzXCI+XFxuICAgIDxkaXYgaWQ9XCJkZWJ1Zy1idXR0b25zXCI+XFxuICAgICAgPGJ1dHRvbiBpZD1cInBhdXNlQnV0dG9uXCIgY2xhc3M9XCJkZWJ1Z2dlcl9idXR0b25cIj5cXG4gICAgICAgIDxpbWcgc3JjPVwiJywgZXNjYXBlKCg0NCwgIGFzc2V0VXJsKCdtZWRpYS8xeDEuZ2lmJykgKSksICdcIiBjbGFzcz1cInBhdXNlLWJ0biBpY29uMjFcIj5cXG4gICAgICAgICcsIGVzY2FwZSgoNDUsICBpMThuLnBhdXNlKCkgKSksICdcXG4gICAgICA8L2J1dHRvbj5cXG4gICAgICA8YnV0dG9uIGlkPVwiY29udGludWVCdXR0b25cIiBjbGFzcz1cImRlYnVnZ2VyX2J1dHRvblwiPlxcbiAgICAgICAgPGltZyBzcmM9XCInLCBlc2NhcGUoKDQ4LCAgYXNzZXRVcmwoJ21lZGlhLzF4MS5naWYnKSApKSwgJ1wiIGNsYXNzPVwiY29udGludWUtYnRuIGljb24yMVwiPlxcbiAgICAgICAgJywgZXNjYXBlKCg0OSwgIGkxOG4uY29udGludWUoKSApKSwgJ1xcbiAgICAgIDwvYnV0dG9uPlxcbiAgICAgIDxidXR0b24gaWQ9XCJzdGVwT3ZlckJ1dHRvblwiIGNsYXNzPVwiZGVidWdnZXJfYnV0dG9uXCI+XFxuICAgICAgICA8aW1nIHNyYz1cIicsIGVzY2FwZSgoNTIsICBhc3NldFVybCgnbWVkaWEvMXgxLmdpZicpICkpLCAnXCIgY2xhc3M9XCJzdGVwLW92ZXItYnRuIGljb24yMVwiPlxcbiAgICAgICAgJywgZXNjYXBlKCg1MywgIGkxOG4uc3RlcE92ZXIoKSApKSwgJ1xcbiAgICAgIDwvYnV0dG9uPlxcbiAgICAgIDxidXR0b24gaWQ9XCJzdGVwT3V0QnV0dG9uXCIgY2xhc3M9XCJkZWJ1Z2dlcl9idXR0b25cIj5cXG4gICAgICAgIDxpbWcgc3JjPVwiJywgZXNjYXBlKCg1NiwgIGFzc2V0VXJsKCdtZWRpYS8xeDEuZ2lmJykgKSksICdcIiBjbGFzcz1cInN0ZXAtb3V0LWJ0biBpY29uMjFcIj5cXG4gICAgICAgICcsIGVzY2FwZSgoNTcsICBpMThuLnN0ZXBPdXQoKSApKSwgJ1xcbiAgICAgIDwvYnV0dG9uPlxcbiAgICAgIDxidXR0b24gaWQ9XCJzdGVwSW5CdXR0b25cIiBjbGFzcz1cImRlYnVnZ2VyX2J1dHRvblwiPlxcbiAgICAgICAgPGltZyBzcmM9XCInLCBlc2NhcGUoKDYwLCAgYXNzZXRVcmwoJ21lZGlhLzF4MS5naWYnKSApKSwgJ1wiIGNsYXNzPVwic3RlcC1pbi1idG4gaWNvbjIxXCI+XFxuICAgICAgICAnLCBlc2NhcGUoKDYxLCAgaTE4bi5zdGVwSW4oKSApKSwgJ1xcbiAgICAgIDwvYnV0dG9uPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbiAgJyk7NjU7IH0gOyBidWYucHVzaCgnXFxuICAnKTs2NjsgaWYgKGRlYnVnQ29uc29sZSkgeyA7IGJ1Zi5wdXNoKCdcXG4gIDxkaXYgaWQ9XCJkZWJ1Zy1jb25zb2xlXCIgY2xhc3M9XCJkZWJ1Zy1jb25zb2xlICcsIGVzY2FwZSgoNjcsICBkZWJ1Z0J1dHRvbnMgPyAnJyA6ICdmdWxsJyApKSwgJ1wiPlxcbiAgICA8ZGl2IGlkPVwiZGVidWctb3V0cHV0XCIgY2xhc3M9XCJkZWJ1Zy1vdXRwdXRcIj48L2Rpdj5cXG4gICAgPHNwYW4gY2xhc3M9XCJkZWJ1Zy1pbnB1dC1wcm9tcHRcIj5cXG4gICAgICAmZ3Q7XFxuICAgIDwvc3Bhbj5cXG4gICAgPGRpdiBjb250ZW50ZWRpdGFibGUgc3BlbGxjaGVjaz1cImZhbHNlXCIgaWQ9XCJkZWJ1Zy1pbnB1dFwiIGNsYXNzPVwiZGVidWctaW5wdXRcIj48L2Rpdj5cXG4gIDwvZGl2PlxcbiAgJyk7NzQ7IH0gOyBidWYucHVzaCgnXFxuPC9kaXY+XFxuJyk7IH0pKCk7XG59IFxucmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG4gIHJldHVybiBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICByZXR1cm4gdChsb2NhbHMsIHJlcXVpcmUoXCJlanNcIikuZmlsdGVycyk7XG4gIH1cbn0oKSk7IiwiXG4vKiFcbiAqIEVKU1xuICogQ29weXJpZ2h0KGMpIDIwMTIgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcbiAgLCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG4gICwgYmFzZW5hbWUgPSBwYXRoLmJhc2VuYW1lXG4gICwgZGlybmFtZSA9IHBhdGguZGlybmFtZVxuICAsIGV4dG5hbWUgPSBwYXRoLmV4dG5hbWVcbiAgLCBqb2luID0gcGF0aC5qb2luXG4gICwgZnMgPSByZXF1aXJlKCdmcycpXG4gICwgcmVhZCA9IGZzLnJlYWRGaWxlU3luYztcblxuLyoqXG4gKiBGaWx0ZXJzLlxuICpcbiAqIEB0eXBlIE9iamVjdFxuICovXG5cbnZhciBmaWx0ZXJzID0gZXhwb3J0cy5maWx0ZXJzID0gcmVxdWlyZSgnLi9maWx0ZXJzJyk7XG5cbi8qKlxuICogSW50ZXJtZWRpYXRlIGpzIGNhY2hlLlxuICpcbiAqIEB0eXBlIE9iamVjdFxuICovXG5cbnZhciBjYWNoZSA9IHt9O1xuXG4vKipcbiAqIENsZWFyIGludGVybWVkaWF0ZSBqcyBjYWNoZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uKCl7XG4gIGNhY2hlID0ge307XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZSBmaWx0ZXJlZCBjb2RlIGludG8gZnVuY3Rpb24gY2FsbHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGpzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmaWx0ZXJlZChqcykge1xuICByZXR1cm4ganMuc3Vic3RyKDEpLnNwbGl0KCd8JykucmVkdWNlKGZ1bmN0aW9uKGpzLCBmaWx0ZXIpe1xuICAgIHZhciBwYXJ0cyA9IGZpbHRlci5zcGxpdCgnOicpXG4gICAgICAsIG5hbWUgPSBwYXJ0cy5zaGlmdCgpXG4gICAgICAsIGFyZ3MgPSBwYXJ0cy5qb2luKCc6JykgfHwgJyc7XG4gICAgaWYgKGFyZ3MpIGFyZ3MgPSAnLCAnICsgYXJncztcbiAgICByZXR1cm4gJ2ZpbHRlcnMuJyArIG5hbWUgKyAnKCcgKyBqcyArIGFyZ3MgKyAnKSc7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZS10aHJvdyB0aGUgZ2l2ZW4gYGVycmAgaW4gY29udGV4dCB0byB0aGVcbiAqIGBzdHJgIG9mIGVqcywgYGZpbGVuYW1lYCwgYW5kIGBsaW5lbm9gLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbGluZW5vXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiByZXRocm93KGVyciwgc3RyLCBmaWxlbmFtZSwgbGluZW5vKXtcbiAgdmFyIGxpbmVzID0gc3RyLnNwbGl0KCdcXG4nKVxuICAgICwgc3RhcnQgPSBNYXRoLm1heChsaW5lbm8gLSAzLCAwKVxuICAgICwgZW5kID0gTWF0aC5taW4obGluZXMubGVuZ3RoLCBsaW5lbm8gKyAzKTtcblxuICAvLyBFcnJvciBjb250ZXh0XG4gIHZhciBjb250ZXh0ID0gbGluZXMuc2xpY2Uoc3RhcnQsIGVuZCkubWFwKGZ1bmN0aW9uKGxpbmUsIGkpe1xuICAgIHZhciBjdXJyID0gaSArIHN0YXJ0ICsgMTtcbiAgICByZXR1cm4gKGN1cnIgPT0gbGluZW5vID8gJyA+PiAnIDogJyAgICAnKVxuICAgICAgKyBjdXJyXG4gICAgICArICd8ICdcbiAgICAgICsgbGluZTtcbiAgfSkuam9pbignXFxuJyk7XG5cbiAgLy8gQWx0ZXIgZXhjZXB0aW9uIG1lc3NhZ2VcbiAgZXJyLnBhdGggPSBmaWxlbmFtZTtcbiAgZXJyLm1lc3NhZ2UgPSAoZmlsZW5hbWUgfHwgJ2VqcycpICsgJzonXG4gICAgKyBsaW5lbm8gKyAnXFxuJ1xuICAgICsgY29udGV4dCArICdcXG5cXG4nXG4gICAgKyBlcnIubWVzc2FnZTtcbiAgXG4gIHRocm93IGVycjtcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgb2YgZWpzLCByZXR1cm5pbmcgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG52YXIgcGFyc2UgPSBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24oc3RyLCBvcHRpb25zKXtcbiAgdmFyIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgLCBvcGVuID0gb3B0aW9ucy5vcGVuIHx8IGV4cG9ydHMub3BlbiB8fCAnPCUnXG4gICAgLCBjbG9zZSA9IG9wdGlvbnMuY2xvc2UgfHwgZXhwb3J0cy5jbG9zZSB8fCAnJT4nXG4gICAgLCBmaWxlbmFtZSA9IG9wdGlvbnMuZmlsZW5hbWVcbiAgICAsIGNvbXBpbGVEZWJ1ZyA9IG9wdGlvbnMuY29tcGlsZURlYnVnICE9PSBmYWxzZVxuICAgICwgYnVmID0gW107XG5cbiAgYnVmLnB1c2goJ3ZhciBidWYgPSBbXTsnKTtcbiAgaWYgKGZhbHNlICE9PSBvcHRpb25zLl93aXRoKSBidWYucHVzaCgnXFxud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyAnKTtcbiAgYnVmLnB1c2goJ1xcbiBidWYucHVzaChcXCcnKTtcblxuICB2YXIgbGluZW5vID0gMTtcblxuICB2YXIgY29uc3VtZUVPTCA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHN0ci5zbGljZShpLCBvcGVuLmxlbmd0aCArIGkpID09IG9wZW4pIHtcbiAgICAgIGkgKz0gb3Blbi5sZW5ndGhcbiAgXG4gICAgICB2YXIgcHJlZml4LCBwb3N0Zml4LCBsaW5lID0gKGNvbXBpbGVEZWJ1ZyA/ICdfX3N0YWNrLmxpbmVubz0nIDogJycpICsgbGluZW5vO1xuICAgICAgc3dpdGNoIChzdHIuc3Vic3RyKGksIDEpKSB7XG4gICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgIHByZWZpeCA9IFwiJywgZXNjYXBlKChcIiArIGxpbmUgKyAnLCAnO1xuICAgICAgICAgIHBvc3RmaXggPSBcIikpLCAnXCI7XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICBwcmVmaXggPSBcIicsIChcIiArIGxpbmUgKyAnLCAnO1xuICAgICAgICAgIHBvc3RmaXggPSBcIiksICdcIjtcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHJlZml4ID0gXCInKTtcIiArIGxpbmUgKyAnOyc7XG4gICAgICAgICAgcG9zdGZpeCA9IFwiOyBidWYucHVzaCgnXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbmQgPSBzdHIuaW5kZXhPZihjbG9zZSwgaSlcbiAgICAgICAgLCBqcyA9IHN0ci5zdWJzdHJpbmcoaSwgZW5kKVxuICAgICAgICAsIHN0YXJ0ID0gaVxuICAgICAgICAsIGluY2x1ZGUgPSBudWxsXG4gICAgICAgICwgbiA9IDA7XG5cbiAgICAgIGlmICgnLScgPT0ganNbanMubGVuZ3RoLTFdKXtcbiAgICAgICAganMgPSBqcy5zdWJzdHJpbmcoMCwganMubGVuZ3RoIC0gMik7XG4gICAgICAgIGNvbnN1bWVFT0wgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoMCA9PSBqcy50cmltKCkuaW5kZXhPZignaW5jbHVkZScpKSB7XG4gICAgICAgIHZhciBuYW1lID0ganMudHJpbSgpLnNsaWNlKDcpLnRyaW0oKTtcbiAgICAgICAgaWYgKCFmaWxlbmFtZSkgdGhyb3cgbmV3IEVycm9yKCdmaWxlbmFtZSBvcHRpb24gaXMgcmVxdWlyZWQgZm9yIGluY2x1ZGVzJyk7XG4gICAgICAgIHZhciBwYXRoID0gcmVzb2x2ZUluY2x1ZGUobmFtZSwgZmlsZW5hbWUpO1xuICAgICAgICBpbmNsdWRlID0gcmVhZChwYXRoLCAndXRmOCcpO1xuICAgICAgICBpbmNsdWRlID0gZXhwb3J0cy5wYXJzZShpbmNsdWRlLCB7IGZpbGVuYW1lOiBwYXRoLCBfd2l0aDogZmFsc2UsIG9wZW46IG9wZW4sIGNsb3NlOiBjbG9zZSwgY29tcGlsZURlYnVnOiBjb21waWxlRGVidWcgfSk7XG4gICAgICAgIGJ1Zi5wdXNoKFwiJyArIChmdW5jdGlvbigpe1wiICsgaW5jbHVkZSArIFwifSkoKSArICdcIik7XG4gICAgICAgIGpzID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh+KG4gPSBqcy5pbmRleE9mKFwiXFxuXCIsIG4pKSkgbisrLCBsaW5lbm8rKztcbiAgICAgIGlmIChqcy5zdWJzdHIoMCwgMSkgPT0gJzonKSBqcyA9IGZpbHRlcmVkKGpzKTtcbiAgICAgIGlmIChqcykge1xuICAgICAgICBpZiAoanMubGFzdEluZGV4T2YoJy8vJykgPiBqcy5sYXN0SW5kZXhPZignXFxuJykpIGpzICs9ICdcXG4nO1xuICAgICAgICBidWYucHVzaChwcmVmaXgsIGpzLCBwb3N0Zml4KTtcbiAgICAgIH1cbiAgICAgIGkgKz0gZW5kIC0gc3RhcnQgKyBjbG9zZS5sZW5ndGggLSAxO1xuXG4gICAgfSBlbHNlIGlmIChzdHIuc3Vic3RyKGksIDEpID09IFwiXFxcXFwiKSB7XG4gICAgICBidWYucHVzaChcIlxcXFxcXFxcXCIpO1xuICAgIH0gZWxzZSBpZiAoc3RyLnN1YnN0cihpLCAxKSA9PSBcIidcIikge1xuICAgICAgYnVmLnB1c2goXCJcXFxcJ1wiKTtcbiAgICB9IGVsc2UgaWYgKHN0ci5zdWJzdHIoaSwgMSkgPT0gXCJcXHJcIikge1xuICAgICAgLy8gaWdub3JlXG4gICAgfSBlbHNlIGlmIChzdHIuc3Vic3RyKGksIDEpID09IFwiXFxuXCIpIHtcbiAgICAgIGlmIChjb25zdW1lRU9MKSB7XG4gICAgICAgIGNvbnN1bWVFT0wgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1Zi5wdXNoKFwiXFxcXG5cIik7XG4gICAgICAgIGxpbmVubysrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYucHVzaChzdHIuc3Vic3RyKGksIDEpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZmFsc2UgIT09IG9wdGlvbnMuX3dpdGgpIGJ1Zi5wdXNoKFwiJyk7IH0pKCk7XFxufSBcXG5yZXR1cm4gYnVmLmpvaW4oJycpO1wiKVxuICBlbHNlIGJ1Zi5wdXNoKFwiJyk7XFxucmV0dXJuIGJ1Zi5qb2luKCcnKTtcIik7XG5cbiAgcmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgZ2l2ZW4gYHN0cmAgb2YgZWpzIGludG8gYSBgRnVuY3Rpb25gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIGNvbXBpbGUgPSBleHBvcnRzLmNvbXBpbGUgPSBmdW5jdGlvbihzdHIsIG9wdGlvbnMpe1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGVzY2FwZSA9IG9wdGlvbnMuZXNjYXBlIHx8IHV0aWxzLmVzY2FwZTtcbiAgXG4gIHZhciBpbnB1dCA9IEpTT04uc3RyaW5naWZ5KHN0cilcbiAgICAsIGNvbXBpbGVEZWJ1ZyA9IG9wdGlvbnMuY29tcGlsZURlYnVnICE9PSBmYWxzZVxuICAgICwgY2xpZW50ID0gb3B0aW9ucy5jbGllbnRcbiAgICAsIGZpbGVuYW1lID0gb3B0aW9ucy5maWxlbmFtZVxuICAgICAgICA/IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuZmlsZW5hbWUpXG4gICAgICAgIDogJ3VuZGVmaW5lZCc7XG4gIFxuICBpZiAoY29tcGlsZURlYnVnKSB7XG4gICAgLy8gQWRkcyB0aGUgZmFuY3kgc3RhY2sgdHJhY2UgbWV0YSBpbmZvXG4gICAgc3RyID0gW1xuICAgICAgJ3ZhciBfX3N0YWNrID0geyBsaW5lbm86IDEsIGlucHV0OiAnICsgaW5wdXQgKyAnLCBmaWxlbmFtZTogJyArIGZpbGVuYW1lICsgJyB9OycsXG4gICAgICByZXRocm93LnRvU3RyaW5nKCksXG4gICAgICAndHJ5IHsnLFxuICAgICAgZXhwb3J0cy5wYXJzZShzdHIsIG9wdGlvbnMpLFxuICAgICAgJ30gY2F0Y2ggKGVycikgeycsXG4gICAgICAnICByZXRocm93KGVyciwgX19zdGFjay5pbnB1dCwgX19zdGFjay5maWxlbmFtZSwgX19zdGFjay5saW5lbm8pOycsXG4gICAgICAnfSdcbiAgICBdLmpvaW4oXCJcXG5cIik7XG4gIH0gZWxzZSB7XG4gICAgc3RyID0gZXhwb3J0cy5wYXJzZShzdHIsIG9wdGlvbnMpO1xuICB9XG4gIFxuICBpZiAob3B0aW9ucy5kZWJ1ZykgY29uc29sZS5sb2coc3RyKTtcbiAgaWYgKGNsaWVudCkgc3RyID0gJ2VzY2FwZSA9IGVzY2FwZSB8fCAnICsgZXNjYXBlLnRvU3RyaW5nKCkgKyAnO1xcbicgKyBzdHI7XG5cbiAgdHJ5IHtcbiAgICB2YXIgZm4gPSBuZXcgRnVuY3Rpb24oJ2xvY2FscywgZmlsdGVycywgZXNjYXBlJywgc3RyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKCdTeW50YXhFcnJvcicgPT0gZXJyLm5hbWUpIHtcbiAgICAgIGVyci5tZXNzYWdlICs9IG9wdGlvbnMuZmlsZW5hbWVcbiAgICAgICAgPyAnIGluICcgKyBmaWxlbmFtZVxuICAgICAgICA6ICcgd2hpbGUgY29tcGlsaW5nIGVqcyc7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIGlmIChjbGllbnQpIHJldHVybiBmbjtcblxuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKXtcbiAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBsb2NhbHMsIGZpbHRlcnMsIGVzY2FwZSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVuZGVyIHRoZSBnaXZlbiBgc3RyYCBvZiBlanMuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgIC0gYGxvY2Fsc2AgICAgICAgICAgTG9jYWwgdmFyaWFibGVzIG9iamVjdFxuICogICAtIGBjYWNoZWAgICAgICAgICAgIENvbXBpbGVkIGZ1bmN0aW9ucyBhcmUgY2FjaGVkLCByZXF1aXJlcyBgZmlsZW5hbWVgXG4gKiAgIC0gYGZpbGVuYW1lYCAgICAgICAgVXNlZCBieSBgY2FjaGVgIHRvIGtleSBjYWNoZXNcbiAqICAgLSBgc2NvcGVgICAgICAgICAgICBGdW5jdGlvbiBleGVjdXRpb24gY29udGV4dFxuICogICAtIGBkZWJ1Z2AgICAgICAgICAgIE91dHB1dCBnZW5lcmF0ZWQgZnVuY3Rpb24gYm9keVxuICogICAtIGBvcGVuYCAgICAgICAgICAgIE9wZW4gdGFnLCBkZWZhdWx0aW5nIHRvIFwiPCVcIlxuICogICAtIGBjbG9zZWAgICAgICAgICAgIENsb3NpbmcgdGFnLCBkZWZhdWx0aW5nIHRvIFwiJT5cIlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucmVuZGVyID0gZnVuY3Rpb24oc3RyLCBvcHRpb25zKXtcbiAgdmFyIGZuXG4gICAgLCBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAob3B0aW9ucy5jYWNoZSkge1xuICAgIGlmIChvcHRpb25zLmZpbGVuYW1lKSB7XG4gICAgICBmbiA9IGNhY2hlW29wdGlvbnMuZmlsZW5hbWVdIHx8IChjYWNoZVtvcHRpb25zLmZpbGVuYW1lXSA9IGNvbXBpbGUoc3RyLCBvcHRpb25zKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJjYWNoZVwiIG9wdGlvbiByZXF1aXJlcyBcImZpbGVuYW1lXCIuJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZuID0gY29tcGlsZShzdHIsIG9wdGlvbnMpO1xuICB9XG5cbiAgb3B0aW9ucy5fX3Byb3RvX18gPSBvcHRpb25zLmxvY2FscztcbiAgcmV0dXJuIGZuLmNhbGwob3B0aW9ucy5zY29wZSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFJlbmRlciBhbiBFSlMgZmlsZSBhdCB0aGUgZ2l2ZW4gYHBhdGhgIGFuZCBjYWxsYmFjayBgZm4oZXJyLCBzdHIpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IG9wdGlvbnMgb3IgY2FsbGJhY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucmVuZGVyRmlsZSA9IGZ1bmN0aW9uKHBhdGgsIG9wdGlvbnMsIGZuKXtcbiAgdmFyIGtleSA9IHBhdGggKyAnOnN0cmluZyc7XG5cbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICBmbiA9IG9wdGlvbnMsIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIG9wdGlvbnMuZmlsZW5hbWUgPSBwYXRoO1xuXG4gIHZhciBzdHI7XG4gIHRyeSB7XG4gICAgc3RyID0gb3B0aW9ucy5jYWNoZVxuICAgICAgPyBjYWNoZVtrZXldIHx8IChjYWNoZVtrZXldID0gcmVhZChwYXRoLCAndXRmOCcpKVxuICAgICAgOiByZWFkKHBhdGgsICd1dGY4Jyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGZuKGVycik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZuKG51bGwsIGV4cG9ydHMucmVuZGVyKHN0ciwgb3B0aW9ucykpO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlIGluY2x1ZGUgYG5hbWVgIHJlbGF0aXZlIHRvIGBmaWxlbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZVxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcmVzb2x2ZUluY2x1ZGUobmFtZSwgZmlsZW5hbWUpIHtcbiAgdmFyIHBhdGggPSBqb2luKGRpcm5hbWUoZmlsZW5hbWUpLCBuYW1lKTtcbiAgdmFyIGV4dCA9IGV4dG5hbWUobmFtZSk7XG4gIGlmICghZXh0KSBwYXRoICs9ICcuZWpzJztcbiAgcmV0dXJuIHBhdGg7XG59XG5cbi8vIGV4cHJlc3Mgc3VwcG9ydFxuXG5leHBvcnRzLl9fZXhwcmVzcyA9IGV4cG9ydHMucmVuZGVyRmlsZTtcblxuLyoqXG4gKiBFeHBvc2UgdG8gcmVxdWlyZSgpLlxuICovXG5cbmlmIChyZXF1aXJlLmV4dGVuc2lvbnMpIHtcbiAgcmVxdWlyZS5leHRlbnNpb25zWycuZWpzJ10gPSBmdW5jdGlvbihtb2R1bGUsIGZpbGVuYW1lKSB7XG4gICAgc291cmNlID0gcmVxdWlyZSgnZnMnKS5yZWFkRmlsZVN5bmMoZmlsZW5hbWUsICd1dGYtOCcpO1xuICAgIG1vZHVsZS5fY29tcGlsZShjb21waWxlKHNvdXJjZSwge30pLCBmaWxlbmFtZSk7XG4gIH07XG59IGVsc2UgaWYgKHJlcXVpcmUucmVnaXN0ZXJFeHRlbnNpb24pIHtcbiAgcmVxdWlyZS5yZWdpc3RlckV4dGVuc2lvbignLmVqcycsIGZ1bmN0aW9uKHNyYykge1xuICAgIHJldHVybiBjb21waWxlKHNyYywge30pO1xuICB9KTtcbn1cbiIsIlxuLyohXG4gKiBFSlNcbiAqIENvcHlyaWdodChjKSAyMDEwIFRKIEhvbG93YXljaHVrIDx0akB2aXNpb24tbWVkaWEuY2E+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqIEVzY2FwZSB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGBodG1sYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lc2NhcGUgPSBmdW5jdGlvbihodG1sKXtcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxuICAgIC5yZXBsYWNlKC8mKD8hXFx3KzspL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufTtcbiAiLCJcbi8qIVxuICogRUpTIC0gRmlsdGVyc1xuICogQ29weXJpZ2h0KGMpIDIwMTAgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogRmlyc3QgZWxlbWVudCBvZiB0aGUgdGFyZ2V0IGBvYmpgLlxuICovXG5cbmV4cG9ydHMuZmlyc3QgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9ialswXTtcbn07XG5cbi8qKlxuICogTGFzdCBlbGVtZW50IG9mIHRoZSB0YXJnZXQgYG9iamAuXG4gKi9cblxuZXhwb3J0cy5sYXN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmpbb2JqLmxlbmd0aCAtIDFdO1xufTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIHRoZSBmaXJzdCBsZXR0ZXIgb2YgdGhlIHRhcmdldCBgc3RyYC5cbiAqL1xuXG5leHBvcnRzLmNhcGl0YWxpemUgPSBmdW5jdGlvbihzdHIpe1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgcmV0dXJuIHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cigxLCBzdHIubGVuZ3RoKTtcbn07XG5cbi8qKlxuICogRG93bmNhc2UgdGhlIHRhcmdldCBgc3RyYC5cbiAqL1xuXG5leHBvcnRzLmRvd25jYXNlID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIFN0cmluZyhzdHIpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG4vKipcbiAqIFVwcGVyY2FzZSB0aGUgdGFyZ2V0IGBzdHJgLlxuICovXG5cbmV4cG9ydHMudXBjYXNlID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIFN0cmluZyhzdHIpLnRvVXBwZXJDYXNlKCk7XG59O1xuXG4vKipcbiAqIFNvcnQgdGhlIHRhcmdldCBgb2JqYC5cbiAqL1xuXG5leHBvcnRzLnNvcnQgPSBmdW5jdGlvbihvYmope1xuICByZXR1cm4gT2JqZWN0LmNyZWF0ZShvYmopLnNvcnQoKTtcbn07XG5cbi8qKlxuICogU29ydCB0aGUgdGFyZ2V0IGBvYmpgIGJ5IHRoZSBnaXZlbiBgcHJvcGAgYXNjZW5kaW5nLlxuICovXG5cbmV4cG9ydHMuc29ydF9ieSA9IGZ1bmN0aW9uKG9iaiwgcHJvcCl7XG4gIHJldHVybiBPYmplY3QuY3JlYXRlKG9iaikuc29ydChmdW5jdGlvbihhLCBiKXtcbiAgICBhID0gYVtwcm9wXSwgYiA9IGJbcHJvcF07XG4gICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICByZXR1cm4gMDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFNpemUgb3IgbGVuZ3RoIG9mIHRoZSB0YXJnZXQgYG9iamAuXG4gKi9cblxuZXhwb3J0cy5zaXplID0gZXhwb3J0cy5sZW5ndGggPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iai5sZW5ndGg7XG59O1xuXG4vKipcbiAqIEFkZCBgYWAgYW5kIGBiYC5cbiAqL1xuXG5leHBvcnRzLnBsdXMgPSBmdW5jdGlvbihhLCBiKXtcbiAgcmV0dXJuIE51bWJlcihhKSArIE51bWJlcihiKTtcbn07XG5cbi8qKlxuICogU3VidHJhY3QgYGJgIGZyb20gYGFgLlxuICovXG5cbmV4cG9ydHMubWludXMgPSBmdW5jdGlvbihhLCBiKXtcbiAgcmV0dXJuIE51bWJlcihhKSAtIE51bWJlcihiKTtcbn07XG5cbi8qKlxuICogTXVsdGlwbHkgYGFgIGJ5IGBiYC5cbiAqL1xuXG5leHBvcnRzLnRpbWVzID0gZnVuY3Rpb24oYSwgYil7XG4gIHJldHVybiBOdW1iZXIoYSkgKiBOdW1iZXIoYik7XG59O1xuXG4vKipcbiAqIERpdmlkZSBgYWAgYnkgYGJgLlxuICovXG5cbmV4cG9ydHMuZGl2aWRlZF9ieSA9IGZ1bmN0aW9uKGEsIGIpe1xuICByZXR1cm4gTnVtYmVyKGEpIC8gTnVtYmVyKGIpO1xufTtcblxuLyoqXG4gKiBKb2luIGBvYmpgIHdpdGggdGhlIGdpdmVuIGBzdHJgLlxuICovXG5cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKG9iaiwgc3RyKXtcbiAgcmV0dXJuIG9iai5qb2luKHN0ciB8fCAnLCAnKTtcbn07XG5cbi8qKlxuICogVHJ1bmNhdGUgYHN0cmAgdG8gYGxlbmAuXG4gKi9cblxuZXhwb3J0cy50cnVuY2F0ZSA9IGZ1bmN0aW9uKHN0ciwgbGVuKXtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIHJldHVybiBzdHIuc3Vic3RyKDAsIGxlbik7XG59O1xuXG4vKipcbiAqIFRydW5jYXRlIGBzdHJgIHRvIGBuYCB3b3Jkcy5cbiAqL1xuXG5leHBvcnRzLnRydW5jYXRlX3dvcmRzID0gZnVuY3Rpb24oc3RyLCBuKXtcbiAgdmFyIHN0ciA9IFN0cmluZyhzdHIpXG4gICAgLCB3b3JkcyA9IHN0ci5zcGxpdCgvICsvKTtcbiAgcmV0dXJuIHdvcmRzLnNsaWNlKDAsIG4pLmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogUmVwbGFjZSBgcGF0dGVybmAgd2l0aCBgc3Vic3RpdHV0aW9uYCBpbiBgc3RyYC5cbiAqL1xuXG5leHBvcnRzLnJlcGxhY2UgPSBmdW5jdGlvbihzdHIsIHBhdHRlcm4sIHN1YnN0aXR1dGlvbil7XG4gIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKHBhdHRlcm4sIHN1YnN0aXR1dGlvbiB8fCAnJyk7XG59O1xuXG4vKipcbiAqIFByZXBlbmQgYHZhbGAgdG8gYG9iamAuXG4gKi9cblxuZXhwb3J0cy5wcmVwZW5kID0gZnVuY3Rpb24ob2JqLCB2YWwpe1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopXG4gICAgPyBbdmFsXS5jb25jYXQob2JqKVxuICAgIDogdmFsICsgb2JqO1xufTtcblxuLyoqXG4gKiBBcHBlbmQgYHZhbGAgdG8gYG9iamAuXG4gKi9cblxuZXhwb3J0cy5hcHBlbmQgPSBmdW5jdGlvbihvYmosIHZhbCl7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG9iailcbiAgICA/IG9iai5jb25jYXQodmFsKVxuICAgIDogb2JqICsgdmFsO1xufTtcblxuLyoqXG4gKiBNYXAgdGhlIGdpdmVuIGBwcm9wYC5cbiAqL1xuXG5leHBvcnRzLm1hcCA9IGZ1bmN0aW9uKGFyciwgcHJvcCl7XG4gIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uKG9iail7XG4gICAgcmV0dXJuIG9ialtwcm9wXTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJldmVyc2UgdGhlIGdpdmVuIGBvYmpgLlxuICovXG5cbmV4cG9ydHMucmV2ZXJzZSA9IGZ1bmN0aW9uKG9iail7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG9iailcbiAgICA/IG9iai5yZXZlcnNlKClcbiAgICA6IFN0cmluZyhvYmopLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7XG59O1xuXG4vKipcbiAqIEdldCBgcHJvcGAgb2YgdGhlIGdpdmVuIGBvYmpgLlxuICovXG5cbmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24ob2JqLCBwcm9wKXtcbiAgcmV0dXJuIG9ialtwcm9wXTtcbn07XG5cbi8qKlxuICogUGFja3MgdGhlIGdpdmVuIGBvYmpgIGludG8ganNvbiBzdHJpbmdcbiAqL1xuZXhwb3J0cy5qc29uID0gZnVuY3Rpb24ob2JqKXtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLG51bGwsIi8vIFN0cmljdCBsaW50aW5nOiBBYnNvcmIgaW50byBnbG9iYWwgY29uZmlnIHdoZW4gcG9zc2libGVcbi8qIGpzaGludFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG4gbWF4bGVuOiAxMjBcbiAqL1xuXG52YXIgY29kZWdlbiA9IHJlcXVpcmUoJy4vY29kZWdlbicpO1xudmFyIE9ic2VydmFibGVFdmVudCA9IHJlcXVpcmUoJy4vT2JzZXJ2YWJsZUV2ZW50Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgSlNJbnRlcnByZXRlciBvYmplY3QuIFRoaXMgb2JqZWN0IHdyYXBzIGFuIEludGVycHJldGVyIG9iamVjdCBhbmRcbiAqIGFkZHMgc3RlcHBpbmcsIGJhdGNoaW5nIG9mIHN0ZXBzLCBjb2RlIGhpZ2hsaWdodGluZywgZXJyb3IgaGFuZGxpbmcsXG4gKiBicmVha3BvaW50cywgZ2VuZXJhbCBkZWJ1ZyBjYXBhYmlsaXRpZXMgKHN0ZXAgaW4sIHN0ZXAgb3V0LCBzdGVwIG92ZXIpLCBhbmRcbiAqIGFuIG9wdGlvbmFsIGV2ZW50IHF1ZXVlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0geyFPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7IVN0dWRpb0FwcH0gb3B0aW9ucy5zdHVkaW9BcHBcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLnNob3VsZFJ1bkF0TWF4U3BlZWRdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4SW50ZXJwcmV0ZXJTdGVwc1BlclRpY2tdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY3VzdG9tTWFyc2hhbEdsb2JhbFByb3BlcnRpZXNdXG4gKi9cbnZhciBKU0ludGVycHJldGVyID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB0aGlzLnN0dWRpb0FwcCA9IG9wdGlvbnMuc3R1ZGlvQXBwO1xuICB0aGlzLnNob3VsZFJ1bkF0TWF4U3BlZWQgPSBvcHRpb25zLnNob3VsZFJ1bkF0TWF4U3BlZWQgfHwgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xuICB0aGlzLm1heEludGVycHJldGVyU3RlcHNQZXJUaWNrID0gb3B0aW9ucy5tYXhJbnRlcnByZXRlclN0ZXBzUGVyVGljayB8fCAxMDAwMDtcbiAgdGhpcy5jdXN0b21NYXJzaGFsR2xvYmFsUHJvcGVydGllcyA9IG9wdGlvbnMuY3VzdG9tTWFyc2hhbEdsb2JhbFByb3BlcnRpZXMgfHwge307XG5cbiAgLy8gUHVibGljbHktZXhwb3NlZCBldmVudHMgdGhhdCBhbnlvbmUgd2l0aCBhY2Nlc3MgdG8gdGhlIEpTSW50ZXJwcmV0ZXIgY2FuXG4gIC8vIG9ic2VydmUgYW5kIHJlc3BvbmQgdG8uXG5cbiAgLyoqIEB0eXBlIHtPYnNlcnZhYmxlRXZlbnR9ICovXG4gIHRoaXMub25OZXh0U3RlcENoYW5nZWQgPSBuZXcgT2JzZXJ2YWJsZUV2ZW50KCk7XG5cbiAgLyoqIEB0eXBlIHtPYnNlcnZhYmxlRXZlbnR9ICovXG4gIHRoaXMub25QYXVzZSA9IG5ldyBPYnNlcnZhYmxlRXZlbnQoKTtcblxuICAvKiogQHR5cGUge09ic2VydmFibGVFdmVudH0gKi9cbiAgdGhpcy5vbkV4ZWN1dGlvbkVycm9yID0gbmV3IE9ic2VydmFibGVFdmVudCgpO1xuXG4gIC8qKiBAdHlwZSB7T2JzZXJ2YWJsZUV2ZW50fSAqL1xuICB0aGlzLm9uRXhlY3V0aW9uV2FybmluZyA9IG5ldyBPYnNlcnZhYmxlRXZlbnQoKTtcblxuICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICB0aGlzLnlpZWxkRXhlY3V0aW9uID0gZmFsc2U7XG4gIHRoaXMuc3RhcnRlZEhhbmRsaW5nRXZlbnRzID0gZmFsc2U7XG4gIHRoaXMuZXhlY3V0aW9uRXJyb3IgPSBudWxsO1xuICB0aGlzLm5leHRTdGVwID0gU3RlcFR5cGUuUlVOO1xuICB0aGlzLm1heFZhbGlkQ2FsbEV4cHJlc3Npb25EZXB0aCA9IDA7XG4gIHRoaXMuZXhlY3V0ZUxvb3BEZXB0aCA9IDA7XG4gIHRoaXMuY2FsbEV4cHJlc3Npb25TZWVuQXREZXB0aCA9IFtdO1xuICB0aGlzLnN0b3BwZWRBdEJyZWFrcG9pbnRSb3dzID0gW107XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIEpTSW50ZXJwcmV0ZXIsIHBhcnNpbmcgdGhlIHByb3ZpZGVkIGNvZGUgYW5kIHByZXBhcmluZyB0b1xuICogZXhlY3V0ZSBpdCBvbmUgc3RlcCBhdCBhIHRpbWUuXG4gKlxuICogQHBhcmFtIHshT2JqZWN0fSBvcHRpb25zIC0gZm9yIG5vdywgc2FtZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7IXN0cmluZ30gb3B0aW9ucy5jb2RlIC0gQ29kZSB0byBiZSBleGVjdXRlZCBieSB0aGUgaW50ZXJwcmV0ZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5ibG9ja3NdIC0gaW4gZHJvcGxldENvbmZpZy5ibG9ja3MgZm9ybWF0LiAgSWYgYSBibG9ja1xuICogICAgICAgIGhhcyBhIHBhcmVudCBwcm9wZXJ0eSwgd2Ugd2lsbCBwb3B1bGF0ZSB0aGF0IGZ1bmN0aW9uIGludG8gdGhlXG4gKiAgICAgICAgaW50ZXJwcmV0ZXIgZ2xvYmFsIHNjb3BlLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmJsb2NrRmlsdGVyXSAtIGFuIG9iamVjdCB3aXRoIGJsb2NrLW5hbWUga2V5cyB0aGF0XG4gKiAgICAgICAgc2hvdWxkIGJlIHVzZWQgdG8gZmlsdGVyIHdoaWNoIGJsb2NrcyBhcmUgcG9wdWxhdGVkLlxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuZ2xvYmFsRnVuY3Rpb25zXSAtIG9iamVjdHMgY29udGFpbmluZyBmdW5jdGlvbnMgdG9cbiAqICAgICAgICBwbGFjZSBpbiB0aGUgaW50ZXJwcmV0ZXIgZ2xvYmFsIHNjb3BlLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbmFibGVFdmVudHNdIC0gYWxsb3cgdGhlIGludGVycHJldGVyIHRvIGRlZmluZVxuICogICAgICAgIGV2ZW50IGhhbmRsZXJzIHRoYXQgY2FuIGJlIGludm9rZWQgYnkgbmF0aXZlIGNvZGUuIChkZWZhdWx0IGZhbHNlKVxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmICghdGhpcy5zdHVkaW9BcHAuaGlkZVNvdXJjZSkge1xuICAgIHRoaXMuY2FsY3VsYXRlQ29kZUluZm8ob3B0aW9ucy5jb2RlKTtcblxuICAgIHZhciBzZXNzaW9uID0gdGhpcy5zdHVkaW9BcHAuZWRpdG9yLmFjZUVkaXRvci5nZXRTZXNzaW9uKCk7XG4gICAgdGhpcy5pc0JyZWFrcG9pbnRSb3cgPSBjb2RlZ2VuLmlzQWNlQnJlYWtwb2ludFJvdy5iaW5kKG51bGwsIHNlc3Npb24pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNCcmVha3BvaW50Um93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChvcHRpb25zLmVuYWJsZUV2ZW50cykge1xuICAgIHRoaXMuZXZlbnRRdWV1ZSA9IFtdO1xuICAgIC8vIEFwcGVuZCBvdXIgbWluaS1ydW50aW1lIGFmdGVyIHRoZSB1c2VyJ3MgY29kZS4gVGhpcyB3aWxsIHNwaW4gYW5kIHByb2Nlc3NcbiAgICAvLyBjYWxsYmFjayBmdW5jdGlvbnM6XG4gICAgb3B0aW9ucy5jb2RlICs9ICdcXG53aGlsZSAodHJ1ZSkgeyB2YXIgb2JqID0gZ2V0Q2FsbGJhY2soKTsgJyArXG4gICAgICAnaWYgKG9iaikgeyB2YXIgcmV0ID0gb2JqLmZuLmFwcGx5KG51bGwsIG9iai5hcmd1bWVudHMgPyBvYmouYXJndW1lbnRzIDogbnVsbCk7JyArXG4gICAgICAgICAgICAgICAgICdzZXRDYWxsYmFja1JldFZhbChyZXQpOyB9fSc7XG5cbiAgICBjb2RlZ2VuLmNyZWF0ZU5hdGl2ZUZ1bmN0aW9uRnJvbUludGVycHJldGVyRnVuY3Rpb24gPSBmdW5jdGlvbiAoaW50RnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGYuaW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICAgIHNlbGYucXVldWVFdmVudChpbnRGdW5jLCBhcmd1bWVudHMpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChzZWxmLmV4ZWN1dGVMb29wRGVwdGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIGludGVycHJldGVyIGFuZCBpZiBhIHJldHVybiB2YWx1ZSBpcyBzZW50IGJhY2sgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIGludGVycHJldGVyJ3MgZXZlbnQgaGFuZGxlciwgcGFzcyB0aGF0IGJhY2sgaW4gdGhlIG5hdGl2ZSB3b3JsZFxuXG4gICAgICAgICAgICAvLyBOT1RFOiB0aGUgaW50ZXJwcmV0ZXIgd2lsbCBub3QgZXhlY3V0ZSBmb3JldmVyLCBpZiB0aGUgZXZlbnQgaGFuZGxlclxuICAgICAgICAgICAgLy8gdGFrZXMgdG9vIGxvbmcsIGV4ZWN1dGVJbnRlcnByZXRlcigpIHdpbGwgcmV0dXJuIGFuZCB0aGUgbmF0aXZlIHNpZGVcbiAgICAgICAgICAgIC8vIHdpbGwganVzdCBzZWUgJ3VuZGVmaW5lZCcgYXMgdGhlIHJldHVybiB2YWx1ZS4gVGhlIHJlc3Qgb2YgdGhlIGludGVycHJldGVyXG4gICAgICAgICAgICAvLyBldmVudCBoYW5kbGVyIHdpbGwgcnVuIGluIHRoZSBuZXh0IG9uVGljaygpLCBidXQgdGhlIHJldHVybiB2YWx1ZSB3aWxsXG4gICAgICAgICAgICAvLyBubyBsb25nZXIgaGF2ZSBhbnkgZWZmZWN0LlxuICAgICAgICAgICAgc2VsZi5leGVjdXRlSW50ZXJwcmV0ZXIoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYubGFzdENhbGxiYWNrUmV0VmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGluaXRGdW5jID0gZnVuY3Rpb24gKGludGVycHJldGVyLCBzY29wZSkge1xuICAgIC8vIFN0b3JlIEludGVycHJldGVyIG9uIEpTSW50ZXJwcmV0ZXJcbiAgICBzZWxmLmludGVycHJldGVyID0gaW50ZXJwcmV0ZXI7XG4gICAgLy8gU3RvcmUgZ2xvYmFsU2NvcGUgb24gSlNJbnRlcnByZXRlclxuICAgIHNlbGYuZ2xvYmFsU2NvcGUgPSBzY29wZTtcbiAgICAvLyBPdmVycmlkZSBJbnRlcnByZXRlcidzIGdldC9zZXQgUHJvcGVydHkgZnVuY3Rpb25zIHdpdGggSlNJbnRlcnByZXRlclxuICAgIGludGVycHJldGVyLmdldFByb3BlcnR5ID0gc2VsZi5nZXRQcm9wZXJ0eS5iaW5kKFxuICAgICAgICBzZWxmLFxuICAgICAgICBpbnRlcnByZXRlcixcbiAgICAgICAgaW50ZXJwcmV0ZXIuZ2V0UHJvcGVydHkpO1xuICAgIC8vIFN0b3JlIHRoaXMgZm9yIGxhdGVyIGJlY2F1c2Ugd2UgbmVlZCB0byBieXBhc3Mgb3VyIG92ZXJyaWRlbiBmdW5jdGlvblxuICAgIC8vIGluIGNyZWF0ZUdsb2JhbFByb3BlcnR5KClcbiAgICBzZWxmLmJhc2VTZXRQcm9wZXJ0eSA9IGludGVycHJldGVyLnNldFByb3BlcnR5O1xuICAgIGludGVycHJldGVyLnNldFByb3BlcnR5ID0gc2VsZi5zZXRQcm9wZXJ0eS5iaW5kKFxuICAgICAgICBzZWxmLFxuICAgICAgICBpbnRlcnByZXRlcixcbiAgICAgICAgaW50ZXJwcmV0ZXIuc2V0UHJvcGVydHkpO1xuICAgIGNvZGVnZW4uaW5pdEpTSW50ZXJwcmV0ZXIoXG4gICAgICAgIGludGVycHJldGVyLFxuICAgICAgICBvcHRpb25zLmJsb2NrcyxcbiAgICAgICAgb3B0aW9ucy5ibG9ja0ZpbHRlcixcbiAgICAgICAgc2NvcGUsXG4gICAgICAgIG9wdGlvbnMuZ2xvYmFsRnVuY3Rpb25zKTtcblxuICAgIC8vIE9ubHkgYWxsb3cgZml2ZSBsZXZlbHMgb2YgZGVwdGggd2hlbiBtYXJzaGFsbGluZyB0aGUgcmV0dXJuIHZhbHVlXG4gICAgLy8gc2luY2Ugd2Ugd2lsbCBvY2Nhc2lvbmFsbHkgcmV0dXJuIERPTSBFdmVudCBvYmplY3RzIHdoaWNoIGNvbnRhaW5cbiAgICAvLyBwcm9wZXJ0aWVzIHRoYXQgcmVjdXJzZSBvdmVyIGFuZCBvdmVyLi4uXG4gICAgdmFyIHdyYXBwZXIgPSBjb2RlZ2VuLm1ha2VOYXRpdmVNZW1iZXJGdW5jdGlvbih7XG4gICAgICAgIGludGVycHJldGVyOiBpbnRlcnByZXRlcixcbiAgICAgICAgbmF0aXZlRnVuYzogc2VsZi5uYXRpdmVHZXRDYWxsYmFjay5iaW5kKHNlbGYpLFxuICAgICAgICBtYXhEZXB0aDogNVxuICAgIH0pO1xuICAgIGludGVycHJldGVyLnNldFByb3BlcnR5KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdnZXRDYWxsYmFjaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXIuY3JlYXRlTmF0aXZlRnVuY3Rpb24od3JhcHBlcikpO1xuXG4gICAgd3JhcHBlciA9IGNvZGVnZW4ubWFrZU5hdGl2ZU1lbWJlckZ1bmN0aW9uKHtcbiAgICAgICAgaW50ZXJwcmV0ZXI6IGludGVycHJldGVyLFxuICAgICAgICBuYXRpdmVGdW5jOiBzZWxmLm5hdGl2ZVNldENhbGxiYWNrUmV0VmFsLmJpbmQoc2VsZiksXG4gICAgfSk7XG4gICAgaW50ZXJwcmV0ZXIuc2V0UHJvcGVydHkoc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NldENhbGxiYWNrUmV0VmFsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnByZXRlci5jcmVhdGVOYXRpdmVGdW5jdGlvbih3cmFwcGVyKSk7XG4gIH07XG5cbiAgdHJ5IHtcbiAgICAvLyBSZXR1cm4gdmFsdWUgd2lsbCBiZSBzdG9yZWQgYXMgdGhpcy5pbnRlcnByZXRlciBpbnNpZGUgdGhlIHN1cHBsaWVkXG4gICAgLy8gaW5pdEZ1bmMoKSAob3RoZXIgY29kZSBpbiBpbml0RnVuYygpIGRlcGVuZHMgb24gdGhpcy5pbnRlcnByZXRlciwgc29cbiAgICAvLyB3ZSBjYW4ndCB3YWl0IHVudGlsIHRoZSBjb25zdHJ1Y3RvciByZXR1cm5zKVxuICAgIC8qIGpzaGludCBub25ldzpmYWxzZSAqL1xuICAgIG5ldyB3aW5kb3cuSW50ZXJwcmV0ZXIob3B0aW9ucy5jb2RlLCBpbml0RnVuYyk7XG4gICAgLyoganNoaW50IG5vbmV3OnRydWUgKi9cbiAgfVxuICBjYXRjaChlcnIpIHtcbiAgICB0aGlzLmV4ZWN1dGlvbkVycm9yID0gZXJyO1xuICAgIHRoaXMuaGFuZGxlRXJyb3IoKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEluaXQgYHRoaXMuY29kZUluZm9gIHdpdGggY3VtdWxhdGl2ZSBsZW5ndGggaW5mbyAodXNlZCB0byBsb2NhdGUgYnJlYWtwb2ludHMpLlxuICogQHBhcmFtIGNvZGVcbiAqL1xuSlNJbnRlcnByZXRlci5wcm90b3R5cGUuY2FsY3VsYXRlQ29kZUluZm8gPSBmdW5jdGlvbiAoY29kZSkge1xuICB0aGlzLmNvZGVJbmZvID0ge307XG4gIHRoaXMuY29kZUluZm8udXNlckNvZGVTdGFydE9mZnNldCA9IDA7XG4gIHRoaXMuY29kZUluZm8udXNlckNvZGVMZW5ndGggPSBjb2RlLmxlbmd0aDtcbiAgdGhpcy5jb2RlSW5mby5jdW11bGF0aXZlTGVuZ3RoID0gY29kZWdlbi5jYWxjdWxhdGVDdW11bGF0aXZlTGVuZ3RoKGNvZGUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEpTSW50ZXJwcmV0ZXIgaW5zdGFuY2UgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzXG4gKiB3b3VsZCB0eXBpY2FsbHkgZmFpbCB3aGVuIHRoZSBwcm9ncmFtIGNvbnRhaW5zIGEgc3ludGF4IGVycm9yLlxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5pbml0aWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhdGhpcy5pbnRlcnByZXRlcjtcbn07XG5cbi8qKlxuICogRGV0ZWNoIHRoZSBJbnRlcnByZXRlciBpbnN0YW5jZS4gQ2FsbCBiZWZvcmUgcmVsZWFzaW5nIHJlZmVyZW5jZXMgdG9cbiAqIEpTSW50ZXJwcmV0ZXIgc28gYW55IGFzeW5jIGNhbGxiYWNrcyB3aWxsIG5vdCBleGVjdXRlLlxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5kZWluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaW50ZXJwcmV0ZXIgPSBudWxsO1xufTtcblxuSlNJbnRlcnByZXRlci5TdGVwVHlwZSA9IHtcbiAgUlVOOiAgMCxcbiAgSU46ICAgMSxcbiAgT1ZFUjogMixcbiAgT1VUOiAgMyxcbn07XG5cbi8qKlxuICogQSBtaW5pYXR1cmUgcnVudGltZSBpbiB0aGUgaW50ZXJwcmV0ZWQgd29ybGQgY2FsbHMgdGhpcyBmdW5jdGlvbiByZXBlYXRlZGx5XG4gKiB0byBjaGVjayB0byBzZWUgaWYgaXQgc2hvdWxkIGludm9rZSBhbnkgY2FsbGJhY2tzIGZyb20gd2l0aGluIHRoZVxuICogaW50ZXJwcmV0ZWQgd29ybGQuIElmIHRoZSBldmVudFF1ZXVlIGlzIG5vdCBlbXB0eSwgd2Ugd2lsbCByZXR1cm4gYW4gb2JqZWN0XG4gKiB0aGF0IGNvbnRhaW5zIGFuIGludGVycHJldGVkIGNhbGxiYWNrIGZ1bmN0aW9uIChzdG9yZWQgaW4gXCJmblwiKSBhbmQsXG4gKiBvcHRpb25hbGx5LCBjYWxsYmFjayBhcmd1bWVudHMgKHN0b3JlZCBpbiBcImFyZ3VtZW50c1wiKVxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5uYXRpdmVHZXRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zdGFydGVkSGFuZGxpbmdFdmVudHMgPSB0cnVlO1xuICB2YXIgcmV0VmFsID0gdGhpcy5ldmVudFF1ZXVlLnNoaWZ0KCk7XG4gIGlmICh0eXBlb2YgcmV0VmFsID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhpcy55aWVsZCgpO1xuICB9XG4gIHJldHVybiByZXRWYWw7XG59O1xuXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5uYXRpdmVTZXRDYWxsYmFja1JldFZhbCA9IGZ1bmN0aW9uIChyZXRWYWwpIHtcbiAgaWYgKHRoaXMuZXZlbnRRdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiBub3RoaW5nIGVsc2UgaXMgaW4gdGhlIGV2ZW50IHF1ZXVlLCB0aGVuIHN0b3JlIHRoaXMgcmV0dXJuIHZhbHVlXG4gICAgLy8gYXdheSBzbyBpdCBjYW4gYmUgcmV0dXJuZWQgaW4gdGhlIG5hdGl2ZSBldmVudCBoYW5kbGVyXG4gICAgdGhpcy5zZWVuUmV0dXJuRnJvbUNhbGxiYWNrRHVyaW5nRXhlY3V0aW9uID0gdHJ1ZTtcbiAgICB0aGlzLmxhc3RDYWxsYmFja1JldFZhbCA9IHJldFZhbDtcbiAgfVxuICAvLyBQcm92aWRlIHdhcm5pbmdzIHRvIHRoZSB1c2VyIGlmIHRoaXMgZnVuY3Rpb24gaGFzIGJlZW4gY2FsbGVkIHdpdGggYVxuICAvLyBtZWFuaW5nZnVsIHJldHVybiB2YWx1ZSB3aGlsZSB3ZSBhcmUgbm8gbG9uZ2VyIGluIHRoZSBuYXRpdmUgZXZlbnQgaGFuZGxlclxuXG4gIC8vIFRPRE8gKGNwaXJpY2gpOiBDaGVjayB0byBzZWUgaWYgdGhlIERPTSBldmVudCBvYmplY3Qgd2FzIG1vZGlmaWVkXG4gIC8vIChwcmV2ZW50RGVmYXVsdCgpLCBzdG9wUHJvcGFnYXRpb24oKSwgcmV0dXJuVmFsdWUpIGFuZCBwcm92aWRlIGEgc2ltaWxhclxuICAvLyB3YXJuaW5nIHNpbmNlIHRoZXNlIHdvbid0IHdvcmsgYXMgZXhwZWN0ZWQgdW5sZXNzIHJ1bm5pbmcgYXRNYXhTcGVlZFxuICBpZiAoIXRoaXMucnVuVW50aWxDYWxsYmFja1JldHVybiAmJlxuICAgICAgdHlwZW9mIHRoaXMubGFzdENhbGxiYWNrUmV0VmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMub25FeGVjdXRpb25XYXJuaW5nLm5vdGlmeU9ic2VydmVycyhcIkZ1bmN0aW9uIHBhc3NlZCB0byBvbkV2ZW50KCkgXCIgK1xuICAgICAgICBcImhhcyB0YWtlbiB0b28gbG9uZyAtIHRoZSByZXR1cm4gdmFsdWUgd2FzIGlnbm9yZWQuXCIpO1xuICAgIGlmICghdGhpcy5zaG91bGRSdW5BdE1heFNwZWVkKCkpIHtcbiAgICAgIHRoaXMub25FeGVjdXRpb25XYXJuaW5nLm5vdGlmeU9ic2VydmVycyhcIiAgKHRyeSBtb3ZpbmcgdGhlIHNwZWVkIFwiICtcbiAgICAgICAgICBcInNsaWRlciB0byBpdHMgbWF4aW11bSB2YWx1ZSlcIik7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFF1ZXVlIGFuIGV2ZW50IHRvIGJlIGZpcmVkIGluIHRoZSBpbnRlcnByZXRlci4gVGhlIG5hdGl2ZUFyZ3MgYXJlIG9wdGlvbmFsLlxuICogVGhlIGZ1bmN0aW9uIG11c3QgYmUgYW4gaW50ZXJwcmV0ZXIgZnVuY3Rpb24gb2JqZWN0IChub3QgbmF0aXZlKS5cbiAqL1xuSlNJbnRlcnByZXRlci5wcm90b3R5cGUucXVldWVFdmVudCA9IGZ1bmN0aW9uIChpbnRlcnByZXRlckZ1bmMsIG5hdGl2ZUFyZ3MpIHtcbiAgdGhpcy5ldmVudFF1ZXVlLnB1c2goe1xuICAgICdmbic6IGludGVycHJldGVyRnVuYyxcbiAgICAnYXJndW1lbnRzJzogbmF0aXZlQXJncyA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG5hdGl2ZUFyZ3MpIDogW11cbiAgfSk7XG59O1xuXG4vKipcbiAqIFlpZWxkIGV4ZWN1dGlvbiAoY2F1c2VzIGV4ZWN1dGVJbnRlcnByZXRlciBsb29wIHRvIGJyZWFrIG91dCBpZiB0aGlzIGlzXG4gKiBjYWxsZWQgYnkgQVBJcyBjYWxsZWQgYnkgaW50ZXJwcmV0ZWQgY29kZSlcbiAqL1xuSlNJbnRlcnByZXRlci5wcm90b3R5cGUueWllbGQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMueWllbGRFeGVjdXRpb24gPSB0cnVlO1xufTtcblxuXG52YXIgU3RlcFR5cGUgPSBKU0ludGVycHJldGVyLlN0ZXBUeXBlO1xuXG4vKipcbiAqIFNtYWxsIGhlbHBlciB0byBzdGVwIHRoZSBpbnRlcnByZXRlciBzbyB0aGF0IGV4Y2VwdGlvbiBoYW5kbGVyIGNhbiBleGlzdCBvdXRzaWRlXG4gKiBvZiB0aGUgY29yZSBleGVjdXRlSW50ZXJwZXRlcigpIGZ1bmN0aW9uIChpbXByb3ZlcyBicm93c2VyIEpTIGVuZ2luZSBwZXJmb3JtYW5jZSlcbiAqL1xuZnVuY3Rpb24gc2FmZVN0ZXBJbnRlcnByZXRlcihqc2kpIHtcbiAgdHJ5IHtcbiAgICBqc2kuaW50ZXJwcmV0ZXIuc3RlcCgpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZXJyO1xuICB9XG59XG5cbi8qKlxuICogRmluZCBhIGJwUm93IGZyb20gdGhlIFwic3RvcHBlZCBhdCBicmVha3BvaW50XCIgYXJyYXkgYnkgbWF0Y2hpbmcgdGhlIHNjb3BlXG4gKlxuICogQHBhcmFtIHshT2JqZWN0fSBzY29wZSB0byBtYXRjaCBmcm9tIHRoZSBsaXN0XG4gKiBAcGFyYW0ge251bWJlcn0gW3Jvd10gdG8gbWF0Y2ggZnJvbSB0aGUgbGlzdCAtIGluIGFkZGl0aW9uIHRvIHNjb3BlXG4gKi9cbkpTSW50ZXJwcmV0ZXIucHJvdG90eXBlLmZpbmRTdG9wcGVkQXRCcmVha3BvaW50Um93ID0gZnVuY3Rpb24gKHNjb3BlLCByb3cpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0b3BwZWRBdEJyZWFrcG9pbnRSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJwUm93ID0gdGhpcy5zdG9wcGVkQXRCcmVha3BvaW50Um93c1tpXTtcbiAgICBpZiAoYnBSb3cuc2NvcGUgPT09IHNjb3BlKSB7XG4gICAgICBpZiAodHlwZW9mIHJvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgcm93ID09PSBicFJvdy5yb3cpIHtcbiAgICAgICAgcmV0dXJuIGJwUm93O1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXBsYWNlIGEgYnBSb3cgZnJvbSB0aGUgXCJzdG9wcGVkIGF0IGJyZWFrcG9pbnRcIiBhcnJheSBieSBtYXRjaGluZ1xuICogdGhlIHNjb3BlLlxuICpcbiAqIElmIG5vIHJvd3MgYXJlIGZvdW5kIG1hdGNoaW5nIHRoZSBnaXZlbiBzY29wZSwgYSBuZXcgb25lIGlzIGludHJvZHVjZWQuXG4gKlxuICogQHBhcmFtIHshT2JqZWN0fSBzY29wZSB0byBtYXRjaCBmcm9tIHRoZSBsaXN0XG4gKiBAcGFyYW0geyFudW1iZXJ9IHJvdyB0byByZXBsYWNlIGluIHRoZSBsaXN0LlxuICogQHRocm93cyB7VHlwZUVycm9yfSB3aGVuIGdpdmVuIGFuIGludmFsaWQgcm93LlxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5yZXBsYWNlU3RvcHBlZEF0QnJlYWtwb2ludFJvd0ZvclNjb3BlID0gZnVuY3Rpb24gKHNjb3BlLCByb3cpIHtcbiAgaWYgKHR5cGVvZiByb3cgIT09ICdudW1iZXInIHx8IHJvdyA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSb3cgJyArIHJvdyArICcgaXMgbm90IGEgdmFsaWQgcm93IGluIHVzZXIgY29kZS4nKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdG9wcGVkQXRCcmVha3BvaW50Um93cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBicFJvdyA9IHRoaXMuc3RvcHBlZEF0QnJlYWtwb2ludFJvd3NbaV07XG4gICAgaWYgKGJwUm93LnNjb3BlID09PSBzY29wZSkge1xuICAgICAgLy8gVXBkYXRlIHJvdyBudW1iZXJcbiAgICAgIGJwUm93LnJvdyA9IHJvdztcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgLy8gU2NvcGUgbm90IGZvdW5kLCBpbnNlcnQgbmV3IG9iamVjdCBpbiBhcnJheTpcbiAgdGhpcy5zdG9wcGVkQXRCcmVha3BvaW50Um93cy51bnNoaWZ0KHtcbiAgICByb3c6IHJvdyxcbiAgICBzY29wZTogc2NvcGVcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIGJwUm93IGZyb20gdGhlIFwic3RvcHBlZCBhdCBicmVha3BvaW50XCIgYXJyYXkgYnkgbWF0Y2hpbmdcbiAqIHRoZSBzY29wZS5cbiAqXG4gKiBEb2VzIG5vdGhpbmcgaWYgbm8gcm93cyBhcmUgZm91bmQgbWF0Y2hpbmcgdGhlIGdpdmVuIHNjb3BlLlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gc2NvcGUgdG8gbWF0Y2ggZnJvbSB0aGUgbGlzdFxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5yZW1vdmVTdG9wcGVkQXRCcmVha3BvaW50Um93Rm9yU2NvcGUgPSBmdW5jdGlvbiAoc2NvcGUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0b3BwZWRBdEJyZWFrcG9pbnRSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJwUm93ID0gdGhpcy5zdG9wcGVkQXRCcmVha3BvaW50Um93c1tpXTtcbiAgICBpZiAoYnBSb3cuc2NvcGUgPT09IHNjb3BlKSB7XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIGFycmF5XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0QnJlYWtwb2ludFJvd3Muc3BsaWNlKGksIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHByb2dyYW0gaXMgZG9uZSBleGVjdXRpbmcuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBwcm9ncmFtIGlzIGNvbXBsZXRlIChvciBhbiBlcnJvciBoYXMgb2NjdXJyZWQpLlxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5pc1Byb2dyYW1Eb25lID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5leGVjdXRpb25FcnJvciB8fFxuICAgICAgIXRoaXMuaW50ZXJwcmV0ZXIgfHxcbiAgICAgICF0aGlzLmludGVycHJldGVyLnN0YXRlU3RhY2subGVuZ3RoO1xufTtcblxuLyoqXG4gKiBOb2RlcyB0aGF0IGFyZSB2aXNpdGVkIGJldHdlZW4gZXhwcmVzc2lvbnMsIHNpZ25pZnlpbmcgdGhlIHByZXZpb3VzXG4gKiBleHByZXNzaW9uIGlzIGRvbmUuXG4gKi9cbnZhciBJTlRFUlNUSVRJQUxfTk9ERVMgPSB7XG4gIFByb2dyYW06IHRydWUsXG4gIEJsb2NrU3RhdGVtZW50OiB0cnVlLFxuICBTd2l0Y2hTdGF0ZW1lbnQ6IHRydWVcbn07XG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgaW50ZXJwcmV0ZXJcbiAqL1xuSlNJbnRlcnByZXRlci5wcm90b3R5cGUuZXhlY3V0ZUludGVycHJldGVyID0gZnVuY3Rpb24gKGZpcnN0U3RlcCwgcnVuVW50aWxDYWxsYmFja1JldHVybikge1xuICB0aGlzLmV4ZWN1dGVMb29wRGVwdGgrKztcbiAgdGhpcy5ydW5VbnRpbENhbGxiYWNrUmV0dXJuID0gcnVuVW50aWxDYWxsYmFja1JldHVybjtcbiAgaWYgKHJ1blVudGlsQ2FsbGJhY2tSZXR1cm4pIHtcbiAgICBkZWxldGUgdGhpcy5sYXN0Q2FsbGJhY2tSZXRWYWw7XG4gIH1cbiAgdGhpcy55aWVsZEV4ZWN1dGlvbiA9IGZhbHNlO1xuICB0aGlzLnNlZW5SZXR1cm5Gcm9tQ2FsbGJhY2tEdXJpbmdFeGVjdXRpb24gPSBmYWxzZTtcblxuICB2YXIgYXRJbml0aWFsQnJlYWtwb2ludCA9IHRoaXMucGF1c2VkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RlcCA9PT0gU3RlcFR5cGUuSU4gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFN0ZXA7XG4gIHZhciBhdE1heFNwZWVkID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgc3dpdGNoICh0aGlzLm5leHRTdGVwKSB7XG4gICAgICBjYXNlIFN0ZXBUeXBlLlJVTjpcbiAgICAgICAgLy8gQmFpbCBvdXQgaGVyZSBpZiBpbiBhIGJyZWFrIHN0YXRlIChwYXVzZWQpLCBidXQgbWFrZSBzdXJlIHRoYXQgd2Ugc3RpbGxcbiAgICAgICAgLy8gaGF2ZSB0aGUgbmV4dCB0aWNrIHF1ZXVlZCBmaXJzdCwgc28gd2UgY2FuIHJlc3VtZSBhZnRlciB1bi1wYXVzaW5nKTpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBTdGVwVHlwZS5PVVQ6XG4gICAgICAgIC8vIElmIHdlIGhhdmVuJ3QgeWV0IHNldCBzdGVwT3V0VG9TdGFja0RlcHRoLCB3b3JrIGJhY2t3YXJkcyB0aHJvdWdoIHRoZVxuICAgICAgICAvLyBoaXN0b3J5IG9mIGNhbGxFeHByZXNzaW9uU2VlbkF0RGVwdGggdW50aWwgd2UgZmluZCB0aGUgb25lIHdlIHdhbnQgdG9cbiAgICAgICAgLy8gc3RlcCBvdXQgdG8gLSBhbmQgc3RvcmUgdGhhdCBpbiBzdGVwT3V0VG9TdGFja0RlcHRoOlxuICAgICAgICBpZiAodGhpcy5pbnRlcnByZXRlciAmJiB0eXBlb2YgdGhpcy5zdGVwT3V0VG9TdGFja0RlcHRoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRoaXMuc3RlcE91dFRvU3RhY2tEZXB0aCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubWF4VmFsaWRDYWxsRXhwcmVzc2lvbkRlcHRoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxsRXhwcmVzc2lvblNlZW5BdERlcHRoW2ldKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RlcE91dFRvU3RhY2tEZXB0aCA9IGk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgZG9uZVVzZXJMaW5lID0gZmFsc2U7XG4gIHZhciByZWFjaGVkQnJlYWsgPSBmYWxzZTtcbiAgdmFyIHVud2luZGluZ0FmdGVyU3RlcCA9IGZhbHNlO1xuICB2YXIgaW5Vc2VyQ29kZTtcbiAgdmFyIHVzZXJDb2RlUm93O1xuXG4gIC8vIEluIGVhY2ggdGljaywgd2Ugd2lsbCBzdGVwIHRoZSBpbnRlcnByZXRlciBtdWx0aXBsZSB0aW1lcyBpbiBhIHRpZ2h0XG4gIC8vIGxvb3AgYXMgbG9uZyBhcyB3ZSBhcmUgaW50ZXJwcmV0aW5nIGNvZGUgdGhhdCB0aGUgdXNlciBjYW4ndCBzZWVcbiAgLy8gKGZ1bmN0aW9uIGFsaWFzZXMgYXQgdGhlIGJlZ2lubmluZywgZ2V0Q2FsbGJhY2sgZXZlbnQgbG9vcCBhdCB0aGUgZW5kKVxuICBmb3IgKHZhciBzdGVwc1RoaXNUaWNrID0gMDtcbiAgICAgICAoc3RlcHNUaGlzVGljayA8IHRoaXMubWF4SW50ZXJwcmV0ZXJTdGVwc1BlclRpY2spIHx8IHVud2luZGluZ0FmdGVyU3RlcDtcbiAgICAgICBzdGVwc1RoaXNUaWNrKyspIHtcbiAgICAvLyBDaGVjayB0aGlzIGV2ZXJ5IHRpbWUgYmVjYXVzZSB0aGUgc3BlZWQgaXMgYWxsb3dlZCB0byBjaGFuZ2UuLi5cbiAgICBhdE1heFNwZWVkID0gdGhpcy5zaG91bGRSdW5BdE1heFNwZWVkKCk7XG4gICAgLy8gTk9URTpcbiAgICAvLyAoMSkgV2hlbiBydW5uaW5nIHdpdGggbm8gc291cmNlIHZpc2libGUgQU5EIGF0IG1heCBzcGVlZCwgYWx3YXlzIHNldFxuICAgIC8vICAgYHVzZXJDb2RlUm93YCB0byAtMS4gV2UnbGwgbmV2ZXIgaGl0IGEgYnJlYWtwb2ludCBvciBuZWVkIHRvIGFkZCBkZWxheS5cbiAgICAvLyAoMikgV2hlbiBydW5uaW5nIHdpdGggbm8gc291cmNlIHZpc2libGUgT1IgYXQgbWF4IHNwZWVkLCBjYWxsIGEgc2ltcGxlXG4gICAgLy8gICBmdW5jdGlvbiB0byBqdXN0IGdldCB0aGUgbGluZSBudW1iZXIuIE5lZWQgdG8gY2hlY2sgYGluVXNlckNvZGVgIHRvXG4gICAgLy8gICBtYXliZSBzdG9wIGF0IGEgYnJlYWtwb2ludCwgb3IgYWRkIGEgYHNwZWVkKG4pYCBkZWxheS5cbiAgICAvLyAoMykgT3RoZXJ3aXNlIGNhbGwgYSBmdW5jdGlvbiB0aGF0IGFsc28gaGlnaGxpZ2h0cyB0aGUgY29kZS5cbiAgICB2YXIgc2VsZWN0Q29kZUZ1bmM7XG4gICAgaWYgKHRoaXMuc3R1ZGlvQXBwLmhpZGVTb3VyY2UgJiYgYXRNYXhTcGVlZCkge1xuICAgICAgc2VsZWN0Q29kZUZ1bmMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtMTsgfTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3R1ZGlvQXBwLmhpZGVTb3VyY2UgfHwgYXRNYXhTcGVlZCkge1xuICAgICAgc2VsZWN0Q29kZUZ1bmMgPSB0aGlzLmdldFVzZXJDb2RlTGluZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0Q29kZUZ1bmMgPSB0aGlzLnNlbGVjdEN1cnJlbnRDb2RlO1xuICAgIH1cbiAgICB2YXIgY3VycmVudFNjb3BlID0gdGhpcy5pbnRlcnByZXRlci5nZXRTY29wZSgpO1xuXG4gICAgaWYgKChyZWFjaGVkQnJlYWsgJiYgIXVud2luZGluZ0FmdGVyU3RlcCkgfHxcbiAgICAgICAgKGRvbmVVc2VyTGluZSAmJiAhdW53aW5kaW5nQWZ0ZXJTdGVwICYmICFhdE1heFNwZWVkKSB8fFxuICAgICAgICB0aGlzLnlpZWxkRXhlY3V0aW9uIHx8XG4gICAgICAgIHRoaXMuaW50ZXJwcmV0ZXIucGF1c2VkXyB8fFxuICAgICAgICAocnVuVW50aWxDYWxsYmFja1JldHVybiAmJiB0aGlzLnNlZW5SZXR1cm5Gcm9tQ2FsbGJhY2tEdXJpbmdFeGVjdXRpb24pKSB7XG4gICAgICAvLyBzdG9wIHN0ZXBwaW5nIHRoZSBpbnRlcnByZXRlciBhbmQgd2FpdCB1bnRpbCB0aGUgbmV4dCB0aWNrIG9uY2Ugd2U6XG4gICAgICAvLyAoMSkgcmVhY2hlZCBhIGJyZWFrcG9pbnQgYW5kIGFyZSBkb25lIHVud2luZGluZyBPUlxuICAgICAgLy8gKDIpIGNvbXBsZXRlZCBhIGxpbmUgb2YgdXNlciBjb2RlIGFuZCBhcmUgYXJlIGRvbmUgdW53aW5kaW5nXG4gICAgICAvLyAgICAgKHdoaWxlIG5vdCBydW5uaW5nIGF0TWF4U3BlZWQpIE9SXG4gICAgICAvLyAoMykgd2UndmUgYmVlbiBhc2tlZCB0byB5aWVsZCBvdXIgZXhlY3V0ZUludGVycGV0ZXIoKSBsb29wIE9SXG4gICAgICAvLyAoNCkgdGhlIGludGVycHJldGVyIGlzIHBhdXNlZCAoaGFuZGxpbmcgYSBuYXRpdmUgYXN5bmMgZnVuYyB0aGF0IGlzXG4gICAgICAvLyAgICAgZ29pbmcgdG8gYmxvY2sgdG8gcmV0dXJuIGEgdmFsdWUgc3luY2hyb25vdXNseSBpbiB0aGUgaW50ZXJwcmV0ZXIpIE9SXG4gICAgICAvLyAoNSkgaGF2ZSBzZWVuIGFuIGVtcHR5IGV2ZW50IHF1ZXVlIGluIG5hdGl2ZUdldENhbGxiYWNrIChubyBldmVudHMpIE9SXG4gICAgICAvLyAoNikgaGF2ZSBzZWVuIGEgbmF0aXZlU2V0Q2FsbGJhY2tSZXRWYWwgY2FsbCBpbiBydW5VbnRpbENhbGxiYWNrUmV0dXJuIG1vZGVcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB1c2VyQ29kZVJvdyA9IHNlbGVjdENvZGVGdW5jLmNhbGwodGhpcyk7XG4gICAgaW5Vc2VyQ29kZSA9ICgtMSAhPT0gdXNlckNvZGVSb3cpO1xuICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSd2ZSBhcnJpdmVkIGF0IGEgbmV3IGJyZWFrcG9pbnQ6XG4gICAgLy8gICgxKSBzaG91bGQgYmUgaW4gdXNlciBjb2RlXG4gICAgLy8gICgyKSBzaG91bGQgbmV2ZXIgaGFwcGVuIHdoaWxlIHVud2luZGluZ1xuICAgIC8vICAoMykgc2hvdWxkIG5ldmVyIGhhcHBlbiB3aGVuIHJldmlzaXRpbmcgYW4gaW50ZXJzdGl0aWFsIG5vZGVcbiAgICAvLyAgKDQpIHJlcXVpcmVzIGVpdGhlclxuICAgIC8vICAgKGEpIGF0SW5pdGlhbEJyZWFrcG9pbnQgT1JcbiAgICAvLyAgIChiKSBpc0FjZUJyZWFrcG9pbnRSb3coKSBBTkQgbm90IHN0aWxsIGF0IHRoZSBzYW1lIGxpbmUgbnVtYmVyIHdoZXJlXG4gICAgLy8gICAgICAgd2UgaGF2ZSBhbHJlYWR5IHN0b3BwZWQgZnJvbSB0aGUgbGFzdCBzdGVwL2JyZWFrcG9pbnRcbiAgICBpZiAoaW5Vc2VyQ29kZSAmJiAhdW53aW5kaW5nQWZ0ZXJTdGVwICYmICF0aGlzLmF0SW50ZXJzdGl0aWFsTm9kZSAmJlxuICAgICAgICAoYXRJbml0aWFsQnJlYWtwb2ludCB8fFxuICAgICAgICAgKHRoaXMuaXNCcmVha3BvaW50Um93KHVzZXJDb2RlUm93KSAmJlxuICAgICAgICAgICF0aGlzLmZpbmRTdG9wcGVkQXRCcmVha3BvaW50Um93KGN1cnJlbnRTY29wZSwgdXNlckNvZGVSb3cpKSkpIHtcbiAgICAgIC8vIFllcywgYXJyaXZlZCBhdCBhIG5ldyBicmVha3BvaW50OlxuICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgIC8vIE92ZXJ3cml0ZSB0aGUgbmV4dFN0ZXAgdmFsdWUuIChJZiB3ZSBoaXQgYSBicmVha3BvaW50IGR1cmluZyBhIHN0ZXBcbiAgICAgICAgLy8gb3V0IG9yIHN0ZXAgb3ZlciwgdGhpcyB3aWxsIGNhbmNlbCB0aGF0IHN0ZXAgb3BlcmF0aW9uIGVhcmx5KVxuICAgICAgICB0aGlzLm5leHRTdGVwID0gU3RlcFR5cGUuUlVOO1xuICAgICAgICB0aGlzLm9uTmV4dFN0ZXBDaGFuZ2VkLm5vdGlmeU9ic2VydmVycygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vblBhdXNlLm5vdGlmeU9ic2VydmVycygpO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgc29tZSBwcm9wZXJ0aWVzIGFib3V0IHdoZXJlIHdlIHN0b3BwZWQ6XG4gICAgICB0aGlzLnJlcGxhY2VTdG9wcGVkQXRCcmVha3BvaW50Um93Rm9yU2NvcGUoY3VycmVudFNjb3BlLCB1c2VyQ29kZVJvdyk7XG5cbiAgICAgIC8vIE1hcmsgcmVhY2hlZEJyZWFrIHRvIHN0b3Agc3RlcHBpbmcsIGFuZCBzdGFydCB1bndpbmRpbmcgaWYgbmVlZGVkOlxuICAgICAgcmVhY2hlZEJyZWFrID0gdHJ1ZTtcbiAgICAgIHVud2luZGluZ0FmdGVyU3RlcCA9IGNvZGVnZW4uaXNOZXh0U3RlcFNhZmVXaGlsZVVud2luZGluZyh0aGlzLmludGVycHJldGVyKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBJZiB3ZSd2ZSBtb3ZlZCBwYXN0IHRoZSBwbGFjZSBvZiB0aGUgbGFzdCBicmVha3BvaW50IGhpdCB3aXRob3V0IGJlaW5nXG4gICAgLy8gZGVlcGVyIGluIHRoZSBzdGFjaywgd2Ugd2lsbCBkaXNjYXJkIHRoZSBzdG9wcGVkQXRCcmVha3BvaW50IHByb3BlcnRpZXM6XG4gICAgaWYgKGluVXNlckNvZGUgJiYgIXRoaXMuZmluZFN0b3BwZWRBdEJyZWFrcG9pbnRSb3coY3VycmVudFNjb3BlLCB1c2VyQ29kZVJvdykpIHtcbiAgICAgIHRoaXMucmVtb3ZlU3RvcHBlZEF0QnJlYWtwb2ludFJvd0ZvclNjb3BlKGN1cnJlbnRTY29wZSk7XG4gICAgfVxuICAgIC8vIElmIHdlJ3JlIHVud2luZGluZywgY29udGludWUgdG8gdXBkYXRlIHRoZSBzdG9wcGVkQXRCcmVha3BvaW50IHByb3BlcnRpZXNcbiAgICAvLyB0byBlbnN1cmUgdGhhdCB3ZSBoYXZlIHRoZSByaWdodCBwcm9wZXJ0aWVzIHN0b3JlZCB3aGVuIHRoZSB1bndpbmQgY29tcGxldGVzOlxuICAgIGlmIChpblVzZXJDb2RlICYmIHVud2luZGluZ0FmdGVyU3RlcCkge1xuICAgICAgdGhpcy5yZXBsYWNlU3RvcHBlZEF0QnJlYWtwb2ludFJvd0ZvclNjb3BlKGN1cnJlbnRTY29wZSwgdXNlckNvZGVSb3cpO1xuICAgIH1cbiAgICB0aGlzLmV4ZWN1dGlvbkVycm9yID0gc2FmZVN0ZXBJbnRlcnByZXRlcih0aGlzKTtcbiAgICBpZiAoIXRoaXMuZXhlY3V0aW9uRXJyb3IgJiYgdGhpcy5pbnRlcnByZXRlci5zdGF0ZVN0YWNrLmxlbmd0aCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy5pbnRlcnByZXRlci5zdGF0ZVN0YWNrWzBdLCBub2RlVHlwZSA9IHN0YXRlLm5vZGUudHlwZTtcbiAgICAgIHRoaXMuYXRJbnRlcnN0aXRpYWxOb2RlID0gSU5URVJTVElUSUFMX05PREVTLmhhc093blByb3BlcnR5KG5vZGVUeXBlKTtcbiAgICAgIGlmIChpblVzZXJDb2RlKSB7XG4gICAgICAgIGRvbmVVc2VyTGluZSA9IGRvbmVVc2VyTGluZSB8fCAoc3RhdGUuZG9uZSB8fCB0aGlzLmF0SW50ZXJzdGl0aWFsTm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFja0RlcHRoID0gdGhpcy5pbnRlcnByZXRlci5zdGF0ZVN0YWNrLmxlbmd0aDtcbiAgICAgIC8vIFJlbWVtYmVyIHRoZSBzdGFjayBkZXB0aHMgb2YgY2FsbCBleHByZXNzaW9ucyAoc28gd2UgY2FuIGltcGxlbWVudCAnc3RlcCBvdXQnKVxuXG4gICAgICAvLyBUcnVuY2F0ZSBhbnkgaGlzdG9yeSBvZiBjYWxsIGV4cHJlc3Npb25zIHNlZW4gZGVlcGVyIHRoYW4gb3VyIGN1cnJlbnQgc3RhY2sgcG9zaXRpb246XG4gICAgICBmb3IgKHZhciBkZXB0aCA9IHN0YWNrRGVwdGggKyAxO1xuICAgICAgICAgICAgZGVwdGggPD0gdGhpcy5tYXhWYWxpZENhbGxFeHByZXNzaW9uRGVwdGg7XG4gICAgICAgICAgICBkZXB0aCsrKSB7XG4gICAgICAgIHRoaXMuY2FsbEV4cHJlc3Npb25TZWVuQXREZXB0aFtkZXB0aF0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWF4VmFsaWRDYWxsRXhwcmVzc2lvbkRlcHRoID0gc3RhY2tEZXB0aDtcblxuICAgICAgaWYgKGluVXNlckNvZGUgJiYgdGhpcy5pbnRlcnByZXRlci5zdGF0ZVN0YWNrWzBdLm5vZGUudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIC8vIFN0b3JlIHRoYXQgd2UndmUgc2VlbiBhIGNhbGwgZXhwcmVzc2lvbiBhdCB0aGlzIGRlcHRoIGluIGNhbGxFeHByZXNzaW9uU2VlbkF0RGVwdGg6XG4gICAgICAgIHRoaXMuY2FsbEV4cHJlc3Npb25TZWVuQXREZXB0aFtzdGFja0RlcHRoXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAvLyBTdG9yZSB0aGUgZmlyc3QgY2FsbCBleHByZXNzaW9uIHN0YWNrIGRlcHRoIHNlZW4gd2hpbGUgaW4gdGhpcyBzdGVwIG9wZXJhdGlvbjpcbiAgICAgICAgaWYgKGluVXNlckNvZGUgJiYgdGhpcy5pbnRlcnByZXRlci5zdGF0ZVN0YWNrWzBdLm5vZGUudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmZpcnN0Q2FsbFN0YWNrRGVwdGhUaGlzU3RlcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RDYWxsU3RhY2tEZXB0aFRoaXNTdGVwID0gc3RhY2tEZXB0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3IgdGhlIHN0ZXAgaW4gY2FzZSwgd2Ugd2FudCB0byBzdG9wIHRoZSBpbnRlcnByZXRlciBhcyBzb29uIGFzIHdlIGVudGVyIHRoZSBjYWxsZWU6XG4gICAgICAgIGlmICghZG9uZVVzZXJMaW5lICYmXG4gICAgICAgICAgICBpblVzZXJDb2RlICYmXG4gICAgICAgICAgICB0aGlzLm5leHRTdGVwID09PSBTdGVwVHlwZS5JTiAmJlxuICAgICAgICAgICAgc3RhY2tEZXB0aCA+IHRoaXMuZmlyc3RDYWxsU3RhY2tEZXB0aFRoaXNTdGVwKSB7XG4gICAgICAgICAgcmVhY2hlZEJyZWFrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZnRlciB0aGUgaW50ZXJwcmV0ZXIgc2F5cyBhIG5vZGUgaXMgXCJkb25lXCIgKG1lYW5pbmcgaXQgaXMgdGltZSB0byBzdG9wKSwgd2Ugd2lsbFxuICAgICAgICAvLyBhZHZhbmNlIGEgbGl0dGxlIGZ1cnRoZXIgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IHN0YXRlbWVudC4gV2UgYWNoaWV2ZSB0aGlzIGJ5XG4gICAgICAgIC8vIGNvbnRpbnVpbmcgdG8gc2V0IHVud2luZGluZ0FmdGVyU3RlcCB0byB0cnVlIHRvIGtlZXAgdGhlIGxvb3AgZ29pbmc6XG4gICAgICAgIGlmIChkb25lVXNlckxpbmUgfHwgcmVhY2hlZEJyZWFrKSB7XG4gICAgICAgICAgdmFyIHdhc1Vud2luZGluZyA9IHVud2luZGluZ0FmdGVyU3RlcDtcbiAgICAgICAgICAvLyBzdGVwKCkgYWRkaXRpb25hbCB0aW1lcyBpZiB3ZSBrbm93IGl0IHRvIGJlIHNhZmUgdG8gZ2V0IHVzIHRvIHRoZSBuZXh0IHN0YXRlbWVudDpcbiAgICAgICAgICB1bndpbmRpbmdBZnRlclN0ZXAgPSBjb2RlZ2VuLmlzTmV4dFN0ZXBTYWZlV2hpbGVVbndpbmRpbmcodGhpcy5pbnRlcnByZXRlcik7XG4gICAgICAgICAgaWYgKHdhc1Vud2luZGluZyAmJiAhdW53aW5kaW5nQWZ0ZXJTdGVwKSB7XG4gICAgICAgICAgICAvLyBkb25lIHVud2luZGluZy4uIHNlbGVjdCBjb2RlIHRoYXQgaXMgbmV4dCB0byBleGVjdXRlOlxuICAgICAgICAgICAgdXNlckNvZGVSb3cgPSBzZWxlY3RDb2RlRnVuYy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgaW5Vc2VyQ29kZSA9ICgtMSAhPT0gdXNlckNvZGVSb3cpO1xuICAgICAgICAgICAgaWYgKCFpblVzZXJDb2RlKSB7XG4gICAgICAgICAgICAgIC8vIG5vdCBpbiB1c2VyIGNvZGUsIHNvIGtlZXAgdW53aW5kaW5nIGFmdGVyIGFsbC4uLlxuICAgICAgICAgICAgICB1bndpbmRpbmdBZnRlclN0ZXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgocmVhY2hlZEJyZWFrIHx8IGRvbmVVc2VyTGluZSkgJiYgIXVud2luZGluZ0FmdGVyU3RlcCkge1xuICAgICAgICAgIGlmICh0aGlzLm5leHRTdGVwID09PSBTdGVwVHlwZS5PVVQgJiZcbiAgICAgICAgICAgICAgc3RhY2tEZXB0aCA+IHRoaXMuc3RlcE91dFRvU3RhY2tEZXB0aCkge1xuICAgICAgICAgICAgLy8gdHJ5aW5nIHRvIHN0ZXAgb3V0LCBidXQgd2UgZGlkbid0IGdldCBvdXQgeWV0Li4uIGNvbnRpbnVlIG9uLlxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0U3RlcCA9PT0gU3RlcFR5cGUuT1ZFUiAmJlxuICAgICAgICAgICAgICB0eXBlb2YgdGhpcy5maXJzdENhbGxTdGFja0RlcHRoVGhpc1N0ZXAgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgIHN0YWNrRGVwdGggPiB0aGlzLmZpcnN0Q2FsbFN0YWNrRGVwdGhUaGlzU3RlcCkge1xuICAgICAgICAgICAgLy8gdHJ5aW5nIHRvIHN0ZXAgb3ZlciwgYW5kIHdlJ3JlIGluIGRlZXBlciBpbnNpZGUgYSBmdW5jdGlvbiBjYWxsLi4uIGNvbnRpbnVlIG5leHQgb25UaWNrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE91ciBzdGVwIG9wZXJhdGlvbiBpcyBjb21wbGV0ZSwgcmVzZXQgbmV4dFN0ZXAgdG8gU3RlcFR5cGUuUlVOIHRvXG4gICAgICAgICAgICAvLyByZXR1cm4gdG8gYSBub3JtYWwgJ2JyZWFrJyBzdGF0ZTpcbiAgICAgICAgICAgIHRoaXMubmV4dFN0ZXAgPSBTdGVwVHlwZS5SVU47XG4gICAgICAgICAgICB0aGlzLm9uTmV4dFN0ZXBDaGFuZ2VkLm5vdGlmeU9ic2VydmVycygpO1xuICAgICAgICAgICAgaWYgKGluVXNlckNvZGUpIHtcbiAgICAgICAgICAgICAgLy8gU3RvcmUgc29tZSBwcm9wZXJ0aWVzIGFib3V0IHdoZXJlIHdlIHN0b3BwZWQ6XG4gICAgICAgICAgICAgIHRoaXMucmVwbGFjZVN0b3BwZWRBdEJyZWFrcG9pbnRSb3dGb3JTY29wZSh0aGlzLmludGVycHJldGVyLmdldFNjb3BlKCksIHVzZXJDb2RlUm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0ZXBPdXRUb1N0YWNrRGVwdGg7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5maXJzdENhbGxTdGFja0RlcHRoVGhpc1N0ZXA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuZXhlY3V0aW9uRXJyb3IpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihpblVzZXJDb2RlID8gKHVzZXJDb2RlUm93ICsgMSkgOiB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5leGVjdXRlTG9vcERlcHRoLS07XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChyZWFjaGVkQnJlYWsgJiYgYXRNYXhTcGVlZCkge1xuICAgIC8vIElmIHdlIHdlcmUgcnVubmluZyBhdE1heFNwZWVkIGFuZCBqdXN0IHJlYWNoZWQgYSBicmVha3BvaW50LCB0aGVcbiAgICAvLyBjb2RlIG1heSBub3QgYmUgc2VsZWN0ZWQgaW4gdGhlIGVkaXRvciwgc28gZG8gaXQgbm93OlxuICAgIHRoaXMuc2VsZWN0Q3VycmVudENvZGUoKTtcbiAgfVxuICB0aGlzLmV4ZWN1dGVMb29wRGVwdGgtLTtcbn07XG5cbi8qKlxuICogSGVscGVyIHRoYXQgd3JhcHMgc29tZSBlcnJvciBwcmVwcm9jZXNzaW5nIGJlZm9yZSB3ZSBub3RpZnkgb2JzZXJ2ZXJzIHRoYXRcbiAqIGFuIGV4ZWN1dGlvbiBlcnJvciBoYXMgb2NjdXJyZWQuIE9wZXJhdGVzIG9uIHRoZSBjdXJyZW50IGVycm9yIHRoYXQgaXNcbiAqIGFscmVhZHkgc2F2ZWQgYXMgdGhpcy5leGVjdXRpb25FcnJvclxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGluZU51bWJlcl1cbiAqL1xuSlNJbnRlcnByZXRlci5wcm90b3R5cGUuaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAobGluZU51bWJlcikge1xuICBpZiAoIWxpbmVOdW1iZXIgJiYgdGhpcy5leGVjdXRpb25FcnJvciBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSB7XG4gICAgLy8gc3ludGF4IGVycm9ycyBjYW1lIGJlZm9yZSBleGVjdXRpb24gKGR1cmluZyBwYXJzaW5nKSwgc28gd2UgbmVlZFxuICAgIC8vIHRvIGRldGVybWluZSB0aGUgcHJvcGVyIGxpbmUgbnVtYmVyIGJ5IGxvb2tpbmcgYXQgdGhlIGV4Y2VwdGlvblxuICAgIGxpbmVOdW1iZXIgPSB0aGlzLmV4ZWN1dGlvbkVycm9yLmxvYy5saW5lO1xuICAgIC8vIE5vdyBzZWxlY3QgdGhpcyBsb2NhdGlvbiBpbiB0aGUgZWRpdG9yLCBzaW5jZSB3ZSBrbm93IHdlIGRpZG4ndCBoaXRcbiAgICAvLyB0aGlzIHdoaWxlIGV4ZWN1dGluZyAoaW4gd2hpY2ggY2FzZSwgaXQgd291bGQgYWxyZWFkeSBoYXZlIGJlZW4gc2VsZWN0ZWQpXG4gICAgY29kZWdlbi5zZWxlY3RFZGl0b3JSb3dDb2xFcnJvcihcbiAgICAgICAgdGhpcy5zdHVkaW9BcHAuZWRpdG9yLFxuICAgICAgICBsaW5lTnVtYmVyIC0gMSxcbiAgICAgICAgdGhpcy5leGVjdXRpb25FcnJvci5sb2MuY29sdW1uKTtcbiAgfVxuXG4gIC8vIFNlbGVjdCBjb2RlIHRoYXQganVzdCBleGVjdXRlZDpcbiAgdGhpcy5zZWxlY3RDdXJyZW50Q29kZShcImFjZV9lcnJvclwiKTtcbiAgLy8gR3JhYiBsaW5lIG51bWJlciBpZiB3ZSBkb24ndCBoYXZlIG9uZSBhbHJlYWR5OlxuICBpZiAoIWxpbmVOdW1iZXIpIHtcbiAgICBsaW5lTnVtYmVyID0gMSArIHRoaXMuZ2V0TmVhcmVzdFVzZXJDb2RlTGluZSgpO1xuICB9XG5cbiAgdGhpcy5vbkV4ZWN1dGlvbkVycm9yLm5vdGlmeU9ic2VydmVycyh0aGlzLmV4ZWN1dGlvbkVycm9yLCBsaW5lTnVtYmVyKTtcbn07XG5cbi8qKlxuICogSGVscGVyIHRvIGNyZWF0ZSBhbiBpbnRlcnBldGVyIHByaW1pdGl2ZSB2YWx1ZS4gVXNlZnVsIHdoZW4gZXh0ZW5kaW5nIHRoZVxuICogaW50ZXJwcmV0ZXIgd2l0aG91dCByZWx5aW5nIG9uIGNvZGVnZW4gbWFyc2hhbGxpbmcgaGVscGVycy5cbiAqL1xuSlNJbnRlcnByZXRlci5wcm90b3R5cGUuY3JlYXRlUHJpbWl0aXZlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgaWYgKHRoaXMuaW50ZXJwcmV0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcnByZXRlci5jcmVhdGVQcmltaXRpdmUoZGF0YSk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JhcHBlciB0byBJbnRlcnByZXRlcidzIGdldFByb3BlcnR5IChleHRlbmRlZCBmb3IgY3VzdG9tIG1hcnNoYWxpbmcpXG4gKlxuICogRmV0Y2ggYSBwcm9wZXJ0eSB2YWx1ZSBmcm9tIGEgZGF0YSBvYmplY3QuXG4gKiBAcGFyYW0geyFPYmplY3R9IGludGVycGV0ZXIgSW50ZXJwcmV0ZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyFGdW5jdGlvbn0gYmFzZUdldFByb3BlcnR5IE9yaWdpbmFsIGdldFByb3BlcnR5KCkgaW1wbGVtZW50YXRpb24uXG4gKiBAcGFyYW0geyFPYmplY3R9IG9iaiBEYXRhIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gbmFtZSBOYW1lIG9mIHByb3BlcnR5LlxuICogQHJldHVybiB7IU9iamVjdH0gUHJvcGVydHkgdmFsdWUgKG1heSBiZSBVTkRFRklORUQpLlxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5nZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChcbiAgICBpbnRlcnByZXRlcixcbiAgICBiYXNlR2V0UHJvcGVydHksXG4gICAgb2JqLFxuICAgIG5hbWUpIHtcbiAgbmFtZSA9IG5hbWUudG9TdHJpbmcoKTtcbiAgdmFyIG5hdGl2ZVBhcmVudDtcbiAgaWYgKG9iai5pc0N1c3RvbU1hcnNoYWwgfHxcbiAgICAgIChvYmogPT09IHRoaXMuZ2xvYmFsU2NvcGUgJiZcbiAgICAgICAgICAoISEobmF0aXZlUGFyZW50ID0gdGhpcy5jdXN0b21NYXJzaGFsR2xvYmFsUHJvcGVydGllc1tuYW1lXSkpKSkge1xuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAob2JqLmlzQ3VzdG9tTWFyc2hhbCkge1xuICAgICAgdmFsdWUgPSBvYmouZGF0YVtuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBuYXRpdmVQYXJlbnRbbmFtZV07XG4gICAgfVxuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAnYm9vbGVhbicgfHwgdHlwZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgdHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBpbnRlcnByZXRlci5jcmVhdGVQcmltaXRpdmUodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29kZWdlbi5tYXJzaGFsTmF0aXZlVG9JbnRlcnByZXRlcihpbnRlcnByZXRlciwgdmFsdWUsIG9iai5kYXRhKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2VHZXRQcm9wZXJ0eS5jYWxsKGludGVycHJldGVyLCBvYmosIG5hbWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyYXBwZXIgdG8gSW50ZXJwcmV0ZXIncyBzZXRQcm9wZXJ0eSAoZXh0ZW5kZWQgZm9yIGN1c3RvbSBtYXJzaGFsaW5nKVxuICpcbiAqIFNldCBhIHByb3BlcnR5IHZhbHVlIG9uIGEgZGF0YSBvYmplY3QuXG4gKiBAcGFyYW0geyFPYmplY3R9IGludGVycGV0ZXIgSW50ZXJwcmV0ZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyFGdW5jdGlvbn0gYmFzZVNldFByb3BlcnR5IE9yaWdpbmFsIHNldFByb3BlcnR5KCkgaW1wbGVtZW50YXRpb24uXG4gKiBAcGFyYW0geyFPYmplY3R9IG9iaiBEYXRhIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gbmFtZSBOYW1lIG9mIHByb3BlcnR5LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdF9maXhlZCBVbmNoYW5nZWFibGUgcHJvcGVydHkgaWYgdHJ1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0X25vbmVudW0gTm9uLWVudW1lcmFibGUgcHJvcGVydHkgaWYgdHJ1ZS5cbiAqL1xuSlNJbnRlcnByZXRlci5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBmdW5jdGlvbihcbiAgICBpbnRlcnByZXRlcixcbiAgICBiYXNlU2V0UHJvcGVydHksXG4gICAgb2JqLFxuICAgIG5hbWUsXG4gICAgdmFsdWUsXG4gICAgb3B0X2ZpeGVkLFxuICAgIG9wdF9ub25lbnVtKSB7XG4gIG5hbWUgPSBuYW1lLnRvU3RyaW5nKCk7XG4gIHZhciBuYXRpdmVQYXJlbnQ7XG4gIGlmIChvYmouaXNDdXN0b21NYXJzaGFsKSB7XG4gICAgb2JqLmRhdGFbbmFtZV0gPSBjb2RlZ2VuLm1hcnNoYWxJbnRlcnByZXRlclRvTmF0aXZlKGludGVycHJldGVyLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAob2JqID09PSB0aGlzLmdsb2JhbFNjb3BlICYmXG4gICAgICAoISEobmF0aXZlUGFyZW50ID0gdGhpcy5jdXN0b21NYXJzaGFsR2xvYmFsUHJvcGVydGllc1tuYW1lXSkpKSB7XG4gICAgbmF0aXZlUGFyZW50W25hbWVdID0gY29kZWdlbi5tYXJzaGFsSW50ZXJwcmV0ZXJUb05hdGl2ZShpbnRlcnByZXRlciwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlU2V0UHJvcGVydHkuY2FsbChcbiAgICAgICAgaW50ZXJwcmV0ZXIsIG9iaiwgbmFtZSwgdmFsdWUsIG9wdF9maXhlZCwgb3B0X25vbmVudW0pO1xuICB9XG59O1xuXG4vKipcbiAqIFNlbGVjdHMgY29kZSBpbiBkcm9wbGV0L2FjZSBlZGl0b3IuXG4gKlxuICogUmV0dXJucyB0aGUgcm93IChsaW5lKSBvZiBjb2RlIGhpZ2hsaWdodGVkLiBJZiBub3RoaW5nIGlzIGhpZ2hsaWdodGVkXG4gKiBiZWNhdXNlIGl0IGlzIG91dHNpZGUgb2YgdGhlIHVzZXJDb2RlIGFyZWEsIHRoZSByZXR1cm4gdmFsdWUgaXMgLTFcbiAqL1xuSlNJbnRlcnByZXRlci5wcm90b3R5cGUuc2VsZWN0Q3VycmVudENvZGUgPSBmdW5jdGlvbiAoaGlnaGxpZ2h0Q2xhc3MpIHtcbiAgaWYgKHRoaXMuc3R1ZGlvQXBwLmhpZGVTb3VyY2UpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgcmV0dXJuIGNvZGVnZW4uc2VsZWN0Q3VycmVudENvZGUodGhpcy5pbnRlcnByZXRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2RlSW5mby5jdW11bGF0aXZlTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZGVJbmZvLnVzZXJDb2RlU3RhcnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29kZUluZm8udXNlckNvZGVMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R1ZGlvQXBwLmVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0Q2xhc3MpO1xufTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgY3VycmVudCBsaW5lIG9mIGNvZGUgaW4gZHJvcGxldC9hY2UgZWRpdG9yLlxuICpcbiAqIFJldHVybnMgdGhlIGxpbmUgb2YgY29kZSB3aGVyZSB0aGUgaW50ZXJwcmV0ZXIgaXMgYXQuIElmIGl0IGlzIG91dHNpZGVcbiAqIG9mIHRoZSB1c2VyQ29kZSBhcmVhLCB0aGUgcmV0dXJuIHZhbHVlIGlzIC0xXG4gKi9cbkpTSW50ZXJwcmV0ZXIucHJvdG90eXBlLmdldFVzZXJDb2RlTGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHVzZXJDb2RlUm93ID0gLTE7XG4gIGlmICh0aGlzLmludGVycHJldGVyLnN0YXRlU3RhY2tbMF0pIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJwcmV0ZXIuc3RhdGVTdGFja1swXS5ub2RlO1xuICAgIC8vIEFkanVzdCBzdGFydC9lbmQgYnkgdXNlckNvZGVTdGFydE9mZnNldCBzaW5jZSB0aGUgY29kZSBydW5uaW5nXG4gICAgLy8gaGFzIGJlZW4gZXhwYW5kZWQgdnMuIHdoYXQgdGhlIHVzZXIgc2VlcyBpbiB0aGUgZWRpdG9yIHdpbmRvdzpcbiAgICB2YXIgc3RhcnQgPSBub2RlLnN0YXJ0IC0gdGhpcy5jb2RlSW5mby51c2VyQ29kZVN0YXJ0T2Zmc2V0O1xuXG4gICAgLy8gT25seSByZXR1cm4gYSB2YWxpZCB1c2VyQ29kZVJvdyBpZiB0aGUgbm9kZSBiZWluZyBleGVjdXRlZCBpcyBpbnNpZGUgdGhlXG4gICAgLy8gdXNlcidzIGNvZGUgKG5vdCBpbnNpZGUgY29kZSB3ZSBpbnNlcnRlZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlaXIgY29kZSB0aGF0XG4gICAgLy8gaXMgbm90IHZpc2libGUgaW4gdGhlIGVkaXRvcik6XG4gICAgaWYgKHN0YXJ0ID49IDAgJiYgc3RhcnQgPCB0aGlzLmNvZGVJbmZvLnVzZXJDb2RlTGVuZ3RoKSB7XG4gICAgICB1c2VyQ29kZVJvdyA9IGNvZGVnZW4uYWNlRmluZFJvdyh0aGlzLmNvZGVJbmZvLmN1bXVsYXRpdmVMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2RlSW5mby5jdW11bGF0aXZlTGVuZ3RoLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVzZXJDb2RlUm93O1xufTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgY3VycmVudCBsaW5lIG9mIGNvZGUgaW4gZHJvcGxldC9hY2UgZWRpdG9yLiBXYWxrcyB1cCB0aGUgc3RhY2sgaWZcbiAqIG5vdCBjdXJyZW50bHkgaW4gdGhlIHVzZXIgY29kZSBhcmVhLlxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5nZXROZWFyZXN0VXNlckNvZGVMaW5lID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdHVkaW9BcHAuaGlkZVNvdXJjZSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICB2YXIgdXNlckNvZGVSb3cgPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmludGVycHJldGVyLnN0YXRlU3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJwcmV0ZXIuc3RhdGVTdGFja1tpXS5ub2RlO1xuICAgIC8vIEFkanVzdCBzdGFydC9lbmQgYnkgdXNlckNvZGVTdGFydE9mZnNldCBzaW5jZSB0aGUgY29kZSBydW5uaW5nXG4gICAgLy8gaGFzIGJlZW4gZXhwYW5kZWQgdnMuIHdoYXQgdGhlIHVzZXIgc2VlcyBpbiB0aGUgZWRpdG9yIHdpbmRvdzpcbiAgICB2YXIgc3RhcnQgPSBub2RlLnN0YXJ0IC0gdGhpcy5jb2RlSW5mby51c2VyQ29kZVN0YXJ0T2Zmc2V0O1xuXG4gICAgLy8gT25seSByZXR1cm4gYSB2YWxpZCB1c2VyQ29kZVJvdyBpZiB0aGUgbm9kZSBiZWluZyBleGVjdXRlZCBpcyBpbnNpZGUgdGhlXG4gICAgLy8gdXNlcidzIGNvZGUgKG5vdCBpbnNpZGUgY29kZSB3ZSBpbnNlcnRlZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlaXIgY29kZSB0aGF0XG4gICAgLy8gaXMgbm90IHZpc2libGUgaW4gdGhlIGVkaXRvcik6XG4gICAgaWYgKHN0YXJ0ID49IDAgJiYgc3RhcnQgPCB0aGlzLmNvZGVJbmZvLnVzZXJDb2RlTGVuZ3RoKSB7XG4gICAgICB1c2VyQ29kZVJvdyA9IGNvZGVnZW4uYWNlRmluZFJvdyh0aGlzLmNvZGVJbmZvLmN1bXVsYXRpdmVMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2RlSW5mby5jdW11bGF0aXZlTGVuZ3RoLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdXNlckNvZGVSb3c7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBwcm9wZXJ0eSBpbiB0aGUgaW50ZXJwcmV0ZXIncyBnbG9iYWwgc2NvcGUuIFdoZW4gYSBwYXJlbnQgaXNcbiAqIHN1cHBsaWVkIGFuZCB0aGF0IHBhcmVudCBvYmplY3QgaXMgaW4gY29kZWdlbidzIGN1c3RvbU1hcnNoYWxPYmplY3RMaXN0LFxuICogcHJvcGVydHkgZ2V0cy9zZXRzIGluIHRoZSBpbnRlcnByZXRlciB3aWxsIGJlIHJlZmxlY3RlZCBvbiB0aGUgbmF0aXZlIHBhcmVudFxuICogb2JqZWN0LiBGdW5jdGlvbnMgY2FuIGFsc28gYmUgaW5zZXJ0ZWQgaW50byB0aGUgZ2xvYmFsIG5hbWVzcGFjZSB1c2luZyB0aGlzXG4gKiBtZXRob2QuIElmIGEgcGFyZW50IGlzIHN1cHBsaWVkLCB0aGV5IHdpbGwgYmUgaW52b2tlZCBuYXRpdmVseSB3aXRoIHRoYXRcbiAqIHBhcmVudCBhcyB0aGUgdGhpcyBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBmb3IgdGhlIHByb3BlcnR5IGluIHRoZSBnbG9iYWwgc2NvcGUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIE5hdGl2ZSB2YWx1ZSB0aGF0IHdpbGwgYmUgbWFyc2hhbGxlZCB0byB0aGUgaW50ZXJwcmV0ZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50IChPcHRpb25hbCkgcGFyZW50IGZvciB0aGUgbmF0aXZlIHZhbHVlLlxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5jcmVhdGVHbG9iYWxQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgcGFyZW50KSB7XG5cbiAgdmFyIGludGVycHJldGVyVmFsO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHdyYXBwZXIgPSBjb2RlZ2VuLm1ha2VOYXRpdmVNZW1iZXJGdW5jdGlvbih7XG4gICAgICAgIGludGVycHJldGVyOiB0aGlzLmludGVycHJldGVyLFxuICAgICAgICBuYXRpdmVGdW5jOiB2YWx1ZSxcbiAgICAgICAgbmF0aXZlUGFyZW50T2JqOiBwYXJlbnRcbiAgICB9KTtcbiAgICBpbnRlcnByZXRlclZhbCA9IHRoaXMuaW50ZXJwcmV0ZXIuY3JlYXRlTmF0aXZlRnVuY3Rpb24od3JhcHBlcik7XG4gIH0gZWxzZSB7XG4gICAgaW50ZXJwcmV0ZXJWYWwgPSBjb2RlZ2VuLm1hcnNoYWxOYXRpdmVUb0ludGVycHJldGVyKFxuICAgICAgICB0aGlzLmludGVycHJldGVyLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdXRpbHMudmFsdWVPcihwYXJlbnQsIHdpbmRvdykpO1xuICB9XG5cbiAgLy8gQnlwYXNzIHNldFByb3BlcnR5IHNpbmNlIHdlJ3ZlIGhvb2tlZCBpdCBhbmQgaXQgd2lsbCBub3QgY3JlYXRlIHRoZVxuICAvLyBwcm9wZXJ0eSBpZiBpdCBpcyBpbiBjdXN0b21NYXJzaGFsR2xvYmFsUHJvcGVydGllc1xuICB0aGlzLmJhc2VTZXRQcm9wZXJ0eS5jYWxsKFxuICAgICAgdGhpcy5pbnRlcnByZXRlcixcbiAgICAgIHRoaXMuZ2xvYmFsU2NvcGUsXG4gICAgICBuYW1lLFxuICAgICAgaW50ZXJwcmV0ZXJWYWwpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnRlcnByZXRlciBmdW5jdGlvbiBvYmplY3QgY29ycmVzcG9uZGluZyB0byAnZnVuY05hbWUnIGlmIGFcbiAqIGZ1bmN0aW9uIHdpdGggdGhhdCBuYW1lIGlzIGZvdW5kIGluIHRoZSBpbnRlcnByZXRlcidzIGdsb2JhbCBzY29wZS5cbiAqL1xuSlNJbnRlcnByZXRlci5wcm90b3R5cGUuZmluZEdsb2JhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmNOYW1lKSB7XG4gIHZhciBmdW5jT2JqID0gdGhpcy5pbnRlcnByZXRlci5nZXRQcm9wZXJ0eSh0aGlzLmdsb2JhbFNjb3BlLCBmdW5jTmFtZSk7XG4gIGlmIChmdW5jT2JqLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnVuY09iajtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCBvZiB0aGUgZ2xvYmFsIGZ1bmN0aW9uc1xuICogaW4gdGhlIGludGVycHJldGVyJ3MgZ2xvYmFsIHNjb3BlLiBCdWlsdC1pbiBnbG9iYWwgZnVuY3Rpb25zIGFyZSBleGNsdWRlZC5cbiAqL1xuSlNJbnRlcnByZXRlci5wcm90b3R5cGUuZ2V0R2xvYmFsRnVuY3Rpb25OYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJ1aWx0SW5FeGNsdXNpb25MaXN0ID0gWyBcImV2YWxcIiwgXCJnZXRDYWxsYmFja1wiLCBcInNldENhbGxiYWNrUmV0VmFsXCIgXTtcblxuICB2YXIgbmFtZXMgPSBbXTtcbiAgZm9yICh2YXIgb2JqTmFtZSBpbiB0aGlzLmdsb2JhbFNjb3BlLnByb3BlcnRpZXMpIHtcbiAgICB2YXIgb2JqZWN0ID0gdGhpcy5nbG9iYWxTY29wZS5wcm9wZXJ0aWVzW29iak5hbWVdO1xuICAgIGlmIChvYmplY3QudHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAhb2JqZWN0Lm5hdGl2ZUZ1bmMgJiZcbiAgICAgICAgYnVpbHRJbkV4Y2x1c2lvbkxpc3QuaW5kZXhPZihvYmpOYW1lKSA9PT0gLTEpIHtcbiAgICAgIG5hbWVzLnB1c2gob2JqTmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgb2YgdGhlIGZ1bmN0aW9ucyBkZWZpbmVkXG4gKiBpbnNpZGUgb3RoZXIgZnVuY3Rpb25zLlxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5nZXRMb2NhbEZ1bmN0aW9uTmFtZXMgPSBmdW5jdGlvbiAoc2NvcGUpIHtcbiAgaWYgKCFzY29wZSkge1xuICAgIHNjb3BlID0gdGhpcy5nbG9iYWxTY29wZTtcbiAgfVxuICB2YXIgbmFtZXMgPSBbXTtcbiAgZm9yICh2YXIgb2JqTmFtZSBpbiBzY29wZS5wcm9wZXJ0aWVzKSB7XG4gICAgdmFyIG9iamVjdCA9IHNjb3BlLnByb3BlcnRpZXNbb2JqTmFtZV07XG4gICAgaWYgKG9iamVjdC50eXBlID09PSAnZnVuY3Rpb24nICYmICFvYmplY3QubmF0aXZlRnVuYyAmJiBvYmplY3Qubm9kZSkge1xuICAgICAgaWYgKHNjb3BlICE9PSB0aGlzLmdsb2JhbFNjb3BlKSB7XG4gICAgICAgIG5hbWVzLnB1c2gob2JqTmFtZSk7XG4gICAgICB9XG4gICAgICB2YXIgbG9jYWxTY29wZSA9IHRoaXMuaW50ZXJwcmV0ZXIuY3JlYXRlU2NvcGUob2JqZWN0Lm5vZGUuYm9keSwgb2JqZWN0LnBhcmVudFNjb3BlKTtcbiAgICAgIHZhciBsb2NhbE5hbWVzID0gdGhpcy5nZXRMb2NhbEZ1bmN0aW9uTmFtZXMobG9jYWxTY29wZSk7XG4gICAgICBuYW1lcyA9IG5hbWVzLmNvbmNhdChsb2NhbE5hbWVzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGludGVycHJldGVyIHN0YXRlIG9iamVjdC5cbiAqL1xuSlNJbnRlcnByZXRlci5wcm90b3R5cGUuZ2V0Q3VycmVudFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5pbnRlcnByZXRlciAmJiB0aGlzLmludGVycHJldGVyLnN0YXRlU3RhY2tbMF07XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIGFuIGV4cHJlc3Npb24gaW4gdGhlIGludGVycHJldGVyJ3MgY3VycmVudCBzY29wZSwgYW5kIHJldHVybiB0aGVcbiAqIHZhbHVlIG9mIHRoZSBldmFsdWF0ZWQgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7IXN0cmluZ30gZXhwcmVzc2lvblxuICogQHJldHVybnMgez99IHZhbHVlIG9mIHRoZSBleHByZXNzaW9uXG4gKiBAdGhyb3dzIGlmIHRoZXJlJ3MgYSBwcm9ibGVtIGV2YWx1YXRpbmcgdGhlIGV4cHJlc3Npb25cbiAqL1xuSlNJbnRlcnByZXRlci5wcm90b3R5cGUuZXZhbEluQ3VycmVudFNjb3BlID0gZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgdmFyIGN1cnJlbnRTY29wZSA9IHRoaXMuaW50ZXJwcmV0ZXIuZ2V0U2NvcGUoKTtcbiAgdmFyIGV2YWxJbnRlcnByZXRlciA9IG5ldyB3aW5kb3cuSW50ZXJwcmV0ZXIoZXhwcmVzc2lvbik7XG4gIC8vIFNldCBzY29wZSB0byB0aGUgY3VycmVudCBzY29wZSBvZiB0aGUgcnVubmluZyBwcm9ncmFtXG4gIC8vIE5PVEU6IHdlIGFyZSBiZWluZyBhIGxpdHRsZSB0cmlja3kgaGVyZSAod2UgYXJlIHJlLXJ1bm5pbmdcbiAgLy8gcGFydCBvZiB0aGUgSW50ZXJwcmV0ZXIgY29uc3RydWN0b3Igd2l0aCBhIGRpZmZlcmVudCBpbnRlcnByZXRlcidzXG4gIC8vIHNjb3BlKVxuICBldmFsSW50ZXJwcmV0ZXIucG9wdWxhdGVTY29wZV8oZXZhbEludGVycHJldGVyLmFzdCwgY3VycmVudFNjb3BlKTtcbiAgZXZhbEludGVycHJldGVyLnN0YXRlU3RhY2sgPSBbe1xuICAgIG5vZGU6IGV2YWxJbnRlcnByZXRlci5hc3QsXG4gICAgc2NvcGU6IGN1cnJlbnRTY29wZSxcbiAgICB0aGlzRXhwcmVzc2lvbjogY3VycmVudFNjb3BlXG4gIH1dO1xuICAvLyBDb3B5IHRoZXNlIHByb3BlcnRpZXMgZGlyZWN0bHkgaW50byB0aGUgZXZhbEludGVycHJldGVyIHNvIHRoZSAuaXNhKClcbiAgLy8gbWV0aG9kIGJlaGF2ZXMgYXMgZXhwZWN0ZWRcbiAgWydBUlJBWScsICdCT09MRUFOJywgJ0RBVEUnLCAnRlVOQ1RJT04nLCAnTlVNQkVSJywgJ09CSkVDVCcsICdTVFJJTkcnLFxuICAgICdVTkRFRklORUQnXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgZXZhbEludGVycHJldGVyW3Byb3BdID0gdGhpcy5pbnRlcnByZXRlcltwcm9wXTtcbiAgfSwgdGhpcyk7XG5cbiAgLy8gUGF0Y2ggZ2V0UHJvcGVydHkgYW5kIHNldFByb3BlcnR5IHRvIGVuYWJsZSBjdXN0b20gbWFyc2hhbGxpbmdcbiAgZXZhbEludGVycHJldGVyLmdldFByb3BlcnR5ID0gdGhpcy5nZXRQcm9wZXJ0eS5iaW5kKFxuICAgICAgdGhpcyxcbiAgICAgIGV2YWxJbnRlcnByZXRlcixcbiAgICAgIGV2YWxJbnRlcnByZXRlci5nZXRQcm9wZXJ0eSk7XG4gIGV2YWxJbnRlcnByZXRlci5zZXRQcm9wZXJ0eSA9IHRoaXMuc2V0UHJvcGVydHkuYmluZChcbiAgICAgIHRoaXMsXG4gICAgICBldmFsSW50ZXJwcmV0ZXIsXG4gICAgICBldmFsSW50ZXJwcmV0ZXIuc2V0UHJvcGVydHkpO1xuXG4gIC8vIHJ1bigpIG1heSB0aHJvdyBpZiB0aGVyZSdzIGEgcHJvYmxlbSBpbiB0aGUgZXhwcmVzc2lvblxuICBldmFsSW50ZXJwcmV0ZXIucnVuKCk7XG4gIHJldHVybiBldmFsSW50ZXJwcmV0ZXIudmFsdWU7XG59O1xuIiwiLyogZ2xvYmFsIEludGVycHJldGVyLCBDYW52YXNQaXhlbEFycmF5LCBhY2UgKi9cblxudmFyIGRyb3BsZXRVdGlscyA9IHJlcXVpcmUoJy4vZHJvcGxldFV0aWxzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogRXZhbHVhdGVzIGEgc3RyaW5nIG9mIGNvZGUgcGFyYW1ldGVyaXplZCB3aXRoIGEgZGljdGlvbmFyeS5cbiAqL1xuZXhwb3J0cy5ldmFsV2l0aCA9IGZ1bmN0aW9uKGNvZGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuU3R1ZGlvQXBwICYmIG9wdGlvbnMuU3R1ZGlvQXBwLmVkaXRDb2RlKSB7XG4gICAgLy8gVXNlIEpTIGludGVycHJldGVyIG9uIGVkaXRDb2RlIGxldmVsc1xuICAgIHZhciBpbml0RnVuYyA9IGZ1bmN0aW9uKGludGVycHJldGVyLCBzY29wZSkge1xuICAgICAgZXhwb3J0cy5pbml0SlNJbnRlcnByZXRlcihpbnRlcnByZXRlciwgbnVsbCwgbnVsbCwgc2NvcGUsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgdmFyIG15SW50ZXJwcmV0ZXIgPSBuZXcgSW50ZXJwcmV0ZXIoY29kZSwgaW5pdEZ1bmMpO1xuICAgIC8vIGludGVycHJldCB0aGUgSlMgcHJvZ3JhbSBhbGwgYXQgb25jZTpcbiAgICBteUludGVycHJldGVyLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIC8vIGV4ZWN1dGUgSlMgY29kZSBcIm5hdGl2ZWx5XCJcbiAgICB2YXIgcGFyYW1zID0gW107XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBrIGluIG9wdGlvbnMpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGspO1xuICAgICAgYXJncy5wdXNoKG9wdGlvbnNba10pO1xuICAgIH1cbiAgICBwYXJhbXMucHVzaChjb2RlKTtcbiAgICB2YXIgY3RvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIHBhcmFtcyk7XG4gICAgfTtcbiAgICBjdG9yLnByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgICByZXR1cm4gbmV3IGN0b3IoKS5hcHBseShudWxsLCBhcmdzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gYmFzZWQgb24gYSBzdHJpbmcgb2YgY29kZSBwYXJhbWV0ZXJpemVkIHdpdGggYSBkaWN0aW9uYXJ5LlxuICovXG5leHBvcnRzLmZ1bmN0aW9uRnJvbUNvZGUgPSBmdW5jdGlvbihjb2RlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLlN0dWRpb0FwcCAmJiBvcHRpb25zLlN0dWRpb0FwcC5lZGl0Q29kZSkge1xuICAgIC8vIFNpbmNlIHRoaXMgcmV0dXJucyBhIG5ldyBuYXRpdmUgZnVuY3Rpb24sIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSBpbiB0aGVcbiAgICAvLyBlZGl0Q29kZSBjYXNlICh3ZSBhc3N1bWUgdGhhdCB0aGUgYXBwIHdpbGwgYmUgdXNpbmcgSlNJbnRlcnByZXRlcilcbiAgICB0aHJvdyBcIlVuZXhwZWN0ZWRcIjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFyYW1zID0gW107XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBrIGluIG9wdGlvbnMpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGspO1xuICAgICAgYXJncy5wdXNoKG9wdGlvbnNba10pO1xuICAgIH1cbiAgICBwYXJhbXMucHVzaChjb2RlKTtcbiAgICB2YXIgY3RvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIHBhcmFtcyk7XG4gICAgfTtcbiAgICBjdG9yLnByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgICByZXR1cm4gbmV3IGN0b3IoKTtcbiAgfVxufTtcblxuLy9cbi8vIEJsb2NrbHkgc3BlY2lmaWMgY29kZWdlbiBmdW5jdGlvbnM6XG4vL1xuXG52YXIgSU5GSU5JVEVfTE9PUF9UUkFQID0gJyAgZXhlY3V0aW9uSW5mby5jaGVja1RpbWVvdXQoKTsgaWYgKGV4ZWN1dGlvbkluZm8uaXNUZXJtaW5hdGVkKCkpe3JldHVybjt9XFxuJztcblxudmFyIExPT1BfSElHSExJR0hUID0gJ2xvb3BIaWdobGlnaHQoKTtcXG4nO1xudmFyIExPT1BfSElHSExJR0hUX1JFID1cbiAgICBuZXcgUmVnRXhwKExPT1BfSElHSExJR0hULnJlcGxhY2UoL1xcKC4qXFwpLywgJ1xcXFwoLipcXFxcKScpLCAnZycpO1xuXG4vKipcbiAqIFJldHVybnMgamF2YXNjcmlwdCBjb2RlIHRvIGNhbGwgYSB0aW1lb3V0IGNoZWNrXG4gKi9cbmV4cG9ydHMubG9vcFRyYXAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIElORklOSVRFX0xPT1BfVFJBUDtcbn07XG5cbmV4cG9ydHMubG9vcEhpZ2hsaWdodCA9IGZ1bmN0aW9uIChhcGlOYW1lLCBibG9ja0lkKSB7XG4gIHZhciBhcmdzID0gXCInYmxvY2tfaWRfXCIgKyBibG9ja0lkICsgXCInXCI7XG4gIGlmIChibG9ja0lkID09PSB1bmRlZmluZWQpIHtcbiAgICBhcmdzID0gXCIlMVwiO1xuICB9XG4gIHJldHVybiBhcGlOYW1lICsgJy4nICsgTE9PUF9ISUdITElHSFQucmVwbGFjZSgnKCknLCAnKCcgKyBhcmdzICsgJyknKTtcbn07XG5cbi8qKlxuICogRXh0cmFjdCB0aGUgdXNlcidzIGNvZGUgYXMgcmF3IEphdmFTY3JpcHQuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZSBHZW5lcmF0ZWQgY29kZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvZGUgd2l0aG91dCBzZXJpYWwgbnVtYmVycyBhbmQgdGltZW91dCBjaGVja3MuXG4gKi9cbmV4cG9ydHMuc3RyaXAgPSBmdW5jdGlvbihjb2RlKSB7XG4gIHJldHVybiAoY29kZVxuICAgIC8vIFN0cmlwIG91dCBzZXJpYWwgbnVtYmVycy5cbiAgICAucmVwbGFjZSgvKCxcXHMqKT8nYmxvY2tfaWRfXFxkKydcXCkvZywgJyknKVxuICAgIC8vIFJlbW92ZSB0aW1lb3V0cy5cbiAgICAucmVwbGFjZShJTkZJTklURV9MT09QX1RSQVAsICcnKVxuICAgIC8vIFN0cmlwIG91dCBsb29wIGhpZ2hsaWdodFxuICAgIC5yZXBsYWNlKExPT1BfSElHSExJR0hUX1JFLCAnJylcbiAgICAvLyBTdHJpcCBvdXQgY2xhc3MgbmFtZXNwYWNlcy5cbiAgICAucmVwbGFjZSgvKFN0dWRpb0FwcHxNYXplfFR1cnRsZSlcXC4vZywgJycpXG4gICAgLy8gU3RyaXAgb3V0IHBhcnRpY3VsYXIgaGVscGVyIGZ1bmN0aW9ucy5cbiAgICAucmVwbGFjZSgvXmZ1bmN0aW9uIChjb2xvdXJfcmFuZG9tKVtcXHNcXFNdKj9efS9nbSwgJycpXG4gICAgLy8gQ29sbGFwc2UgY29uc2VjdXRpdmUgYmxhbmsgbGluZXMuXG4gICAgLnJlcGxhY2UoL1xcblxcbisvZ20sICdcXG5cXG4nKVxuICAgIC8vIFRyaW0uXG4gICAgLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxuICApO1xufTtcblxuLyoqXG4gKiBFeHRyYWN0IHRoZSB1c2VyJ3MgY29kZSBhcyByYXcgSmF2YVNjcmlwdC5cbiAqL1xuZXhwb3J0cy53b3Jrc3BhY2VDb2RlID0gZnVuY3Rpb24oYmxvY2tseSkge1xuICB2YXIgY29kZSA9IGJsb2NrbHkuR2VuZXJhdG9yLmJsb2NrU3BhY2VUb0NvZGUoJ0phdmFTY3JpcHQnLCBudWxsLCBmYWxzZSk7XG4gIHJldHVybiBleHBvcnRzLnN0cmlwKGNvZGUpO1xufTtcblxuLy9cbi8vIFByb3BlcnR5IGFjY2VzcyB3cmFwcGVkIGluIHRyeS9jYXRjaC4gVGhpcyBpcyBpbiBhbiBpbmRlcGVkZW5kZW50IGZ1bmN0aW9uXG4vLyBzbyB0aGUgSklUIGNvbXBpbGVyIGNhbiBvcHRpbWl6ZSB0aGUgY2FsbGluZyBmdW5jdGlvbi5cbi8vXG5cbmZ1bmN0aW9uIHNhZmVSZWFkUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB0cnkge1xuICAgIHJldHVybiBvYmplY3RbcHJvcGVydHldO1xuICB9IGNhdGNoIChlKSB7IH1cbn1cblxuLy9cbi8vIE1hcnNoYWwgYSBzaW5nbGUgbmF0aXZlIG9iamVjdCBmcm9tIG5hdGl2ZSB0byBpbnRlcnByZXRlci4gVGhpcyBpcyBpbiBhblxuLy8gaW5kZXBlZGVuZGVudCBmdW5jdGlvbiBzbyB0aGUgSklUIGNvbXBpbGVyIGNhbiBvcHRpbWl6ZSB0aGUgY2FsbGluZyBmdW5jdGlvbi5cbi8vIChDaHJvbWUgVjggc2F5cyBGb3JJblN0YXRlbWVudCBpcyBub3QgZmFzdCBjYXNlKVxuLy9cblxuLyoqXG4gKiBNYXJzaGFsIGEgbmF0aXZlIG9iamVjdCB0byBhbiBpbnRlcnByZXRlciBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtJbnRlcnByZXRlcn0gaW50ZXJwcmV0ZXIgSW50ZXJwcmV0ZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBuYXRpdmVPYmplY3QgT2JqZWN0IHRvIG1hcnNoYWxcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhEZXB0aCBPcHRpb25hbCBtYXhpbXVtIGRlcHRoIHRvIHRyYXZlcnNlIGluIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnRlcnByZXRlck9iamVjdCBPcHRpb25hbCBleGlzdGluZyBpbnRlcnByZXRlciBvYmplY3RcbiAqIEByZXR1cm4geyFPYmplY3R9IFRoZSBpbnRlcnByZXRlciBvYmplY3QsIHdoaWNoIHdhcyBjcmVhdGVkIGlmIG5lZWRlZC5cbiAqL1xuZnVuY3Rpb24gbWFyc2hhbE5hdGl2ZVRvSW50ZXJwcmV0ZXJPYmplY3QoXG4gICAgaW50ZXJwcmV0ZXIsXG4gICAgbmF0aXZlT2JqZWN0LFxuICAgIG1heERlcHRoLFxuICAgIGludGVycHJldGVyT2JqZWN0KSB7XG4gIHZhciByZXRWYWwgPSBpbnRlcnByZXRlck9iamVjdCB8fCBpbnRlcnByZXRlci5jcmVhdGVPYmplY3QoaW50ZXJwcmV0ZXIuT0JKRUNUKTtcbiAgdmFyIGlzRnVuYyA9IGludGVycHJldGVyLmlzYShyZXRWYWwsIGludGVycHJldGVyLkZVTkNUSU9OKTtcbiAgZm9yICh2YXIgcHJvcCBpbiBuYXRpdmVPYmplY3QpIHtcbiAgICB2YXIgdmFsdWUgPSBzYWZlUmVhZFByb3BlcnR5KG5hdGl2ZU9iamVjdCwgcHJvcCk7XG4gICAgaWYgKGlzRnVuYyAmJlxuICAgICAgICAodmFsdWUgPT09IEZ1bmN0aW9uLnByb3RvdHlwZS50cmlnZ2VyIHx8XG4gICAgICAgICAgICB2YWx1ZSA9PT0gRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzKSkge1xuICAgICAgLy8gRG9uJ3QgbWFyc2hhbCB0aGVzZSB0aGF0IHdlcmUgYWRkZWQgYnkganF1ZXJ5IG9yIGVsc2Ugd2Ugd2lsbCByZWN1cnNlXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaW50ZXJwcmV0ZXIuc2V0UHJvcGVydHkocmV0VmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5tYXJzaGFsTmF0aXZlVG9JbnRlcnByZXRlcihpbnRlcnByZXRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlT2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4RGVwdGgpKTtcbiAgfVxuICByZXR1cm4gcmV0VmFsO1xufVxuXG5mdW5jdGlvbiBpc0NhbnZhc0ltYWdlRGF0YShuYXRpdmVWYXIpIHtcbiAgLy8gSUUgOS8xMCBkb24ndCBrbm93IGFib3V0IFVpbnQ4Q2xhbXBlZEFycmF5IGFuZCBjYWxsIGl0IENhbnZhc1BpeGVsQXJyYXkgaW5zdGVhZFxuICBpZiAodHlwZW9mKFVpbnQ4Q2xhbXBlZEFycmF5KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBuYXRpdmVWYXIgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheTtcbiAgfVxuICByZXR1cm4gbmF0aXZlVmFyIGluc3RhbmNlb2YgQ2FudmFzUGl4ZWxBcnJheTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBcImN1c3RvbSBtYXJzaGFsXCIgaW50ZXJwcmV0ZXIgb2JqZWN0IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBuYXRpdmVcbiAqIG9iamVjdC5cbiAqIEBwYXJhbSB7SW50ZXJwcmV0ZXJ9IGludGVycHJldGVyIEludGVycHJldGVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gbmF0aXZlT2JqIE9iamVjdCB0byB3cmFwXG4gKiBAcGFyYW0ge09iamVjdH0gbmF0aXZlUGFyZW50T2JqIFBhcmVudCBvZiBvYmplY3QgdG8gd3JhcFxuICogQHJldHVybiB7IU9iamVjdH0gTmV3IGludGVycHJldGVyIG9iamVjdC5cbiAqL1xudmFyIGNyZWF0ZUN1c3RvbU1hcnNoYWxPYmplY3QgPSBmdW5jdGlvbiAoaW50ZXJwcmV0ZXIsIG5hdGl2ZU9iaiwgbmF0aXZlUGFyZW50T2JqKSB7XG4gIGlmIChuYXRpdmVPYmogPT09IHVuZGVmaW5lZCAmJiBpbnRlcnByZXRlci5VTkRFRklORUQpIHtcbiAgICByZXR1cm4gaW50ZXJwcmV0ZXIuVU5ERUZJTkVEOyAgLy8gUmV1c2UgdGhlIHNhbWUgb2JqZWN0LlxuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIG5hdGl2ZU9iajtcbiAgdmFyIG9iaiA9IHtcbiAgICBkYXRhOiBuYXRpdmVPYmosXG4gICAgaXNQcmltaXRpdmU6IGZhbHNlLFxuICAgIGlzQ3VzdG9tTWFyc2hhbDogdHJ1ZSxcbiAgICB0eXBlOiB0eXBlb2YgbmF0aXZlT2JqLFxuICAgIHBhcmVudDogbmF0aXZlUGFyZW50T2JqLCAvLyBUT0RPIChjcGlyaWNoKTogcmVwbGFjZSB3aXRoIGludGVycHJldGVyIG9iamVjdD9cbiAgICB0b0Jvb2xlYW46IGZ1bmN0aW9uKCkge3JldHVybiBCb29sZWFuKHRoaXMuZGF0YSk7fSxcbiAgICB0b051bWJlcjogZnVuY3Rpb24oKSB7cmV0dXJuIE51bWJlcih0aGlzLmRhdGEpO30sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge3JldHVybiBTdHJpbmcodGhpcy5kYXRhKTt9LFxuICAgIHZhbHVlT2Y6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmRhdGE7fVxuICB9O1xuICByZXR1cm4gb2JqO1xufTtcblxuZXhwb3J0cy5jdXN0b21NYXJzaGFsT2JqZWN0TGlzdCA9IFtdO1xuZXhwb3J0cy5hc3luY0Z1bmN0aW9uTGlzdCA9IFtdO1xuZXhwb3J0cy5uYXRpdmVDYWxsc0ludGVycHJldGVyRnVuY3Rpb25MaXN0ID0gW107XG5cbi8vIElmIHRoaXMgaXMgb24gb3VyIGxpc3Qgb2YgXCJjdXN0b20gbWFyc2hhbFwiIG9iamVjdHMgLSBvciBpZiBpdCBhIHByb3BlcnR5XG4vLyBvbiBvbmUgb2YgdGhvc2Ugb2JqZWN0cyAob3RoZXIgdGhhbiBhIGZ1bmN0aW9uKSwgcmV0dXJuIHRydWVcblxudmFyIHNob3VsZEN1c3RvbU1hcnNoYWxPYmplY3QgPSBmdW5jdGlvbiAobmF0aXZlVmFyLCBuYXRpdmVQYXJlbnRPYmopIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBvcnRzLmN1c3RvbU1hcnNoYWxPYmplY3RMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1hcnNoYWxPYmogPSBleHBvcnRzLmN1c3RvbU1hcnNoYWxPYmplY3RMaXN0W2ldO1xuICAgIGlmICgobmF0aXZlVmFyIGluc3RhbmNlb2YgbWFyc2hhbE9iai5pbnN0YW5jZSAmJlxuICAgICAgICAgICh0eXBlb2YgbWFyc2hhbE9iai5yZXF1aXJlZE1ldGhvZCA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgIG5hdGl2ZVZhclttYXJzaGFsT2JqLnJlcXVpcmVkTWV0aG9kXSAhPT0gdW5kZWZpbmVkKSkgfHxcbiAgICAgICAgKHR5cGVvZiBuYXRpdmVWYXIgIT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIG5hdGl2ZVBhcmVudE9iaiBpbnN0YW5jZW9mIG1hcnNoYWxPYmouaW5zdGFuY2UpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gV2hlbiBtYXJzaGFsaW5nIG1ldGhvZHMgb24gXCJjdXN0b20gbWFyc2hhbFwiIG9iamVjdHMsIHdlIG1heSBuZWVkIHRvIGF1Z21lbnRcbi8vIHRoZSBtYXJzaGFsaW5nIG9wdGlvbnMuIFRoaXMgcmV0dXJucyB0aG9zZSBvcHRpb25zLlxuXG52YXIgZ2V0Q3VzdG9tTWFyc2hhbE1ldGhvZE9wdGlvbnMgPSBmdW5jdGlvbiAobmF0aXZlUGFyZW50T2JqKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwb3J0cy5jdXN0b21NYXJzaGFsT2JqZWN0TGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtYXJzaGFsT2JqID0gZXhwb3J0cy5jdXN0b21NYXJzaGFsT2JqZWN0TGlzdFtpXTtcbiAgICBpZiAobmF0aXZlUGFyZW50T2JqIGluc3RhbmNlb2YgbWFyc2hhbE9iai5pbnN0YW5jZSkge1xuICAgICAgaWYgKHR5cGVvZiBtYXJzaGFsT2JqLnJlcXVpcmVkTWV0aG9kID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICBuYXRpdmVQYXJlbnRPYmpbbWFyc2hhbE9iai5yZXF1aXJlZE1ldGhvZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbWFyc2hhbE9iai5tZXRob2RPcHRzIHx8IHt9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge307XG59O1xuXG4vL1xuLy8gRHJvcGxldC9KYXZhU2NyaXB0L0ludGVycHJldGVyIGNvZGVnZW4gZnVuY3Rpb25zOlxuLy9cbmV4cG9ydHMubWFyc2hhbE5hdGl2ZVRvSW50ZXJwcmV0ZXIgPSBmdW5jdGlvbiAoaW50ZXJwcmV0ZXIsIG5hdGl2ZVZhciwgbmF0aXZlUGFyZW50T2JqLCBtYXhEZXB0aCkge1xuICBpZiAobWF4RGVwdGggPT09IDAgfHwgdHlwZW9mIG5hdGl2ZVZhciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gaW50ZXJwcmV0ZXIuVU5ERUZJTkVEO1xuICB9XG4gIHZhciBpLCByZXRWYWw7XG4gIGlmICh0eXBlb2YgbWF4RGVwdGggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtYXhEZXB0aCA9IEluZmluaXR5OyAvLyBkZWZhdWx0IHRvIGluZmluaXRlIGxldmVscyBvZiBkZXB0aFxuICB9XG4gIGlmIChzaG91bGRDdXN0b21NYXJzaGFsT2JqZWN0KG5hdGl2ZVZhciwgbmF0aXZlUGFyZW50T2JqKSkge1xuICAgIHJldHVybiBjcmVhdGVDdXN0b21NYXJzaGFsT2JqZWN0KGludGVycHJldGVyLCBuYXRpdmVWYXIsIG5hdGl2ZVBhcmVudE9iaik7XG4gIH1cbiAgaWYgKG5hdGl2ZVZhciBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgcmV0VmFsID0gaW50ZXJwcmV0ZXIuY3JlYXRlT2JqZWN0KGludGVycHJldGVyLkFSUkFZKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbmF0aXZlVmFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXRWYWwucHJvcGVydGllc1tpXSA9IGV4cG9ydHMubWFyc2hhbE5hdGl2ZVRvSW50ZXJwcmV0ZXIoaW50ZXJwcmV0ZXIsXG4gICAgICAgIG5hdGl2ZVZhcltpXSwgbnVsbCwgbWF4RGVwdGggLSAxKTtcbiAgICB9XG4gICAgcmV0VmFsLmxlbmd0aCA9IG5hdGl2ZVZhci5sZW5ndGg7XG4gIH0gZWxzZSBpZiAoaXNDYW52YXNJbWFnZURhdGEobmF0aXZlVmFyKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgY2FudmFzIGltYWdlIGRhdGEgLSBjb3VsZCBleHBhbmQgdG8gc3VwcG9ydCBUeXBlZEFycmF5XG4gICAgcmV0VmFsID0gaW50ZXJwcmV0ZXIuY3JlYXRlT2JqZWN0KGludGVycHJldGVyLkFSUkFZKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbmF0aXZlVmFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXRWYWwucHJvcGVydGllc1tpXSA9IGludGVycHJldGVyLmNyZWF0ZVByaW1pdGl2ZShuYXRpdmVWYXJbaV0pO1xuICAgIH1cbiAgICByZXRWYWwubGVuZ3RoID0gbmF0aXZlVmFyLmxlbmd0aDtcbiAgfSBlbHNlIGlmIChuYXRpdmVWYXIgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIHZhciBtYWtlTmF0aXZlT3B0cyA9IHtcbiAgICAgIGludGVycHJldGVyOiBpbnRlcnByZXRlcixcbiAgICAgIG5hdGl2ZUZ1bmM6IG5hdGl2ZVZhcixcbiAgICAgIG5hdGl2ZVBhcmVudE9iajogbmF0aXZlUGFyZW50T2JqLFxuICAgIH07XG4gICAgaWYgKGV4cG9ydHMuYXN5bmNGdW5jdGlvbkxpc3QuaW5kZXhPZihuYXRpdmVWYXIpICE9PSAtMSkge1xuICAgICAgLy8gTWFyayBpZiB0aGlzIHNob3VsZCBiZSBuYXRpdmVJc0FzeW5jOlxuICAgICAgbWFrZU5hdGl2ZU9wdHMubmF0aXZlSXNBc3luYyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChleHBvcnRzLm5hdGl2ZUNhbGxzSW50ZXJwcmV0ZXJGdW5jdGlvbkxpc3QuaW5kZXhPZihuYXRpdmVWYXIpICE9PSAtMSkge1xuICAgICAgLy8gTWFyayBpZiB0aGlzIHNob3VsZCBiZSBuYXRpdmVDYWxsc0JhY2tJbnRlcnByZXRlcjpcbiAgICAgIG1ha2VOYXRpdmVPcHRzLm5hdGl2ZUNhbGxzQmFja0ludGVycHJldGVyID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGV4dHJhT3B0cyA9IGdldEN1c3RvbU1hcnNoYWxNZXRob2RPcHRpb25zKG5hdGl2ZVBhcmVudE9iaik7XG4gICAgLy8gQWRkIGV4dHJhIG9wdGlvbnMgaWYgdGhlIHBhcmVudCBvZiB0aGlzIGZ1bmN0aW9uIGlzIGluIG91ciBjdXN0b20gbWFyc2hhbFxuICAgIC8vIG1vZGlmaWVkIG9iamVjdCBsaXN0OlxuICAgIGZvciAodmFyIHByb3AgaW4gZXh0cmFPcHRzKSB7XG4gICAgICBtYWtlTmF0aXZlT3B0c1twcm9wXSA9IGV4dHJhT3B0c1twcm9wXTtcbiAgICB9XG4gICAgdmFyIHdyYXBwZXIgPSBleHBvcnRzLm1ha2VOYXRpdmVNZW1iZXJGdW5jdGlvbihtYWtlTmF0aXZlT3B0cyk7XG4gICAgaWYgKG1ha2VOYXRpdmVPcHRzLm5hdGl2ZUlzQXN5bmMpIHtcbiAgICAgIHJldFZhbCA9IGludGVycHJldGVyLmNyZWF0ZUFzeW5jRnVuY3Rpb24od3JhcHBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldFZhbCA9IGludGVycHJldGVyLmNyZWF0ZU5hdGl2ZUZ1bmN0aW9uKHdyYXBwZXIpO1xuICAgIH1cbiAgICAvLyBBbHNvIG1hcnNoYWwgcHJvcGVydGllcyBvbiB0aGUgbmF0aXZlIGZ1bmN0aW9uIG9iamVjdDpcbiAgICBtYXJzaGFsTmF0aXZlVG9JbnRlcnByZXRlck9iamVjdChpbnRlcnByZXRlciwgbmF0aXZlVmFyLCBtYXhEZXB0aCAtIDEsIHJldFZhbCk7XG4gIH0gZWxzZSBpZiAobmF0aXZlVmFyIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgLy8gbm90ZSBPYmplY3QgbXVzdCBiZSBjaGVja2VkIGFmdGVyIEZ1bmN0aW9uIGFuZCBBcnJheSAoc2luY2UgdGhleSBhcmUgYWxzbyBPYmplY3RzKVxuICAgIGlmIChpbnRlcnByZXRlci5pc2EobmF0aXZlVmFyLCBpbnRlcnByZXRlci5GVU5DVElPTikpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSB0byBzZWUgaWYgd2UgYXJlIHRyeWluZyB0byBtYXJzaGFsIGFuIGludGVycHJldGVyIG9iamVjdFxuICAgICAgLy8gKHRoaXMgY3VycmVudGx5IGhhcHBlbnMgd2hlbiB3ZSBzdG9yZSBpbnRlcnByZXRlciBmdW5jdGlvbiBvYmplY3RzIGluIG5hdGl2ZVxuICAgICAgLy8gIGFuZCByZXR1cm4gdGhlbSBiYWNrIGluIG5hdGl2ZUdldENhbGxiYWNrKVxuXG4gICAgICAvLyBOT1RFOiB0aGlzIGNoZWNrIGNvdWxkIGJlIGV4cGFuZGVkIHRvIGNoZWNrIGZvciBvdGhlciBpbnRlcnByZXRlciBvYmplY3QgdHlwZXNcbiAgICAgIC8vIGlmIHdlIGhhdmUgcmVhc29uIHRvIGJlbGlldmUgdGhhdCB3ZSBtYXkgYmUgcGFzc2luZyB0aG9zZSBiYWNrXG5cbiAgICAgIHJldFZhbCA9IG5hdGl2ZVZhcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0VmFsID0gbWFyc2hhbE5hdGl2ZVRvSW50ZXJwcmV0ZXJPYmplY3QoaW50ZXJwcmV0ZXIsIG5hdGl2ZVZhciwgbWF4RGVwdGggLSAxKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0VmFsID0gaW50ZXJwcmV0ZXIuY3JlYXRlUHJpbWl0aXZlKG5hdGl2ZVZhcik7XG4gIH1cbiAgcmV0dXJuIHJldFZhbDtcbn07XG5cbmV4cG9ydHMuY3JlYXRlTmF0aXZlRnVuY3Rpb25Gcm9tSW50ZXJwcmV0ZXJGdW5jdGlvbiA9IG51bGw7XG5cbmV4cG9ydHMubWFyc2hhbEludGVycHJldGVyVG9OYXRpdmUgPSBmdW5jdGlvbiAoaW50ZXJwcmV0ZXIsIGludGVycHJldGVyVmFyKSB7XG4gIGlmIChpbnRlcnByZXRlclZhci5pc1ByaW1pdGl2ZSB8fCBpbnRlcnByZXRlclZhci5pc0N1c3RvbU1hcnNoYWwpIHtcbiAgICByZXR1cm4gaW50ZXJwcmV0ZXJWYXIuZGF0YTtcbiAgfSBlbHNlIGlmIChpbnRlcnByZXRlci5pc2EoaW50ZXJwcmV0ZXJWYXIsIGludGVycHJldGVyLkFSUkFZKSkge1xuICAgIHZhciBuYXRpdmVBcnJheSA9IFtdO1xuICAgIG5hdGl2ZUFycmF5Lmxlbmd0aCA9IGludGVycHJldGVyVmFyLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hdGl2ZUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBuYXRpdmVBcnJheVtpXSA9IGV4cG9ydHMubWFyc2hhbEludGVycHJldGVyVG9OYXRpdmUoaW50ZXJwcmV0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXJWYXIucHJvcGVydGllc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBuYXRpdmVBcnJheTtcbiAgfSBlbHNlIGlmIChpbnRlcnByZXRlci5pc2EoaW50ZXJwcmV0ZXJWYXIsIGludGVycHJldGVyLk9CSkVDVCkgfHxcbiAgICAgIGludGVycHJldGVyVmFyLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIG5hdGl2ZU9iamVjdCA9IHt9O1xuICAgIGZvciAodmFyIHByb3AgaW4gaW50ZXJwcmV0ZXJWYXIucHJvcGVydGllcykge1xuICAgICAgbmF0aXZlT2JqZWN0W3Byb3BdID0gZXhwb3J0cy5tYXJzaGFsSW50ZXJwcmV0ZXJUb05hdGl2ZShpbnRlcnByZXRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXJWYXIucHJvcGVydGllc1twcm9wXSk7XG4gICAgfVxuICAgIHJldHVybiBuYXRpdmVPYmplY3Q7XG4gIH0gZWxzZSBpZiAoaW50ZXJwcmV0ZXIuaXNhKGludGVycHJldGVyVmFyLCBpbnRlcnByZXRlci5GVU5DVElPTikpIHtcbiAgICBpZiAoZXhwb3J0cy5jcmVhdGVOYXRpdmVGdW5jdGlvbkZyb21JbnRlcnByZXRlckZ1bmN0aW9uKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5jcmVhdGVOYXRpdmVGdW5jdGlvbkZyb21JbnRlcnByZXRlckZ1bmN0aW9uKGludGVycHJldGVyVmFyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSnVzdCByZXR1cm4gdGhlIGludGVycHJldGVyIG9iamVjdCBpZiB3ZSBjYW4ndCBjb252ZXJ0IGl0LiBUaGlzIGlzIG5lZWRlZFxuICAgICAgLy8gZm9yIHBhc3NpbmcgaW50ZXJwcmV0ZXIgY2FsbGJhY2sgZnVuY3Rpb25zIGludG8gbmF0aXZlLlxuXG4gICAgICByZXR1cm4gaW50ZXJwcmV0ZXJWYXI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IFwiQ2FuJ3QgbWFyc2hhbCB0eXBlIFwiICsgdHlwZW9mIGludGVycHJldGVyVmFyO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgZnVuY3Rpb24gd3JhcHBlciBmb3IgYW4gaW50ZXJwcmV0ZXIgYXN5bmMgZnVuY3Rpb24gY2FsbGJhY2suXG4gKiBUaGUgaW50ZXJwcmV0ZXIgYXN5bmMgZnVuY3Rpb24gY2FsbGJhY2sgdGFrZXMgYSBzaW5nbGUgcGFyYW1ldGVyLCB3aGljaFxuICogYmVjb21lcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBzeW5jaHJvbm91cyBmdW5jdGlvbiBpbiB0aGUgaW50ZXJwcmV0ZXJcbiAqIHdvcmxkLiBIZXJlLCB3ZSB3cmFwIHRoZSBzdXBwbGllZCBjYWxsYmFjayB0byBtYXJzaGFsIHRoZSBzaW5nbGUgcGFyYW1ldGVyXG4gKiBmcm9tIG5hdGl2ZSB0byBpbnRlcnByZXRlciBiZWZvcmUgY2FsbGluZyB0aGUgc3VwcGxpZWQgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9ucyBibG9jayB3aXRoIGludGVycHJldGVyIGFuZCBtYXhEZXB0aCBwcm92aWRlZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGludGVycHJldGVyIHN1cHBsaWVkIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cbnZhciBjcmVhdGVOYXRpdmVDYWxsYmFja0ZvckFzeW5jRnVuY3Rpb24gPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVWYWx1ZSkge1xuICAgIGNhbGxiYWNrKFxuICAgICAgICBleHBvcnRzLm1hcnNoYWxOYXRpdmVUb0ludGVycHJldGVyKFxuICAgICAgICAgICAgb3B0cy5pbnRlcnByZXRlcixcbiAgICAgICAgICAgIG5hdGl2ZVZhbHVlLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG9wdHMubWF4RGVwdGgpKTtcbiAgfTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBmdW5jdGlvbiB3cmFwcGVyIGZvciBhbiBpbnRlcnByZXRlciBjYWxsYmFjayB0aGF0IHdpbGwgYmVcbiAqIGludm9rZWQgYnkgYSBzcGVjaWFsIG5hdGl2ZSBmdW5jdGlvbiB0aGF0IGNhbiBleGVjdXRlIHRoZXNlIGNhbGxiYWNrcyBpbmxpbmVcbiAqIG9uIHRoZSBpbnRlcnByZXRlciBzdGFjay5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25zIGJsb2NrIHdpdGggaW50ZXJwcmV0ZXIgYW5kIG1heERlcHRoIHByb3ZpZGVkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBpbnRGdW5jIFRoZSBpbnRlcnByZXRlciBzdXBwbGllZCBjYWxsYmFjayBmdW5jdGlvblxuICovXG52YXIgY3JlYXRlTmF0aXZlSW50ZXJwcmV0ZXJDYWxsYmFjayA9IGZ1bmN0aW9uIChvcHRzLCBpbnRGdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobmF0aXZlVmFsdWUpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIGludEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGludEFyZ3NbaV0gPSBleHBvcnRzLm1hcnNoYWxOYXRpdmVUb0ludGVycHJldGVyKFxuICAgICAgICAgIG9wdHMuaW50ZXJwcmV0ZXIsXG4gICAgICAgICAgYXJnc1tpXSxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG9wdHMubWF4RGVwdGgpO1xuICAgIH1cbiAgICAvLyBTaGlmdCBhIENhbGxFeHByZXNzaW9uIG5vZGUgb24gdGhlIHN0YWNrIHRoYXQgYWxyZWFkeSBoYXMgaXRzIGZ1bmNfLFxuICAgIC8vIGFyZ3VtZW50cywgYW5kIG90aGVyIHN0YXRlIHBvcHVsYXRlZDpcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBub2RlOiB7XG4gICAgICAgIHR5cGU6ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICAgIGFyZ3VtZW50czogaW50QXJncyAvKiB0aGlzIGp1c3QgbmVlZHMgdG8gYmUgYXJyYXkgb2YgdGhlIHNhbWUgc2l6ZSAqL1xuICAgICAgICB9LFxuICAgICAgZG9uZUNhbGxlZV86IHRydWUsXG4gICAgICBmdW5jXzogaW50RnVuYyxcbiAgICAgIGFyZ3VtZW50czogaW50QXJncyxcbiAgICAgIG5fOiBpbnRBcmdzLmxlbmd0aFxuICAgIH07XG4gICAgb3B0cy5pbnRlcnByZXRlci5zdGF0ZVN0YWNrLnVuc2hpZnQoc3RhdGUpO1xuICB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG5hdGl2ZSBmdW5jdGlvbiB3cmFwcGVyIGZvciB1c2Ugd2l0aCB0aGUgSlMgaW50ZXJwcmV0ZXIuXG4gKi9cbmV4cG9ydHMubWFrZU5hdGl2ZU1lbWJlckZ1bmN0aW9uID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgaWYgKG9wdHMuZG9udE1hcnNoYWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBKdXN0IGNhbGwgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhbmQgbWFyc2hhbCB0aGUgcmV0dXJuIHZhbHVlOlxuICAgICAgdmFyIG5hdGl2ZVJldFZhbCA9IG9wdHMubmF0aXZlRnVuYy5hcHBseShvcHRzLm5hdGl2ZVBhcmVudE9iaiwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBleHBvcnRzLm1hcnNoYWxOYXRpdmVUb0ludGVycHJldGVyKG9wdHMuaW50ZXJwcmV0ZXIsIG5hdGl2ZVJldFZhbCxcbiAgICAgICAgbnVsbCwgb3B0cy5tYXhEZXB0aCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBDYWxsIHRoZSBuYXRpdmUgZnVuY3Rpb24gYWZ0ZXIgbWFyc2hhbGxpbmcgcGFyYW1ldGVyczpcbiAgICAgIHZhciBuYXRpdmVBcmdzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAob3B0cy5uYXRpdmVJc0FzeW5jICYmIChpID09PSBhcmd1bWVudHMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAvLyBBc3luYyBmdW5jdGlvbnMgcmVjZWl2ZSBhIG5hdGl2ZSBjYWxsYmFjayBtZXRob2QgYXMgdGhlaXIgbGFzdFxuICAgICAgICAgIC8vIHBhcmFtZXRlciwgYW5kIHdlIHdhbnQgdG8gd3JhcCB0aGF0IGNhbGxiYWNrIHRvIGVhc2UgbWFyc2hhbGxpbmc6XG4gICAgICAgICAgbmF0aXZlQXJnc1tpXSA9IGNyZWF0ZU5hdGl2ZUNhbGxiYWNrRm9yQXN5bmNGdW5jdGlvbihvcHRzLCBhcmd1bWVudHNbaV0pO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdHMubmF0aXZlQ2FsbHNCYWNrSW50ZXJwcmV0ZXIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBhcmd1bWVudHNbaV0gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBvcHRzLmludGVycHJldGVyLmlzYShhcmd1bWVudHNbaV0sIG9wdHMuaW50ZXJwcmV0ZXIuRlVOQ1RJT04pKSB7XG4gICAgICAgICAgLy8gQSBzZWxlY3QgY2xhc3Mgb2YgbmF0aXZlIGZ1bmN0aW9ucyBpcyBhd2FyZSBvZiB0aGUgaW50ZXJwcmV0ZXIgYW5kXG4gICAgICAgICAgLy8gY2FwYWJsZSBvZiBjYWxsaW5nIHRoZSBpbnRlcnByZXRlciBvbiB0aGUgc3RhY2sgaW1tZWRpYXRlbHkuIFdlXG4gICAgICAgICAgLy8gbWFyc2hhbCB0aGVzZSBkaWZmZXJlbnRseTpcbiAgICAgICAgICBuYXRpdmVBcmdzW2ldID0gY3JlYXRlTmF0aXZlSW50ZXJwcmV0ZXJDYWxsYmFjayhvcHRzLCBhcmd1bWVudHNbaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5hdGl2ZUFyZ3NbaV0gPSBleHBvcnRzLm1hcnNoYWxJbnRlcnByZXRlclRvTmF0aXZlKG9wdHMuaW50ZXJwcmV0ZXIsIGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBuYXRpdmVSZXRWYWwgPSBvcHRzLm5hdGl2ZUZ1bmMuYXBwbHkob3B0cy5uYXRpdmVQYXJlbnRPYmosIG5hdGl2ZUFyZ3MpO1xuICAgICAgcmV0dXJuIGV4cG9ydHMubWFyc2hhbE5hdGl2ZVRvSW50ZXJwcmV0ZXIob3B0cy5pbnRlcnByZXRlciwgbmF0aXZlUmV0VmFsLFxuICAgICAgICBudWxsLCBvcHRzLm1heERlcHRoKTtcbiAgICB9O1xuICB9XG59O1xuXG5mdW5jdGlvbiBwb3B1bGF0ZUZ1bmN0aW9uc0ludG9TY29wZShpbnRlcnByZXRlciwgc2NvcGUsIGZ1bmNzT2JqLCBwYXJlbnRPYmosIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgcHJvcCBpbiBmdW5jc09iaikge1xuICAgIHZhciBmdW5jID0gZnVuY3NPYmpbcHJvcF07XG4gICAgaWYgKGZ1bmMgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgLy8gUG9wdWxhdGUgdGhlIHNjb3BlIHdpdGggbmF0aXZlIGZ1bmN0aW9uc1xuICAgICAgLy8gTk9URTogb3RoZXIgcHJvcGVydGllcyBhcmUgbm90IGN1cnJlbnRseSBwYXNzZWQgdG8gdGhlIGludGVycHJldGVyXG4gICAgICB2YXIgcGFyZW50ID0gcGFyZW50T2JqID8gcGFyZW50T2JqIDogZnVuY3NPYmo7XG4gICAgICB2YXIgd3JhcHBlciA9IGV4cG9ydHMubWFrZU5hdGl2ZU1lbWJlckZ1bmN0aW9uKHV0aWxzLmV4dGVuZChvcHRpb25zLCB7XG4gICAgICAgICAgaW50ZXJwcmV0ZXI6IGludGVycHJldGVyLFxuICAgICAgICAgIG5hdGl2ZUZ1bmM6IGZ1bmMsXG4gICAgICAgICAgbmF0aXZlUGFyZW50T2JqOiBwYXJlbnQsXG4gICAgICB9KSk7XG4gICAgICBpbnRlcnByZXRlci5zZXRQcm9wZXJ0eShzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnByZXRlci5jcmVhdGVOYXRpdmVGdW5jdGlvbih3cmFwcGVyKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvcHVsYXRlR2xvYmFsRnVuY3Rpb25zKGludGVycHJldGVyLCBibG9ja3MsIGJsb2NrRmlsdGVyLCBzY29wZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2Nrcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBibG9jayA9IGJsb2Nrc1tpXTtcbiAgICBpZiAoYmxvY2sucGFyZW50ICYmXG4gICAgICAgICghYmxvY2tGaWx0ZXIgfHwgdHlwZW9mIGJsb2NrRmlsdGVyW2Jsb2NrLmZ1bmNdICE9PSAndW5kZWZpbmVkJykpIHtcbiAgICAgIHZhciBmdW5jU2NvcGUgPSBzY29wZTtcbiAgICAgIHZhciBmdW5jTmFtZSA9IGJsb2NrLmZ1bmM7XG4gICAgICB2YXIgZnVuY0NvbXBvbmVudHMgPSBmdW5jTmFtZS5zcGxpdCgnLicpO1xuICAgICAgaWYgKGZ1bmNDb21wb25lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAvLyBTcGVjaWFsIGFjY29tbW9kYXRpb24gZm9yIE9iamVjdC5mdW5jdGlvbiBzeW50YXggKDIgY29tcG9uZW50cyBvbmx5KTpcbiAgICAgICAgdmFyIG9iak5hbWUgPSBmdW5jQ29tcG9uZW50c1swXTtcbiAgICAgICAgLy8gRmluZCBvciBjcmVhdGUgZ2xvYmFsIG9iamVjdCBuYW1lZCAnb2JqTmFtZScgYW5kIG1ha2UgaXQgdGhlIHNjb3BlOlxuICAgICAgICBmdW5jU2NvcGUgPSBpbnRlcnByZXRlci5nZXRQcm9wZXJ0eShzY29wZSwgb2JqTmFtZSk7XG4gICAgICAgIGlmIChpbnRlcnByZXRlci5VTkRFRklORUQgPT09IGZ1bmNTY29wZSkge1xuICAgICAgICAgIGZ1bmNTY29wZSA9IGludGVycHJldGVyLmNyZWF0ZU9iamVjdChpbnRlcnByZXRlci5PQkpFQ1QpO1xuICAgICAgICAgIGludGVycHJldGVyLnNldFByb3BlcnR5KHNjb3BlLCBvYmpOYW1lLCBmdW5jU2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmNOYW1lID0gZnVuY0NvbXBvbmVudHNbMV07XG4gICAgICB9XG4gICAgICB2YXIgZnVuYyA9IGJsb2NrLnBhcmVudFtmdW5jTmFtZV07XG4gICAgICB2YXIgd3JhcHBlciA9IGV4cG9ydHMubWFrZU5hdGl2ZU1lbWJlckZ1bmN0aW9uKHtcbiAgICAgICAgICBpbnRlcnByZXRlcjogaW50ZXJwcmV0ZXIsXG4gICAgICAgICAgbmF0aXZlRnVuYzogZnVuYyxcbiAgICAgICAgICBuYXRpdmVQYXJlbnRPYmo6IGJsb2NrLnBhcmVudCxcbiAgICAgICAgICBkb250TWFyc2hhbDogYmxvY2suZG9udE1hcnNoYWwsXG4gICAgICAgICAgbmF0aXZlSXNBc3luYzogYmxvY2submF0aXZlSXNBc3luY1xuICAgICAgfSk7XG4gICAgICB2YXIgaW50RnVuYztcbiAgICAgIGlmIChibG9jay5uYXRpdmVJc0FzeW5jKSB7XG4gICAgICAgIGludEZ1bmMgPSBpbnRlcnByZXRlci5jcmVhdGVBc3luY0Z1bmN0aW9uKHdyYXBwZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50RnVuYyA9IGludGVycHJldGVyLmNyZWF0ZU5hdGl2ZUZ1bmN0aW9uKHdyYXBwZXIpO1xuICAgICAgfVxuICAgICAgaW50ZXJwcmV0ZXIuc2V0UHJvcGVydHkoZnVuY1Njb3BlLCBmdW5jTmFtZSwgaW50RnVuYyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvcHVsYXRlSlNGdW5jdGlvbnMoaW50ZXJwcmV0ZXIpIHtcbiAgLy8gVGhlIGludGVycHJldGVyIGlzIG1pc3Npbmcgc29tZSBiYXNpYyBKUyBmdW5jdGlvbnMuIEFkZCB0aGVtIGFzIG5lZWRlZDpcbiAgdmFyIHdyYXBwZXI7XG5cbiAgLy8gQWRkIHN0YXRpYyBtZXRob2RzIGZyb20gU3RyaW5nOlxuICB2YXIgZnVuY3Rpb25zID0gWydmcm9tQ2hhckNvZGUnXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB3cmFwcGVyID0gZXhwb3J0cy5tYWtlTmF0aXZlTWVtYmVyRnVuY3Rpb24oe1xuICAgICAgaW50ZXJwcmV0ZXI6IGludGVycHJldGVyLFxuICAgICAgbmF0aXZlRnVuYzogU3RyaW5nW2Z1bmN0aW9uc1tpXV0sXG4gICAgICBuYXRpdmVQYXJlbnRPYmo6IFN0cmluZyxcbiAgICB9KTtcbiAgICBpbnRlcnByZXRlci5zZXRQcm9wZXJ0eShpbnRlcnByZXRlci5TVFJJTkcsIGZ1bmN0aW9uc1tpXSxcbiAgICAgIGludGVycHJldGVyLmNyZWF0ZU5hdGl2ZUZ1bmN0aW9uKHdyYXBwZXIpLCBmYWxzZSwgdHJ1ZSk7XG4gIH1cblxuICAvLyBBZGQgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc1xuICB3cmFwcGVyID0gZnVuY3Rpb24oc2VhcmNoU3RyKSB7XG4gICAgLy8gUG9seWZpbGwgYmFzZWQgb2ZmIG9mIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9pbmNsdWRlc1xuICAgIHJldHVybiBpbnRlcnByZXRlci5jcmVhdGVQcmltaXRpdmUoXG4gICAgICBTdHJpbmcucHJvdG90eXBlLmluZGV4T2YuYXBwbHkodGhpcywgYXJndW1lbnRzKSAhPT0gLTEpO1xuICB9O1xuICBpbnRlcnByZXRlci5zZXRQcm9wZXJ0eShpbnRlcnByZXRlci5TVFJJTkcucHJvcGVydGllcy5wcm90b3R5cGUsICdpbmNsdWRlcycsXG4gICAgaW50ZXJwcmV0ZXIuY3JlYXRlTmF0aXZlRnVuY3Rpb24od3JhcHBlciksIGZhbHNlLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGEgSlMgaW50ZXJwcmV0ZXIuXG4gKlxuICogaW50ZXJwcmV0ZXIgKHJlcXVpcmVkKTogSlMgaW50ZXJwcmV0ZXIgaW5zdGFuY2UuXG4gKiBibG9ja3MgKG9wdGlvbmFsKTogYmxvY2tzIGluIGRyb3BsZXRDb25maWcuYmxvY2tzIGZvcm1hdC4gSWYgYSBibG9jayBoYXNcbiAqICBhIHBhcmVudCBwcm9wZXJ0eSwgd2Ugd2lsbCBwb3B1bGF0ZSB0aGF0IGZ1bmN0aW9uIGludG8gdGhlIHNwZWNpZmllZCBzY29wZS5cbiAqIGJsb2NrRmlsdGVyIChvcHRpb25hbCk6IGFuIG9iamVjdCB3aXRoIGJsb2NrLW5hbWUga2V5cyB0aGF0IHNob3VsZCBiZSB1c2VkXG4gKiAgdG8gZmlsdGVyIHdoaWNoIGJsb2NrcyBhcmUgcG9wdWxhdGVkLlxuICogc2NvcGUgKHJlcXVpcmVkKTogaW50ZXJwcmV0ZXIncyBnbG9iYWwgc2NvcGUuXG4gKiBnbG9iYWxPYmplY3RzIChvcHRpb25hbCk6IG9iamVjdHMgY29udGFpbmluZyBmdW5jdGlvbnMgdG8gcGxhY2VkIGluIGEgbmV3IHNjb3BlXG4gKiAgY3JlYXRlZCBiZW5lYXRoIHRoZSBzdXBwbGllZCBzY29wZS5cbiAqL1xuZXhwb3J0cy5pbml0SlNJbnRlcnByZXRlciA9IGZ1bmN0aW9uIChpbnRlcnByZXRlciwgYmxvY2tzLCBibG9ja0ZpbHRlciwgc2NvcGUsIGdsb2JhbE9iamVjdHMpIHtcbiAgZm9yICh2YXIgZ2xvYmFsT2JqIGluIGdsb2JhbE9iamVjdHMpIHtcbiAgICAvLyBUaGUgZ2xvYmFsT2JqZWN0cyBvYmplY3QgY29udGFpbnMgb2JqZWN0cyB0aGF0IHdpbGwgYmUgcmVmZXJlbmNlZFxuICAgIC8vIGJ5IHRoZSBjb2RlIHdlIHBsYW4gdG8gZXhlY3V0ZS4gU2luY2UgdGhlc2Ugb2JqZWN0cyBleGlzdCBpbiB0aGUgbmF0aXZlXG4gICAgLy8gd29ybGQsIHdlIG5lZWQgdG8gY3JlYXRlIGFzc29jaWF0ZWQgb2JqZWN0cyBpbiB0aGUgaW50ZXJwcmV0ZXIncyB3b3JsZFxuICAgIC8vIHNvIHRoZSBpbnRlcnByZXRlZCBjb2RlIGNhbiBjYWxsIG91dCB0byB0aGVzZSBuYXRpdmUgb2JqZWN0c1xuXG4gICAgLy8gQ3JlYXRlIGdsb2JhbCBvYmplY3RzIGluIHRoZSBpbnRlcnByZXRlciBmb3IgZXZlcnl0aGluZyBpbiBvcHRpb25zXG4gICAgdmFyIG9iaiA9IGludGVycHJldGVyLmNyZWF0ZU9iamVjdChpbnRlcnByZXRlci5PQkpFQ1QpO1xuICAgIGludGVycHJldGVyLnNldFByb3BlcnR5KHNjb3BlLCBnbG9iYWxPYmoudG9TdHJpbmcoKSwgb2JqKTtcbiAgICAvLyBNYXJzaGFsIHJldHVybiB2YWx1ZXMgd2l0aCBhIG1heERlcHRoIG9mIDIgKGp1c3QgYW4gb2JqZWN0IGFuZCBpdHMgY2hpbGRcbiAgICAvLyBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIG9ubHkpXG4gICAgcG9wdWxhdGVGdW5jdGlvbnNJbnRvU2NvcGUoXG4gICAgICAgIGludGVycHJldGVyLFxuICAgICAgICBvYmosXG4gICAgICAgIGdsb2JhbE9iamVjdHNbZ2xvYmFsT2JqXSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgeyBtYXhEZXB0aDogMiB9KTtcbiAgfVxuICBwb3B1bGF0ZUdsb2JhbEZ1bmN0aW9ucyhcbiAgICAgIGludGVycHJldGVyLFxuICAgICAgZHJvcGxldFV0aWxzLmRyb3BsZXRHbG9iYWxDb25maWdCbG9ja3MsXG4gICAgICBibG9ja0ZpbHRlcixcbiAgICAgIHNjb3BlKTtcbiAgaWYgKGJsb2Nrcykge1xuICAgIHBvcHVsYXRlR2xvYmFsRnVuY3Rpb25zKFxuICAgICAgICBpbnRlcnByZXRlcixcbiAgICAgICAgYmxvY2tzLFxuICAgICAgICBibG9ja0ZpbHRlcixcbiAgICAgICAgc2NvcGUpO1xuICB9XG4gIHBvcHVsYXRlSlNGdW5jdGlvbnMoaW50ZXJwcmV0ZXIpO1xufTtcblxuLyoqXG4gKiBDaGVjayB0byBzZWUgaWYgaXQgaXMgc2FmZSB0byBzdGVwIHRoZSBpbnRlcnByZXRlciB3aGlsZSB3ZSBhcmUgdW53aW5kaW5nLlxuICogKENhbGxlZCByZXBlYXRlZGx5IGFmdGVyIGNvbXBsZXRpbmcgYSBzdGVwIHdoZXJlIHRoZSBub2RlIHdhcyBtYXJrZWQgJ2RvbmUnKVxuICovXG5leHBvcnRzLmlzTmV4dFN0ZXBTYWZlV2hpbGVVbndpbmRpbmcgPSBmdW5jdGlvbiAoaW50ZXJwcmV0ZXIpIHtcbiAgdmFyIHN0YXRlID0gaW50ZXJwcmV0ZXIuc3RhdGVTdGFja1swXTtcbiAgdmFyIHR5cGUgPSBzdGF0ZS5ub2RlLnR5cGU7XG4gIGlmIChzdGF0ZS5kb25lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwiU3dpdGNoU3RhdGVtZW50XCIpIHtcbiAgICAvLyBTYWZlIHRvIHNraXAgb3ZlciBTd2l0Y2hTdGF0ZW1lbnQncyBleGNlcHQgdGhlIHZlcnkgc3RhcnQgKGJlZm9yZSBhXG4gICAgLy8gc3dpdGNoVmFsdWUgaGFzIGJlZW4gc2V0KTpcbiAgICByZXR1cm4gdHlwZW9mIHN0YXRlLnN3aXRjaFZhbHVlICE9PSAndW5kZWZpbmVkJztcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpIHtcbiAgICAvLyBPbmx5IHN0b3AgdGhlIGZpcnN0IHRpbWUgdGhpcyBWYXJpYWJsZURlY2xhcmF0aW9uIGlzIHByb2Nlc3NlZCAodGhlXG4gICAgLy8gaW50ZXJwcmV0ZXIgd2lsbCBzdG9wIG9uIHRoaXMgbm9kZSBtdWx0aXBsZSB0aW1lcywgYnV0IHdpdGggZGlmZmVyZW50XG4gICAgLy8gYHN0YXRlLm5gIHJlcHJlc2VudGluZyB3aGljaCBWYXJpYWJsZURlY2xhcmF0b3IgaXMgYmVpbmcgZXhlY3V0ZWQpLlxuICAgIHJldHVybiBzdGF0ZS5uID4gMDtcbiAgfVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAvLyBEZWNsYXJhdGlvbnM6XG4gICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiOlxuICAgIC8vIFN0YXRlbWVudHM6XG4gICAgY2FzZSBcIkJsb2NrU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkJyZWFrU3RhdGVtZW50XCI6XG4gICAgLy8gQWxsIEV4cHJlc3Npb25zOlxuICAgIGNhc2UgXCJUaGlzRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJBcnJvd0V4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiU2VxdWVuY2VFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlVwZGF0ZUV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiTG9naWNhbEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIk5ld0V4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQ2FsbEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAvLyBPdGhlcjpcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgIGNhc2UgXCJMaXRlcmFsXCI6XG4gICAgY2FzZSBcIlByb2dyYW1cIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIHNlc3Npb24gaXMgYW4gaW5zdGFuY2Ugb2YgQWNlIGVkaXRTZXNzaW9uXG4vLyBVc2FnZVxuLy8gdmFyIGxlbmd0aEFycmF5ID0gY2FsY3VsYXRlQ3VtdWxhdGl2ZUxlbmd0aChlZGl0b3IuZ2V0U2Vzc2lvbigpKTtcbi8vIE5lZWQgdG8gY2FsbCB0aGlzIG9ubHkgaWYgdGhlIGRvY3VtZW50IGlzIHVwZGF0ZWQgYWZ0ZXIgdGhlIGxhc3QgY2FsbC5cbmV4cG9ydHMuY2FsY3VsYXRlQ3VtdWxhdGl2ZUxlbmd0aCA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gIHZhciByZWdleCA9IC9cXG4vZywgcmVzdWx0ID0gW107XG4gIGRvIHtcbiAgICByZXN1bHQucHVzaChyZWdleC5sYXN0SW5kZXgpO1xuICAgIHJlZ2V4LmV4ZWMoY29kZSk7XG4gIH0gd2hpbGUgKHJlZ2V4Lmxhc3RJbmRleCAhPT0gMCk7XG5cbiAgcmVzdWx0LnB1c2goY29kZS5sZW5ndGggKyAxKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIEZhc3QgYmluYXJ5IHNlYXJjaCBpbXBsZW1lbnRhdGlvblxuLy8gUGFzcyB0aGUgY3VtdWxhdGl2ZSBsZW5ndGggYXJyYXkgaGVyZS5cbi8vIFVzYWdlXG4vLyB2YXIgcm93ID0gYWNlRmluZFJvdyhsZW5ndGhBcnJheSwgMCwgbGVuZ3RoQXJyYXkubGVuZ3RoLCAyNTEyKTtcbi8vIHRyaWVzIHRvIGZpbmQgMjUxMnRoIGNoYXJhY3RlciBsaWVzIGluIHdoaWNoIHJvdy5cbmV4cG9ydHMuYWNlRmluZFJvdyA9IGZ1bmN0aW9uIChjdW11bGF0aXZlTGVuZ3RoLCByb3dzLCByb3dlLCBwb3MpIHtcbiAgaWYgKHJvd3MgPiByb3dlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHJvd3MgKyAxID09PSByb3dlKSB7XG4gICAgcmV0dXJuIHJvd3M7XG4gIH1cblxuICB2YXIgbWlkID0gTWF0aC5mbG9vcigocm93cyArIHJvd2UpIC8gMik7XG5cbiAgaWYgKHBvcyA8IGN1bXVsYXRpdmVMZW5ndGhbbWlkXSkge1xuICAgIHJldHVybiBleHBvcnRzLmFjZUZpbmRSb3coY3VtdWxhdGl2ZUxlbmd0aCwgcm93cywgbWlkLCBwb3MpO1xuICB9IGVsc2UgaWYocG9zID4gY3VtdWxhdGl2ZUxlbmd0aFttaWRdKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuYWNlRmluZFJvdyhjdW11bGF0aXZlTGVuZ3RoLCBtaWQsIHJvd2UsIHBvcyk7XG4gIH1cbiAgcmV0dXJuIG1pZDtcbn07XG5cbmV4cG9ydHMuaXNBY2VCcmVha3BvaW50Um93ID0gZnVuY3Rpb24gKHNlc3Npb24sIHVzZXJDb2RlUm93KSB7XG4gIGlmICghc2Vzc2lvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgYnBzID0gc2Vzc2lvbi5nZXRCcmVha3BvaW50cygpO1xuICByZXR1cm4gQm9vbGVhbihicHNbdXNlckNvZGVSb3ddKTtcbn07XG5cbnZhciBsYXN0SGlnaGxpZ2h0TWFya2VySWRzID0ge307XG5cbi8qKlxuICogQ2xlYXJzIGFsbCBoaWdobGlnaHRzIHRoYXQgd2UgaGF2ZSBhZGRlZCBpbiB0aGUgYWNlIGVkaXRvci5cbiAqL1xuZnVuY3Rpb24gY2xlYXJBbGxIaWdobGlnaHRlZEFjZUxpbmVzIChhY2VFZGl0b3IpIHtcbiAgdmFyIHNlc3Npb24gPSBhY2VFZGl0b3IuZ2V0U2Vzc2lvbigpO1xuICBmb3IgKHZhciBobENsYXNzIGluIGxhc3RIaWdobGlnaHRNYXJrZXJJZHMpIHtcbiAgICBzZXNzaW9uLnJlbW92ZU1hcmtlcihsYXN0SGlnaGxpZ2h0TWFya2VySWRzW2hsQ2xhc3NdKTtcbiAgfVxuICBsYXN0SGlnaGxpZ2h0TWFya2VySWRzID0ge307XG59XG5cbi8qKlxuICogSGlnaGxpZ2h0cyBsaW5lcyBpbiB0aGUgYWNlIGVkaXRvci4gQWx3YXlzIG1vdmVzIHRoZSBwcmV2aW91cyBoaWdobGlnaHQgd2l0aFxuICogdGhlIHNhbWUgY2xhc3MgdG8gdGhlIG5ldyBsb2NhdGlvbi5cbiAqXG4gKiBJZiB0aGUgcm93IHBhcmFtZXRlcnMgYXJlIG5vdCBzdXBwbGllZCwganVzdCBjbGVhciB0aGUgbGFzdCBoaWdobGlnaHQuXG4gKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodEFjZUxpbmVzIChhY2VFZGl0b3IsIGNsYXNzTmFtZSwgc3RhcnRSb3csIHN0YXJ0Q29sdW1uLCBlbmRSb3csIGVuZENvbHVtbikge1xuICB2YXIgc2Vzc2lvbiA9IGFjZUVkaXRvci5nZXRTZXNzaW9uKCk7XG4gIGNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCAnYWNlX3N0ZXAnO1xuICBpZiAobGFzdEhpZ2hsaWdodE1hcmtlcklkc1tjbGFzc05hbWVdKSB7XG4gICAgc2Vzc2lvbi5yZW1vdmVNYXJrZXIobGFzdEhpZ2hsaWdodE1hcmtlcklkc1tjbGFzc05hbWVdKTtcbiAgICBsYXN0SGlnaGxpZ2h0TWFya2VySWRzW2NsYXNzTmFtZV0gPSBudWxsO1xuICB9XG4gIGlmICh0eXBlb2Ygc3RhcnRSb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbGFzdEhpZ2hsaWdodE1hcmtlcklkc1tjbGFzc05hbWVdID0gc2Vzc2lvbi5hZGRNYXJrZXIoXG4gICAgICAgIG5ldyAod2luZG93LmFjZS5yZXF1aXJlKCdhY2UvcmFuZ2UnKS5SYW5nZSkoXG4gICAgICAgICAgICBzdGFydFJvdywgc3RhcnRDb2x1bW4sIGVuZFJvdywgZW5kQ29sdW1uKSwgY2xhc3NOYW1lLCAndGV4dCcpO1xuICAgIGlmICghYWNlRWRpdG9yLmlzUm93RnVsbHlWaXNpYmxlKHN0YXJ0Um93KSkge1xuICAgICAgYWNlRWRpdG9yLnNjcm9sbFRvTGluZShzdGFydFJvdywgdHJ1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2VsZWN0cyBhbmQgaGlnaGxpZ2h0cyBjb2RlIGluIGRyb3BsZXQvYWNlIGVkaXRvciB0byBpbmRpY2F0ZSBhbiBlcnJvci5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHNpbXBseSBoaWdobGlnaHRzIG9uZSBzcG90LCBub3QgYSByYW5nZS4gSXQgaXMgdHlwaWNhbGx5IHVzZWRcbiAqIHRvIGhpZ2hsaWdodCB3aGVyZSBhbiBlcnJvciBoYXMgb2NjdXJyZWQuXG4gKi9cbmV4cG9ydHMuc2VsZWN0RWRpdG9yUm93Q29sRXJyb3IgPSBmdW5jdGlvbiAoZWRpdG9yLCByb3csIGNvbCkge1xuICBpZiAoIWVkaXRvcikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWRpdG9yLmN1cnJlbnRseVVzaW5nQmxvY2tzKSB7XG4gICAgdmFyIHN0eWxlID0ge2NvbG9yOiAnI0ZGRkYyMid9O1xuICAgIGVkaXRvci5jbGVhckxpbmVNYXJrcygpO1xuICAgIGVkaXRvci5tYXJrTGluZShyb3csIHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmFjZUVkaXRvci5nZXRTZWxlY3Rpb24oKTtcbiAgICB2YXIgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcblxuICAgIHJhbmdlLnN0YXJ0LnJvdyA9IHJvdztcbiAgICByYW5nZS5zdGFydC5jb2x1bW4gPSBjb2w7XG4gICAgcmFuZ2UuZW5kLnJvdyA9IHJvdztcbiAgICByYW5nZS5lbmQuY29sdW1uID0gY29sICsgMTtcblxuICAgIC8vIHNldHRpbmcgd2l0aCB0aGUgYmFja3dhcmRzIHBhcmFtZXRlciBzZXQgdG8gdHJ1ZSAtIHRoaXMgcHJldmVudHMgaG9yaXpvbnRhbFxuICAgIC8vIHNjcm9sbGluZyB0byB0aGUgcmlnaHRcbiAgICBzZWxlY3Rpb24uc2V0U2VsZWN0aW9uUmFuZ2UocmFuZ2UsIHRydWUpO1xuICB9XG4gIGxhc3RIaWdobGlnaHRNYXJrZXJJZHMuYWNlX2Vycm9yID0gZWRpdG9yLmFjZUVkaXRvci5nZXRTZXNzaW9uKClcbiAgICAgIC5oaWdobGlnaHRMaW5lcyhyb3csIHJvdywgJ2FjZV9lcnJvcicpLmlkO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGhpZ2hsaWdodHMgKGZvciB0aGUgZGVmYXVsdCBhY2Vfc3RlcCBjbGFzcykgYW5kIHNlbGVjdGlvbiBpblxuICogZHJvcGxldCBhbmQgYWNlIGVkaXRvcnMuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBhbGxDbGFzc2VzIFdoZW4gc2V0IHRvIHRydWUsIHJlbW92ZSBhbGwgY2xhc3NlcyBvZlxuICogaGlnaGxpZ2h0cyAoaW5jbHVkaW5nIGFjZV9zdGVwLCBhY2VfZXJyb3IsIGFuZCBhbnl0aGluZyBlbHNlKVxuICovXG5leHBvcnRzLmNsZWFyRHJvcGxldEFjZUhpZ2hsaWdodGluZyA9IGZ1bmN0aW9uIChlZGl0b3IsIGFsbENsYXNzZXMpIHtcbiAgaWYgKGVkaXRvci5jdXJyZW50bHlVc2luZ0Jsb2Nrcykge1xuICAgIGVkaXRvci5jbGVhckxpbmVNYXJrcygpO1xuICB9IGVsc2Uge1xuICAgIGVkaXRvci5hY2VFZGl0b3IuZ2V0U2VsZWN0aW9uKCkuY2xlYXJTZWxlY3Rpb24oKTtcbiAgfVxuICBpZiAoYWxsQ2xhc3Nlcykge1xuICAgIGNsZWFyQWxsSGlnaGxpZ2h0ZWRBY2VMaW5lcyhlZGl0b3IuYWNlRWRpdG9yKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB3aGVuIGNhbGxpbmcgd2l0aG91dCBhIGNsYXNzIG9yIHJvd3MsIGhpZ2hsaWdodEFjZUxpbmVzKCkgd2lsbCBjbGVhclxuICAgIC8vIGV2ZXJ5dGhpbmcgaGlnaGxpZ2h0ZWQgd2l0aCB0aGUgZGVmYXVsdCBoaWdobGlnaHQgY2xhc3NcbiAgICBoaWdobGlnaHRBY2VMaW5lcyhlZGl0b3IuYWNlRWRpdG9yKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gc2VsZWN0QW5kSGlnaGxpZ2h0Q29kZSAoYWNlRWRpdG9yLCBjdW11bGF0aXZlTGVuZ3RoLCBzdGFydCwgZW5kLCBoaWdobGlnaHRDbGFzcykge1xuICB2YXIgc2VsZWN0aW9uID0gYWNlRWRpdG9yLmdldFNlbGVjdGlvbigpO1xuICB2YXIgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcblxuICByYW5nZS5zdGFydC5yb3cgPSBleHBvcnRzLmFjZUZpbmRSb3coY3VtdWxhdGl2ZUxlbmd0aCwgMCwgY3VtdWxhdGl2ZUxlbmd0aC5sZW5ndGgsIHN0YXJ0KTtcbiAgcmFuZ2Uuc3RhcnQuY29sdW1uID0gc3RhcnQgLSBjdW11bGF0aXZlTGVuZ3RoW3JhbmdlLnN0YXJ0LnJvd107XG4gIHJhbmdlLmVuZC5yb3cgPSBleHBvcnRzLmFjZUZpbmRSb3coY3VtdWxhdGl2ZUxlbmd0aCwgMCwgY3VtdWxhdGl2ZUxlbmd0aC5sZW5ndGgsIGVuZCk7XG4gIHJhbmdlLmVuZC5jb2x1bW4gPSBlbmQgLSBjdW11bGF0aXZlTGVuZ3RoW3JhbmdlLmVuZC5yb3ddO1xuXG4gIGhpZ2hsaWdodEFjZUxpbmVzKGFjZUVkaXRvciwgaGlnaGxpZ2h0Q2xhc3MgfHwgXCJhY2Vfc3RlcFwiLCByYW5nZS5zdGFydC5yb3csXG4gICAgICByYW5nZS5zdGFydC5jb2x1bW4sIHJhbmdlLmVuZC5yb3csIHJhbmdlLmVuZC5jb2x1bW4pO1xufVxuXG4vKipcbiAqIFNlbGVjdHMgY29kZSBpbiBkcm9wbGV0L2FjZSBlZGl0b3IuXG4gKlxuICogUmV0dXJucyB0aGUgcm93IChsaW5lKSBvZiBjb2RlIGhpZ2hsaWdodGVkLiBJZiBub3RoaW5nIGlzIGhpZ2hsaWdodGVkXG4gKiBiZWNhdXNlIGl0IGlzIG91dHNpZGUgb2YgdGhlIHVzZXJDb2RlIGFyZWEsIHRoZSByZXR1cm4gdmFsdWUgaXMgLTFcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGlnaGxpZ2h0Q2xhc3MgQ1NTIGNsYXNzIHRvIHVzZSB3aGVuIGhpZ2hsaWdodGluZyBpbiBBQ0VcbiAqL1xuZXhwb3J0cy5zZWxlY3RDdXJyZW50Q29kZSA9IGZ1bmN0aW9uIChpbnRlcnByZXRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VtdWxhdGl2ZUxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlckNvZGVTdGFydE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlckNvZGVMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0Q2xhc3MpIHtcbiAgdmFyIHVzZXJDb2RlUm93ID0gLTE7XG4gIGlmIChpbnRlcnByZXRlciAmJiBpbnRlcnByZXRlci5zdGF0ZVN0YWNrWzBdKSB7XG4gICAgdmFyIG5vZGUgPSBpbnRlcnByZXRlci5zdGF0ZVN0YWNrWzBdLm5vZGU7XG5cbiAgICBpZiAobm9kZS50eXBlID09PSAnRm9yU3RhdGVtZW50Jykge1xuICAgICAgdmFyIG1vZGUgPSBpbnRlcnByZXRlci5zdGF0ZVN0YWNrWzBdLm1vZGUgfHwgMCwgc3ViTm9kZTtcbiAgICAgIGlmIChtb2RlID09PSAwKSB7XG4gICAgICAgIHN1Yk5vZGUgPSBub2RlLmluaXQ7XG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IDEpIHtcbiAgICAgICAgc3ViTm9kZSA9IG5vZGUudGVzdDtcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gMikge1xuICAgICAgICBzdWJOb2RlID0gbm9kZS5ib2R5O1xuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAzKSB7XG4gICAgICAgIHN1Yk5vZGUgPSBub2RlLnVwZGF0ZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBzdWJOb2RlIHx8IG5vZGU7XG4gICAgfVxuXG4gICAgLy8gQWRqdXN0IHN0YXJ0L2VuZCBieSB1c2VyQ29kZVN0YXJ0T2Zmc2V0IHNpbmNlIHRoZSBjb2RlIHJ1bm5pbmdcbiAgICAvLyBoYXMgYmVlbiBleHBhbmRlZCB2cy4gd2hhdCB0aGUgdXNlciBzZWVzIGluIHRoZSBlZGl0b3Igd2luZG93OlxuICAgIHZhciBzdGFydCA9IG5vZGUuc3RhcnQgLSB1c2VyQ29kZVN0YXJ0T2Zmc2V0O1xuICAgIHZhciBlbmQgPSBub2RlLmVuZCAtIHVzZXJDb2RlU3RhcnRPZmZzZXQ7XG5cbiAgICAvLyBPbmx5IHNob3cgc2VsZWN0aW9uIGlmIHRoZSBub2RlIGJlaW5nIGV4ZWN1dGVkIGlzIGluc2lkZSB0aGUgdXNlcidzXG4gICAgLy8gY29kZSAobm90IGluc2lkZSBjb2RlIHdlIGluc2VydGVkIGJlZm9yZSBvciBhZnRlciB0aGVpciBjb2RlIHRoYXQgaXNcbiAgICAvLyBub3QgdmlzaWJsZSBpbiB0aGUgZWRpdG9yKTpcbiAgICBpZiAoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHVzZXJDb2RlTGVuZ3RoICYmIGVuZCA8PSB1c2VyQ29kZUxlbmd0aCkge1xuICAgICAgdXNlckNvZGVSb3cgPSBleHBvcnRzLmFjZUZpbmRSb3coY3VtdWxhdGl2ZUxlbmd0aCwgMCwgY3VtdWxhdGl2ZUxlbmd0aC5sZW5ndGgsIHN0YXJ0KTtcbiAgICAgIC8vIEhpZ2hsaWdodCB0aGUgY29kZSBiZWluZyBleGVjdXRlZCBpbiBlYWNoIHN0ZXA6XG4gICAgICBpZiAoZWRpdG9yLmN1cnJlbnRseVVzaW5nQmxvY2tzKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHtjb2xvcjogJyNGRkZGMjInfTtcbiAgICAgICAgZWRpdG9yLmNsZWFyTGluZU1hcmtzKCk7XG4gICAgICAgIGVkaXRvci5tYXJrKHtyb3c6IHVzZXJDb2RlUm93LCBjb2w6IHN0YXJ0IC0gY3VtdWxhdGl2ZUxlbmd0aFt1c2VyQ29kZVJvd119LCBzdHlsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RBbmRIaWdobGlnaHRDb2RlKGVkaXRvci5hY2VFZGl0b3IsIGN1bXVsYXRpdmVMZW5ndGgsIHN0YXJ0LCBlbmQsXG4gICAgICAgICAgICBoaWdobGlnaHRDbGFzcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuY2xlYXJEcm9wbGV0QWNlSGlnaGxpZ2h0aW5nKGVkaXRvcik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuY2xlYXJEcm9wbGV0QWNlSGlnaGxpZ2h0aW5nKGVkaXRvcik7XG4gIH1cbiAgcmV0dXJuIHVzZXJDb2RlUm93O1xufTtcbiIsInZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBfID0gdXRpbHMuZ2V0TG9kYXNoKCk7XG5cbi8qKlxuICogQG5hbWUgRHJvcGxldEJsb2NrXG4gKiBAZGVzY3JpcHRpb24gRGVmaW5pdGlvbiBvZiBhIGJsb2NrIHRvIGJlIHVzZWQgaW4gRHJvcGxldFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZ1bmMgaWRlbnRpZnlpbmcgdGhlIGZ1bmN0aW9uIHRoaXMgYmxvY2sgcnVuc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGJsb2NrUHJlZml4IFByZXBlbmQgdGhpcyBzdHJpbmcgYmVmb3JlIHRoZSBub3JtYWwgYmxvY2sgbmFtZSBpbiB0aGUgcGFsZXR0ZVxuICogQHByb3BlcnR5IHtPYmplY3R9IHBhcmVudCBvYmplY3Qgd2l0aGluIHdoaWNoIHRoaXMgZnVuY3Rpb24gaXMgZGVmaW5lZCBhcyBhIHByb3BlcnR5LCBrZXllZCBieSB0aGUgZnVuYyBuYW1lXG4gKiBAcHJvcGVydHkge1N0cmluZ30gY2F0ZWdvcnkgY2F0ZWdvcnkgd2l0aGluIHdoaWNoIHRvIHBsYWNlIHRoZSBibG9ja1xuICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGUgdHlwZSBvZiB0aGUgYmxvY2sgKGUuZy4gdmFsdWUsIGVpdGhlciwgcHJvcGVydHkpXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBwYWxldHRlUGFyYW1zXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBwYXJhbXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxudW1iZXIsIGZ1bmN0aW9uPn0gZHJvcGRvd25cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxudW1iZXIsIGZ1bmN0aW9uPn0gYXNzZXRUb29sdGlwXG4gKiBAcHJvcGVydHkge2Jvb2x9IGRvbnRNYXJzaGFsIEFQSSBleHBlY3RzIHBhcmFtcyBpbiBpbnRlcnByZXRlciBmb3JtIGFuZCB3aWxsIHJldHVybiBhbiBpbnRlcnByZXRlciB2YWx1ZVxuICogQHByb3BlcnR5IHtib29sfSBub0F1dG9jb21wbGV0ZSBEbyBub3QgaW5jbHVkZSB0aGlzIGZ1bmN0aW9uIGluIG91ciBhY2UgY29tcGxldGVyXG4gKiBAcHJvcGVydHkge2Jvb2x9IG5hdGl2ZUlzQXN5bmMgVGhlIG5hdGl2ZSBmdW5jdGlvbiBpcyBpbnRlcm5hbGx5IGFzeW5jIGFuZCB3aWxsIGNhbGwgYSBjYWxsYmFjayBmdW5jdGlvbiB0byByZXN1bWUgdGhlIGludGVycHJldGVyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGlwUHJlZml4IFByZXBlbmQgdGhpcyBzdHJpbmcgYmVmb3JlIHRoZSB0b29sdGlwIGZvcm1lZCBmcm9tIHRoZSBmdW5jdGlvbiBuYW1lIGFuZCAob3B0aW9uYWxseSkgcGFyYW1ldGVyc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGRvY0Z1bmMgVXNlIHRoZSBwcm92aWRlZCBmdW5jIGFzIHRoZSBrZXkgZm9yIG91ciBkb2N1bWVudGF0aW9uLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1vZGVPcHRpb25OYW1lIEFsdGVybmF0ZSBuYW1lIHRvIGJlIHVzZWQgd2hlbiBnZW5lcmF0aW5nIGRyb3BsZXQgbW9kZSBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBAbmFtZSBEcm9wbGV0Q29uZmlnXG4gKiBAZGVzY3JpcHRpb24gQ29uZmlndXJhdGlvbiBpbmZvcm1hdGlvbiBmb3IgRHJvcGxldFxuICogQHByb3BlcnR5IHtEcm9wbGV0QmxvY2tbXX0gYmxvY2tzIGxpc3Qgb2YgYmxvY2tzXG4gKiBAcHJvcGVydHkge09iamVjdH0gY2F0ZWdvcmllcyBjb25maWd1cmF0aW9uIG9mIGNhdGVnb3JpZXMgd2l0aGluIHdoaWNoIHRvIHBsYWNlIGJsb2Nrc1xuICovXG5cbnZhciBDT0xPUl9QSU5LID0gJyNGNTdBQzYnO1xudmFyIENPTE9SX1BVUlBMRSA9ICcjQkI3N0M3JztcbnZhciBDT0xPUl9HUkVFTiA9ICcjNjhEOTk1JztcbnZhciBDT0xPUl9MSUdIVF9HUkVFTiA9ICcjRDNFOTY1JztcbnZhciBDT0xPUl9XSElURSA9ICcjRkZGRkZGJztcbnZhciBDT0xPUl9CTFVFID0gJyM2NEI1RjYnO1xudmFyIENPTE9SX09SQU5HRSA9ICcjRkZCNzREJztcblxuZXhwb3J0cy5yYW5kb21OdW1iZXIgPSBmdW5jdGlvbiAobWluLCBtYXgpIHtcbiAgaWYgKHR5cGVvZiBtYXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gSWYgb25seSBvbmUgcGFyYW1ldGVyIGlzIHNwZWNpZmllZCwgdXNlIGl0IGFzIHRoZSBtYXggd2l0aCB6ZXJvIGFzIG1pbjpcbiAgICBtYXggPSBtaW47XG4gICAgbWluID0gMDtcbiAgfVxuICAvLyBVc2UgZG91YmxlLXRpbGRlIHRvIGVuc3VyZSB3ZSBhcmUgZGVhbGluZyB3aXRoIGludGVnZXJzOlxuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKH5+bWF4IC0gfn5taW4gKyAxKSkgKyB+fm1pbjtcbn07XG5cbmV4cG9ydHMuZ2V0VGltZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbn07XG5cbi8qKlxuICogVXNlIG5hdGl2ZSB3aW5kb3cucHJvbXB0IHRvIGFzayBmb3IgYSB2YWx1ZSwgYnV0IGNvbnRpbnVlIHByb21wdGluZyB1bnRpbCB3ZVxuICogZ2V0IGEgbnVtZXJpY2FsIHZhbHVlLlxuICogQHJldHVybnMge251bWJlcn0gVXNlciB2YWx1ZSwgY29udmVydGVkIHRvIGEgbnVtYmVyXG4gKi9cbmV4cG9ydHMucHJvbXB0TnVtID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgdmFyIHZhbDtcbiAgZG8ge1xuICAgIHZhbCA9IHBhcnNlSW50KHdpbmRvdy5wcm9tcHQodGV4dCksIDEwKTtcbiAgfSB3aGlsZSAoaXNOYU4odmFsKSk7XG4gIHJldHVybiB2YWw7XG59O1xuXG4vKipcbiAqIEB0eXBlIHtEcm9wbGV0QmxvY2tbXX1cbiAqL1xuZXhwb3J0cy5kcm9wbGV0R2xvYmFsQ29uZmlnQmxvY2tzID0gW1xuICB7ZnVuYzogJ2dldFRpbWUnLCBwYXJlbnQ6IGV4cG9ydHMsIGNhdGVnb3J5OiAnQ29udHJvbCcsIHR5cGU6ICd2YWx1ZScgfSxcbiAge2Z1bmM6ICdyYW5kb21OdW1iZXInLCBwYXJlbnQ6IGV4cG9ydHMsIGNhdGVnb3J5OiAnTWF0aCcsIHR5cGU6ICd2YWx1ZScgfSxcbiAge2Z1bmM6ICdwcm9tcHQnLCBwYXJlbnQ6IHdpbmRvdywgY2F0ZWdvcnk6ICdWYXJpYWJsZXMnLCB0eXBlOiAndmFsdWUnIH0sXG4gIHtmdW5jOiAncHJvbXB0TnVtJywgcGFyZW50OiBleHBvcnRzLCBjYXRlZ29yeTogJ1ZhcmlhYmxlcycsIHR5cGU6ICd2YWx1ZScgfVxuXTtcblxuLyoqXG4gKiBAdHlwZSB7RHJvcGxldEJsb2NrW119XG4gKi9cbmV4cG9ydHMuZHJvcGxldEJ1aWx0aW5Db25maWdCbG9ja3MgPSBbXG4gIHtmdW5jOiAnTWF0aC5yb3VuZCcsIGNhdGVnb3J5OiAnTWF0aCcsIHR5cGU6ICd2YWx1ZScsIGRvY0Z1bmM6ICdtYXRoUm91bmQnIH0sXG4gIHtmdW5jOiAnTWF0aC5hYnMnLCBjYXRlZ29yeTogJ01hdGgnLCB0eXBlOiAndmFsdWUnLCBkb2NGdW5jOiAnbWF0aEFicycgfSxcbiAge2Z1bmM6ICdNYXRoLm1heCcsIGNhdGVnb3J5OiAnTWF0aCcsIHR5cGU6ICd2YWx1ZScsIGRvY0Z1bmM6ICdtYXRoTWF4JyB9LFxuICB7ZnVuYzogJ01hdGgubWluJywgY2F0ZWdvcnk6ICdNYXRoJywgdHlwZTogJ3ZhbHVlJywgZG9jRnVuYzogJ21hdGhNaW4nIH0sXG4gIHtmdW5jOiAnTWF0aC5yYW5kb20nLCBjYXRlZ29yeTogJ01hdGgnLCB0eXBlOiAndmFsdWUnLCBkb2NGdW5jOiAnbWF0aFJhbmRvbScgfVxuXTtcblxuLyoqXG4gKiBAdHlwZSB7RHJvcGxldENvbmZpZ3wqfX1cbiAqL1xudmFyIHN0YW5kYXJkQ29uZmlnID0ge307XG5cbnN0YW5kYXJkQ29uZmlnLmJsb2NrcyA9IFtcbiAgLy8gQ29udHJvbFxuICB7ZnVuYzogJ2Zvckxvb3BfaV8wXzQnLCBibG9jazogJ2ZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XFxuICBfXztcXG59JywgY2F0ZWdvcnk6ICdDb250cm9sJyB9LFxuICB7ZnVuYzogJ3doaWxlQmxvY2snLCBibG9jazogJ3doaWxlIChfXykge1xcbiAgX187XFxufScsIGNhdGVnb3J5OiAnQ29udHJvbCcgfSxcbiAge2Z1bmM6ICdpZkJsb2NrJywgYmxvY2s6ICdpZiAoX18pIHtcXG4gIF9fO1xcbn0nLCBjYXRlZ29yeTogJ0NvbnRyb2wnIH0sXG4gIHtmdW5jOiAnaWZFbHNlQmxvY2snLCBibG9jazogJ2lmIChfXykge1xcbiAgX187XFxufSBlbHNlIHtcXG4gIF9fO1xcbn0nLCBjYXRlZ29yeTogJ0NvbnRyb2wnIH0sXG4gIHtmdW5jOiAnZ2V0VGltZScsIGJsb2NrOiAnZ2V0VGltZSgpJywgY2F0ZWdvcnk6ICdDb250cm9sJywgdHlwZTogJ3ZhbHVlJyB9LFxuXG4gIC8vIE1hdGhcbiAge2Z1bmM6ICdhZGRPcGVyYXRvcicsIGJsb2NrOiAnX18gKyBfXycsIGNhdGVnb3J5OiAnTWF0aCcgfSxcbiAge2Z1bmM6ICdzdWJ0cmFjdE9wZXJhdG9yJywgYmxvY2s6ICdfXyAtIF9fJywgY2F0ZWdvcnk6ICdNYXRoJyB9LFxuICB7ZnVuYzogJ211bHRpcGx5T3BlcmF0b3InLCBibG9jazogJ19fICogX18nLCBjYXRlZ29yeTogJ01hdGgnIH0sXG4gIHtmdW5jOiAnZGl2aWRlT3BlcmF0b3InLCBibG9jazogJ19fIC8gX18nLCBjYXRlZ29yeTogJ01hdGgnIH0sXG4gIHtmdW5jOiAnZXF1YWxpdHlPcGVyYXRvcicsIGJsb2NrOiAnX18gPT0gX18nLCBjYXRlZ29yeTogJ01hdGgnIH0sXG4gIHtmdW5jOiAnaW5lcXVhbGl0eU9wZXJhdG9yJywgYmxvY2s6ICdfXyAhPSBfXycsIGNhdGVnb3J5OiAnTWF0aCcgfSxcbiAge2Z1bmM6ICdncmVhdGVyVGhhbk9wZXJhdG9yJywgYmxvY2s6ICdfXyA+IF9fJywgY2F0ZWdvcnk6ICdNYXRoJyB9LFxuICB7ZnVuYzogJ2dyZWF0ZXJUaGFuT3JFcXVhbE9wZXJhdG9yJywgYmxvY2s6ICdfXyA+PSBfXycsIGNhdGVnb3J5OiAnTWF0aCcgfSxcbiAge2Z1bmM6ICdsZXNzVGhhbk9wZXJhdG9yJywgYmxvY2s6ICdfXyA8IF9fJywgY2F0ZWdvcnk6ICdNYXRoJyB9LFxuICB7ZnVuYzogJ2xlc3NUaGFuT3JFcXVhbE9wZXJhdG9yJywgYmxvY2s6ICdfXyA8PSBfXycsIGNhdGVnb3J5OiAnTWF0aCcgfSxcbiAge2Z1bmM6ICdhbmRPcGVyYXRvcicsIGJsb2NrOiAnX18gJiYgX18nLCBjYXRlZ29yeTogJ01hdGgnIH0sXG4gIHtmdW5jOiAnb3JPcGVyYXRvcicsIGJsb2NrOiAnX18gfHwgX18nLCBjYXRlZ29yeTogJ01hdGgnIH0sXG4gIHtmdW5jOiAnbm90T3BlcmF0b3InLCBibG9jazogJyFfXycsIGNhdGVnb3J5OiAnTWF0aCcgfSxcbiAgLy8gcmFuZG9tTnVtYmVyX21heCBoYXMgYmVlbiBkZXByZWNhdGVkXG4gIC8vIHtmdW5jOiAncmFuZG9tTnVtYmVyX21heCcsIGJsb2NrOiAncmFuZG9tTnVtYmVyKF9fKScsIGNhdGVnb3J5OiAnTWF0aCcgfSxcbiAgLy8gTm90ZTogV2UgdXNlIHJhbmRvbU51bWJlciBhcyBvdXIgYmFzZSBkb2NGdW5jIGhlcmUgc28gdGhhdCB3ZSBnZXQgdGhlIGJlbmVmaXRzIG9mIHBhcmFtIGRlc2NyaXB0aW9uc1xuICB7ZnVuYzogJ3JhbmRvbU51bWJlcl9taW5fbWF4JywgYmxvY2s6ICdyYW5kb21OdW1iZXIoX18sIF9fKScsIGNhdGVnb3J5OiAnTWF0aCcsIGRvY0Z1bmM6ICdyYW5kb21OdW1iZXInfSxcbiAge2Z1bmM6ICdtYXRoUm91bmQnLCBibG9jazogJ01hdGgucm91bmQoX18pJywgY2F0ZWdvcnk6ICdNYXRoJyB9LFxuICB7ZnVuYzogJ21hdGhBYnMnLCBibG9jazogJ01hdGguYWJzKF9fKScsIGNhdGVnb3J5OiAnTWF0aCcgfSxcbiAge2Z1bmM6ICdtYXRoTWF4JywgYmxvY2s6ICdNYXRoLm1heChfXyknLCBjYXRlZ29yeTogJ01hdGgnIH0sXG4gIHtmdW5jOiAnbWF0aE1pbicsIGJsb2NrOiAnTWF0aC5taW4oX18pJywgY2F0ZWdvcnk6ICdNYXRoJyB9LFxuICB7ZnVuYzogJ21hdGhSYW5kb20nLCBibG9jazogJ01hdGgucmFuZG9tKCknLCBjYXRlZ29yeTogJ01hdGgnIH0sXG5cbiAgLy8gVmFyaWFibGVzXG4gIHtmdW5jOiAnZGVjbGFyZUFzc2lnbl94JywgYmxvY2s6ICd2YXIgeCA9IF9fOycsIGNhdGVnb3J5OiAnVmFyaWFibGVzJyB9LFxuICB7ZnVuYzogJ2RlY2xhcmVOb0Fzc2lnbl94JywgYmxvY2s6ICd2YXIgeDsnLCBjYXRlZ29yeTogJ1ZhcmlhYmxlcycgfSxcbiAge2Z1bmM6ICdhc3NpZ25feCcsIGJsb2NrOiAneCA9IF9fOycsIGNhdGVnb3J5OiAnVmFyaWFibGVzJyB9LFxuICB7ZnVuYzogJ2RlY2xhcmVBc3NpZ25feF9hcnJheV8xXzQnLCBibG9jazogJ3ZhciB4ID0gWzEsIDIsIDMsIDRdOycsIGNhdGVnb3J5OiAnVmFyaWFibGVzJyB9LFxuICB7ZnVuYzogJ2RlY2xhcmVBc3NpZ25feF9wcm9tcHQnLCBibG9jazogJ3ZhciB4ID0gcHJvbXB0KFwiRW50ZXIgYSB2YWx1ZVwiKTsnLCBjYXRlZ29yeTogJ1ZhcmlhYmxlcycgfSxcbiAge2Z1bmM6ICdkZWNsYXJlQXNzaWduX3hfcHJvbXB0TnVtJywgYmxvY2s6ICd2YXIgeCA9IHByb21wdE51bShcIkVudGVyIGEgdmFsdWVcIik7JywgY2F0ZWdvcnk6ICdWYXJpYWJsZXMnIH0sXG5cbiAgLy8gRnVuY3Rpb25zXG4gIHtmdW5jOiAnZnVuY3Rpb25QYXJhbXNfbm9uZScsIGJsb2NrOiAnZnVuY3Rpb24gbXlGdW5jdGlvbigpIHtcXG4gIF9fO1xcbn0nLCBjYXRlZ29yeTogJ0Z1bmN0aW9ucycgfSxcbiAge2Z1bmM6ICdmdW5jdGlvblBhcmFtc19uJywgYmxvY2s6ICdmdW5jdGlvbiBteUZ1bmN0aW9uKG4pIHtcXG4gIF9fO1xcbn0nLCBjYXRlZ29yeTogJ0Z1bmN0aW9ucycgfSxcbiAge2Z1bmM6ICdjYWxsTXlGdW5jdGlvbicsIGJsb2NrOiAnbXlGdW5jdGlvbigpJywgY2F0ZWdvcnk6ICdGdW5jdGlvbnMnIH0sXG4gIHtmdW5jOiAnY2FsbE15RnVuY3Rpb25fbicsIGJsb2NrOiAnbXlGdW5jdGlvbihuKScsIGNhdGVnb3J5OiAnRnVuY3Rpb25zJyB9LFxuICB7ZnVuYzogJ3JldHVybicsIGJsb2NrOiAncmV0dXJuIF9fOycsIGNhdGVnb3J5OiAnRnVuY3Rpb25zJyB9LFxuICB7ZnVuYzogJ2NvbW1lbnQnLCBibG9jazogJy8vIENvbW1lbnQnLCBjYXRlZ29yeTogJ0Z1bmN0aW9ucycgfVxuXTtcblxuc3RhbmRhcmRDb25maWcuY2F0ZWdvcmllcyA9IHtcbiAgQ29udHJvbDoge1xuICAgIGNvbG9yOiAnYmx1ZScsXG4gICAgcmdiOiBDT0xPUl9CTFVFLFxuICAgIGJsb2NrczogW11cbiAgfSxcbiAgTWF0aDoge1xuICAgIGNvbG9yOiAnb3JhbmdlJyxcbiAgICByZ2I6IENPTE9SX09SQU5HRSxcbiAgICBibG9ja3M6IFtdXG4gIH0sXG4gIFZhcmlhYmxlczoge1xuICAgIGNvbG9yOiAncHVycGxlJyxcbiAgICByZ2I6IENPTE9SX1BVUlBMRSxcbiAgICBibG9ja3M6IFtdXG4gIH0sXG4gIEZ1bmN0aW9uczoge1xuICAgIGNvbG9yOiAnZ3JlZW4nLFxuICAgIHJnYjogQ09MT1JfR1JFRU4sXG4gICAgYmxvY2tzOiBbXVxuICB9LFxuICAvLyBjcmVhdGUgYmxhbmsgY2F0ZWdvcnkgaW4gY2FzZSBsZXZlbCBidWlsZGVycyB3YW50IHRvIG1vdmUgYWxsIGJsb2NrcyBoZXJlXG4gIC8vICh3aGljaCB3aWxsIGNhdXNlIHRoZSBwYWxldHRlIGhlYWRlciB0byBkaXNhcHBlYXIpXG4gICcnIDogeyAnYmxvY2tzJzogW10gfSxcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBjb2xsZWN0aW9uIG9mIGNvZGUgZnVuY3Rpb25zIGFuZCBhIHNldCBvZiBkcm9wbGV0dGVDb25maWcsIHJldHVybnMgYVxuICogYSBsaXN0IG9mIGJsb2Nrcy5cbiAqIEBwYXJhbSBjb2RlRnVuY3Rpb25zIHtvYmplY3R9IEEgY29sbGVjdGlvbiBvZiBuYW1lZCBrZXkvdmFsdWUgcGFpcnNcbiAqICAga2V5IGlzIGEgYmxvY2sgbmFtZSBmcm9tIGRyb3BsZXRCbG9ja3Mgb3Igc3RhbmRhcmRCbG9ja3NcbiAqICAgdmFsdWUgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgYmxvY2sgZGVmYXVsdHNcbiAqIEBwYXJhbSB7RHJvcGxldENvbmZpZ30gZHJvcGxldENvbmZpZ1xuICogQHBhcmFtIHtEcm9wbGV0Q29uZmlnfSBvdGhlckNvbmZpZyBvcHRpb25hbGx5IHVzZWQgdG8gc3VwcGx5IGEgc3RhbmRhcmRDb25maWdcbiAqICBvYmplY3Qgd2hpY2ggaXMgbm90IGFwcCBzcGVjaWZpYy4gSXQgd2lsbCBiZSB1c2VkIGZpcnN0LCB0aGVuIG92ZXJyaWRlblxuICogIGJ5IHRoZSBwcmltYXJ5IGRyb3BsZXRDb25maWcgaWYgdGhlcmUgaXMgb3ZlcmxhcCBiZXR3ZWVuIHRoZSB0d28uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnBhbGV0dGVPbmx5IGlnbm9yZSBibG9ja3Mgbm90IGluIGNvZGVGdW5jdGlvbnMgcGFsZXR0ZVxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmlnbm9yZURvY0Z1bmMgZG9uJ3QgaW5jbHVkZSBiYXNlZCBvbiBibG9jay5kb2NGdW5jXG4gKiBAcmV0dXJucyB7QXJyYXk8RHJvcGxldEJsb2NrPn1cbiAqL1xuZnVuY3Rpb24gZmlsdGVyZWRCbG9ja3NGcm9tQ29uZmlnKGNvZGVGdW5jdGlvbnMsIGRyb3BsZXRDb25maWcsIG90aGVyQ29uZmlnLCBvcHRpb25zKSB7XG4gIGlmICghY29kZUZ1bmN0aW9ucyB8fCAhZHJvcGxldENvbmZpZyB8fCAhZHJvcGxldENvbmZpZy5ibG9ja3MpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgYmxvY2tzID0gW107XG4gIGlmIChvdGhlckNvbmZpZykge1xuICAgIGJsb2NrcyA9IGJsb2Nrcy5jb25jYXQob3RoZXJDb25maWcuYmxvY2tzKTtcbiAgfVxuICBibG9ja3MgPSBibG9ja3MuY29uY2F0KGRyb3BsZXRDb25maWcuYmxvY2tzKTtcblxuICB2YXIgZG9jRnVuY3Rpb25zID0ge307XG4gIGJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChibG9jaykge1xuICAgIGlmICghKGJsb2NrLmZ1bmMgaW4gY29kZUZ1bmN0aW9ucykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMuaWdub3JlRG9jRnVuYykge1xuICAgICAgLy8gRm9yIGNhc2VzIHdoZXJlIHdlIHVzZSBhIGRpZmZlcmVudCBibG9jayBmb3Igb3VyIHRvb2x0aXBzLCBtYWtlIHN1cmUgdGhhdFxuICAgICAgLy8gdGhlIHRhcmdldCBibG9jayBlbmRzIHVwIGluIHRoZSBsaXN0IG9mIGJsb2NrcyB3ZSB3YW50XG4gICAgICB2YXIgZG9jRnVuYyA9IGJsb2NrLmRvY0Z1bmM7XG4gICAgICBpZiAoZG9jRnVuYyAmJiAhKGRvY0Z1bmMgaW4gY29kZUZ1bmN0aW9ucykpIHtcbiAgICAgICAgZG9jRnVuY3Rpb25zW2RvY0Z1bmNdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBibG9ja3MuZmlsdGVyKGZ1bmN0aW9uIChibG9jaykge1xuICAgIHJldHVybiAhb3B0aW9ucy5wYWxldHRlT25seSB8fCBibG9jay5mdW5jIGluIGNvZGVGdW5jdGlvbnMgfHwgYmxvY2suZnVuYyBpbiBkb2NGdW5jdGlvbnM7XG4gIH0pLm1hcChmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAvLyBXZSBmb3VuZCB0aGlzIHBhcnRpY3VsYXIgYmxvY2ssIG5vdyBvdmVycmlkZSB0aGUgZGVmYXVsdHMgd2l0aCBleHRlbmRcbiAgICByZXR1cm4gJC5leHRlbmQoe30sIGJsb2NrLCBjb2RlRnVuY3Rpb25zW2Jsb2NrLmZ1bmNdKTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgbmV3IGNhdGVnb3JpZXMgb2JqZWN0IHdpdGggdGhlIGNhdGVnb3JpZXMgZnJvbSBkcm9wbGV0Q29uZmlnIChhcHBcbiAqIHNwZWNpZmljIGNvbmZpZ3VyYXRpb24pIG1lcmdlZCB3aXRoIHRoZSBvbmVzIGluIHN0YW5kYXJkQ29uZmlnIChnbG9iYWxcbiAqIGNvbmZpZ3VyYXRpb24pLiBBcHAgY29uZmlndXJhdGlvbiB0YWtlcyBwcmVjZW5kZW5jZVxuICovXG5mdW5jdGlvbiBtZXJnZUNhdGVnb3JpZXNXaXRoQ29uZmlnKGRyb3BsZXRDb25maWcpIHtcbiAgLy8gQ2xvbmUgb3VyIG1lcmdlZCBjYXRlZ29yaWVzIHNvIHRoYXQgYXMgd2UgbXV0YXRlIGl0LCB3ZSdyZSBub3QgbXV0YXRpbmdcbiAgLy8gb3VyIG9yaWdpbmFsIGNvbmZpZ1xuICB2YXIgZHJvcGxldENhdGVnb3JpZXMgPSBkcm9wbGV0Q29uZmlnICYmIGRyb3BsZXRDb25maWcuY2F0ZWdvcmllcztcbiAgLy8gV2UgaW5jbHVkZSBkcm9wbGV0Q2F0ZWdvcmllcyB0d2ljZSBzbyB0aGF0IChhKSBpdCdzIG9yZGVyaW5nIG9mIGNhdGVnb3JpZXNcbiAgLy8gZ2V0cyBwcmVmZXJlbmNlIGFuZCAoYikgaXQncyB2YWx1ZSBvdmVycmlkZSBhbnl0aGluZyBpbiBzdGFuZGFyZENvbmZpZ1xuICByZXR1cm4gXy5jbG9uZURlZXAoJC5leHRlbmQoe30sIGRyb3BsZXRDYXRlZ29yaWVzLCBzdGFuZGFyZENvbmZpZy5jYXRlZ29yaWVzLFxuICAgIGRyb3BsZXRDYXRlZ29yaWVzKSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgY29kZSBhbGlhc2VzIGluIEphdmFzY3JpcHQgYmFzZWQgb24gc29tZSBsZXZlbCBkYXRhLlxuICogQHBhcmFtIHtEcm9wbGV0Q29uZmlnfSBkcm9wbGV0Q29uZmlnXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50T2JqTmFtZSBzdHJpbmcgcmVmZXJlbmNlIHRvIG9iamVjdCB1cG9uIHdoaWNoIGZ1bmMgaXNcbiAqICBhIHByb3BlcnR5XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBjb2RlXG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVDb2RlQWxpYXNlcyA9IGZ1bmN0aW9uIChkcm9wbGV0Q29uZmlnLCBwYXJlbnRPYmpOYW1lKSB7XG4gIHZhciBjb2RlID0gJyc7XG4gIHZhciBhbGlhc0Z1bmN0aW9ucyA9IGRyb3BsZXRDb25maWcuYmxvY2tzO1xuXG4gIC8vIEluc2VydCBhbGlhc2VzIGZyb20gYWxpYXNGdW5jdGlvbnMgaW50byBjb2RlXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxpYXNGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2YgPSBhbGlhc0Z1bmN0aW9uc1tpXTtcbiAgICBjb2RlICs9IFwidmFyIFwiICsgY2YuZnVuYyArIFwiID0gZnVuY3Rpb24oKSB7IFwiO1xuICAgIGlmIChjZi5pZEFyZ05vbmUpIHtcbiAgICAgIGNvZGUgKz0gXCJyZXR1cm4gXCIgKyBwYXJlbnRPYmpOYW1lICsgXCIuXCIgKyBjZi5mdW5jICsgXCIuYXBwbHkoXCIgK1xuICAgICAgICAgICAgICBwYXJlbnRPYmpOYW1lICsgXCIsIGFyZ3VtZW50cyk7IH07XFxuXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgKz0gXCJ2YXIgbmV3QXJncyA9IFwiICtcbiAgICAgICAgKGNmLmlkQXJnTGFzdCA/IFwiYXJndW1lbnRzLmNvbmNhdChbJyddKTtcIiA6IFwiWycnXS5jb25jYXQoYXJndW1lbnRzKTtcIikgK1xuICAgICAgICBcIiByZXR1cm4gXCIgKyBwYXJlbnRPYmpOYW1lICsgXCIuXCIgKyBjZi5mdW5jICtcbiAgICAgICAgXCIuYXBwbHkoXCIgKyBwYXJlbnRPYmpOYW1lICsgXCIsIG5ld0FyZ3MpOyB9O1xcblwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29kZTtcbn07XG5cbmZ1bmN0aW9uIGJ1aWxkRnVuY3Rpb25Qcm90b3R5cGUocHJlZml4LCBwYXJhbXMpIHtcbiAgdmFyIHByb3RvID0gcHJlZml4ICsgXCIoXCI7XG4gIGlmIChwYXJhbXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGkgIT09IDApIHtcbiAgICAgICAgcHJvdG8gKz0gXCIsIFwiO1xuICAgICAgfVxuICAgICAgcHJvdG8gKz0gcGFyYW1zW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvdG8gKyBcIilcIjtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHBhbGV0dGUgZm9yIHRoZSBkcm9wbGV0IGVkaXRvciBiYXNlZCBvbiBzb21lIGxldmVsIGRhdGEuXG4gKiBAcGFyYW0ge29iamVjdH0gY29kZUZ1bmN0aW9ucyBUaGUgc2V0IG9mIGZ1bmN0aW9ucyB3ZSB3YW50IHRvIHVzZSBmb3IgdGhpcyBsZXZlbFxuICogQHBhcmFtIHtvYmplY3R9IGRyb3BsZXRDb25maWdcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRyb3BsZXRDb25maWcuZ2V0QmxvY2tzXG4gKiBAcGFyYW0ge29iamVjdH0gZHJvcGxldENvbmZpZy5jYXRlZ29yaWVzXG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVEcm9wbGV0UGFsZXR0ZSA9IGZ1bmN0aW9uIChjb2RlRnVuY3Rpb25zLCBkcm9wbGV0Q29uZmlnKSB7XG4gIHZhciBtZXJnZWRDYXRlZ29yaWVzID0gbWVyZ2VDYXRlZ29yaWVzV2l0aENvbmZpZyhkcm9wbGV0Q29uZmlnKTtcbiAgdmFyIG1lcmdlZEZ1bmN0aW9ucyA9IGZpbHRlcmVkQmxvY2tzRnJvbUNvbmZpZyhcbiAgICAgIGNvZGVGdW5jdGlvbnMsXG4gICAgICBkcm9wbGV0Q29uZmlnLFxuICAgICAgc3RhbmRhcmRDb25maWcsXG4gICAgICB7IHBhbGV0dGVPbmx5OiB0cnVlLCBpZ25vcmVEb2NGdW5jOiB0cnVlIH1cbiAgKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lcmdlZEZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmdW5jSW5mbyA9IG1lcmdlZEZ1bmN0aW9uc1tpXTtcbiAgICB2YXIgYmxvY2sgPSBmdW5jSW5mby5ibG9jaztcbiAgICB2YXIgZXhwYW5zaW9uID0gZnVuY0luZm8uZXhwYW5zaW9uO1xuICAgIGlmICghYmxvY2spIHtcbiAgICAgIHZhciBuYW1lV2l0aFByZWZpeCA9IGZ1bmNJbmZvLmZ1bmM7XG4gICAgICBpZiAoZnVuY0luZm8uYmxvY2tQcmVmaXgpIHtcbiAgICAgICAgbmFtZVdpdGhQcmVmaXggPSBmdW5jSW5mby5ibG9ja1ByZWZpeCArIG5hbWVXaXRoUHJlZml4O1xuICAgICAgfVxuICAgICAgaWYgKGZ1bmNJbmZvLnR5cGUgPT09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgYmxvY2sgPSBuYW1lV2l0aFByZWZpeDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwYWxldHRlUGFyYW1zID0gZnVuY0luZm8ucGFsZXR0ZVBhcmFtcyB8fCBmdW5jSW5mby5wYXJhbXM7XG4gICAgICAgIGJsb2NrID0gYnVpbGRGdW5jdGlvblByb3RvdHlwZShuYW1lV2l0aFByZWZpeCwgcGFsZXR0ZVBhcmFtcyk7XG4gICAgICAgIGlmIChmdW5jSW5mby5wYWxldHRlUGFyYW1zKSB7XG4gICAgICAgICAgLy8gSWYgcGFsZXR0ZVBhcmFtcyB3ZXJlIHNwZWNpZmllZCBhbmQgdXNlZCBmb3IgdGhlICdibG9jaycsIHRoZW4gdXNlXG4gICAgICAgICAgLy8gdGhlIHJlZ3VsYXIgcGFyYW1zIGZvciB0aGUgJ2V4cGFuc2lvbicgd2hpY2ggYXBwZWFycyB3aGVuIHRoZSBibG9ja1xuICAgICAgICAgIC8vIGlzIGRyYWdnZWQgb3V0IG9mIHRoZSBwYWxldHRlOlxuICAgICAgICAgIGV4cGFuc2lvbiA9IGJ1aWxkRnVuY3Rpb25Qcm90b3R5cGUobmFtZVdpdGhQcmVmaXgsIGZ1bmNJbmZvLnBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZXJlIHdlIHNldCB0aGUgdGl0bGUgYXR0cmlidXRlIHRvIHRoZSBmdW5jdGlvbiBzaG9ydG5hbWUsXG4gICAgICogdGhpcyBpcyBsYXRlciB1c2VkIGFzIGEga2V5IGZvciBmdW5jdGlvbiBkb2N1bWVudGF0aW9uIGFuZCB0b29sdGlwc1xuICAgICAqL1xuICAgIHZhciBibG9ja1BhaXIgPSB7XG4gICAgICBibG9jazogYmxvY2ssXG4gICAgICBleHBhbnNpb246IGV4cGFuc2lvbixcbiAgICAgIHRpdGxlOiBmdW5jSW5mby5tb2RlT3B0aW9uTmFtZSB8fCBmdW5jSW5mby5mdW5jXG4gICAgfTtcbiAgICBtZXJnZWRDYXRlZ29yaWVzW2Z1bmNJbmZvLmNhdGVnb3J5XS5ibG9ja3MucHVzaChibG9ja1BhaXIpO1xuICB9XG5cbiAgLy8gQ29udmVydCB0byBkcm9wbGV0J3MgZXhwZWN0ZWQgcGFsZXR0ZSBmb3JtYXQ6XG4gIHZhciBhZGRlZFBhbGV0dGUgPSBbXTtcbiAgZm9yICh2YXIgY2F0ZWdvcnkgaW4gbWVyZ2VkQ2F0ZWdvcmllcykge1xuICAgIGlmIChtZXJnZWRDYXRlZ29yaWVzW2NhdGVnb3J5XS5ibG9ja3MubGVuZ3RoID4gMCkge1xuICAgICAgbWVyZ2VkQ2F0ZWdvcmllc1tjYXRlZ29yeV0ubmFtZSA9IGNhdGVnb3J5O1xuICAgICAgYWRkZWRQYWxldHRlLnB1c2gobWVyZ2VkQ2F0ZWdvcmllc1tjYXRlZ29yeV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhZGRlZFBhbGV0dGU7XG59O1xuXG5mdW5jdGlvbiBwb3B1bGF0ZUNvbXBsZXRlckFwaXNGcm9tQ29uZmlnQmxvY2tzKG9wdHMsIGFwaXMsIG1ldGhvZHNBbmRQcm9wZXJ0aWVzLCBjb25maWdCbG9ja3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25maWdCbG9ja3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYmxvY2sgPSBjb25maWdCbG9ja3NbaV07XG4gICAgaWYgKCFibG9jay5ub0F1dG9jb21wbGV0ZSkge1xuICAgICAgLy8gVXNlIHNjb3JlIHZhbHVlIG9mIDEwMCB0byBlbnN1cmUgdGhhdCBvdXIgQVBJcyBhcmUgbm90IHJlcGxhY2VkIGJ5XG4gICAgICAvLyBvdGhlciBjb21wbGV0ZXJzIHRoYXQgYXJlIHN1Z2dlc3RpbmcgdGhlIHNhbWUgbmFtZVxuICAgICAgdmFyIG5ld0FwaSA9IHtcbiAgICAgICAgbmFtZTogJ2FwaScsXG4gICAgICAgIHZhbHVlOiBibG9jay5tb2RlT3B0aW9uTmFtZSB8fCBibG9jay5mdW5jLFxuICAgICAgICBzY29yZTogMTAwLFxuICAgICAgICBtZXRhOiBibG9jay5jYXRlZ29yeVxuICAgICAgfTtcbiAgICAgIGlmIChvcHRzLmF1dG9jb21wbGV0ZUZ1bmN0aW9uc1dpdGhQYXJlbnMpIHtcbiAgICAgICAgbmV3QXBpLmNvbXBsZXRlciA9IHtcbiAgICAgICAgICBpbnNlcnRNYXRjaDogZnVuY3Rpb24gKHZhbHVlLCBlZGl0b3IpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZmlsdGVyVGV4dCB0aGF0IHdhcyBhbHJlYWR5IHR5cGVkIChhY2UncyBidWlsdC1pblxuICAgICAgICAgICAgLy8gaW5zZXJ0TWF0Y2ggd291bGQgbm9ybWFsbHkgZG8gdGhpcyBhdXRvbWF0aWNhbGx5KVxuICAgICAgICAgICAgaWYgKGVkaXRvci5jb21wbGV0ZXIuY29tcGxldGlvbnMuZmlsdGVyVGV4dCkge1xuICAgICAgICAgICAgICB2YXIgcmFuZ2VzID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHJhbmdlOyAhIShyYW5nZSA9IHJhbmdlc1tpXSk7IGkrKykge1xuICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbiAtPSBlZGl0b3IuY29tcGxldGVyLmNvbXBsZXRpb25zLmZpbHRlclRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGVkaXRvci5zZXNzaW9uLnJlbW92ZShyYW5nZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgZnVuY3Rpb24gbmFtZSBwbHVzIHBhcmVudGhlc2VzIGFuZCBzZW1pY29sb246XG4gICAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoXCJpbnNlcnRzdHJpbmdcIiwgdmFsdWUgKyAnKCk7Jyk7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgLy8gTW92ZSB0aGUgc2VsZWN0aW9uIGJhY2sgc28gcGFyYW1ldGVycyBjYW4gYmUgZW50ZXJlZDpcbiAgICAgICAgICAgICAgdmFyIGN1clJhbmdlID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgICBjdXJSYW5nZS5zdGFydC5jb2x1bW4gLT0gMjtcbiAgICAgICAgICAgICAgY3VyUmFuZ2UuZW5kLmNvbHVtbiAtPSAyO1xuICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFNlbGVjdGlvblJhbmdlKGN1clJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LmJpbmQoYmxvY2ssIG5ld0FwaS52YWx1ZSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdBcGkudmFsdWUuaW5kZXhPZignKi4nKSA9PT0gMCB8fCBuZXdBcGkudmFsdWUuaW5kZXhPZignPy4nKSA9PT0gMCkge1xuICAgICAgICAvLyBQb3B1bGF0ZSB0aGlzIGluIGEgc3BlY2lhbCBtZXRob2RzQW5kUHJvcGVydGllcyBjb2xsZWN0aW9uOlxuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCBuYW1lIGluIGEgZG9jRnVuYyBwcm9wZXJ0eSBmb3IgdGhlXG4gICAgICAgIC8vIGJlbmVmaXQgb2Ygb3VyIERyb3BsZXRBdXRvY29tcGxldGVQb3B1cFRvb2x0aXBNYW5hZ2VyOlxuICAgICAgICBuZXdBcGkuZG9jRnVuYyA9IG5ld0FwaS52YWx1ZTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSB2YWx1ZSB0byBza2lwIG92ZXIgdGhlICcqLicgb3IgJz8uJyBhdCB0aGUgYmVnaW5uaW5nOlxuICAgICAgICBuZXdBcGkudmFsdWUgPSBuZXdBcGkudmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgICAgICBtZXRob2RzQW5kUHJvcGVydGllcy5wdXNoKG5ld0FwaSk7XG4gICAgICAgIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUG9wdWxhdGUgdGhpcyBpbiB0aGUgXCJub3JtYWxcIiBhcGlzIGNvbGxlY3Rpb246XG4gICAgICAgIGFwaXMucHVzaChuZXdBcGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3B1bGF0ZUNvbXBsZXRlckZyb21QcmVkZWZWYWx1ZXMoYXBpcywgcHJlZGVmVmFsdWVzKSB7XG4gIGlmIChwcmVkZWZWYWx1ZXMpIHtcbiAgICBwcmVkZWZWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAvLyBVc2Ugc2NvcmUgdmFsdWUgb2YgMTAwIHRvIGVuc3VyZSB0aGF0IG91ciBBUElzIGFyZSBub3QgcmVwbGFjZWQgYnlcbiAgICAgIC8vIG90aGVyIGNvbXBsZXRlcnMgdGhhdCBhcmUgc3VnZ2VzdGluZyB0aGUgc2FtZSBuYW1lXG4gICAgICBhcGlzLnB1c2goe1xuICAgICAgICBuYW1lOiAnYXBpJyxcbiAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgc2NvcmU6IDEwMCxcbiAgICAgICAgbWV0YTogJ2NvbnN0YW50cydcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgYWNlIGVkaXRvciBjdXJzb3IgcG9zaXRpb24gaXMgYXQgdGhlIGJlZ2lubmluZyBvZiBhIG1ldGhvZFxuICogb3IgcHJvcGVydHkgKGFmdGVyIGEgZG90KS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uIEFjZSBlZGl0b3Igc2Vzc2lvblxuICogQHBhcmFtIHtPYmplY3R9IHBvcyBBY2UgZWRpdG9yIHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHBvc2l0aW9uIGlzIGF0IHRoZSBzdGFydCBvZiBhIG1ldGhvZCBvciBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiBpc1Bvc2l0aW9uQWZ0ZXJEb3QgKHNlc3Npb24sIHBvcykge1xuICB2YXIgYWNVdGlsID0gd2luZG93LmFjZS5yZXF1aXJlKFwiYWNlL2F1dG9jb21wbGV0ZS91dGlsXCIpO1xuICB2YXIgbGluZSA9IHNlc3Npb24uZ2V0TGluZShwb3Mucm93KTtcbiAgdmFyIGlkZW50aWZpZXIgPSBhY1V0aWwucmV0cmlldmVQcmVjZWRpbmdJZGVudGlmaWVyKGxpbmUsIHBvcy5jb2x1bW4pO1xuICAvLyBJZiB3ZSdyZSB0eXBpbmcgYSB2YWxpZCBpZGVudGlmaWVyLCBpbnNwZWN0IHRoZSBwcmVjZWVkaW5nXG4gIC8vIGNoYXJhY3RlciB0byBzZWUgaWYgaXQgaXMgYSBwZXJpb2QgYW5kIGVuc3VyZSB0aGVyZSdzIGF0IGxlYXN0IG9uZVxuICAvLyBjaGFyYWN0ZXIgYmVmb3JlXG4gIGlmIChpZGVudGlmaWVyLmxlbmd0aCA+IDAgJiYgaWRlbnRpZmllci5sZW5ndGggPCBwb3MuY29sdW1uKSB7XG4gICAgLy8gV2UgaGF2ZSBhbiBpZGVudGlmaWVyIGFuZCBpdCBpcyBzaG9ydGVyIHRoYW4gb3VyIGNvbHVtbiBwb3NpdGlvbiBpblxuICAgIC8vIHRoaXMgbGluZSwgd2hpY2ggbWVhbnMgaXQgaXMgc2FmZSB0byBjaGVjayB0aGUgbGluZVtdIGJlZm9yZSB0aGVcbiAgICAvLyBpZGVudGlmaWVyXG4gICAgdmFyIHBvc0JlZm9yZUlkZW50aWZpZXIgPSBwb3MuY29sdW1uIC0gaWRlbnRpZmllci5sZW5ndGggLSAxO1xuICAgIHJldHVybiBsaW5lW3Bvc0JlZm9yZUlkZW50aWZpZXJdID09PSAnLic7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGFuIEFjZSBlZGl0b3IgY29tcGxldGVyIGZvciBhIHNldCBvZiBBUElzIGJhc2VkIG9uIHNvbWUgbGV2ZWwgZGF0YS5cbiAqXG4gKiBJZiBmdW5jdGlvbkZpbHRlciBpcyBub24tbnVsbCwgdXNlIGl0IHRvIGZpbHRlciB0aGUgZHJvcGxldENvbmZpZ1xuICogQVBJcyB0byBiZSBzZXQgaW4gYXV0b2NvbXBsZXRlIGFuZCBjcmVhdGUgbm8gb3RoZXIgYXV0b2NvbXBsZXRlIGVudHJpZXNcbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZUFjZUFwaUNvbXBsZXRlciA9IGZ1bmN0aW9uIChmdW5jdGlvbkZpbHRlciwgZHJvcGxldENvbmZpZykge1xuICB2YXIgYXBpcyA9IFtdO1xuICB2YXIgbWV0aG9kc0FuZFByb3BlcnRpZXMgPSBbXTtcbiAgdmFyIG9wdHMgPSB7fTtcblxuICAvLyBJZiBhdXRvY29tcGxldGVGdW5jdGlvbnNXaXRoUGFyZW5zIGlzIHNldCwgd2Ugd2lsbCBhcHBlbmQgXCIoKTtcIiBhZnRlciBmdW5jdGlvbnNcbiAgb3B0cy5hdXRvY29tcGxldGVGdW5jdGlvbnNXaXRoUGFyZW5zID0gZHJvcGxldENvbmZpZy5hdXRvY29tcGxldGVGdW5jdGlvbnNXaXRoUGFyZW5zO1xuXG4gIGlmIChmdW5jdGlvbkZpbHRlcikge1xuICAgIHZhciBtZXJnZWRCbG9ja3MgPSBmaWx0ZXJlZEJsb2Nrc0Zyb21Db25maWcoZnVuY3Rpb25GaWx0ZXIsIGRyb3BsZXRDb25maWcsIG51bGwsIHsgcGFsZXR0ZU9ubHk6IHRydWUgfSk7XG4gICAgcG9wdWxhdGVDb21wbGV0ZXJBcGlzRnJvbUNvbmZpZ0Jsb2NrcyhvcHRzLCBhcGlzLCBtZXRob2RzQW5kUHJvcGVydGllcywgbWVyZ2VkQmxvY2tzKTtcbiAgfSBlbHNlIHtcbiAgICBwb3B1bGF0ZUNvbXBsZXRlckFwaXNGcm9tQ29uZmlnQmxvY2tzKG9wdHMsIGFwaXMsIG1ldGhvZHNBbmRQcm9wZXJ0aWVzLCBleHBvcnRzLmRyb3BsZXRHbG9iYWxDb25maWdCbG9ja3MpO1xuICAgIHBvcHVsYXRlQ29tcGxldGVyQXBpc0Zyb21Db25maWdCbG9ja3Mob3B0cywgYXBpcywgbWV0aG9kc0FuZFByb3BlcnRpZXMsIGV4cG9ydHMuZHJvcGxldEJ1aWx0aW5Db25maWdCbG9ja3MpO1xuICAgIHBvcHVsYXRlQ29tcGxldGVyQXBpc0Zyb21Db25maWdCbG9ja3Mob3B0cywgYXBpcywgbWV0aG9kc0FuZFByb3BlcnRpZXMsIGRyb3BsZXRDb25maWcuYmxvY2tzKTtcbiAgICBwb3B1bGF0ZUNvbXBsZXRlckZyb21QcmVkZWZWYWx1ZXMoYXBpcywgZHJvcGxldENvbmZpZy5hZGRpdGlvbmFsUHJlZGVmVmFsdWVzKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0Q29tcGxldGlvbnM6IGZ1bmN0aW9uKGVkaXRvciwgc2Vzc2lvbiwgcG9zLCBwcmVmaXgsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAocHJlZml4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBbXSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Bvc2l0aW9uQWZ0ZXJEb3Qoc2Vzc2lvbiwgcG9zKSkge1xuICAgICAgICAvLyBGb2xsb3dpbmcgYSBkb3QsIHdlIGF1dG9jb21wbGV0ZSBmcm9tIG1ldGhvZHNBbmRQcm9wZXJ0aWVzOlxuICAgICAgICBjYWxsYmFjayhudWxsLCBtZXRob2RzQW5kUHJvcGVydGllcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBhcGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIEdpdmVuIGEgZHJvcGxldCBjb25maWcsIGNyZWF0ZSBhIG1vZGUgb3B0aW9uIGZ1bmN0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcbiAqIEBwYXJhbSB7b2JqZWN0W119IGNvbmZpZy5ibG9ja3NcbiAqIEBwYXJhbSB7b2JqZWN0W119IGNvbmZpZy5jYXRlZ29yaWVzXG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVPcHRpb25GdW5jdGlvbnNGcm9tQ29uZmlnKGNvbmZpZykge1xuICB2YXIgbWVyZ2VkQ2F0ZWdvcmllcyA9IG1lcmdlQ2F0ZWdvcmllc1dpdGhDb25maWcoY29uZmlnKTtcblxuICB2YXIgbW9kZU9wdGlvbkZ1bmN0aW9ucyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29uZmlnLmJsb2Nrcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuZXdGdW5jID0ge307XG5cbiAgICBpZiAoY29uZmlnLmJsb2Nrc1tpXS50eXBlID09PSAndmFsdWUnKSB7XG4gICAgICBuZXdGdW5jLnZhbHVlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5ibG9ja3NbaV0udHlwZSA9PT0gJ2VpdGhlcicpIHtcbiAgICAgIG5ld0Z1bmMudmFsdWUgPSB0cnVlO1xuICAgICAgbmV3RnVuYy5jb21tYW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5ibG9ja3NbaV0udHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgbmV3RnVuYy5wcm9wZXJ0eSA9IHRydWU7XG4gICAgICBuZXdGdW5jLnZhbHVlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgY2F0ZWdvcnkgPSBtZXJnZWRDYXRlZ29yaWVzW2NvbmZpZy5ibG9ja3NbaV0uY2F0ZWdvcnldO1xuICAgIGlmIChjYXRlZ29yeSkge1xuICAgICAgbmV3RnVuYy5jb2xvciA9IGNhdGVnb3J5LnJnYiB8fCBjYXRlZ29yeS5jb2xvcjtcbiAgICB9XG5cbiAgICBuZXdGdW5jLmRyb3Bkb3duID0gY29uZmlnLmJsb2Nrc1tpXS5kcm9wZG93bjtcblxuICAgIHZhciBtb2RlT3B0aW9uTmFtZSA9IGNvbmZpZy5ibG9ja3NbaV0ubW9kZU9wdGlvbk5hbWUgfHwgY29uZmlnLmJsb2Nrc1tpXS5mdW5jO1xuICAgIG5ld0Z1bmMudGl0bGUgPSBtb2RlT3B0aW9uTmFtZTtcblxuICAgIG1vZGVPcHRpb25GdW5jdGlvbnNbbW9kZU9wdGlvbk5hbWVdID0gbmV3RnVuYztcbiAgfVxuICByZXR1cm4gbW9kZU9wdGlvbkZ1bmN0aW9ucztcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBtb2RlT3B0aW9ucyBmb3IgdGhlIGRyb3BsZXQgZWRpdG9yIGJhc2VkIG9uIHNvbWUgbGV2ZWwgZGF0YS5cbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZURyb3BsZXRNb2RlT3B0aW9ucyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIG1vZGVPcHRpb25zID0ge1xuICAgIGZ1bmN0aW9uczoge1xuICAgIH0sXG4gICAgY2F0ZWdvcmllczoge1xuICAgICAgYXJpdGhtZXRpYzogeyBjb2xvcjogQ09MT1JfT1JBTkdFIH0sXG4gICAgICBsb2dpYzogeyBjb2xvcjogQ09MT1JfT1JBTkdFIH0sXG4gICAgICBjb25kaXRpb25hbHM6IHsgY29sb3I6IENPTE9SX0JMVUUgfSxcbiAgICAgIGxvb3BzOiB7XG4gICAgICAgIGNvbG9yOiBDT0xPUl9CTFVFLFxuICAgICAgICBiZWdpbm5lcjogY29uZmlnLmxldmVsLmJlZ2lubmVyTW9kZSB8fCBmYWxzZVxuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uczogeyBjb2xvcjogQ09MT1JfR1JFRU4gfSxcbiAgICAgIHJldHVybnM6IHsgY29sb3I6IENPTE9SX0dSRUVOIH0sXG4gICAgICBjb21tZW50czogeyBjb2xvcjogQ09MT1JfV0hJVEUgfSxcbiAgICAgIGNvbnRhaW5lcnM6IHsgY29sb3I6IENPTE9SX1BVUlBMRSB9LFxuICAgICAgdmFsdWU6IHsgY29sb3I6IENPTE9SX1BVUlBMRSB9LFxuICAgICAgY29tbWFuZDogeyBjb2xvcjogQ09MT1JfR1JFRU4gfSxcbiAgICAgIGFzc2lnbm1lbnRzOiB7IGNvbG9yOiBDT0xPUl9QVVJQTEUgfVxuICAgICAgLy8gZXJyb3JzOiB7IH0sXG4gICAgfSxcbiAgICBsb2NrWmVyb1BhcmFtRnVuY3Rpb25zOiBjb25maWcubGV2ZWwubG9ja1plcm9QYXJhbUZ1bmN0aW9uc1xuICB9O1xuXG4gICQuZXh0ZW5kKG1vZGVPcHRpb25zLmZ1bmN0aW9ucyxcbiAgICBnZXRNb2RlT3B0aW9uRnVuY3Rpb25zRnJvbUNvbmZpZyh7IGJsb2NrczogZXhwb3J0cy5kcm9wbGV0R2xvYmFsQ29uZmlnQmxvY2tzIH0pLFxuICAgIGdldE1vZGVPcHRpb25GdW5jdGlvbnNGcm9tQ29uZmlnKHsgYmxvY2tzOiBleHBvcnRzLmRyb3BsZXRCdWlsdGluQ29uZmlnQmxvY2tzIH0pLFxuICAgIGdldE1vZGVPcHRpb25GdW5jdGlvbnNGcm9tQ29uZmlnKGNvbmZpZy5kcm9wbGV0Q29uZmlnKVxuICApO1xuXG4gIHJldHVybiBtb2RlT3B0aW9ucztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHNldCBvZiBhbGwgYmxvY2tzXG4gKiBAcGFyYW0ge0Ryb3BsZXRDb25maWd8bnVsbH0gZHJvcGxldENvbmZpZyBjdXN0b20gY29uZmlndXJhdGlvbiwgbWF5IGJlIG51bGxcbiAqIEBwYXJhbSB7Y29kZUZ1bmN0aW9uc3xudWxsfSBjb2RlRnVuY3Rpb25zIHdpdGggYmxvY2sgb3ZlcnJpZGVzLCBtYXkgYmUgbnVsbFxuICogQHBhcmFtIHBhbGV0dGVPbmx5IGJvb2xlYW46IGZpbHRlciB0byBvbmx5IHRob3NlIGJsb2NrcyB0aGF0IGFyZSBpbiBjb2RlRnVuY3Rpb25zXG4gKiAgIHBhbGV0dGUsIG9yIHdobyBzaGFyZSBkb2N1bWVudGF0aW9uICh2aWEgZG9jRnVuYykgd2l0aCBvdGhlciBibG9ja3MgdGhhdCBhcmVcbiAqIEByZXR1cm5zIHtEcm9wbGV0QmxvY2tbXX0gYSBsaXN0IG9mIGFsbCBhdmFpbGFibGUgRHJvcGxldCBibG9ja3MsXG4gKiAgICAgIGluY2x1ZGluZyB0aGUgZ2l2ZW4gY29uZmlnJ3MgYmxvY2tzXG4gKi9cbmV4cG9ydHMuZ2V0QWxsQXZhaWxhYmxlRHJvcGxldEJsb2NrcyA9IGZ1bmN0aW9uIChkcm9wbGV0Q29uZmlnLCBjb2RlRnVuY3Rpb25zLCBwYWxldHRlT25seSkge1xuICB2YXIgaGFzQ29uZmlndXJlZEJsb2NrcyA9IGRyb3BsZXRDb25maWcgJiYgZHJvcGxldENvbmZpZy5ibG9ja3M7XG4gIHZhciBjb25maWd1cmVkQmxvY2tzID0gaGFzQ29uZmlndXJlZEJsb2NrcyA/IGRyb3BsZXRDb25maWcuYmxvY2tzIDogW107XG4gIGlmIChjb2RlRnVuY3Rpb25zICYmIGhhc0NvbmZpZ3VyZWRCbG9ja3MpIHtcbiAgICBjb25maWd1cmVkQmxvY2tzID0gZmlsdGVyZWRCbG9ja3NGcm9tQ29uZmlnKFxuICAgICAgICBjb2RlRnVuY3Rpb25zLFxuICAgICAgICBkcm9wbGV0Q29uZmlnLFxuICAgICAgICBudWxsLFxuICAgICAgICB7IHBhbGV0dGVPbmx5OiBwYWxldHRlT25seSB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4gZXhwb3J0cy5kcm9wbGV0R2xvYmFsQ29uZmlnQmxvY2tzXG4gICAgLmNvbmNhdChleHBvcnRzLmRyb3BsZXRCdWlsdGluQ29uZmlnQmxvY2tzKVxuICAgIC5jb25jYXQoc3RhbmRhcmRDb25maWcuYmxvY2tzKVxuICAgIC5jb25jYXQoY29uZmlndXJlZEJsb2Nrcyk7XG59O1xuXG5leHBvcnRzLl9fVGVzdEludGVyZmFjZSA9IHtcbiAgbWVyZ2VDYXRlZ29yaWVzV2l0aENvbmZpZzogbWVyZ2VDYXRlZ29yaWVzV2l0aENvbmZpZyxcbiAgZmlsdGVyZWRCbG9ja3NGcm9tQ29uZmlnOiBmaWx0ZXJlZEJsb2Nrc0Zyb21Db25maWdcbn07XG4iLCIvLyBTdHJpY3QgbGludGluZzogQWJzb3JiIGludG8gZ2xvYmFsIGNvbmZpZyB3aGVuIHBvc3NpYmxlXG4vKiBqc2hpbnRcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuIG1heGxlbjogMTIwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIHN1YnNjcmlwdGlvbi9ub3RpZmljYXRpb24gYXRvbSwgdXNlZCB0byBjbGVhbmx5IGhvb2sgdXAgY2FsbGJhY2tzXG4gKiB3aXRob3V0IGF0dGFjaGluZyBhbnl0aGluZyB0byB0aGUgRE9NIG9yIG90aGVyIGdsb2JhbCBzY29wZS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgT2JzZXJ2YWJsZUV2ZW50ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBPYmplY3RzIG9ic2VydmluZyB0aGlzLlxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm9ic2VydmVyTGlzdF8gPSBbXTtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlIGEgbWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIG5vdGlmeU9ic2VydmVycyBpcyBjYWxsZWQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbk5vdGlmeSAtIG1ldGhvZCBjYWxsZWQgd2hlbiBub3RpZnlPYnNlcnZlcnMgZ2V0cyBjYWxsZWQuXG4gKiAgICAgICAgV2lsbCByZWNlaXZlIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIG5vdGlmeU9ic2VydmVycy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IGtleSAtIHVzZWQgdG8gdW5yZWdpc3RlciBmcm9tIG9ic2VydmFibGVcbiAqL1xuT2JzZXJ2YWJsZUV2ZW50LnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChvbk5vdGlmeSkge1xuICB2YXIga2V5ID0ge3RvQ2FsbDpvbk5vdGlmeX07XG4gIE9iamVjdC5mcmVlemUoa2V5KTtcbiAgdGhpcy5vYnNlcnZlckxpc3RfLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleTtcbn07XG5cbi8qKlxuICogVW5zdWJzY3JpYmUgZnJvbSBub3RpZmljYXRpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IGtleU9iaiAtIEtleSBnZW5lcmF0ZWQgd2hlbiByZWdpc3RlcmluZ1xuICogQHJldHVybnMge2Jvb2xlYW59IC0gV2hldGhlciBhbiB1bnJlZ2lzdHJhdGlvbiBhY3R1YWxseSBvY2N1cnJlZFxuICovXG5PYnNlcnZhYmxlRXZlbnQucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiAoa2V5T2JqKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vYnNlcnZlckxpc3RfLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGtleU9iaiA9PT0gdGhpcy5vYnNlcnZlckxpc3RfW2ldKSB7XG4gICAgICB0aGlzLm9ic2VydmVyTGlzdF8uc3BsaWNlKGksIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQ2FsbCBhbGwgbWV0aG9kcyBzdWJzY3JpYmVkIHRvIHRoaXMgT2JzZXJ2YWJsZUV2ZW50LCBwYXNzaW5nIHRocm91Z2hcbiAqIGFueSBhcmd1bWVudHMuXG4gKiBAcGFyYW0gey4uLn0gQW55IGFyZ3VtZW50cywgd2hpY2ggYXJlIHBhc3NlZCB0aHJvdWdoIHRvIHRoZSBvYnNlcnZpbmdcbiAqICAgICAgICAgICAgICBmdW5jdGlvbnMuXG4gKi9cbk9ic2VydmFibGVFdmVudC5wcm90b3R5cGUubm90aWZ5T2JzZXJ2ZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDAgKTtcbiAgdGhpcy5vYnNlcnZlckxpc3RfLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgb2JzZXJ2ZXIudG9DYWxsLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gIH0pO1xufTsiLCIvLyBTdHJpY3QgbGludGluZzogQWJzb3JiIGludG8gZ2xvYmFsIGNvbmZpZyB3aGVuIHBvc3NpYmxlXG4vKiBqc2hpbnRcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuIG1heGxlbjogMTIwXG4gKi9cblxudmFyIGkxOG4gPSByZXF1aXJlKCcuL2xvY2FsZScpO1xudmFyIGRvbSA9IHJlcXVpcmUoJy4vZG9tJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgZGVidWcgYXJlYSBjb250cm9sbGVyIGFuZCBjb25maWd1cmVzIGl0IHRvIG9wZXJhdGUgb24gdGhlIGdpdmVuXG4gKiBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0hUTUxEaXZFbGVtZW50fSBkZWJ1Z0FyZWFSb290XG4gKiBAcGFyYW0ge0hUTUxEaXZFbGVtZW50fSBjb2RlVGV4dGJveFJvb3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRGVidWdBcmVhID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGVidWdBcmVhUm9vdCwgY29kZVRleHRib3hSb290KSB7XG4gIGlmICghZGVidWdBcmVhUm9vdCB8fCAhY29kZVRleHRib3hSb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGVidWdBcmVhUm9vdCBhbmQgY29kZVRleHRib3hSb290IGFyZSByZXF1aXJlZFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7alF1ZXJ5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yb290RGl2XyA9ICQoZGVidWdBcmVhUm9vdCk7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtqUXVlcnl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmNvZGVUZXh0Ym94XyA9ICQoY29kZVRleHRib3hSb290KTtcblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmlzT3Blbl8gPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5sYXN0T3BlbkhlaWdodF8gPSB0aGlzLnJvb3REaXZfLmhlaWdodCgpO1xuXG4gIERlYnVnQXJlYS5wcm90b3R5cGUuYmluZEhhbmRsZXJzRm9yRGVidWdDb21tYW5kc0hlYWRlci5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBCaW5kcyBtb3VzZW92ZXIsIG1vdXNlb3V0LCBjbGljayBhbmQgdG91Y2ggaGFuZGxlcnMgZm9yIHRoZSBkZWJ1ZyBjb21tYW5kc1xuICogaGVhZGVyIGRpdi5cbiAqL1xuRGVidWdBcmVhLnByb3RvdHlwZS5iaW5kSGFuZGxlcnNGb3JEZWJ1Z0NvbW1hbmRzSGVhZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdG9nZ2xlRGVidWdJY29uID0gdGhpcy5yb290RGl2Xy5maW5kKCcjc2hvdy1oaWRlLWRlYnVnLWljb24nKTtcbiAgZG9tLmFkZENsaWNrVG91Y2hFdmVudCh0b2dnbGVEZWJ1Z0ljb25bMF0sIERlYnVnQXJlYS5wcm90b3R5cGUuc2xpZGVUb2dnbGUuYmluZCh0aGlzKSk7XG59O1xuXG4vKiogQHJldHVybnMge2Jvb2xlYW59ICovXG5EZWJ1Z0FyZWEucHJvdG90eXBlLmlzT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaXNPcGVuXztcbn07XG5cbi8qKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbkRlYnVnQXJlYS5wcm90b3R5cGUuaXNTaHV0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIXRoaXMuaXNPcGVuXztcbn07XG5cbi8qKlxuICogT3Blbi9jbG9zZSB0aGUgZGVidWcgYXJlYSB0byB0aGUgcmV2ZXJzZSBvZiBpdHMgY3VycmVudCBzdGF0ZSwgdXNpbmcgbm9cbiAqIGFuaW1hdGlvbi5cbiAqL1xuRGVidWdBcmVhLnNuYXBUb2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmlzT3Blbl8pIHtcbiAgICB0aGlzLnNuYXBTaHV0KCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zbmFwT3BlbigpO1xuICB9XG59O1xuXG5EZWJ1Z0FyZWEucHJvdG90eXBlLnNuYXBPcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmlzT3Blbl8gPSB0cnVlO1xuICB0aGlzLnNldENvbnRlbnRzVmlzaWJsZSh0cnVlKTtcbiAgdGhpcy5zZXRJY29uUG9pbnRpbmdEb3duKHRydWUpO1xuICB0aGlzLnNldEhlaWdodCh0aGlzLmxhc3RPcGVuSGVpZ2h0Xyk7XG5cbiAgLy8gU2V0IHRoZSAnY2xlYXInIGJ1dHRvbiB2aXNpYmxlXG4gIHRoaXMucm9vdERpdl8uZmluZCgnI2NsZWFyLWNvbnNvbGUtaGVhZGVyJylcbiAgICAgIC5jc3MoJ29wYWNpdHknLCAxKVxuICAgICAgLmNzcygndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG59O1xuXG5EZWJ1Z0FyZWEucHJvdG90eXBlLnNuYXBTaHV0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmlzT3Blbl8gPSBmYWxzZTtcbiAgdGhpcy5sYXN0T3BlbkhlaWdodF8gPSB0aGlzLnJvb3REaXZfLmhlaWdodCgpO1xuICB0aGlzLnNldENvbnRlbnRzVmlzaWJsZShmYWxzZSk7XG4gIHRoaXMuc2V0SWNvblBvaW50aW5nRG93bihmYWxzZSk7XG4gIHRoaXMuc2V0SGVpZ2h0KHRoaXMuZ2V0SGVpZ2h0V2hlbkNsb3NlZCgpKTtcblxuICAvLyBTZXQgdGhlICdjbGVhcicgYnV0dG9uIGhpZGRlbiAobm90IGRpc3BsYXk6bm9uZSwgaXQgc2hvdWxkIHRha2UgdXAgc3BhY2UpXG4gIHRoaXMucm9vdERpdl8uZmluZCgnI2NsZWFyLWNvbnNvbGUtaGVhZGVyJylcbiAgICAgIC5jc3MoJ29wYWNpdHknLCAwKVxuICAgICAgLmNzcygndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcbn07XG5cbi8qKlxuICogT3Blbi9jbG9zZSB0aGUgZGVidWcgYXJlYSB0byB0aGUgcmV2ZXJzZSBvZiBpdHMgY3VycmVudCBzdGF0ZSwgdXNpbmcgYVxuICogc2xpZGUgYW5pbWF0aW9uLlxuICovXG5EZWJ1Z0FyZWEucHJvdG90eXBlLnNsaWRlVG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5pc09wZW5fKSB7XG4gICAgdGhpcy5zbGlkZVNodXQoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNsaWRlT3BlbigpO1xuICB9XG59O1xuXG5EZWJ1Z0FyZWEucHJvdG90eXBlLnNsaWRlT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5pc09wZW5fID0gdHJ1ZTtcbiAgdGhpcy5zZXRDb250ZW50c1Zpc2libGUodHJ1ZSk7XG5cbiAgLy8gTWFudWFsbHkgcmVtb3ZlIGhvdmVyIGVmZmVjdCBhdCBzdGFydCBhbmQgZW5kIG9mIGFuaW1hdGlvbiB0byBnZXQgKmNsb3NlKlxuICAvLyB0byB0aGUgY29ycmVjdCBlZmZlY3QuXG4gIHRoaXMucm9vdERpdl8uYW5pbWF0ZSh7XG4gICAgaGVpZ2h0OiB0aGlzLmxhc3RPcGVuSGVpZ2h0X1xuICB9LHtcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zZXRJY29uUG9pbnRpbmdEb3duKHRydWUpO1xuICAgIH0uYmluZCh0aGlzKVxuICB9KTtcblxuICAvLyBBbmltYXRlIHRoZSBib3R0b20gb2YgdGhlIHdvcmtzcGFjZSBhdCB0aGUgc2FtZSB0aW1lXG4gIHRoaXMuY29kZVRleHRib3hfLmFuaW1hdGUoe1xuICAgIGJvdHRvbTogdGhpcy5sYXN0T3BlbkhlaWdodF9cbiAgfSx7XG4gICAgc3RlcDogdXRpbHMuZmlyZVJlc2l6ZUV2ZW50XG4gIH0pO1xuXG4gIC8vIEFuaW1hdGUgdGhlICdjbGVhcicgYnV0dG9uIGFwcGVhcmluZyBhdCB0aGUgc2FtZSB0aW1lXG4gIHZhciBjbGVhckJ1dHRvbiA9IHRoaXMucm9vdERpdl8uZmluZCgnI2NsZWFyLWNvbnNvbGUtaGVhZGVyJyk7XG4gIGNsZWFyQnV0dG9uLmNzcygndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG4gIGNsZWFyQnV0dG9uLmFuaW1hdGUoe1xuICAgIG9wYWNpdHk6IDEuMFxuICB9KTtcbn07XG5cbkRlYnVnQXJlYS5wcm90b3R5cGUuc2xpZGVTaHV0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmlzT3Blbl8gPSBmYWxzZTtcbiAgdGhpcy5sYXN0T3BlbkhlaWdodF8gPSB0aGlzLnJvb3REaXZfLmhlaWdodCgpO1xuXG4gIC8vIFdlIHdpbGwgbGVhdmUgdGhlIGhlYWRlciBhbmQgcmVzaXplIGJhciB2aXNpYmxlLCBzbyB0b2dldGhlciB0aGV5XG4gIC8vIGNvbnN0aXR1dGUgb3VyIGhlaWdodCB3aGVuIGNsb3NlZC5cbiAgdmFyIGNsb3NlZEhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0V2hlbkNsb3NlZCgpO1xuICAvLyBNYW51YWxseSByZW1vdmUgaG92ZXIgZWZmZWN0IGF0IHN0YXJ0IGFuZCBlbmQgb2YgYW5pbWF0aW9uIHRvIGdldCAqY2xvc2UqXG4gIC8vIHRvIHRoZSBjb3JyZWN0IGVmZmVjdC5cbiAgdGhpcy5yb290RGl2Xy5hbmltYXRlKHtcbiAgICBoZWlnaHQ6IGNsb3NlZEhlaWdodFxuICB9LHtcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zZXRDb250ZW50c1Zpc2libGUoZmFsc2UpO1xuICAgICAgdGhpcy5zZXRJY29uUG9pbnRpbmdEb3duKGZhbHNlKTtcbiAgICB9LmJpbmQodGhpcylcbiAgfSk7XG5cbiAgLy8gQW5pbWF0ZSB0aGUgYm90dG9tIG9mIHRoZSB3b3Jrc3BhY2UgYXQgdGhlIHNhbWUgdGltZVxuICB0aGlzLmNvZGVUZXh0Ym94Xy5hbmltYXRlKHtcbiAgICBib3R0b206IGNsb3NlZEhlaWdodFxuICB9LHtcbiAgICBzdGVwOiB1dGlscy5maXJlUmVzaXplRXZlbnQsXG4gICAgY29tcGxldGU6IHV0aWxzLmZpcmVSZXNpemVFdmVudFxuICB9KTtcblxuICAvLyBBbmltYXRlIHRoZSAnY2xlYXInIGJ1dHRvbiB2YW5pc2hpbmcgYXQgdGhlIHNhbWUgdGltZVxuICB2YXIgY2xlYXJCdXR0b24gPSB0aGlzLnJvb3REaXZfLmZpbmQoJyNjbGVhci1jb25zb2xlLWhlYWRlcicpO1xuICBjbGVhckJ1dHRvbi5hbmltYXRlKHtcbiAgICBvcGFjaXR5OiAwLjBcbiAgfSx7XG4gICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsZWFyQnV0dG9uLmNzcygndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcbiAgICB9XG4gIH0pO1xufTtcblxuRGVidWdBcmVhLnByb3RvdHlwZS5zZXRDb250ZW50c1Zpc2libGUgPSBmdW5jdGlvbiAoaXNWaXNpYmxlKSB7XG4gIHRoaXMucm9vdERpdl8uZmluZCgnI2RlYnVnLWNvbW1hbmRzJykudG9nZ2xlKGlzVmlzaWJsZSk7XG4gIHRoaXMucm9vdERpdl8uZmluZCgnI2RlYnVnLWNvbnNvbGUnKS50b2dnbGUoaXNWaXNpYmxlKTtcbn07XG5cbkRlYnVnQXJlYS5wcm90b3R5cGUuc2V0SWNvblBvaW50aW5nRG93biA9IGZ1bmN0aW9uIChpc1BvaW50aW5nRG93bikge1xuICB2YXIgY29tbWFuZHNIZWFkZXIgPSB0aGlzLnJvb3REaXZfLmZpbmQoJyNkZWJ1Zy1jb21tYW5kcy1oZWFkZXInKTtcblxuICB2YXIgaWNvbiA9IHRoaXMucm9vdERpdl8uZmluZCgnI3Nob3ctaGlkZS1kZWJ1Zy1pY29uJyk7XG4gIGljb24udG9nZ2xlQ2xhc3MoJ2ZhLWNoZXZyb24tY2lyY2xlLXVwJywgIWlzUG9pbnRpbmdEb3duKTtcbiAgaWNvbi50b2dnbGVDbGFzcygnZmEtY2hldnJvbi1jaXJjbGUtZG93bicsIGlzUG9pbnRpbmdEb3duKTtcblxuICB2YXIgaGVhZGVyVGV4dCA9IGNvbW1hbmRzSGVhZGVyLmZpbmQoJy5oZWFkZXItdGV4dCcpO1xuICBoZWFkZXJUZXh0LnRleHQoaXNQb2ludGluZ0Rvd24gPyBpMThuLmRlYnVnQ29tbWFuZHNIZWFkZXJXaGVuT3BlbigpIDpcbiAgICAgIGkxOG4uZGVidWdDb21tYW5kc0hlYWRlcldoZW5DbG9zZWQoKSk7XG5cbn07XG5cbkRlYnVnQXJlYS5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKG5ld0hlaWdodEluUGl4ZWxzKSB7XG4gIHRoaXMucm9vdERpdl8uaGVpZ2h0KG5ld0hlaWdodEluUGl4ZWxzKTtcbiAgdGhpcy5jb2RlVGV4dGJveF8uY3NzKCdib3R0b20nLCBuZXdIZWlnaHRJblBpeGVscyk7XG4gIHV0aWxzLmZpcmVSZXNpemVFdmVudCgpO1xufTtcblxuRGVidWdBcmVhLnByb3RvdHlwZS5nZXRIZWlnaHRXaGVuQ2xvc2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yb290RGl2Xy5maW5kKCcjZGVidWctYXJlYS1oZWFkZXInKS5oZWlnaHQoKSArXG4gICAgICB0aGlzLnJvb3REaXZfLmZpbmQoJyNkZWJ1Z1Jlc2l6ZUJhcicpLmhlaWdodCgpO1xufTtcbiIsIi8qIGdsb2JhbCBkZWZpbmUgKi9cbi8vIFN0cmljdCBsaW50aW5nOiBBYnNvcmIgaW50byBnbG9iYWwgY29uZmlnIHdoZW4gcG9zc2libGVcbi8qIGpzaGludFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG4gbWF4bGVuOiAxMjBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2F2ZWRBbWQ7XG5cbi8vIERvIHNvbWUgaGFja2VyeSB0byBtYWtlIGl0IHNvIHRoYXQgbG9kYXNoIGRvZXNuJ3QgdGhpbmsgaXQncyBiZWluZyBsb2FkZWRcbi8vIHZpYSByZXF1aXJlIGpzXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICBzYXZlZEFtZCA9IGRlZmluZS5hbWQ7XG4gIGRlZmluZS5hbWQgPSBmYWxzZTtcbn1cblxuLy8gZ2V0IGxvZGFzaFxudmFyIF8gPSByZXF1aXJlKCcuL2xvZGFzaCcpO1xudmFyIEhhbW1lciA9IHJlcXVpcmUoJy4vaGFtbWVyJyk7XG5cbi8vIHVuZG8gaGFja2VyeVxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgc2F2ZWRBbWQpIHtcbiAgZGVmaW5lLmFtZCA9IHNhdmVkQW1kO1xuICBzYXZlZEFtZCA9IG51bGw7XG59XG5cbmV4cG9ydHMuZ2V0TG9kYXNoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gXztcbn07XG5cbmV4cG9ydHMuZ2V0SGFtbWVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gSGFtbWVyO1xufTtcblxuZXhwb3J0cy5zaGFsbG93Q29weSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgcmVzdWx0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBvYmplY3QsIHN0cmlwcGluZyBhbnkgZnVuY3Rpb25zIG9uIGl0LlxuICovXG5leHBvcnRzLmNsb25lV2l0aG91dEZ1bmN0aW9ucyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmplY3QpKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyB3aXRoIGEgZG91YmxlIHF1b3RlIGJlZm9yZSBhbmQgYWZ0ZXIuXG4gKi9cbmV4cG9ydHMucXVvdGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuICdcIicgKyBzdHIgKyAnXCInO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIGZyb20gZGVmYXVsdHMgb3ZlcnJpZGRlbiBieSBhbnlcbiAqIHByb3BlcnRpZXMgaW4gb3B0aW9ucy4gTGVhdmVzIGRlZmF1bHRzIGFuZCBvcHRpb25zIHVuY2hhbmdlZC5cbiAqIE5PVEU6IEZvciBuZXcgY29kZSwgdXNlICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucykgaW5zdGVhZFxuICovXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKGRlZmF1bHRzLCBvcHRpb25zKSB7XG4gIHZhciBmaW5hbE9wdGlvbnMgPSBleHBvcnRzLnNoYWxsb3dDb3B5KGRlZmF1bHRzKTtcbiAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgZmluYWxPcHRpb25zW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgfVxuXG4gIHJldHVybiBmaW5hbE9wdGlvbnM7XG59O1xuXG5leHBvcnRzLmVzY2FwZUh0bWwgPSBmdW5jdGlvbih1bnNhZmUpIHtcbiAgcmV0dXJuIHVuc2FmZVxuICAgIC5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIilcbiAgICAucmVwbGFjZSgvPC9nLCBcIiZsdDtcIilcbiAgICAucmVwbGFjZSgvPi9nLCBcIiZndDtcIilcbiAgICAucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIilcbiAgICAucmVwbGFjZSgvJy9nLCBcIiYjMDM5O1wiKTtcbn07XG5cbi8qKlxuICogVmVyc2lvbiBvZiBtb2R1bG8gd2hpY2gsIHVubGlrZSBqYXZhc2NyaXB0J3MgYCVgIG9wZXJhdG9yLFxuICogd2lsbCBhbHdheXMgcmV0dXJuIGEgcG9zaXRpdmUgcmVtYWluZGVyLlxuICogQHBhcmFtIG51bWJlclxuICogQHBhcmFtIG1vZFxuICovXG5leHBvcnRzLm1vZCA9IGZ1bmN0aW9uKG51bWJlciwgbW9kKSB7XG4gIHJldHVybiAoKG51bWJlciAlIG1vZCkgKyBtb2QpICUgbW9kO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gYXJyYXkgb2YgaW50ZWdlcnMgZnJvbSBzdGFydCB0byBlbmQgaW5jbHVzaXZlXG4gKi9cbmV4cG9ydHMucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHZhciBpbnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuICAgIGludHMucHVzaChpKTtcbiAgfVxuICByZXR1cm4gaW50cztcbn07XG5cbi8qKlxuICogR2l2ZW4gdHdvIGZ1bmN0aW9ucywgZ2VuZXJhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlXG4gKiBzZWNvbmQgZnVuY3Rpb24gaWYgYW5kIG9ubHkgaWYgdGhlIGZpcnN0IGZ1bmN0aW9uIHJldHVybnMgdHJ1ZVxuICovXG5leHBvcnRzLmV4ZWN1dGVJZkNvbmRpdGlvbmFsID0gZnVuY3Rpb24gKGNvbmRpdGlvbmFsLCBmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb25kaXRpb25hbCgpKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIHNpbmdsZSBhbmQgZG91YmxlIHF1b3RlcyBmcm9tIGEgc3RyaW5nXG4gKiBAcGFyYW0gaW5wdXRTdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHN0cmluZyB3aXRob3V0IHF1b3Rlc1xuICovXG5leHBvcnRzLnN0cmlwUXVvdGVzID0gZnVuY3Rpb24oaW5wdXRTdHJpbmcpIHtcbiAgcmV0dXJuIGlucHV0U3RyaW5nLnJlcGxhY2UoL1tcIiddL2csIFwiXCIpO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIGFuIGluaGVyaXRhbmNlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHBhcmVudCBjbGFzcyBhbmQgdGhpcyBjbGFzcy5cbiAqL1xuRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICB0aGlzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSk7XG4gIHRoaXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gdGhpcztcbiAgdGhpcy5zdXBlclByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG59O1xuXG4vKipcbiAqIFdyYXAgYSBjb3VwbGUgb2Ygb3VyIEJsb2NrbHkgbnVtYmVyIHZhbGlkYXRvcnMgdG8gYWxsb3cgZm9yID8/Py4gIFRoaXMgaXNcbiAqIGRvbmUgc28gdGhhdCBsZXZlbCBidWlsZGVycyBjYW4gc3BlY2lmeSByZXF1aXJlZCBibG9ja3Mgd2l0aCB3aWxkY2FyZCBmaWVsZHMuXG4gKi9cbmV4cG9ydHMud3JhcE51bWJlclZhbGlkYXRvcnNGb3JMZXZlbEJ1aWxkZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub25OZWcgPSBCbG9ja2x5LkZpZWxkVGV4dElucHV0Lm5vbm5lZ2F0aXZlSW50ZWdlclZhbGlkYXRvcjtcbiAgdmFyIG51bVZhbCA9IEJsb2NrbHkuRmllbGRUZXh0SW5wdXQubnVtYmVyVmFsaWRhdG9yO1xuXG4gIEJsb2NrbHkuRmllbGRUZXh0SW5wdXQubm9ubmVnYXRpdmVJbnRlZ2VyVmFsaWRhdG9yID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICBpZiAodGV4dCA9PT0gJz8/PycpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbm9uTmVnKHRleHQpO1xuICB9O1xuXG4gIEJsb2NrbHkuRmllbGRUZXh0SW5wdXQubnVtYmVyVmFsaWRhdG9yID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICBpZiAodGV4dCA9PT0gJz8/PycpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbnVtVmFsKHRleHQpO1xuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSByYW5kb20ga2V5IG5hbWUgZnJvbSBhbiBvYmplY3QuXG4gKlxuICogU2xpZ2h0bHkgbW9kaWZpZWQgZnJvbTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTUxMDY1NDFcbiAqL1xuXG5leHBvcnRzLnJhbmRvbUtleSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICByZXR1cm4ga2V5c1trZXlzLmxlbmd0aCAqIE1hdGgucmFuZG9tKCkgPDwgMF07XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgcmFuZG9tIGlkZW50aWZpZXIgaW4gYSBmb3JtYXQgbWF0Y2hpbmcgdGhlIFJGQy00MTIyIHNwZWNpZmljYXRpb24uXG4gKlxuICogVGFrZW4gZnJvbVxuICoge0BsaW5rIGh0dHA6Ly9ieXJvbnNhbGF1LmNvbS9ibG9nL2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdC99XG4gKlxuICogQHNlZSBSRkMtNDEyMiBzdGFuZGFyZCB7QGxpbmsgaHR0cDovL3d3dy5pZXRmLm9yZy9yZmMvcmZjNDEyMi50eHR9XG4gKlxuICogQHJldHVybnMge3N0cmluZ30gUkZDNDEyMi1jb21wbGlhbnQgVVVJRFxuICovXG5leHBvcnRzLmNyZWF0ZVV1aWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uKGMpIHtcbiAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkqMTZ8MCwgdiA9IGMgPT09ICd4JyA/IHIgOiAociYweDN8MHg4KTtcbiAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gIH0pO1xufTtcblxuZXhwb3J0cy5maXJlUmVzaXplRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBldiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICBldi5pbml0RXZlbnQoJ3Jlc2l6ZScsIHRydWUsIHRydWUpO1xuICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldik7XG59O1xuXG4vLyBFQ01BU2NyaXB0IDYgcG9seWZpbGwgZm9yIFN0cmluZy5wcm90b3R5cGUucmVwZWF0XG4vLyBQb2x5ZmlsbCBhZGFwdGVkIGZyb21cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlXG4vLyAgICAgICAgL0dsb2JhbF9PYmplY3RzL1N0cmluZy9yZXBlYXRcbmlmICghU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQpIHtcbiAgLyoqXG4gICAqIFRoZSByZXBlYXQoKSBtZXRob2QgY29uc3RydWN0cyBhbmQgcmV0dXJucyBhIG5ldyBzdHJpbmcgd2hpY2ggY29udGFpbnNcbiAgICogdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgY29waWVzIG9mIHRoZSBzdHJpbmcgb24gd2hpY2ggaXQgd2FzIGNhbGxlZCxcbiAgICogY29uY2F0ZW5hdGVkIHRvZ2V0aGVyP1xuICAgKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIFN0cmluZy5wcm90b3R5cGUucmVwZWF0ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICBpZiAodGhpcyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FuXFwndCBjb252ZXJ0ICcgKyB0aGlzICsgJyB0byBvYmplY3QnKTtcbiAgICB9XG4gICAgdmFyIHN0ciA9ICcnICsgdGhpcztcbiAgICBjb3VudCA9ICtjb3VudDtcbiAgICBpZiAoY291bnQgIT09IGNvdW50KSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdyZXBlYXQgY291bnQgbXVzdCBiZSBub24tbmVnYXRpdmUnKTtcbiAgICB9XG4gICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3JlcGVhdCBjb3VudCBtdXN0IGJlIGxlc3MgdGhhbiBpbmZpbml0eScpO1xuICAgIH1cbiAgICBjb3VudCA9IE1hdGguZmxvb3IoY291bnQpO1xuICAgIGlmIChzdHIubGVuZ3RoID09PSAwIHx8IGNvdW50ID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIC8vIEVuc3VyaW5nIGNvdW50IGlzIGEgMzEtYml0IGludGVnZXIgYWxsb3dzIHVzIHRvIGhlYXZpbHkgb3B0aW1pemUgdGhlXG4gICAgLy8gbWFpbiBwYXJ0LiBCdXQgYW55d2F5LCBtb3N0IGN1cnJlbnQgKGF1Z3VzdCAyMDE0KSBicm93c2VycyBjYW4ndCBoYW5kbGVcbiAgICAvLyBzdHJpbmdzIDEgPDwgMjggY2hhcnMgb3IgbG9uZ2VyLCBzbzpcbiAgICBpZiAoc3RyLmxlbmd0aCAqIGNvdW50ID49IDEgPDwgMjgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdyZXBlYXQgY291bnQgbXVzdCBub3Qgb3ZlcmZsb3cgbWF4aW11bSBzdHJpbmcgc2l6ZScpO1xuICAgIH1cbiAgICB2YXIgcnB0ID0gJyc7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKChjb3VudCAmIDEpID09PSAxKSB7XG4gICAgICAgIHJwdCArPSBzdHI7XG4gICAgICB9XG4gICAgICBjb3VudCA+Pj49IDE7XG4gICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdHIgKz0gc3RyO1xuICAgIH1cbiAgICByZXR1cm4gcnB0O1xuICB9O1xufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gdmFsIHx8IGRlZmF1bHRWYWwsIGV4Y2VwdCBpdCdzIGdhdGVkIG9uIHdoZXRoZXIgb3Igbm90IHZhbCBpc1xuICogdW5kZWZpbmVkIGluc3RlYWQgb2Ygd2hldGhlciB2YWwgaXMgZmFsc2V5LlxuICogQHJldHVybnMgeyp9IHZhbCBpZiBub3QgdW5kZWZpbmVkLCBvdGhlcndpc2UgZGVmYXVsdFZhbFxuICovXG5leHBvcnRzLnZhbHVlT3IgPSBmdW5jdGlvbiAodmFsLCBkZWZhdWx0VmFsKSB7XG4gIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWwgOiB2YWw7XG59O1xuXG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gYW5hbHl6ZSB3aGV0aGVyIG9yIG5vdCBlcnIgcmVwcmVzZW50cyBpbmZpbml0ZSByZWN1cnNpb24gaGF2aW5nXG4gKiBvY2N1cnJlZC4gVGhpcyBlcnJvciBkaWZmZXJzIHBlciBicm93c2VyLCBhbmQgaXQncyBwb3NzaWJsZSB0aGF0IHdlIGRvbid0XG4gKiBwcm9wZXJseSBkaXNjb3ZlciBhbGwgY2FzZXMuXG4gKiBOb3RlOiBPdGhlciBsYW5ndWFnZXMgcHJvYmFibHkgaGF2ZSBsb2NhbGl6ZWQgbWVzc2FnZXMsIG1lYW5pbmcgd2Ugd29uJ3RcbiAqIGNhdGNoIHRoZW0uXG4gKi9cbmV4cG9ydHMuaXNJbmZpbml0ZVJlY3Vyc2lvbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAvLyBDaHJvbWUvU2FmYXJpOiBtZXNzYWdlIGVuZHMgaW4gYSBwZXJpb2QgaW4gU2FmYXJpLCBub3QgaW4gQ2hyb21lXG4gIGlmIChlcnIgaW5zdGFuY2VvZiBSYW5nZUVycm9yICYmXG4gICAgL15NYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZC8udGVzdChlcnIubWVzc2FnZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEZpcmVmb3hcbiAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICAvLyBMaW50ZXIgZG9lc24ndCBsaWtlIG91ciB1c2Ugb2YgSW50ZXJuYWxFcnJvciwgZXZlbiB0aG91Z2ggd2UgZ2F0ZSBvbiBpdHNcbiAgLy8gZXhpc3RlbmNlLlxuICBpZiAodHlwZW9mKEludGVybmFsRXJyb3IpICE9PSAndW5kZWZpbmVkJyAmJiBlcnIgaW5zdGFuY2VvZiBJbnRlcm5hbEVycm9yICYmXG4gICAgICBlcnIubWVzc2FnZSA9PT0gJ3RvbyBtdWNoIHJlY3Vyc2lvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG4gIC8vIElFXG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgZXJyLm1lc3NhZ2UgPT09ICdPdXQgb2Ygc3RhY2sgc3BhY2UnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBUT0RPKGRhdmUpOiBtb3ZlIHRoaXMgbG9naWMgdG8gZGFzaGJvYXJkLlxuZXhwb3J0cy5nZXRQZWdhc3VzSG9zdCA9IGZ1bmN0aW9uKCkge1xuICBzd2l0Y2ggKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSkge1xuICAgIGNhc2UgJ3N0dWRpby5jb2RlLm9yZyc6XG4gICAgY2FzZSAnbGVhcm4uY29kZS5vcmcnOlxuICAgICAgcmV0dXJuICdjb2RlLm9yZyc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBuYW1lID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLnNwbGl0KCcuJylbMF07XG4gICAgICBzd2l0Y2gobmFtZSkge1xuICAgICAgICBjYXNlICdsb2NhbGhvc3QnOlxuICAgICAgICAgIHJldHVybiAnbG9jYWxob3N0LmNvZGUub3JnOjMwMDAnO1xuICAgICAgICBjYXNlICdkZXZlbG9wbWVudCc6XG4gICAgICAgIGNhc2UgJ3N0YWdpbmcnOlxuICAgICAgICBjYXNlICd0ZXN0JzpcbiAgICAgICAgY2FzZSAnbGV2ZWxidWlsZGVyJzpcbiAgICAgICAgICByZXR1cm4gbmFtZSArICcuY29kZS5vcmcnO1xuICAgICAgICBjYXNlICdzdGFnaW5nLXN0dWRpbyc6XG4gICAgICAgICAgcmV0dXJuICdzdGFnaW5nLmNvZGUub3JnJztcbiAgICAgICAgY2FzZSAndGVzdC1zdHVkaW8nOlxuICAgICAgICAgIHJldHVybiAndGVzdC5jb2RlLm9yZyc7XG4gICAgICAgIGNhc2UgJ2xldmVsYnVpbGRlci1zdHVkaW8nOlxuICAgICAgICAgIHJldHVybiAnbGV2ZWxidWlsZGVyLmNvZGUub3JnJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBJRTkgdGhyb3dzIGFuIGV4Y2VwdGlvbiB3aGVuIHRyeWluZyB0byBhY2Nlc3MgdGhlIG1lZGlhIGZpZWxkIG9mIGEgc3R5bGVzaGVldFxuICovXG5leHBvcnRzLmJyb3dzZXJTdXBwb3J0c0Nzc01lZGlhID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3R5bGVTaGVldHMgPSBkb2N1bWVudC5zdHlsZVNoZWV0cztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZVNoZWV0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBydWxlcyA9IHN0eWxlU2hlZXRzW2ldLmNzc1J1bGVzIHx8IHN0eWxlU2hlZXRzW2ldLnJ1bGVzO1xuICAgIHRyeSB7XG4gICAgICBpZiAocnVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBzZWUgaWYgd2UgY2FuIGFjY2VzcyBtZWRpYVxuICAgICAgICB2YXIgbWVkaWEgPSBydWxlc1swXS5tZWRpYTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGVzY2FwZWQgY2hhcmFjdGVycyBhbmQgSFRNTCB0byBjb252ZXJ0IHNvbWUgcmVuZGVyZWQgdGV4dCB0byB3aGF0IHNob3VsZCBhcHBlYXIgaW4gdXNlci1lZGl0ZWQgY29udHJvbHNcbiAqIEBwYXJhbSB0ZXh0XG4gKiBAcmV0dXJucyBTdHJpbmcgdGhhdCBoYXMgbm8gbW9yZSBlc2NhcGUgY2hhcmFjdGVycyBhbmQgbXVsdGlwbGUgZGl2cyBjb252ZXJ0ZWQgdG8gbmV3bGluZXNcbiAqL1xuZXhwb3J0cy51bmVzY2FwZVRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHZhciBjbGVhbmVkVGV4dCA9IHRleHQ7XG4gIGNsZWFuZWRUZXh0ID0gY2xlYW5lZFRleHQucmVwbGFjZSgvPGRpdj4vZ2ksICdcXG4nKTsgLy8gRGl2cyBnZW5lcmF0ZSBuZXdsaW5lc1xuICBjbGVhbmVkVGV4dCA9IGNsZWFuZWRUZXh0LnJlcGxhY2UoLzxbXj5dKz4vZ2ksICcnKTsgLy8gU3RyaXAgYWxsIG90aGVyIHRhZ3NcblxuICAvLyBUaGlzIG5leHQgc3RlcCByZXF1aXJlcyBzb21lIGV4cGxhbmF0aW9uXG4gIC8vIEluIG11bHRpbGluZSB0ZXh0IGl0J3MgcG9zc2libGUgZm9yIHRoZSBmaXJzdCBsaW5lIHRvIHJlbmRlciB3cmFwcGVkIG9yIHVud3JhcHBlZC5cbiAgLy8gICAgIExpbmUgMVxuICAvLyAgICAgTGluZSAyXG4gIC8vICAgQ2FuIHJlbmRlciBhcyBlaXRoZXIgb2Y6XG4gIC8vICAgICBMaW5lIDE8ZGl2PkxpbmUgMjwvZGl2PlxuICAvLyAgICAgPGRpdj5MaW5lIDE8L2Rpdj48ZGl2PkxpbmUgMjwvZGl2PlxuICAvL1xuICAvLyBCdXQgbGVhZGluZyBibGFuayBsaW5lcyB3aWxsIGFsd2F5cyByZW5kZXIgd3JhcHBlZCBhbmQgc2hvdWxkIGJlIHByZXNlcnZlZFxuICAvL1xuICAvLyAgICAgTGluZSAyXG4gIC8vICAgICBMaW5lIDNcbiAgLy8gICBSZW5kZXJzIGFzXG4gIC8vICAgIDxkaXY+PGJyPjwvZGl2PjxkaXY+TGluZSAyPC9kaXY+PGRpdj5MaW5lIDM8L2Rpdj5cbiAgLy9cbiAgLy8gVG8gaGFuZGxlIHRoaXMgYmVoYXZpb3Igd2Ugc3RyaXAgbGVhZGluZyBuZXdsaW5lcyBVTkxFU1MgdGhleSBhcmUgZm9sbG93ZWRcbiAgLy8gYnkgYW5vdGhlciBuZXdsaW5lLCB1c2luZyBhIG5lZ2F0aXZlIGxvb2thaGVhZCAoPyEpXG4gIGNsZWFuZWRUZXh0ID0gY2xlYW5lZFRleHQucmVwbGFjZSgvXlxcbig/IVxcbikvLCAnJyk7IC8vIFN0cmlwIGxlYWRpbmcgbm9uZG91YmxlZCBuZXdsaW5lXG5cbiAgY2xlYW5lZFRleHQgPSBjbGVhbmVkVGV4dC5yZXBsYWNlKC8mbmJzcDsvZ2ksICcgJyk7IC8vIFVuZXNjYXBlIG5vbmJyZWFraW5nIHNwYWNlc1xuICBjbGVhbmVkVGV4dCA9IGNsZWFuZWRUZXh0LnJlcGxhY2UoLyZndDsvZ2ksICc+Jyk7ICAgLy8gVW5lc2NhcGUgPlxuICBjbGVhbmVkVGV4dCA9IGNsZWFuZWRUZXh0LnJlcGxhY2UoLyZsdDsvZ2ksICc8Jyk7ICAgLy8gVW5lc2NhcGUgPFxuICBjbGVhbmVkVGV4dCA9IGNsZWFuZWRUZXh0LnJlcGxhY2UoLyZhbXA7L2dpLCAnJicpOyAgLy8gVW5lc2NhcGUgJiAobXVzdCBoYXBwZW4gbGFzdCEpXG4gIHJldHVybiBjbGVhbmVkVGV4dDtcbn07XG5cbi8qKlxuICogRXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyBpbiBhIHBpZWNlIG9mIHRleHQsIGFuZCBjb252ZXJ0IG5ld2xpbmVzIHRvIHNlcGVyYXRlIGRpdnNcbiAqIEBwYXJhbSB0ZXh0XG4gKiBAcmV0dXJucyBTdHJpbmcgd2l0aCBzcGVjaWFsIGNoYXJhY3RlcnMgZXNjYXBlZCBhbmQgbmV3bGluZXMgY29udmVydGVkIGRpdnNcbiAqL1xuZXhwb3J0cy5lc2NhcGVUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgdmFyIGVzY2FwZWRUZXh0ID0gdGV4dC50b1N0cmluZygpO1xuICBlc2NhcGVkVGV4dCA9IGVzY2FwZWRUZXh0LnJlcGxhY2UoLyYvZywgJyZhbXA7Jyk7ICAgLy8gRXNjYXBlICYgKG11c3QgaGFwcGVuIGZpcnN0ISlcbiAgZXNjYXBlZFRleHQgPSBlc2NhcGVkVGV4dC5yZXBsYWNlKC88L2csICcmbHQ7Jyk7ICAgIC8vIEVzY2FwZSA8XG4gIGVzY2FwZWRUZXh0ID0gZXNjYXBlZFRleHQucmVwbGFjZSgvPi9nLCAnJmd0OycpOyAgICAvLyBFc2NhcGUgPlxuICBlc2NhcGVkVGV4dCA9IGVzY2FwZWRUZXh0LnJlcGxhY2UoLyAgL2csJyAmbmJzcDsnKTsgLy8gRXNjYXBlIGRvdWJsZWQgc3BhY2VzXG5cbiAgLy8gTm93IHdyYXAgZWFjaCBsaW5lIGV4Y2VwdCB0aGUgZmlyc3QgbGluZSBpbiBhIDxkaXY+LFxuICAvLyByZXBsYWNpbmcgYmxhbmsgbGluZXMgd2l0aCA8ZGl2Pjxicj48ZGl2PlxuICB2YXIgbGluZXMgPSBlc2NhcGVkVGV4dC5zcGxpdCgnXFxuJyk7XG4gIHZhciByZXR1cm5WYWx1ZSA9IGxpbmVzWzBdICsgbGluZXMuc2xpY2UoMSkubWFwKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICByZXR1cm4gJzxkaXY+JyArIChsaW5lLmxlbmd0aCA/IGxpbmUgOiAnPGJyPicpICsgJzwvZGl2Pic7XG4gICAgfSkuam9pbignJyk7XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBkZWdyZWVzIGludG8gcmFkaWFucy5cbiAqXG4gKiBAcGFyYW0gZGVncmVlcyAtIFRoZSBkZWdyZWVzIHRvIGNvbnZlcnQgdG8gcmFkaWFuc1xuICogQHJldHVybiBgZGVncmVlc2AgY29udmVydGVkIHRvIHJhZGlhbnNcbiAqL1xuZXhwb3J0cy5kZWdyZWVzVG9SYWRpYW5zID0gZnVuY3Rpb24gKGRlZ3JlZXMpIHtcbiAgICByZXR1cm4gZGVncmVlcyAqIChNYXRoLlBJIC8gMTgwKTtcbn07XG5cbi8qKlxuICogU2ltcGxlIHdyYXBwZXIgYXJvdW5kIGxvY2FsU3RvcmFnZS5zZXRJdGVtIHRoYXQgY2F0Y2hlcyBhbnkgZXhjZXB0aW9ucyAoZm9yXG4gKiBleGFtcGxlIHdoZW4gd2UgY2FsbCBzZXRJdGVtIGluIFNhZmFyaSdzIHByaXZhdGUgbW9kZSlcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgd2Ugc2V0IHN1Y2Nlc3NmdWxseVxuICovXG5leHBvcnRzLnRyeVNldExvY2FsU3RvcmFnZSA9IGZ1bmN0aW9uIChpdGVtLCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGl0ZW0sIHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIExvLURhc2ggMi40LjEgKEN1c3RvbSBCdWlsZCkgPGh0dHA6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIGluY2x1ZGU9XCJkZWJvdW5jZSxyZWplY3QsbWFwLHZhbHVlLHJhbmdlLHdpdGhvdXQsc2FtcGxlLGNyZWF0ZSxmbGF0dGVuLGlzRW1wdHksd3JhcCxzaXplLGJpbmQsY29udGFpbnMsbGFzdCxjbG9uZSxjbG9uZURlZXAsaXNFcXVhbCxmaW5kLHNvcnRCeSx0aHJvdHRsZSx1bmlxXCIgLS1vdXRwdXQgc3JjL2xvZGFzaC5qc2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTMgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuNS4yIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxMyBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG47KGZ1bmN0aW9uKCkge1xuXG4gIC8qKiBVc2VkIGFzIGEgc2FmZSByZWZlcmVuY2UgZm9yIGB1bmRlZmluZWRgIGluIHByZSBFUzUgZW52aXJvbm1lbnRzICovXG4gIHZhciB1bmRlZmluZWQ7XG5cbiAgLyoqIFVzZWQgdG8gcG9vbCBhcnJheXMgYW5kIG9iamVjdHMgdXNlZCBpbnRlcm5hbGx5ICovXG4gIHZhciBhcnJheVBvb2wgPSBbXSxcbiAgICAgIG9iamVjdFBvb2wgPSBbXTtcblxuICAvKiogVXNlZCBpbnRlcm5hbGx5IHRvIGluZGljYXRlIHZhcmlvdXMgdGhpbmdzICovXG4gIHZhciBpbmRpY2F0b3JPYmplY3QgPSB7fTtcblxuICAvKiogVXNlZCB0byBwcmVmaXgga2V5cyB0byBhdm9pZCBpc3N1ZXMgd2l0aCBgX19wcm90b19fYCBhbmQgcHJvcGVydGllcyBvbiBgT2JqZWN0LnByb3RvdHlwZWAgKi9cbiAgdmFyIGtleVByZWZpeCA9ICtuZXcgRGF0ZSArICcnO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzaXplIHdoZW4gb3B0aW1pemF0aW9ucyBhcmUgZW5hYmxlZCBmb3IgbGFyZ2UgYXJyYXlzICovXG4gIHZhciBsYXJnZUFycmF5U2l6ZSA9IDc1O1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBtYXggc2l6ZSBvZiB0aGUgYGFycmF5UG9vbGAgYW5kIGBvYmplY3RQb29sYCAqL1xuICB2YXIgbWF4UG9vbFNpemUgPSA0MDtcblxuICAvKiogVXNlZCB0byBtYXRjaCByZWdleHAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMgKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdGVkIG5hbWVkIGZ1bmN0aW9ucyAqL1xuICB2YXIgcmVGdW5jTmFtZSA9IC9eXFxzKmZ1bmN0aW9uWyBcXG5cXHJcXHRdK1xcdy87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGZ1bmN0aW9ucyBjb250YWluaW5nIGEgYHRoaXNgIHJlZmVyZW5jZSAqL1xuICB2YXIgcmVUaGlzID0gL1xcYnRoaXNcXGIvO1xuXG4gIC8qKiBVc2VkIHRvIGZpeCB0aGUgSlNjcmlwdCBbW0RvbnRFbnVtXV0gYnVnICovXG4gIHZhciBzaGFkb3dlZFByb3BzID0gW1xuICAgICdjb25zdHJ1Y3RvcicsICdoYXNPd25Qcm9wZXJ0eScsICdpc1Byb3RvdHlwZU9mJywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgICAndG9Mb2NhbGVTdHJpbmcnLCAndG9TdHJpbmcnLCAndmFsdWVPZidcbiAgXTtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHNob3J0Y3V0cyAqL1xuICB2YXIgYXJnc0NsYXNzID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgICBhcnJheUNsYXNzID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGJvb2xDbGFzcyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICAgIGRhdGVDbGFzcyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGVycm9yQ2xhc3MgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgICAgZnVuY0NsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIG51bWJlckNsYXNzID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBvYmplY3RDbGFzcyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgcmVnZXhwQ2xhc3MgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHN0cmluZ0NsYXNzID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgb2JqZWN0IGNsYXNzaWZpY2F0aW9ucyB0aGF0IGBfLmNsb25lYCBzdXBwb3J0cyAqL1xuICB2YXIgY2xvbmVhYmxlQ2xhc3NlcyA9IHt9O1xuICBjbG9uZWFibGVDbGFzc2VzW2Z1bmNDbGFzc10gPSBmYWxzZTtcbiAgY2xvbmVhYmxlQ2xhc3Nlc1thcmdzQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1thcnJheUNsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbYm9vbENsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbZGF0ZUNsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbbnVtYmVyQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tvYmplY3RDbGFzc10gPVxuICBjbG9uZWFibGVDbGFzc2VzW3JlZ2V4cENsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbc3RyaW5nQ2xhc3NdID0gdHJ1ZTtcblxuICAvKiogVXNlZCBhcyBhbiBpbnRlcm5hbCBgXy5kZWJvdW5jZWAgb3B0aW9ucyBvYmplY3QgKi9cbiAgdmFyIGRlYm91bmNlT3B0aW9ucyA9IHtcbiAgICAnbGVhZGluZyc6IGZhbHNlLFxuICAgICdtYXhXYWl0JzogMCxcbiAgICAndHJhaWxpbmcnOiBmYWxzZVxuICB9O1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciBgX19iaW5kRGF0YV9fYCAqL1xuICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAnY29uZmlndXJhYmxlJzogZmFsc2UsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBudWxsLFxuICAgICd3cml0YWJsZSc6IGZhbHNlXG4gIH07XG5cbiAgLyoqIFVzZWQgYXMgdGhlIGRhdGEgb2JqZWN0IGZvciBgaXRlcmF0b3JUZW1wbGF0ZWAgKi9cbiAgdmFyIGl0ZXJhdG9yRGF0YSA9IHtcbiAgICAnYXJncyc6ICcnLFxuICAgICdhcnJheSc6IG51bGwsXG4gICAgJ2JvdHRvbSc6ICcnLFxuICAgICdmaXJzdEFyZyc6ICcnLFxuICAgICdpbml0JzogJycsXG4gICAgJ2tleXMnOiBudWxsLFxuICAgICdsb29wJzogJycsXG4gICAgJ3NoYWRvd2VkUHJvcHMnOiBudWxsLFxuICAgICdzdXBwb3J0JzogbnVsbCxcbiAgICAndG9wJzogJycsXG4gICAgJ3VzZUhhcyc6IGZhbHNlXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHZhbHVlcyBhcmUgb2YgdGhlIGxhbmd1YWdlIHR5cGUgT2JqZWN0ICovXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAnYm9vbGVhbic6IGZhbHNlLFxuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWUsXG4gICAgJ251bWJlcic6IGZhbHNlLFxuICAgICdzdHJpbmcnOiBmYWxzZSxcbiAgICAndW5kZWZpbmVkJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCAqL1xuICB2YXIgcm9vdCA9IChvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cpIHx8IHRoaXM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYCAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYCAqL1xuICB2YXIgZnJlZU1vZHVsZSA9IG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuICAvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgICovXG4gIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzICYmIGZyZWVFeHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUgYW5kIHVzZSBpdCBhcyBgcm9vdGAgKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSBvYmplY3RUeXBlc1t0eXBlb2YgZ2xvYmFsXSAmJiBnbG9iYWw7XG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGJpbmFyeSBzZWFyY2hlc1xuICAgKiBvciBgZnJvbUluZGV4YCBjb25zdHJhaW50cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSBvciBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSAoZnJvbUluZGV4IHx8IDApIC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbnRhaW5zYCBmb3IgY2FjaGUgb2JqZWN0cyB0aGF0IG1pbWljcyB0aGUgcmV0dXJuXG4gICAqIHNpZ25hdHVyZSBvZiBgXy5pbmRleE9mYCBieSByZXR1cm5pbmcgYDBgIGlmIHRoZSB2YWx1ZSBpcyBmb3VuZCwgZWxzZSBgLTFgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGAwYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgY2FjaGUgPSBjYWNoZS5jYWNoZTtcblxuICAgIGlmICh0eXBlID09ICdib29sZWFuJyB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVbdmFsdWVdID8gMCA6IC0xO1xuICAgIH1cbiAgICBpZiAodHlwZSAhPSAnbnVtYmVyJyAmJiB0eXBlICE9ICdzdHJpbmcnKSB7XG4gICAgICB0eXBlID0gJ29iamVjdCc7XG4gICAgfVxuICAgIHZhciBrZXkgPSB0eXBlID09ICdudW1iZXInID8gdmFsdWUgOiBrZXlQcmVmaXggKyB2YWx1ZTtcbiAgICBjYWNoZSA9IChjYWNoZSA9IGNhY2hlW3R5cGVdKSAmJiBjYWNoZVtrZXldO1xuXG4gICAgcmV0dXJuIHR5cGUgPT0gJ29iamVjdCdcbiAgICAgID8gKGNhY2hlICYmIGJhc2VJbmRleE9mKGNhY2hlLCB2YWx1ZSkgPiAtMSA/IDAgOiAtMSlcbiAgICAgIDogKGNhY2hlID8gMCA6IC0xKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgZ2l2ZW4gdmFsdWUgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY2FjaGUgb2JqZWN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhZGQgdG8gdGhlIGNhY2hlLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVQdXNoKHZhbHVlKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZSxcbiAgICAgICAgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICAgIGlmICh0eXBlID09ICdib29sZWFuJyB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBjYWNoZVt2YWx1ZV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSAhPSAnbnVtYmVyJyAmJiB0eXBlICE9ICdzdHJpbmcnKSB7XG4gICAgICAgIHR5cGUgPSAnb2JqZWN0JztcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB0eXBlID09ICdudW1iZXInID8gdmFsdWUgOiBrZXlQcmVmaXggKyB2YWx1ZSxcbiAgICAgICAgICB0eXBlQ2FjaGUgPSBjYWNoZVt0eXBlXSB8fCAoY2FjaGVbdHlwZV0gPSB7fSk7XG5cbiAgICAgIGlmICh0eXBlID09ICdvYmplY3QnKSB7XG4gICAgICAgICh0eXBlQ2FjaGVba2V5XSB8fCAodHlwZUNhY2hlW2tleV0gPSBbXSkpLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZUNhY2hlW2tleV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBzb3J0QnlgIHRvIGNvbXBhcmUgdHJhbnNmb3JtZWQgYGNvbGxlY3Rpb25gIGVsZW1lbnRzLCBzdGFibGUgc29ydGluZ1xuICAgKiB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBiYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBhYC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3Igb2YgYDFgIG9yIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKGEsIGIpIHtcbiAgICB2YXIgYWMgPSBhLmNyaXRlcmlhLFxuICAgICAgICBiYyA9IGIuY3JpdGVyaWEsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFjLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhY1tpbmRleF0sXG4gICAgICAgICAgb3RoZXIgPSBiY1tpbmRleF07XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICAgICAgaWYgKHZhbHVlID4gb3RoZXIgfHwgdHlwZW9mIHZhbHVlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgb3RoZXIgfHwgdHlwZW9mIG90aGVyID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byByZXR1cm4gdGhlIHNhbWUgdmFsdWUgZm9yXG4gICAgLy8gYGFgIGFuZCBgYmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gICAgLy9cbiAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgIC8vIFNlZSBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MFxuICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2FjaGUgb2JqZWN0IHRvIG9wdGltaXplIGxpbmVhciBzZWFyY2hlcyBvZiBsYXJnZSBhcnJheXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHJldHVybnMge251bGx8T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBvYmplY3Qgb3IgYG51bGxgIGlmIGNhY2hpbmcgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2FjaGUoYXJyYXkpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBmaXJzdCA9IGFycmF5WzBdLFxuICAgICAgICBtaWQgPSBhcnJheVsobGVuZ3RoIC8gMikgfCAwXSxcbiAgICAgICAgbGFzdCA9IGFycmF5W2xlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGZpcnN0ICYmIHR5cGVvZiBmaXJzdCA9PSAnb2JqZWN0JyAmJlxuICAgICAgICBtaWQgJiYgdHlwZW9mIG1pZCA9PSAnb2JqZWN0JyAmJiBsYXN0ICYmIHR5cGVvZiBsYXN0ID09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjYWNoZSA9IGdldE9iamVjdCgpO1xuICAgIGNhY2hlWydmYWxzZSddID0gY2FjaGVbJ251bGwnXSA9IGNhY2hlWyd0cnVlJ10gPSBjYWNoZVsndW5kZWZpbmVkJ10gPSBmYWxzZTtcblxuICAgIHZhciByZXN1bHQgPSBnZXRPYmplY3QoKTtcbiAgICByZXN1bHQuYXJyYXkgPSBhcnJheTtcbiAgICByZXN1bHQuY2FjaGUgPSBjYWNoZTtcbiAgICByZXN1bHQucHVzaCA9IGNhY2hlUHVzaDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaChhcnJheVtpbmRleF0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gYXJyYXkgZnJvbSB0aGUgYXJyYXkgcG9vbCBvciBjcmVhdGVzIGEgbmV3IG9uZSBpZiB0aGUgcG9vbCBpcyBlbXB0eS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgZnJvbSB0aGUgcG9vbC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEFycmF5KCkge1xuICAgIHJldHVybiBhcnJheVBvb2wucG9wKCkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBvYmplY3QgZnJvbSB0aGUgb2JqZWN0IHBvb2wgb3IgY3JlYXRlcyBhIG5ldyBvbmUgaWYgdGhlIHBvb2wgaXMgZW1wdHkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBvYmplY3QgZnJvbSB0aGUgcG9vbC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldE9iamVjdCgpIHtcbiAgICByZXR1cm4gb2JqZWN0UG9vbC5wb3AoKSB8fCB7XG4gICAgICAnYXJyYXknOiBudWxsLFxuICAgICAgJ2NhY2hlJzogbnVsbCxcbiAgICAgICdjcml0ZXJpYSc6IG51bGwsXG4gICAgICAnZmFsc2UnOiBmYWxzZSxcbiAgICAgICdpbmRleCc6IDAsXG4gICAgICAnbnVsbCc6IGZhbHNlLFxuICAgICAgJ251bWJlcic6IG51bGwsXG4gICAgICAnb2JqZWN0JzogbnVsbCxcbiAgICAgICdwdXNoJzogbnVsbCxcbiAgICAgICdzdHJpbmcnOiBudWxsLFxuICAgICAgJ3RydWUnOiBmYWxzZSxcbiAgICAgICd1bmRlZmluZWQnOiBmYWxzZSxcbiAgICAgICd2YWx1ZSc6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgRE9NIG5vZGUgaW4gSUUgPCA5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgRE9NIG5vZGUsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzTm9kZSh2YWx1ZSkge1xuICAgIC8vIElFIDwgOSBwcmVzZW50cyBET00gbm9kZXMgYXMgYE9iamVjdGAgb2JqZWN0cyBleGNlcHQgdGhleSBoYXZlIGB0b1N0cmluZ2BcbiAgICAvLyBtZXRob2RzIHRoYXQgYXJlIGB0eXBlb2ZgIFwic3RyaW5nXCIgYW5kIHN0aWxsIGNhbiBjb2VyY2Ugbm9kZXMgdG8gc3RyaW5nc1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgKHZhbHVlICsgJycpID09ICdzdHJpbmcnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIHRoZSBnaXZlbiBhcnJheSBiYWNrIHRvIHRoZSBhcnJheSBwb29sLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byByZWxlYXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVsZWFzZUFycmF5KGFycmF5KSB7XG4gICAgYXJyYXkubGVuZ3RoID0gMDtcbiAgICBpZiAoYXJyYXlQb29sLmxlbmd0aCA8IG1heFBvb2xTaXplKSB7XG4gICAgICBhcnJheVBvb2wucHVzaChhcnJheSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIHRoZSBnaXZlbiBvYmplY3QgYmFjayB0byB0aGUgb2JqZWN0IHBvb2wuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHJlbGVhc2UuXG4gICAqL1xuICBmdW5jdGlvbiByZWxlYXNlT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBjYWNoZSA9IG9iamVjdC5jYWNoZTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIHJlbGVhc2VPYmplY3QoY2FjaGUpO1xuICAgIH1cbiAgICBvYmplY3QuYXJyYXkgPSBvYmplY3QuY2FjaGUgPSBvYmplY3QuY3JpdGVyaWEgPSBvYmplY3Qub2JqZWN0ID0gb2JqZWN0Lm51bWJlciA9IG9iamVjdC5zdHJpbmcgPSBvYmplY3QudmFsdWUgPSBudWxsO1xuICAgIGlmIChvYmplY3RQb29sLmxlbmd0aCA8IG1heFBvb2xTaXplKSB7XG4gICAgICBvYmplY3RQb29sLnB1c2gob2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2xpY2VzIHRoZSBgY29sbGVjdGlvbmAgZnJvbSB0aGUgYHN0YXJ0YCBpbmRleCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsXG4gICAqIHRoZSBgZW5kYCBpbmRleC5cbiAgICpcbiAgICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGluc3RlYWQgb2YgYEFycmF5I3NsaWNlYCB0byBzdXBwb3J0IG5vZGUgbGlzdHNcbiAgICogaW4gSUUgPCA5IGFuZCB0byBlbnN1cmUgZGVuc2UgYXJyYXlzIGFyZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNsaWNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgaW5kZXguXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gc2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICBzdGFydCB8fCAoc3RhcnQgPSAwKTtcbiAgICBpZiAodHlwZW9mIGVuZCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgZW5kID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gZW5kIC0gc3RhcnQgfHwgMCxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBVc2VkIGZvciBgQXJyYXlgIG1ldGhvZCByZWZlcmVuY2VzLlxuICAgKlxuICAgKiBOb3JtYWxseSBgQXJyYXkucHJvdG90eXBlYCB3b3VsZCBzdWZmaWNlLCBob3dldmVyLCB1c2luZyBhbiBhcnJheSBsaXRlcmFsXG4gICAqIGF2b2lkcyBpc3N1ZXMgaW4gTmFyd2hhbC5cbiAgICovXG4gIHZhciBhcnJheVJlZiA9IFtdO1xuXG4gIC8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgKi9cbiAgdmFyIGVycm9yUHJvdG8gPSBFcnJvci5wcm90b3R5cGUsXG4gICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICBzdHJpbmdQcm90byA9IFN0cmluZy5wcm90b3R5cGU7XG5cbiAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgaW50ZXJuYWwgW1tDbGFzc11dIG9mIHZhbHVlcyAqL1xuICB2YXIgdG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlICovXG4gIHZhciByZU5hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICAgIFN0cmluZyh0b1N0cmluZylcbiAgICAgIC5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpXG4gICAgICAucmVwbGFjZSgvdG9TdHJpbmd8IGZvciBbXlxcXV0rL2csICcuKj8nKSArICckJ1xuICApO1xuXG4gIC8qKiBOYXRpdmUgbWV0aG9kIHNob3J0Y3V0cyAqL1xuICB2YXIgY2VpbCA9IE1hdGguY2VpbCxcbiAgICAgIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5LFxuICAgICAgcHVzaCA9IGFycmF5UmVmLnB1c2gsXG4gICAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgICAgdW5zaGlmdCA9IGFycmF5UmVmLnVuc2hpZnQ7XG5cbiAgLyoqIFVzZWQgdG8gc2V0IG1ldGEgZGF0YSBvbiBmdW5jdGlvbnMgKi9cbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICAgIC8vIElFIDggb25seSBhY2NlcHRzIERPTSBlbGVtZW50c1xuICAgIHRyeSB7XG4gICAgICB2YXIgbyA9IHt9LFxuICAgICAgICAgIGZ1bmMgPSBpc05hdGl2ZShmdW5jID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KSAmJiBmdW5jLFxuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMobywgbywgbykgJiYgZnVuYztcbiAgICB9IGNhdGNoKGUpIHsgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0oKSk7XG5cbiAgLyogTmF0aXZlIG1ldGhvZCBzaG9ydGN1dHMgZm9yIG1ldGhvZHMgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMgKi9cbiAgdmFyIG5hdGl2ZUNyZWF0ZSA9IGlzTmF0aXZlKG5hdGl2ZUNyZWF0ZSA9IE9iamVjdC5jcmVhdGUpICYmIG5hdGl2ZUNyZWF0ZSxcbiAgICAgIG5hdGl2ZUlzQXJyYXkgPSBpc05hdGl2ZShuYXRpdmVJc0FycmF5ID0gQXJyYXkuaXNBcnJheSkgJiYgbmF0aXZlSXNBcnJheSxcbiAgICAgIG5hdGl2ZUtleXMgPSBpc05hdGl2ZShuYXRpdmVLZXlzID0gT2JqZWN0LmtleXMpICYmIG5hdGl2ZUtleXMsXG4gICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluLFxuICAgICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb207XG5cbiAgLyoqIFVzZWQgdG8gbG9va3VwIGEgYnVpbHQtaW4gY29uc3RydWN0b3IgYnkgW1tDbGFzc11dICovXG4gIHZhciBjdG9yQnlDbGFzcyA9IHt9O1xuICBjdG9yQnlDbGFzc1thcnJheUNsYXNzXSA9IEFycmF5O1xuICBjdG9yQnlDbGFzc1tib29sQ2xhc3NdID0gQm9vbGVhbjtcbiAgY3RvckJ5Q2xhc3NbZGF0ZUNsYXNzXSA9IERhdGU7XG4gIGN0b3JCeUNsYXNzW2Z1bmNDbGFzc10gPSBGdW5jdGlvbjtcbiAgY3RvckJ5Q2xhc3Nbb2JqZWN0Q2xhc3NdID0gT2JqZWN0O1xuICBjdG9yQnlDbGFzc1tudW1iZXJDbGFzc10gPSBOdW1iZXI7XG4gIGN0b3JCeUNsYXNzW3JlZ2V4cENsYXNzXSA9IFJlZ0V4cDtcbiAgY3RvckJ5Q2xhc3Nbc3RyaW5nQ2xhc3NdID0gU3RyaW5nO1xuXG4gIC8qKiBVc2VkIHRvIGF2b2lkIGl0ZXJhdGluZyBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGluIElFIDwgOSAqL1xuICB2YXIgbm9uRW51bVByb3BzID0ge307XG4gIG5vbkVudW1Qcm9wc1thcnJheUNsYXNzXSA9IG5vbkVudW1Qcm9wc1tkYXRlQ2xhc3NdID0gbm9uRW51bVByb3BzW251bWJlckNsYXNzXSA9IHsgJ2NvbnN0cnVjdG9yJzogdHJ1ZSwgJ3RvTG9jYWxlU3RyaW5nJzogdHJ1ZSwgJ3RvU3RyaW5nJzogdHJ1ZSwgJ3ZhbHVlT2YnOiB0cnVlIH07XG4gIG5vbkVudW1Qcm9wc1tib29sQ2xhc3NdID0gbm9uRW51bVByb3BzW3N0cmluZ0NsYXNzXSA9IHsgJ2NvbnN0cnVjdG9yJzogdHJ1ZSwgJ3RvU3RyaW5nJzogdHJ1ZSwgJ3ZhbHVlT2YnOiB0cnVlIH07XG4gIG5vbkVudW1Qcm9wc1tlcnJvckNsYXNzXSA9IG5vbkVudW1Qcm9wc1tmdW5jQ2xhc3NdID0gbm9uRW51bVByb3BzW3JlZ2V4cENsYXNzXSA9IHsgJ2NvbnN0cnVjdG9yJzogdHJ1ZSwgJ3RvU3RyaW5nJzogdHJ1ZSB9O1xuICBub25FbnVtUHJvcHNbb2JqZWN0Q2xhc3NdID0geyAnY29uc3RydWN0b3InOiB0cnVlIH07XG5cbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSBzaGFkb3dlZFByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBzaGFkb3dlZFByb3BzW2xlbmd0aF07XG4gICAgICBmb3IgKHZhciBjbGFzc05hbWUgaW4gbm9uRW51bVByb3BzKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG5vbkVudW1Qcm9wcywgY2xhc3NOYW1lKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChub25FbnVtUHJvcHNbY2xhc3NOYW1lXSwga2V5KSkge1xuICAgICAgICAgIG5vbkVudW1Qcm9wc1tjbGFzc05hbWVdW2tleV0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSgpKTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB3aGljaCB3cmFwcyB0aGUgZ2l2ZW4gdmFsdWUgdG8gZW5hYmxlIGludHVpdGl2ZVxuICAgKiBtZXRob2QgY2hhaW5pbmcuXG4gICAqXG4gICAqIEluIGFkZGl0aW9uIHRvIExvLURhc2ggbWV0aG9kcywgd3JhcHBlcnMgYWxzbyBoYXZlIHRoZSBmb2xsb3dpbmcgYEFycmF5YCBtZXRob2RzOlxuICAgKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgcmV2ZXJzZWAsIGBzaGlmdGAsIGBzbGljZWAsIGBzb3J0YCwgYHNwbGljZWAsXG4gICAqIGFuZCBgdW5zaGlmdGBcbiAgICpcbiAgICogQ2hhaW5pbmcgaXMgc3VwcG9ydGVkIGluIGN1c3RvbSBidWlsZHMgYXMgbG9uZyBhcyB0aGUgYHZhbHVlYCBtZXRob2QgaXNcbiAgICogaW1wbGljaXRseSBvciBleHBsaWNpdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAgICpcbiAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIGZ1bmN0aW9ucyBhcmU6XG4gICAqIGBhZnRlcmAsIGBhc3NpZ25gLCBgYmluZGAsIGBiaW5kQWxsYCwgYGJpbmRLZXlgLCBgY2hhaW5gLCBgY29tcGFjdGAsXG4gICAqIGBjb21wb3NlYCwgYGNvbmNhdGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsIGBjcmVhdGVDYWxsYmFja2AsIGBjdXJyeWAsXG4gICAqIGBkZWJvdW5jZWAsIGBkZWZhdWx0c2AsIGBkZWZlcmAsIGBkZWxheWAsIGBkaWZmZXJlbmNlYCwgYGZpbHRlcmAsIGBmbGF0dGVuYCxcbiAgICogYGZvckVhY2hgLCBgZm9yRWFjaFJpZ2h0YCwgYGZvckluYCwgYGZvckluUmlnaHRgLCBgZm9yT3duYCwgYGZvck93blJpZ2h0YCxcbiAgICogYGZ1bmN0aW9uc2AsIGBncm91cEJ5YCwgYGluZGV4QnlgLCBgaW5pdGlhbGAsIGBpbnRlcnNlY3Rpb25gLCBgaW52ZXJ0YCxcbiAgICogYGludm9rZWAsIGBrZXlzYCwgYG1hcGAsIGBtYXhgLCBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtaW5gLCBgb2JqZWN0YCwgYG9taXRgLFxuICAgKiBgb25jZWAsIGBwYWlyc2AsIGBwYXJ0aWFsYCwgYHBhcnRpYWxSaWdodGAsIGBwaWNrYCwgYHBsdWNrYCwgYHB1bGxgLCBgcHVzaGAsXG4gICAqIGByYW5nZWAsIGByZWplY3RgLCBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzaHVmZmxlYCwgYHNsaWNlYCwgYHNvcnRgLFxuICAgKiBgc29ydEJ5YCwgYHNwbGljZWAsIGB0YXBgLCBgdGhyb3R0bGVgLCBgdGltZXNgLCBgdG9BcnJheWAsIGB0cmFuc2Zvcm1gLFxuICAgKiBgdW5pb25gLCBgdW5pcWAsIGB1bnNoaWZ0YCwgYHVuemlwYCwgYHZhbHVlc2AsIGB3aGVyZWAsIGB3aXRob3V0YCwgYHdyYXBgLFxuICAgKiBhbmQgYHppcGBcbiAgICpcbiAgICogVGhlIG5vbi1jaGFpbmFibGUgd3JhcHBlciBmdW5jdGlvbnMgYXJlOlxuICAgKiBgY2xvbmVgLCBgY2xvbmVEZWVwYCwgYGNvbnRhaW5zYCwgYGVzY2FwZWAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsXG4gICAqIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCwgYGZpbmRMYXN0SW5kZXhgLCBgZmluZExhc3RLZXlgLCBgaGFzYCwgYGlkZW50aXR5YCxcbiAgICogYGluZGV4T2ZgLCBgaXNBcmd1bWVudHNgLCBgaXNBcnJheWAsIGBpc0Jvb2xlYW5gLCBgaXNEYXRlYCwgYGlzRWxlbWVudGAsXG4gICAqIGBpc0VtcHR5YCwgYGlzRXF1YWxgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc05hTmAsIGBpc051bGxgLCBgaXNOdW1iZXJgLFxuICAgKiBgaXNPYmplY3RgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBqb2luYCxcbiAgICogYGxhc3RJbmRleE9mYCwgYG1peGluYCwgYG5vQ29uZmxpY3RgLCBgcGFyc2VJbnRgLCBgcG9wYCwgYHJhbmRvbWAsIGByZWR1Y2VgLFxuICAgKiBgcmVkdWNlUmlnaHRgLCBgcmVzdWx0YCwgYHNoaWZ0YCwgYHNpemVgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBydW5JbkNvbnRleHRgLFxuICAgKiBgdGVtcGxhdGVgLCBgdW5lc2NhcGVgLCBgdW5pcXVlSWRgLCBhbmQgYHZhbHVlYFxuICAgKlxuICAgKiBUaGUgd3JhcHBlciBmdW5jdGlvbnMgYGZpcnN0YCBhbmQgYGxhc3RgIHJldHVybiB3cmFwcGVkIHZhbHVlcyB3aGVuIGBuYCBpc1xuICAgKiBwcm92aWRlZCwgb3RoZXJ3aXNlIHRoZXkgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMuXG4gICAqXG4gICAqIEV4cGxpY2l0IGNoYWluaW5nIGNhbiBiZSBlbmFibGVkIGJ5IHVzaW5nIHRoZSBgXy5jaGFpbmAgbWV0aG9kLlxuICAgKlxuICAgKiBAbmFtZSBfXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgKlxuICAgKiAvLyByZXR1cm5zIGFuIHVud3JhcHBlZCB2YWx1ZVxuICAgKiB3cmFwcGVkLnJlZHVjZShmdW5jdGlvbihzdW0sIG51bSkge1xuICAgKiAgIHJldHVybiBzdW0gKyBudW07XG4gICAqIH0pO1xuICAgKiAvLyA9PiA2XG4gICAqXG4gICAqIC8vIHJldHVybnMgYSB3cmFwcGVkIHZhbHVlXG4gICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoZnVuY3Rpb24obnVtKSB7XG4gICAqICAgcmV0dXJuIG51bSAqIG51bTtcbiAgICogfSk7XG4gICAqXG4gICAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICAgIC8vIGRvbid0IHdyYXAgaWYgYWxyZWFkeSB3cmFwcGVkLCBldmVuIGlmIHdyYXBwZWQgYnkgYSBkaWZmZXJlbnQgYGxvZGFzaGAgY29uc3RydWN0b3JcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpXG4gICAgID8gdmFsdWVcbiAgICAgOiBuZXcgbG9kYXNoV3JhcHBlcih2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQSBmYXN0IHBhdGggZm9yIGNyZWF0aW5nIGBsb2Rhc2hgIHdyYXBwZXIgb2JqZWN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNoYWluQWxsIEEgZmxhZyB0byBlbmFibGUgY2hhaW5pbmcgZm9yIGFsbCBtZXRob2RzXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIGxvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsKSB7XG4gICAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgfVxuICAvLyBlbnN1cmUgYG5ldyBsb2Rhc2hXcmFwcGVyYCBpcyBhbiBpbnN0YW5jZSBvZiBgbG9kYXNoYFxuICBsb2Rhc2hXcmFwcGVyLnByb3RvdHlwZSA9IGxvZGFzaC5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCB1c2VkIHRvIGZsYWcgZW52aXJvbm1lbnRzIGZlYXR1cmVzLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEB0eXBlIE9iamVjdFxuICAgKi9cbiAgdmFyIHN1cHBvcnQgPSBsb2Rhc2guc3VwcG9ydCA9IHt9O1xuXG4gIChmdW5jdGlvbigpIHtcbiAgICB2YXIgY3RvciA9IGZ1bmN0aW9uKCkgeyB0aGlzLnggPSAxOyB9LFxuICAgICAgICBvYmplY3QgPSB7ICcwJzogMSwgJ2xlbmd0aCc6IDEgfSxcbiAgICAgICAgcHJvcHMgPSBbXTtcblxuICAgIGN0b3IucHJvdG90eXBlID0geyAndmFsdWVPZic6IDEsICd5JzogMSB9O1xuICAgIGZvciAodmFyIGtleSBpbiBuZXcgY3RvcikgeyBwcm9wcy5wdXNoKGtleSk7IH1cbiAgICBmb3IgKGtleSBpbiBhcmd1bWVudHMpIHsgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGFuIGBhcmd1bWVudHNgIG9iamVjdCdzIFtbQ2xhc3NdXSBpcyByZXNvbHZhYmxlIChhbGwgYnV0IEZpcmVmb3ggPCA0LCBJRSA8IDkpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmFyZ3NDbGFzcyA9IHRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKSA9PSBhcmdzQ2xhc3M7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgYE9iamVjdGAgb2JqZWN0cyAoYWxsIGJ1dCBOYXJ3aGFsIGFuZCBPcGVyYSA8IDEwLjUpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmFyZ3NPYmplY3QgPSBhcmd1bWVudHMuY29uc3RydWN0b3IgPT0gT2JqZWN0ICYmICEoYXJndW1lbnRzIGluc3RhbmNlb2YgQXJyYXkpO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGBuYW1lYCBvciBgbWVzc2FnZWAgcHJvcGVydGllcyBvZiBgRXJyb3IucHJvdG90eXBlYCBhcmVcbiAgICAgKiBlbnVtZXJhYmxlIGJ5IGRlZmF1bHQuIChJRSA8IDksIFNhZmFyaSA8IDUuMSlcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgc3VwcG9ydC5lbnVtRXJyb3JQcm9wcyA9IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZXJyb3JQcm90bywgJ21lc3NhZ2UnKSB8fCBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGVycm9yUHJvdG8sICduYW1lJyk7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgYHByb3RvdHlwZWAgcHJvcGVydGllcyBhcmUgZW51bWVyYWJsZSBieSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogRmlyZWZveCA8IDMuNiwgT3BlcmEgPiA5LjUwIC0gT3BlcmEgPCAxMS42MCwgYW5kIFNhZmFyaSA8IDUuMVxuICAgICAqIChpZiB0aGUgcHJvdG90eXBlIG9yIGEgcHJvcGVydHkgb24gdGhlIHByb3RvdHlwZSBoYXMgYmVlbiBzZXQpXG4gICAgICogaW5jb3JyZWN0bHkgc2V0cyBhIGZ1bmN0aW9uJ3MgYHByb3RvdHlwZWAgcHJvcGVydHkgW1tFbnVtZXJhYmxlXV1cbiAgICAgKiB2YWx1ZSB0byBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgIHN1cHBvcnQuZW51bVByb3RvdHlwZXMgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGN0b3IsICdwcm90b3R5cGUnKTtcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiBmdW5jdGlvbnMgY2FuIGJlIGRlY29tcGlsZWQgYnkgYEZ1bmN0aW9uI3RvU3RyaW5nYFxuICAgICAqIChhbGwgYnV0IFBTMyBhbmQgb2xkZXIgT3BlcmEgbW9iaWxlIGJyb3dzZXJzICYgYXZvaWRlZCBpbiBXaW5kb3dzIDggYXBwcykuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgIHN1cHBvcnQuZnVuY0RlY29tcCA9ICFpc05hdGl2ZShyb290LldpblJURXJyb3IpICYmIHJlVGhpcy50ZXN0KGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgYEZ1bmN0aW9uI25hbWVgIGlzIHN1cHBvcnRlZCAoYWxsIGJ1dCBJRSkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgIHN1cHBvcnQuZnVuY05hbWVzID0gdHlwZW9mIEZ1bmN0aW9uLm5hbWUgPT0gJ3N0cmluZyc7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgYGFyZ3VtZW50c2Agb2JqZWN0IGluZGV4ZXMgYXJlIG5vbi1lbnVtZXJhYmxlXG4gICAgICogKEZpcmVmb3ggPCA0LCBJRSA8IDksIFBoYW50b21KUywgU2FmYXJpIDwgNS4xKS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgc3VwcG9ydC5ub25FbnVtQXJncyA9IGtleSAhPSAwO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIHByb3BlcnRpZXMgc2hhZG93aW5nIHRob3NlIG9uIGBPYmplY3QucHJvdG90eXBlYCBhcmUgbm9uLWVudW1lcmFibGUuXG4gICAgICpcbiAgICAgKiBJbiBJRSA8IDkgYW4gb2JqZWN0cyBvd24gcHJvcGVydGllcywgc2hhZG93aW5nIG5vbi1lbnVtZXJhYmxlIG9uZXMsIGFyZVxuICAgICAqIG1hZGUgbm9uLWVudW1lcmFibGUgYXMgd2VsbCAoYS5rLmEgdGhlIEpTY3JpcHQgW1tEb250RW51bV1dIGJ1ZykuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgIHN1cHBvcnQubm9uRW51bVNoYWRvd3MgPSAhL3ZhbHVlT2YvLnRlc3QocHJvcHMpO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGBBcnJheSNzaGlmdGAgYW5kIGBBcnJheSNzcGxpY2VgIGF1Z21lbnQgYXJyYXktbGlrZSBvYmplY3RzIGNvcnJlY3RseS5cbiAgICAgKlxuICAgICAqIEZpcmVmb3ggPCAxMCwgSUUgY29tcGF0aWJpbGl0eSBtb2RlLCBhbmQgSUUgPCA5IGhhdmUgYnVnZ3kgQXJyYXkgYHNoaWZ0KClgXG4gICAgICogYW5kIGBzcGxpY2UoKWAgZnVuY3Rpb25zIHRoYXQgZmFpbCB0byByZW1vdmUgdGhlIGxhc3QgZWxlbWVudCwgYHZhbHVlWzBdYCxcbiAgICAgKiBvZiBhcnJheS1saWtlIG9iamVjdHMgZXZlbiB0aG91Z2ggdGhlIGBsZW5ndGhgIHByb3BlcnR5IGlzIHNldCB0byBgMGAuXG4gICAgICogVGhlIGBzaGlmdCgpYCBtZXRob2QgaXMgYnVnZ3kgaW4gSUUgOCBjb21wYXRpYmlsaXR5IG1vZGUsIHdoaWxlIGBzcGxpY2UoKWBcbiAgICAgKiBpcyBidWdneSByZWdhcmRsZXNzIG9mIG1vZGUgaW4gSUUgPCA5IGFuZCBidWdneSBpbiBjb21wYXRpYmlsaXR5IG1vZGUgaW4gSUUgOS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgc3VwcG9ydC5zcGxpY2VPYmplY3RzID0gKGFycmF5UmVmLnNwbGljZS5jYWxsKG9iamVjdCwgMCwgMSksICFvYmplY3RbMF0pO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGxhY2sgb2Ygc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxuICAgICAqXG4gICAgICogSUUgPCA4IGNhbid0IGFjY2VzcyBjaGFyYWN0ZXJzIGJ5IGluZGV4IGFuZCBJRSA4IGNhbiBvbmx5IGFjY2Vzc1xuICAgICAqIGNoYXJhY3RlcnMgYnkgaW5kZXggb24gc3RyaW5nIGxpdGVyYWxzLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LnVuaW5kZXhlZENoYXJzID0gKCd4J1swXSArIE9iamVjdCgneCcpWzBdKSAhPSAneHgnO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGEgRE9NIG5vZGUncyBbW0NsYXNzXV0gaXMgcmVzb2x2YWJsZSAoYWxsIGJ1dCBJRSA8IDkpXG4gICAgICogYW5kIHRoYXQgdGhlIEpTIGVuZ2luZSBlcnJvcnMgd2hlbiBhdHRlbXB0aW5nIHRvIGNvZXJjZSBhbiBvYmplY3QgdG9cbiAgICAgKiBhIHN0cmluZyB3aXRob3V0IGEgYHRvU3RyaW5nYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgdHJ5IHtcbiAgICAgIHN1cHBvcnQubm9kZUNsYXNzID0gISh0b1N0cmluZy5jYWxsKGRvY3VtZW50KSA9PSBvYmplY3RDbGFzcyAmJiAhKHsgJ3RvU3RyaW5nJzogMCB9ICsgJycpKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHN1cHBvcnQubm9kZUNsYXNzID0gdHJ1ZTtcbiAgICB9XG4gIH0oMSkpO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBUaGUgdGVtcGxhdGUgdXNlZCB0byBjcmVhdGUgaXRlcmF0b3IgZnVuY3Rpb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSBvYmplY3QgdXNlZCB0byBwb3B1bGF0ZSB0aGUgdGV4dC5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgaW50ZXJwb2xhdGVkIHRleHQuXG4gICAqL1xuICB2YXIgaXRlcmF0b3JUZW1wbGF0ZSA9IGZ1bmN0aW9uKG9iaikge1xuXG4gICAgdmFyIF9fcCA9ICd2YXIgaW5kZXgsIGl0ZXJhYmxlID0gJyArXG4gICAgKG9iai5maXJzdEFyZykgK1xuICAgICcsIHJlc3VsdCA9ICcgK1xuICAgIChvYmouaW5pdCkgK1xuICAgICc7XFxuaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcXG4nICtcbiAgICAob2JqLnRvcCkgK1xuICAgICc7JztcbiAgICAgaWYgKG9iai5hcnJheSkge1xuICAgIF9fcCArPSAnXFxudmFyIGxlbmd0aCA9IGl0ZXJhYmxlLmxlbmd0aDsgaW5kZXggPSAtMTtcXG5pZiAoJyArXG4gICAgKG9iai5hcnJheSkgK1xuICAgICcpIHsgICc7XG4gICAgIGlmIChzdXBwb3J0LnVuaW5kZXhlZENoYXJzKSB7XG4gICAgX19wICs9ICdcXG4gIGlmIChpc1N0cmluZyhpdGVyYWJsZSkpIHtcXG4gICAgaXRlcmFibGUgPSBpdGVyYWJsZS5zcGxpdChcXCdcXCcpXFxuICB9ICAnO1xuICAgICB9XG4gICAgX19wICs9ICdcXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgICcgK1xuICAgIChvYmoubG9vcCkgK1xuICAgICc7XFxuICB9XFxufVxcbmVsc2UgeyAgJztcbiAgICAgfSBlbHNlIGlmIChzdXBwb3J0Lm5vbkVudW1BcmdzKSB7XG4gICAgX19wICs9ICdcXG4gIHZhciBsZW5ndGggPSBpdGVyYWJsZS5sZW5ndGg7IGluZGV4ID0gLTE7XFxuICBpZiAobGVuZ3RoICYmIGlzQXJndW1lbnRzKGl0ZXJhYmxlKSkge1xcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbiAgICAgIGluZGV4ICs9IFxcJ1xcJztcXG4gICAgICAnICtcbiAgICAob2JqLmxvb3ApICtcbiAgICAnO1xcbiAgICB9XFxuICB9IGVsc2UgeyAgJztcbiAgICAgfVxuXG4gICAgIGlmIChzdXBwb3J0LmVudW1Qcm90b3R5cGVzKSB7XG4gICAgX19wICs9ICdcXG4gIHZhciBza2lwUHJvdG8gPSB0eXBlb2YgaXRlcmFibGUgPT0gXFwnZnVuY3Rpb25cXCc7XFxuICAnO1xuICAgICB9XG5cbiAgICAgaWYgKHN1cHBvcnQuZW51bUVycm9yUHJvcHMpIHtcbiAgICBfX3AgKz0gJ1xcbiAgdmFyIHNraXBFcnJvclByb3BzID0gaXRlcmFibGUgPT09IGVycm9yUHJvdG8gfHwgaXRlcmFibGUgaW5zdGFuY2VvZiBFcnJvcjtcXG4gICc7XG4gICAgIH1cblxuICAgICAgICB2YXIgY29uZGl0aW9ucyA9IFtdOyAgICBpZiAoc3VwcG9ydC5lbnVtUHJvdG90eXBlcykgeyBjb25kaXRpb25zLnB1c2goJyEoc2tpcFByb3RvICYmIGluZGV4ID09IFwicHJvdG90eXBlXCIpJyk7IH0gICAgaWYgKHN1cHBvcnQuZW51bUVycm9yUHJvcHMpICB7IGNvbmRpdGlvbnMucHVzaCgnIShza2lwRXJyb3JQcm9wcyAmJiAoaW5kZXggPT0gXCJtZXNzYWdlXCIgfHwgaW5kZXggPT0gXCJuYW1lXCIpKScpOyB9XG5cbiAgICAgaWYgKG9iai51c2VIYXMgJiYgb2JqLmtleXMpIHtcbiAgICBfX3AgKz0gJ1xcbiAgdmFyIG93bkluZGV4ID0gLTEsXFxuICAgICAgb3duUHJvcHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdICYmIGtleXMoaXRlcmFibGUpLFxcbiAgICAgIGxlbmd0aCA9IG93blByb3BzID8gb3duUHJvcHMubGVuZ3RoIDogMDtcXG5cXG4gIHdoaWxlICgrK293bkluZGV4IDwgbGVuZ3RoKSB7XFxuICAgIGluZGV4ID0gb3duUHJvcHNbb3duSW5kZXhdO1xcbic7XG4gICAgICAgIGlmIChjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIF9fcCArPSAnICAgIGlmICgnICtcbiAgICAoY29uZGl0aW9ucy5qb2luKCcgJiYgJykpICtcbiAgICAnKSB7XFxuICAnO1xuICAgICB9XG4gICAgX19wICs9XG4gICAgKG9iai5sb29wKSArXG4gICAgJzsgICAgJztcbiAgICAgaWYgKGNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgX19wICs9ICdcXG4gICAgfSc7XG4gICAgIH1cbiAgICBfX3AgKz0gJ1xcbiAgfSAgJztcbiAgICAgfSBlbHNlIHtcbiAgICBfX3AgKz0gJ1xcbiAgZm9yIChpbmRleCBpbiBpdGVyYWJsZSkge1xcbic7XG4gICAgICAgIGlmIChvYmoudXNlSGFzKSB7IGNvbmRpdGlvbnMucHVzaChcImhhc093blByb3BlcnR5LmNhbGwoaXRlcmFibGUsIGluZGV4KVwiKTsgfSAgICBpZiAoY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICBfX3AgKz0gJyAgICBpZiAoJyArXG4gICAgKGNvbmRpdGlvbnMuam9pbignICYmICcpKSArXG4gICAgJykge1xcbiAgJztcbiAgICAgfVxuICAgIF9fcCArPVxuICAgIChvYmoubG9vcCkgK1xuICAgICc7ICAgICc7XG4gICAgIGlmIChjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIF9fcCArPSAnXFxuICAgIH0nO1xuICAgICB9XG4gICAgX19wICs9ICdcXG4gIH0gICAgJztcbiAgICAgaWYgKHN1cHBvcnQubm9uRW51bVNoYWRvd3MpIHtcbiAgICBfX3AgKz0gJ1xcblxcbiAgaWYgKGl0ZXJhYmxlICE9PSBvYmplY3RQcm90bykge1xcbiAgICB2YXIgY3RvciA9IGl0ZXJhYmxlLmNvbnN0cnVjdG9yLFxcbiAgICAgICAgaXNQcm90byA9IGl0ZXJhYmxlID09PSAoY3RvciAmJiBjdG9yLnByb3RvdHlwZSksXFxuICAgICAgICBjbGFzc05hbWUgPSBpdGVyYWJsZSA9PT0gc3RyaW5nUHJvdG8gPyBzdHJpbmdDbGFzcyA6IGl0ZXJhYmxlID09PSBlcnJvclByb3RvID8gZXJyb3JDbGFzcyA6IHRvU3RyaW5nLmNhbGwoaXRlcmFibGUpLFxcbiAgICAgICAgbm9uRW51bSA9IG5vbkVudW1Qcm9wc1tjbGFzc05hbWVdO1xcbiAgICAgICc7XG4gICAgIGZvciAoayA9IDA7IGsgPCA3OyBrKyspIHtcbiAgICBfX3AgKz0gJ1xcbiAgICBpbmRleCA9IFxcJycgK1xuICAgIChvYmouc2hhZG93ZWRQcm9wc1trXSkgK1xuICAgICdcXCc7XFxuICAgIGlmICgoIShpc1Byb3RvICYmIG5vbkVudW1baW5kZXhdKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0ZXJhYmxlLCBpbmRleCkpJztcbiAgICAgICAgICAgIGlmICghb2JqLnVzZUhhcykge1xuICAgIF9fcCArPSAnIHx8ICghbm9uRW51bVtpbmRleF0gJiYgaXRlcmFibGVbaW5kZXhdICE9PSBvYmplY3RQcm90b1tpbmRleF0pJztcbiAgICAgfVxuICAgIF9fcCArPSAnKSB7XFxuICAgICAgJyArXG4gICAgKG9iai5sb29wKSArXG4gICAgJztcXG4gICAgfSAgICAgICc7XG4gICAgIH1cbiAgICBfX3AgKz0gJ1xcbiAgfSAgICAnO1xuICAgICB9XG5cbiAgICAgfVxuXG4gICAgIGlmIChvYmouYXJyYXkgfHwgc3VwcG9ydC5ub25FbnVtQXJncykge1xuICAgIF9fcCArPSAnXFxufSc7XG4gICAgIH1cbiAgICBfX3AgKz1cbiAgICAob2JqLmJvdHRvbSkgK1xuICAgICc7XFxucmV0dXJuIHJlc3VsdCc7XG5cbiAgICByZXR1cm4gX19wXG4gIH07XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmJpbmRgIHRoYXQgY3JlYXRlcyB0aGUgYm91bmQgZnVuY3Rpb24gYW5kXG4gICAqIHNldHMgaXRzIG1ldGEgZGF0YS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYmluZERhdGEgVGhlIGJpbmQgZGF0YSBhcnJheS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlQmluZChiaW5kRGF0YSkge1xuICAgIHZhciBmdW5jID0gYmluZERhdGFbMF0sXG4gICAgICAgIHBhcnRpYWxBcmdzID0gYmluZERhdGFbMl0sXG4gICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XTtcblxuICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgLy8gYEZ1bmN0aW9uI2JpbmRgIHNwZWNcbiAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMy40LjVcbiAgICAgIGlmIChwYXJ0aWFsQXJncykge1xuICAgICAgICAvLyBhdm9pZCBgYXJndW1lbnRzYCBvYmplY3QgZGVvcHRpbWl6YXRpb25zIGJ5IHVzaW5nIGBzbGljZWAgaW5zdGVhZFxuICAgICAgICAvLyBvZiBgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGxgIGFuZCBub3QgYXNzaWduaW5nIGBhcmd1bWVudHNgIHRvIGFcbiAgICAgICAgLy8gdmFyaWFibGUgYXMgYSB0ZXJuYXJ5IGV4cHJlc3Npb25cbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShwYXJ0aWFsQXJncyk7XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIC8vIG1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yXG4gICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMlxuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAvLyBlbnN1cmUgYG5ldyBib3VuZGAgaXMgYW4gaW5zdGFuY2Ugb2YgYGZ1bmNgXG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoZnVuYy5wcm90b3R5cGUpLFxuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyB8fCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyB8fCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBzZXRCaW5kRGF0YShib3VuZCwgYmluZERhdGEpO1xuICAgIHJldHVybiBib3VuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgd2l0aG91dCBhcmd1bWVudCBqdWdnbGluZyBvciBzdXBwb3J0XG4gICAqIGZvciBgdGhpc0FyZ2AgYmluZGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcD1mYWxzZV0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2Ugb2JqZWN0cy5cbiAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyBjbG9uZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQikge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrKHZhbHVlKTtcbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGluc3BlY3QgW1tDbGFzc11dXG4gICAgdmFyIGlzT2JqID0gaXNPYmplY3QodmFsdWUpO1xuICAgIGlmIChpc09iaikge1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgaWYgKCFjbG9uZWFibGVDbGFzc2VzW2NsYXNzTmFtZV0gfHwgKCFzdXBwb3J0Lm5vZGVDbGFzcyAmJiBpc05vZGUodmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgY3RvciA9IGN0b3JCeUNsYXNzW2NsYXNzTmFtZV07XG4gICAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgICAgY2FzZSBkYXRlQ2xhc3M6XG4gICAgICAgICAgcmV0dXJuIG5ldyBjdG9yKCt2YWx1ZSk7XG5cbiAgICAgICAgY2FzZSBudW1iZXJDbGFzczpcbiAgICAgICAgY2FzZSBzdHJpbmdDbGFzczpcbiAgICAgICAgICByZXR1cm4gbmV3IGN0b3IodmFsdWUpO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwQ2xhc3M6XG4gICAgICAgICAgcmVzdWx0ID0gY3Rvcih2YWx1ZS5zb3VyY2UsIHJlRmxhZ3MuZXhlYyh2YWx1ZSkpO1xuICAgICAgICAgIHJlc3VsdC5sYXN0SW5kZXggPSB2YWx1ZS5sYXN0SW5kZXg7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAvLyBjaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGNvcnJlc3BvbmRpbmcgY2xvbmVcbiAgICAgIHZhciBpbml0ZWRTdGFjayA9ICFzdGFja0E7XG4gICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IGdldEFycmF5KCkpO1xuICAgICAgc3RhY2tCIHx8IChzdGFja0IgPSBnZXRBcnJheSgpKTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpc0FyciA/IGN0b3IodmFsdWUubGVuZ3RoKSA6IHt9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGlzQXJyID8gc2xpY2UodmFsdWUpIDogYXNzaWduKHt9LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIGFkZCBhcnJheSBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2BcbiAgICBpZiAoaXNBcnIpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaW5kZXgnKSkge1xuICAgICAgICByZXN1bHQuaW5kZXggPSB2YWx1ZS5pbmRleDtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaW5wdXQnKSkge1xuICAgICAgICByZXN1bHQuaW5wdXQgPSB2YWx1ZS5pbnB1dDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZXhpdCBmb3Igc2hhbGxvdyBjbG9uZVxuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBhZGQgdGhlIHNvdXJjZSB2YWx1ZSB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAvLyBhbmQgYXNzb2NpYXRlIGl0IHdpdGggaXRzIGNsb25lXG4gICAgc3RhY2tBLnB1c2godmFsdWUpO1xuICAgIHN0YWNrQi5wdXNoKHJlc3VsdCk7XG5cbiAgICAvLyByZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgKGlzQXJyID8gYmFzZUVhY2ggOiBmb3JPd24pKHZhbHVlLCBmdW5jdGlvbihvYmpWYWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRba2V5XSA9IGJhc2VDbG9uZShvYmpWYWx1ZSwgaXNEZWVwLCBjYWxsYmFjaywgc3RhY2tBLCBzdGFja0IpO1xuICAgIH0pO1xuXG4gICAgaWYgKGluaXRlZFN0YWNrKSB7XG4gICAgICByZWxlYXNlQXJyYXkoc3RhY2tBKTtcbiAgICAgIHJlbGVhc2VBcnJheShzdGFja0IpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlQ3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgIHJldHVybiBpc09iamVjdChwcm90b3R5cGUpID8gbmF0aXZlQ3JlYXRlKHByb3RvdHlwZSkgOiB7fTtcbiAgfVxuICAvLyBmYWxsYmFjayBmb3IgYnJvd3NlcnMgd2l0aG91dCBgT2JqZWN0LmNyZWF0ZWBcbiAgaWYgKCFuYXRpdmVDcmVhdGUpIHtcbiAgICBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gT2JqZWN0KCkge31cbiAgICAgIHJldHVybiBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHByb3RvdHlwZSkpIHtcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgT2JqZWN0O1xuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgfHwgcm9vdC5PYmplY3QoKTtcbiAgICAgIH07XG4gICAgfSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVDYWxsYmFja2Agd2l0aG91dCBzdXBwb3J0IGZvciBjcmVhdGluZ1xuICAgKiBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gW2Z1bmM9aWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdGhlIGNhbGxiYWNrIGFjY2VwdHMuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUNyZWF0ZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICB9XG4gICAgLy8gZXhpdCBlYXJseSBmb3Igbm8gYHRoaXNBcmdgIG9yIGFscmVhZHkgYm91bmQgYnkgYEZ1bmN0aW9uI2JpbmRgXG4gICAgaWYgKHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnIHx8ICEoJ3Byb3RvdHlwZScgaW4gZnVuYykpIHtcbiAgICAgIHJldHVybiBmdW5jO1xuICAgIH1cbiAgICB2YXIgYmluZERhdGEgPSBmdW5jLl9fYmluZERhdGFfXztcbiAgICBpZiAodHlwZW9mIGJpbmREYXRhID09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoc3VwcG9ydC5mdW5jTmFtZXMpIHtcbiAgICAgICAgYmluZERhdGEgPSAhZnVuYy5uYW1lO1xuICAgICAgfVxuICAgICAgYmluZERhdGEgPSBiaW5kRGF0YSB8fCAhc3VwcG9ydC5mdW5jRGVjb21wO1xuICAgICAgaWYgKCFiaW5kRGF0YSkge1xuICAgICAgICB2YXIgc291cmNlID0gZm5Ub1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgICAgICBpZiAoIXN1cHBvcnQuZnVuY05hbWVzKSB7XG4gICAgICAgICAgYmluZERhdGEgPSAhcmVGdW5jTmFtZS50ZXN0KHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFiaW5kRGF0YSkge1xuICAgICAgICAgIC8vIGNoZWNrcyBpZiBgZnVuY2AgcmVmZXJlbmNlcyB0aGUgYHRoaXNgIGtleXdvcmQgYW5kIHN0b3JlcyB0aGUgcmVzdWx0XG4gICAgICAgICAgYmluZERhdGEgPSByZVRoaXMudGVzdChzb3VyY2UpO1xuICAgICAgICAgIHNldEJpbmREYXRhKGZ1bmMsIGJpbmREYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBleGl0IGVhcmx5IGlmIHRoZXJlIGFyZSBubyBgdGhpc2AgcmVmZXJlbmNlcyBvciBgZnVuY2AgaXMgYm91bmRcbiAgICBpZiAoYmluZERhdGEgPT09IGZhbHNlIHx8IChiaW5kRGF0YSAhPT0gdHJ1ZSAmJiBiaW5kRGF0YVsxXSAmIDEpKSB7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9XG4gICAgc3dpdGNoIChhcmdDb3VudCkge1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGEsIGIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGJpbmQoZnVuYywgdGhpc0FyZyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGNyZWF0ZVdyYXBwZXJgIHRoYXQgY3JlYXRlcyB0aGUgd3JhcHBlciBhbmRcbiAgICogc2V0cyBpdHMgbWV0YSBkYXRhLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBiaW5kRGF0YSBUaGUgYmluZCBkYXRhIGFycmF5LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VDcmVhdGVXcmFwcGVyKGJpbmREYXRhKSB7XG4gICAgdmFyIGZ1bmMgPSBiaW5kRGF0YVswXSxcbiAgICAgICAgYml0bWFzayA9IGJpbmREYXRhWzFdLFxuICAgICAgICBwYXJ0aWFsQXJncyA9IGJpbmREYXRhWzJdLFxuICAgICAgICBwYXJ0aWFsUmlnaHRBcmdzID0gYmluZERhdGFbM10sXG4gICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XSxcbiAgICAgICAgYXJpdHkgPSBiaW5kRGF0YVs1XTtcblxuICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgMSxcbiAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIDIsXG4gICAgICAgIGlzQ3VycnkgPSBiaXRtYXNrICYgNCxcbiAgICAgICAgaXNDdXJyeUJvdW5kID0gYml0bWFzayAmIDgsXG4gICAgICAgIGtleSA9IGZ1bmM7XG5cbiAgICBmdW5jdGlvbiBib3VuZCgpIHtcbiAgICAgIHZhciB0aGlzQmluZGluZyA9IGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzO1xuICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgIHZhciBhcmdzID0gc2xpY2UocGFydGlhbEFyZ3MpO1xuICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBpZiAocGFydGlhbFJpZ2h0QXJncyB8fCBpc0N1cnJ5KSB7XG4gICAgICAgIGFyZ3MgfHwgKGFyZ3MgPSBzbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgaWYgKHBhcnRpYWxSaWdodEFyZ3MpIHtcbiAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIHBhcnRpYWxSaWdodEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0N1cnJ5ICYmIGFyZ3MubGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICBiaXRtYXNrIHw9IDE2ICYgfjMyO1xuICAgICAgICAgIHJldHVybiBiYXNlQ3JlYXRlV3JhcHBlcihbZnVuYywgKGlzQ3VycnlCb3VuZCA/IGJpdG1hc2sgOiBiaXRtYXNrICYgfjMpLCBhcmdzLCBudWxsLCB0aGlzQXJnLCBhcml0eV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcmdzIHx8IChhcmdzID0gYXJndW1lbnRzKTtcbiAgICAgIGlmIChpc0JpbmRLZXkpIHtcbiAgICAgICAgZnVuYyA9IHRoaXNCaW5kaW5nW2tleV07XG4gICAgICB9XG4gICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShmdW5jLnByb3RvdHlwZSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICB9XG4gICAgc2V0QmluZERhdGEoYm91bmQsIGJpbmREYXRhKTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGlmZmVyZW5jZWAgdGhhdCBhY2NlcHRzIGEgc2luZ2xlIGFycmF5XG4gICAqIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIGFycmF5IG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgIGlzTGFyZ2UgPSBsZW5ndGggPj0gbGFyZ2VBcnJheVNpemUgJiYgaW5kZXhPZiA9PT0gYmFzZUluZGV4T2YsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgIHZhciBjYWNoZSA9IGNyZWF0ZUNhY2hlKHZhbHVlcyk7XG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgaW5kZXhPZiA9IGNhY2hlSW5kZXhPZjtcbiAgICAgICAgdmFsdWVzID0gY2FjaGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0xhcmdlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAoaW5kZXhPZih2YWx1ZXMsIHZhbHVlKSA8IDApIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgcmVsZWFzZU9iamVjdCh2YWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICogc2hvcnRoYW5kcyBvciBgdGhpc0FyZ2AgYmluZGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2hhbGxvdz1mYWxzZV0gQSBmbGFnIHRvIHJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYSBzaW5nbGUgbGV2ZWwuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0PWZhbHNlXSBBIGZsYWcgdG8gcmVzdHJpY3QgZmxhdHRlbmluZyB0byBhcnJheXMgYW5kIGBhcmd1bWVudHNgIG9iamVjdHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzdGFydCBmcm9tLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGlzU2hhbGxvdywgaXNTdHJpY3QsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IChmcm9tSW5kZXggfHwgMCkgLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09ICdudW1iZXInXG4gICAgICAgICAgJiYgKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKVxuICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgIHZhbHVlID0gYmFzZUZsYXR0ZW4odmFsdWUsIGlzU2hhbGxvdywgaXNTdHJpY3QpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxJbmRleCA9IC0xLFxuICAgICAgICAgICAgdmFsTGVuZ3RoID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgcmVzSW5kZXggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICAgIHJlc3VsdC5sZW5ndGggKz0gdmFsTGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKyt2YWxJbmRleCA8IHZhbExlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlW3ZhbEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgLCB3aXRob3V0IHN1cHBvcnQgZm9yIGB0aGlzQXJnYCBiaW5kaW5nLFxuICAgKiB0aGF0IGFsbG93cyBwYXJ0aWFsIFwiXy53aGVyZVwiIHN0eWxlIGNvbXBhcmlzb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IGEgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7Kn0gYiBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpc1doZXJlPWZhbHNlXSBBIGZsYWcgdG8gaW5kaWNhdGUgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBhYCBvYmplY3RzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBiYCBvYmplY3RzLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUlzRXF1YWwoYSwgYiwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgLy8gdXNlZCB0byBpbmRpY2F0ZSB0aGF0IHdoZW4gY29tcGFyaW5nIG9iamVjdHMsIGBhYCBoYXMgYXQgbGVhc3QgdGhlIHByb3BlcnRpZXMgb2YgYGJgXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soYSwgYik7XG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGV4aXQgZWFybHkgZm9yIGlkZW50aWNhbCB2YWx1ZXNcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgLy8gdHJlYXQgYCswYCB2cy4gYC0wYCBhcyBub3QgZXF1YWxcbiAgICAgIHJldHVybiBhICE9PSAwIHx8ICgxIC8gYSA9PSAxIC8gYik7XG4gICAgfVxuICAgIHZhciB0eXBlID0gdHlwZW9mIGEsXG4gICAgICAgIG90aGVyVHlwZSA9IHR5cGVvZiBiO1xuXG4gICAgLy8gZXhpdCBlYXJseSBmb3IgdW5saWtlIHByaW1pdGl2ZSB2YWx1ZXNcbiAgICBpZiAoYSA9PT0gYSAmJlxuICAgICAgICAhKGEgJiYgb2JqZWN0VHlwZXNbdHlwZV0pICYmXG4gICAgICAgICEoYiAmJiBvYmplY3RUeXBlc1tvdGhlclR5cGVdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBleGl0IGVhcmx5IGZvciBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGF2b2lkaW5nIEVTMydzIEZ1bmN0aW9uI2NhbGwgYmVoYXZpb3JcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjMuNC40XG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICAgIHJldHVybiBhID09PSBiO1xuICAgIH1cbiAgICAvLyBjb21wYXJlIFtbQ2xhc3NdXSBuYW1lc1xuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpLFxuICAgICAgICBvdGhlckNsYXNzID0gdG9TdHJpbmcuY2FsbChiKTtcblxuICAgIGlmIChjbGFzc05hbWUgPT0gYXJnc0NsYXNzKSB7XG4gICAgICBjbGFzc05hbWUgPSBvYmplY3RDbGFzcztcbiAgICB9XG4gICAgaWYgKG90aGVyQ2xhc3MgPT0gYXJnc0NsYXNzKSB7XG4gICAgICBvdGhlckNsYXNzID0gb2JqZWN0Q2xhc3M7XG4gICAgfVxuICAgIGlmIChjbGFzc05hbWUgIT0gb3RoZXJDbGFzcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgY2FzZSBib29sQ2xhc3M6XG4gICAgICBjYXNlIGRhdGVDbGFzczpcbiAgICAgICAgLy8gY29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1iZXJzLCBkYXRlcyB0byBtaWxsaXNlY29uZHMgYW5kIGJvb2xlYW5zXG4gICAgICAgIC8vIHRvIGAxYCBvciBgMGAgdHJlYXRpbmcgaW52YWxpZCBkYXRlcyBjb2VyY2VkIHRvIGBOYU5gIGFzIG5vdCBlcXVhbFxuICAgICAgICByZXR1cm4gK2EgPT0gK2I7XG5cbiAgICAgIGNhc2UgbnVtYmVyQ2xhc3M6XG4gICAgICAgIC8vIHRyZWF0IGBOYU5gIHZzLiBgTmFOYCBhcyBlcXVhbFxuICAgICAgICByZXR1cm4gKGEgIT0gK2EpXG4gICAgICAgICAgPyBiICE9ICtiXG4gICAgICAgICAgLy8gYnV0IHRyZWF0IGArMGAgdnMuIGAtMGAgYXMgbm90IGVxdWFsXG4gICAgICAgICAgOiAoYSA9PSAwID8gKDEgLyBhID09IDEgLyBiKSA6IGEgPT0gK2IpO1xuXG4gICAgICBjYXNlIHJlZ2V4cENsYXNzOlxuICAgICAgY2FzZSBzdHJpbmdDbGFzczpcbiAgICAgICAgLy8gY29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyAoaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4xMC42LjQpXG4gICAgICAgIC8vIHRyZWF0IHN0cmluZyBwcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCBpbnN0YW5jZXMgYXMgZXF1YWxcbiAgICAgICAgcmV0dXJuIGEgPT0gU3RyaW5nKGIpO1xuICAgIH1cbiAgICB2YXIgaXNBcnIgPSBjbGFzc05hbWUgPT0gYXJyYXlDbGFzcztcbiAgICBpZiAoIWlzQXJyKSB7XG4gICAgICAvLyB1bndyYXAgYW55IGBsb2Rhc2hgIHdyYXBwZWQgdmFsdWVzXG4gICAgICB2YXIgYVdyYXBwZWQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgIGJXcmFwcGVkID0gaGFzT3duUHJvcGVydHkuY2FsbChiLCAnX193cmFwcGVkX18nKTtcblxuICAgICAgaWYgKGFXcmFwcGVkIHx8IGJXcmFwcGVkKSB7XG4gICAgICAgIHJldHVybiBiYXNlSXNFcXVhbChhV3JhcHBlZCA/IGEuX193cmFwcGVkX18gOiBhLCBiV3JhcHBlZCA/IGIuX193cmFwcGVkX18gOiBiLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgfVxuICAgICAgLy8gZXhpdCBmb3IgZnVuY3Rpb25zIGFuZCBET00gbm9kZXNcbiAgICAgIGlmIChjbGFzc05hbWUgIT0gb2JqZWN0Q2xhc3MgfHwgKCFzdXBwb3J0Lm5vZGVDbGFzcyAmJiAoaXNOb2RlKGEpIHx8IGlzTm9kZShiKSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIE9wZXJhLCBgYXJndW1lbnRzYCBvYmplY3RzIGhhdmUgYEFycmF5YCBjb25zdHJ1Y3RvcnNcbiAgICAgIHZhciBjdG9yQSA9ICFzdXBwb3J0LmFyZ3NPYmplY3QgJiYgaXNBcmd1bWVudHMoYSkgPyBPYmplY3QgOiBhLmNvbnN0cnVjdG9yLFxuICAgICAgICAgIGN0b3JCID0gIXN1cHBvcnQuYXJnc09iamVjdCAmJiBpc0FyZ3VtZW50cyhiKSA/IE9iamVjdCA6IGIuY29uc3RydWN0b3I7XG5cbiAgICAgIC8vIG5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsXG4gICAgICBpZiAoY3RvckEgIT0gY3RvckIgJiZcbiAgICAgICAgICAgICEoaXNGdW5jdGlvbihjdG9yQSkgJiYgY3RvckEgaW5zdGFuY2VvZiBjdG9yQSAmJiBpc0Z1bmN0aW9uKGN0b3JCKSAmJiBjdG9yQiBpbnN0YW5jZW9mIGN0b3JCKSAmJlxuICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpXG4gICAgICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gYXNzdW1lIGN5Y2xpYyBzdHJ1Y3R1cmVzIGFyZSBlcXVhbFxuICAgIC8vIHRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWMgc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xXG4gICAgLy8gc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYCAoaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4xMi4zKVxuICAgIHZhciBpbml0ZWRTdGFjayA9ICFzdGFja0E7XG4gICAgc3RhY2tBIHx8IChzdGFja0EgPSBnZXRBcnJheSgpKTtcbiAgICBzdGFja0IgfHwgKHN0YWNrQiA9IGdldEFycmF5KCkpO1xuXG4gICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gYSkge1xuICAgICAgICByZXR1cm4gc3RhY2tCW2xlbmd0aF0gPT0gYjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHNpemUgPSAwO1xuICAgIHJlc3VsdCA9IHRydWU7XG5cbiAgICAvLyBhZGQgYGFgIGFuZCBgYmAgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzXG4gICAgc3RhY2tBLnB1c2goYSk7XG4gICAgc3RhY2tCLnB1c2goYik7XG5cbiAgICAvLyByZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgaWYgKGlzQXJyKSB7XG4gICAgICAvLyBjb21wYXJlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeVxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBzaXplID0gYi5sZW5ndGg7XG4gICAgICByZXN1bHQgPSBzaXplID09IGxlbmd0aDtcblxuICAgICAgaWYgKHJlc3VsdCB8fCBpc1doZXJlKSB7XG4gICAgICAgIC8vIGRlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXNcbiAgICAgICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICAgIHZhciBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgICAgdmFsdWUgPSBiW3NpemVdO1xuXG4gICAgICAgICAgaWYgKGlzV2hlcmUpIHtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgICAgIGlmICgocmVzdWx0ID0gYmFzZUlzRXF1YWwoYVtpbmRleF0sIHZhbHVlLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICghKHJlc3VsdCA9IGJhc2VJc0VxdWFsKGFbc2l6ZV0sIHZhbHVlLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gZGVlcCBjb21wYXJlIG9iamVjdHMgdXNpbmcgYGZvckluYCwgaW5zdGVhZCBvZiBgZm9yT3duYCwgdG8gYXZvaWQgYE9iamVjdC5rZXlzYFxuICAgICAgLy8gd2hpY2gsIGluIHRoaXMgY2FzZSwgaXMgbW9yZSBjb3N0bHlcbiAgICAgIGZvckluKGIsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGIpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYiwga2V5KSkge1xuICAgICAgICAgIC8vIGNvdW50IHRoZSBudW1iZXIgb2YgcHJvcGVydGllcy5cbiAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgLy8gZGVlcCBjb21wYXJlIGVhY2ggcHJvcGVydHkgdmFsdWUuXG4gICAgICAgICAgcmV0dXJuIChyZXN1bHQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGtleSkgJiYgYmFzZUlzRXF1YWwoYVtrZXldLCB2YWx1ZSwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVzdWx0ICYmICFpc1doZXJlKSB7XG4gICAgICAgIC8vIGVuc3VyZSBib3RoIG9iamVjdHMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllc1xuICAgICAgICBmb3JJbihhLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBhKSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYSwga2V5KSkge1xuICAgICAgICAgICAgLy8gYHNpemVgIHdpbGwgYmUgYC0xYCBpZiBgYWAgaGFzIG1vcmUgcHJvcGVydGllcyB0aGFuIGBiYFxuICAgICAgICAgICAgcmV0dXJuIChyZXN1bHQgPSAtLXNpemUgPiAtMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhY2tBLnBvcCgpO1xuICAgIHN0YWNrQi5wb3AoKTtcblxuICAgIGlmIChpbml0ZWRTdGFjaykge1xuICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQSk7XG4gICAgICByZWxlYXNlQXJyYXkoc3RhY2tCKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgYXJndW1lbnQganVnZ2xpbmcgb3Igc3VwcG9ydFxuICAgKiBmb3IgcmV0dXJuaW5nIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYSByYW5kb20gbnVtYmVyLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVJhbmRvbShtaW4sIG1heCkge1xuICAgIHJldHVybiBtaW4gKyBmbG9vcihuYXRpdmVSYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAqIG9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaXNTb3J0ZWQ9ZmFsc2VdIEEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IGBhcnJheWAgaXMgc29ydGVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXNTb3J0ZWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB2YXIgaXNMYXJnZSA9ICFpc1NvcnRlZCAmJiBsZW5ndGggPj0gbGFyZ2VBcnJheVNpemUgJiYgaW5kZXhPZiA9PT0gYmFzZUluZGV4T2YsXG4gICAgICAgIHNlZW4gPSAoY2FsbGJhY2sgfHwgaXNMYXJnZSkgPyBnZXRBcnJheSgpIDogcmVzdWx0O1xuXG4gICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgIHZhciBjYWNoZSA9IGNyZWF0ZUNhY2hlKHNlZW4pO1xuICAgICAgaW5kZXhPZiA9IGNhY2hlSW5kZXhPZjtcbiAgICAgIHNlZW4gPSBjYWNoZTtcbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICBjb21wdXRlZCA9IGNhbGxiYWNrID8gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBhcnJheSkgOiB2YWx1ZTtcblxuICAgICAgaWYgKGlzU29ydGVkXG4gICAgICAgICAgICA/ICFpbmRleCB8fCBzZWVuW3NlZW4ubGVuZ3RoIC0gMV0gIT09IGNvbXB1dGVkXG4gICAgICAgICAgICA6IGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQpIDwgMFxuICAgICAgICAgICkge1xuICAgICAgICBpZiAoY2FsbGJhY2sgfHwgaXNMYXJnZSkge1xuICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgcmVsZWFzZUFycmF5KHNlZW4uYXJyYXkpO1xuICAgICAgcmVsZWFzZU9iamVjdChzZWVuKTtcbiAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICByZWxlYXNlQXJyYXkoc2Vlbik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYFxuICAgKiB3aXRoIGFuIG9wdGlvbmFsIGB0aGlzYCBiaW5kaW5nIGFuZCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byByZWZlcmVuY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIG1ldGhvZCBmbGFncyB0byBjb21wb3NlLlxuICAgKiAgVGhlIGJpdG1hc2sgbWF5IGJlIGNvbXBvc2VkIG9mIHRoZSBmb2xsb3dpbmcgZmxhZ3M6XG4gICAqICAxIC0gYF8uYmluZGBcbiAgICogIDIgLSBgXy5iaW5kS2V5YFxuICAgKiAgNCAtIGBfLmN1cnJ5YFxuICAgKiAgOCAtIGBfLmN1cnJ5YCAoYm91bmQpXG4gICAqICAxNiAtIGBfLnBhcnRpYWxgXG4gICAqICAzMiAtIGBfLnBhcnRpYWxSaWdodGBcbiAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxBcmdzXSBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZVxuICAgKiAgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxSaWdodEFyZ3NdIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2VcbiAgICogIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlV3JhcHBlcihmdW5jLCBiaXRtYXNrLCBwYXJ0aWFsQXJncywgcGFydGlhbFJpZ2h0QXJncywgdGhpc0FyZywgYXJpdHkpIHtcbiAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIDEsXG4gICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiAyLFxuICAgICAgICBpc0N1cnJ5ID0gYml0bWFzayAmIDQsXG4gICAgICAgIGlzQ3VycnlCb3VuZCA9IGJpdG1hc2sgJiA4LFxuICAgICAgICBpc1BhcnRpYWwgPSBiaXRtYXNrICYgMTYsXG4gICAgICAgIGlzUGFydGlhbFJpZ2h0ID0gYml0bWFzayAmIDMyO1xuXG4gICAgaWYgKCFpc0JpbmRLZXkgJiYgIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgfVxuICAgIGlmIChpc1BhcnRpYWwgJiYgIXBhcnRpYWxBcmdzLmxlbmd0aCkge1xuICAgICAgYml0bWFzayAmPSB+MTY7XG4gICAgICBpc1BhcnRpYWwgPSBwYXJ0aWFsQXJncyA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNQYXJ0aWFsUmlnaHQgJiYgIXBhcnRpYWxSaWdodEFyZ3MubGVuZ3RoKSB7XG4gICAgICBiaXRtYXNrICY9IH4zMjtcbiAgICAgIGlzUGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0QXJncyA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgYmluZERhdGEgPSBmdW5jICYmIGZ1bmMuX19iaW5kRGF0YV9fO1xuICAgIGlmIChiaW5kRGF0YSAmJiBiaW5kRGF0YSAhPT0gdHJ1ZSkge1xuICAgICAgLy8gY2xvbmUgYGJpbmREYXRhYFxuICAgICAgYmluZERhdGEgPSBzbGljZShiaW5kRGF0YSk7XG4gICAgICBpZiAoYmluZERhdGFbMl0pIHtcbiAgICAgICAgYmluZERhdGFbMl0gPSBzbGljZShiaW5kRGF0YVsyXSk7XG4gICAgICB9XG4gICAgICBpZiAoYmluZERhdGFbM10pIHtcbiAgICAgICAgYmluZERhdGFbM10gPSBzbGljZShiaW5kRGF0YVszXSk7XG4gICAgICB9XG4gICAgICAvLyBzZXQgYHRoaXNCaW5kaW5nYCBpcyBub3QgcHJldmlvdXNseSBib3VuZFxuICAgICAgaWYgKGlzQmluZCAmJiAhKGJpbmREYXRhWzFdICYgMSkpIHtcbiAgICAgICAgYmluZERhdGFbNF0gPSB0aGlzQXJnO1xuICAgICAgfVxuICAgICAgLy8gc2V0IGlmIHByZXZpb3VzbHkgYm91bmQgYnV0IG5vdCBjdXJyZW50bHkgKHN1YnNlcXVlbnQgY3VycmllZCBmdW5jdGlvbnMpXG4gICAgICBpZiAoIWlzQmluZCAmJiBiaW5kRGF0YVsxXSAmIDEpIHtcbiAgICAgICAgYml0bWFzayB8PSA4O1xuICAgICAgfVxuICAgICAgLy8gc2V0IGN1cnJpZWQgYXJpdHkgaWYgbm90IHlldCBzZXRcbiAgICAgIGlmIChpc0N1cnJ5ICYmICEoYmluZERhdGFbMV0gJiA0KSkge1xuICAgICAgICBiaW5kRGF0YVs1XSA9IGFyaXR5O1xuICAgICAgfVxuICAgICAgLy8gYXBwZW5kIHBhcnRpYWwgbGVmdCBhcmd1bWVudHNcbiAgICAgIGlmIChpc1BhcnRpYWwpIHtcbiAgICAgICAgcHVzaC5hcHBseShiaW5kRGF0YVsyXSB8fCAoYmluZERhdGFbMl0gPSBbXSksIHBhcnRpYWxBcmdzKTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGVuZCBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50c1xuICAgICAgaWYgKGlzUGFydGlhbFJpZ2h0KSB7XG4gICAgICAgIHVuc2hpZnQuYXBwbHkoYmluZERhdGFbM10gfHwgKGJpbmREYXRhWzNdID0gW10pLCBwYXJ0aWFsUmlnaHRBcmdzKTtcbiAgICAgIH1cbiAgICAgIC8vIG1lcmdlIGZsYWdzXG4gICAgICBiaW5kRGF0YVsxXSB8PSBiaXRtYXNrO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIuYXBwbHkobnVsbCwgYmluZERhdGEpO1xuICAgIH1cbiAgICAvLyBmYXN0IHBhdGggZm9yIGBfLmJpbmRgXG4gICAgdmFyIGNyZWF0ZXIgPSAoYml0bWFzayA9PSAxIHx8IGJpdG1hc2sgPT09IDE3KSA/IGJhc2VCaW5kIDogYmFzZUNyZWF0ZVdyYXBwZXI7XG4gICAgcmV0dXJuIGNyZWF0ZXIoW2Z1bmMsIGJpdG1hc2ssIHBhcnRpYWxBcmdzLCBwYXJ0aWFsUmlnaHRBcmdzLCB0aGlzQXJnLCBhcml0eV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgY29tcGlsZWQgaXRlcmF0aW9uIGZ1bmN0aW9ucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtvcHRpb25zXSBUaGUgY29tcGlsZSBvcHRpb25zIG9iamVjdChzKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFycmF5XSBDb2RlIHRvIGRldGVybWluZSBpZiB0aGUgaXRlcmFibGUgaXMgYW4gYXJyYXkgb3IgYXJyYXktbGlrZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51c2VIYXNdIFNwZWNpZnkgdXNpbmcgYGhhc093blByb3BlcnR5YCBjaGVja3MgaW4gdGhlIG9iamVjdCBsb29wLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5rZXlzXSBBIHJlZmVyZW5jZSB0byBgXy5rZXlzYCBmb3IgdXNlIGluIG93biBwcm9wZXJ0eSBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hcmdzXSBBIGNvbW1hIHNlcGFyYXRlZCBzdHJpbmcgb2YgaXRlcmF0aW9uIGZ1bmN0aW9uIGFyZ3VtZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRvcF0gQ29kZSB0byBleGVjdXRlIGJlZm9yZSB0aGUgaXRlcmF0aW9uIGJyYW5jaGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9vcF0gQ29kZSB0byBleGVjdXRlIGluIHRoZSBvYmplY3QgbG9vcC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJvdHRvbV0gQ29kZSB0byBleGVjdXRlIGFmdGVyIHRoZSBpdGVyYXRpb24gYnJhbmNoZXMuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29tcGlsZWQgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVJdGVyYXRvcigpIHtcbiAgICAvLyBkYXRhIHByb3BlcnRpZXNcbiAgICBpdGVyYXRvckRhdGEuc2hhZG93ZWRQcm9wcyA9IHNoYWRvd2VkUHJvcHM7XG5cbiAgICAvLyBpdGVyYXRvciBvcHRpb25zXG4gICAgaXRlcmF0b3JEYXRhLmFycmF5ID0gaXRlcmF0b3JEYXRhLmJvdHRvbSA9IGl0ZXJhdG9yRGF0YS5sb29wID0gaXRlcmF0b3JEYXRhLnRvcCA9ICcnO1xuICAgIGl0ZXJhdG9yRGF0YS5pbml0ID0gJ2l0ZXJhYmxlJztcbiAgICBpdGVyYXRvckRhdGEudXNlSGFzID0gdHJ1ZTtcblxuICAgIC8vIG1lcmdlIG9wdGlvbnMgaW50byBhIHRlbXBsYXRlIGRhdGEgb2JqZWN0XG4gICAgZm9yICh2YXIgb2JqZWN0LCBpbmRleCA9IDA7IG9iamVjdCA9IGFyZ3VtZW50c1tpbmRleF07IGluZGV4KyspIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaXRlcmF0b3JEYXRhW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBpdGVyYXRvckRhdGEuYXJncztcbiAgICBpdGVyYXRvckRhdGEuZmlyc3RBcmcgPSAvXlteLF0rLy5leGVjKGFyZ3MpWzBdO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBmdW5jdGlvbiBmYWN0b3J5XG4gICAgdmFyIGZhY3RvcnkgPSBGdW5jdGlvbihcbiAgICAgICAgJ2Jhc2VDcmVhdGVDYWxsYmFjaywgZXJyb3JDbGFzcywgZXJyb3JQcm90bywgaGFzT3duUHJvcGVydHksICcgK1xuICAgICAgICAnaW5kaWNhdG9yT2JqZWN0LCBpc0FyZ3VtZW50cywgaXNBcnJheSwgaXNTdHJpbmcsIGtleXMsIG9iamVjdFByb3RvLCAnICtcbiAgICAgICAgJ29iamVjdFR5cGVzLCBub25FbnVtUHJvcHMsIHN0cmluZ0NsYXNzLCBzdHJpbmdQcm90bywgdG9TdHJpbmcnLFxuICAgICAgJ3JldHVybiBmdW5jdGlvbignICsgYXJncyArICcpIHtcXG4nICsgaXRlcmF0b3JUZW1wbGF0ZShpdGVyYXRvckRhdGEpICsgJ1xcbn0nXG4gICAgKTtcblxuICAgIC8vIHJldHVybiB0aGUgY29tcGlsZWQgZnVuY3Rpb25cbiAgICByZXR1cm4gZmFjdG9yeShcbiAgICAgIGJhc2VDcmVhdGVDYWxsYmFjaywgZXJyb3JDbGFzcywgZXJyb3JQcm90bywgaGFzT3duUHJvcGVydHksXG4gICAgICBpbmRpY2F0b3JPYmplY3QsIGlzQXJndW1lbnRzLCBpc0FycmF5LCBpc1N0cmluZywgaXRlcmF0b3JEYXRhLmtleXMsIG9iamVjdFByb3RvLFxuICAgICAgb2JqZWN0VHlwZXMsIG5vbkVudW1Qcm9wcywgc3RyaW5nQ2xhc3MsIHN0cmluZ1Byb3RvLCB0b1N0cmluZ1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpbmRleE9mXCIgZnVuY3Rpb24uIElmIHRoZSBgXy5pbmRleE9mYCBtZXRob2QgaXNcbiAgICogY3VzdG9taXplZCwgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgY3VzdG9tIG1ldGhvZCwgb3RoZXJ3aXNlIGl0IHJldHVybnNcbiAgICogdGhlIGBiYXNlSW5kZXhPZmAgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgXCJpbmRleE9mXCIgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRJbmRleE9mKCkge1xuICAgIHZhciByZXN1bHQgPSAocmVzdWx0ID0gbG9kYXNoLmluZGV4T2YpID09PSBpbmRleE9mID8gYmFzZUluZGV4T2YgOiByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgJiYgcmVOYXRpdmUudGVzdCh2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBgdGhpc2AgYmluZGluZyBkYXRhIG9uIGEgZ2l2ZW4gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHNldCBkYXRhIG9uLlxuICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSBUaGUgZGF0YSBhcnJheSB0byBzZXQuXG4gICAqL1xuICB2YXIgc2V0QmluZERhdGEgPSAhZGVmaW5lUHJvcGVydHkgPyBub29wIDogZnVuY3Rpb24oZnVuYywgdmFsdWUpIHtcbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gdmFsdWU7XG4gICAgZGVmaW5lUHJvcGVydHkoZnVuYywgJ19fYmluZERhdGFfXycsIGRlc2NyaXB0b3IpO1xuICB9O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogKGZ1bmN0aW9uKCkgeyByZXR1cm4gXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpOyB9KSgxLCAyLCAzKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgICAgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc0NsYXNzIHx8IGZhbHNlO1xuICB9XG4gIC8vIGZhbGxiYWNrIGZvciBicm93c2VycyB0aGF0IGNhbid0IGRldGVjdCBgYXJndW1lbnRzYCBvYmplY3RzIGJ5IFtbQ2xhc3NdXVxuICBpZiAoIXN1cHBvcnQuYXJnc0NsYXNzKSB7XG4gICAgaXNBcmd1bWVudHMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgICAgIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJiAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHR5cGUgRnVuY3Rpb25cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLmlzQXJyYXkoYXJndW1lbnRzKTsgfSkoKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIHZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgICAgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcyB8fCBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgT2JqZWN0LmtleXNgIHdoaWNoIHByb2R1Y2VzIGFuIGFycmF5IG9mIHRoZVxuICAgKiBnaXZlbiBvYmplY3QncyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUgRnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICovXG4gIHZhciBzaGltS2V5cyA9IGNyZWF0ZUl0ZXJhdG9yKHtcbiAgICAnYXJncyc6ICdvYmplY3QnLFxuICAgICdpbml0JzogJ1tdJyxcbiAgICAndG9wJzogJ2lmICghKG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3RdKSkgcmV0dXJuIHJlc3VsdCcsXG4gICAgJ2xvb3AnOiAncmVzdWx0LnB1c2goaW5kZXgpJ1xuICB9KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBjb21wb3NlZCBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ua2V5cyh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICogLy8gPT4gWydvbmUnLCAndHdvJywgJ3RocmVlJ10gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAqL1xuICB2YXIga2V5cyA9ICFuYXRpdmVLZXlzID8gc2hpbUtleXMgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKChzdXBwb3J0LmVudW1Qcm90b3R5cGVzICYmIHR5cGVvZiBvYmplY3QgPT0gJ2Z1bmN0aW9uJykgfHxcbiAgICAgICAgKHN1cHBvcnQubm9uRW51bUFyZ3MgJiYgb2JqZWN0Lmxlbmd0aCAmJiBpc0FyZ3VtZW50cyhvYmplY3QpKSkge1xuICAgICAgcmV0dXJuIHNoaW1LZXlzKG9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH07XG5cbiAgLyoqIFJldXNhYmxlIGl0ZXJhdG9yIG9wdGlvbnMgc2hhcmVkIGJ5IGBlYWNoYCwgYGZvckluYCwgYW5kIGBmb3JPd25gICovXG4gIHZhciBlYWNoSXRlcmF0b3JPcHRpb25zID0ge1xuICAgICdhcmdzJzogJ2NvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnJyxcbiAgICAndG9wJzogXCJjYWxsYmFjayA9IGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnID8gY2FsbGJhY2sgOiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpXCIsXG4gICAgJ2FycmF5JzogXCJ0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInXCIsXG4gICAgJ2tleXMnOiBrZXlzLFxuICAgICdsb29wJzogJ2lmIChjYWxsYmFjayhpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHJldHVybiByZXN1bHQnXG4gIH07XG5cbiAgLyoqIFJldXNhYmxlIGl0ZXJhdG9yIG9wdGlvbnMgZm9yIGBhc3NpZ25gIGFuZCBgZGVmYXVsdHNgICovXG4gIHZhciBkZWZhdWx0c0l0ZXJhdG9yT3B0aW9ucyA9IHtcbiAgICAnYXJncyc6ICdvYmplY3QsIHNvdXJjZSwgZ3VhcmQnLFxuICAgICd0b3AnOlxuICAgICAgJ3ZhciBhcmdzID0gYXJndW1lbnRzLFxcbicgK1xuICAgICAgJyAgICBhcmdzSW5kZXggPSAwLFxcbicgK1xuICAgICAgXCIgICAgYXJnc0xlbmd0aCA9IHR5cGVvZiBndWFyZCA9PSAnbnVtYmVyJyA/IDIgOiBhcmdzLmxlbmd0aDtcXG5cIiArXG4gICAgICAnd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xcbicgK1xuICAgICAgJyAgaXRlcmFibGUgPSBhcmdzW2FyZ3NJbmRleF07XFxuJyArXG4gICAgICAnICBpZiAoaXRlcmFibGUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkgeycsXG4gICAgJ2tleXMnOiBrZXlzLFxuICAgICdsb29wJzogXCJpZiAodHlwZW9mIHJlc3VsdFtpbmRleF0gPT0gJ3VuZGVmaW5lZCcpIHJlc3VsdFtpbmRleF0gPSBpdGVyYWJsZVtpbmRleF1cIixcbiAgICAnYm90dG9tJzogJyAgfVxcbn0nXG4gIH07XG5cbiAgLyoqIFJldXNhYmxlIGl0ZXJhdG9yIG9wdGlvbnMgZm9yIGBmb3JJbmAgYW5kIGBmb3JPd25gICovXG4gIHZhciBmb3JPd25JdGVyYXRvck9wdGlvbnMgPSB7XG4gICAgJ3RvcCc6ICdpZiAoIW9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0pIHJldHVybiByZXN1bHQ7XFxuJyArIGVhY2hJdGVyYXRvck9wdGlvbnMudG9wLFxuICAgICdhcnJheSc6IGZhbHNlXG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gY29tcGlsZWQgdG8gaXRlcmF0ZSBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIG9iamVjdHMsIGFuZFxuICAgKiBzdHJpbmdzIGNvbnNpc3Rlbmx5IGFjcm9zcyBlbnZpcm9ubWVudHMsIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2sgZm9yIGVhY2hcbiAgICogZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbi4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLiBDYWxsYmFja3MgbWF5IGV4aXRcbiAgICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgKi9cbiAgdmFyIGJhc2VFYWNoID0gY3JlYXRlSXRlcmF0b3IoZWFjaEl0ZXJhdG9yT3B0aW9ucyk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgKiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlcyB3aWxsIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91c1xuICAgKiBzb3VyY2VzLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGVcbiAgICogYXNzaWduZWQgdmFsdWVzLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdHdvXG4gICAqIGFyZ3VtZW50czsgKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHR5cGUgRnVuY3Rpb25cbiAgICogQGFsaWFzIGV4dGVuZFxuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25pbmcgdmFsdWVzLlxuICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmFzc2lnbih7ICduYW1lJzogJ2ZyZWQnIH0sIHsgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XG4gICAqXG4gICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduLCBmdW5jdGlvbihhLCBiKSB7XG4gICAqICAgcmV0dXJuIHR5cGVvZiBhID09ICd1bmRlZmluZWQnID8gYiA6IGE7XG4gICAqIH0pO1xuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdiYXJuZXknIH07XG4gICAqIGRlZmF1bHRzKG9iamVjdCwgeyAnbmFtZSc6ICdmcmVkJywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1cbiAgICovXG4gIHZhciBhc3NpZ24gPSBjcmVhdGVJdGVyYXRvcihkZWZhdWx0c0l0ZXJhdG9yT3B0aW9ucywge1xuICAgICd0b3AnOlxuICAgICAgZGVmYXVsdHNJdGVyYXRvck9wdGlvbnMudG9wLnJlcGxhY2UoJzsnLFxuICAgICAgICAnO1xcbicgK1xuICAgICAgICBcImlmIChhcmdzTGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJnc1thcmdzTGVuZ3RoIC0gMl0gPT0gJ2Z1bmN0aW9uJykge1xcblwiICtcbiAgICAgICAgJyAgdmFyIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGFyZ3NbLS1hcmdzTGVuZ3RoIC0gMV0sIGFyZ3NbYXJnc0xlbmd0aC0tXSwgMik7XFxuJyArXG4gICAgICAgIFwifSBlbHNlIGlmIChhcmdzTGVuZ3RoID4gMiAmJiB0eXBlb2YgYXJnc1thcmdzTGVuZ3RoIC0gMV0gPT0gJ2Z1bmN0aW9uJykge1xcblwiICtcbiAgICAgICAgJyAgY2FsbGJhY2sgPSBhcmdzWy0tYXJnc0xlbmd0aF07XFxuJyArXG4gICAgICAgICd9J1xuICAgICAgKSxcbiAgICAnbG9vcCc6ICdyZXN1bHRbaW5kZXhdID0gY2FsbGJhY2sgPyBjYWxsYmFjayhyZXN1bHRbaW5kZXhdLCBpdGVyYWJsZVtpbmRleF0pIDogaXRlcmFibGVbaW5kZXhdJ1xuICB9KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB2YWx1ZWAuIElmIGBpc0RlZXBgIGlzIGB0cnVlYCBuZXN0ZWQgb2JqZWN0cyB3aWxsIGFsc29cbiAgICogYmUgY2xvbmVkLCBvdGhlcndpc2UgdGhleSB3aWxsIGJlIGFzc2lnbmVkIGJ5IHJlZmVyZW5jZS4gSWYgYSBjYWxsYmFja1xuICAgKiBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIHRoZVxuICAgKiBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgIGNsb25pbmcgd2lsbCBiZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC5cbiAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwPWZhbHNlXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAqIF07XG4gICAqXG4gICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShjaGFyYWN0ZXJzKTtcbiAgICogc2hhbGxvd1swXSA9PT0gY2hhcmFjdGVyc1swXTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiB2YXIgZGVlcCA9IF8uY2xvbmUoY2hhcmFjdGVycywgdHJ1ZSk7XG4gICAqIGRlZXBbMF0gPT09IGNoYXJhY3RlcnNbMF07XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8ubWl4aW4oe1xuICAgKiAgICdjbG9uZSc6IF8ucGFydGlhbFJpZ2h0KF8uY2xvbmUsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAqICAgICByZXR1cm4gXy5pc0VsZW1lbnQodmFsdWUpID8gdmFsdWUuY2xvbmVOb2RlKGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICogICB9KVxuICAgKiB9KTtcbiAgICpcbiAgICogdmFyIGNsb25lID0gXy5jbG9uZShkb2N1bWVudC5ib2R5KTtcbiAgICogY2xvbmUuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAqIC8vID0+IDBcbiAgICovXG4gIGZ1bmN0aW9uIGNsb25lKHZhbHVlLCBpc0RlZXAsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgLy8gYWxsb3dzIHdvcmtpbmcgd2l0aCBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcyB3aXRob3V0IHVzaW5nIHRoZWlyIGBpbmRleGBcbiAgICAvLyBhbmQgYGNvbGxlY3Rpb25gIGFyZ3VtZW50cyBmb3IgYGlzRGVlcGAgYW5kIGBjYWxsYmFja2BcbiAgICBpZiAodHlwZW9mIGlzRGVlcCAhPSAnYm9vbGVhbicgJiYgaXNEZWVwICE9IG51bGwpIHtcbiAgICAgIHRoaXNBcmcgPSBjYWxsYmFjaztcbiAgICAgIGNhbGxiYWNrID0gaXNEZWVwO1xuICAgICAgaXNEZWVwID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgJiYgYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAxKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGRlZXAgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlXG4gICAqIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAqIGNsb25pbmcgd2lsbCBiZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvXG4gICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICpcbiAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGUgc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG0uIEZ1bmN0aW9uc1xuICAgKiBhbmQgRE9NIG5vZGVzIGFyZSAqKm5vdCoqIGNsb25lZC4gVGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFuZFxuICAgKiBvYmplY3RzIGNyZWF0ZWQgYnkgY29uc3RydWN0b3JzIG90aGVyIHRoYW4gYE9iamVjdGAgYXJlIGNsb25lZCB0byBwbGFpbiBgT2JqZWN0YCBvYmplY3RzLlxuICAgKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNpbnRlcm5hbC1zdHJ1Y3R1cmVkLWNsb25pbmctYWxnb3JpdGhtLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGRlZXAgY2xvbmUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAqIF07XG4gICAqXG4gICAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAoY2hhcmFjdGVycyk7XG4gICAqIGRlZXBbMF0gPT09IGNoYXJhY3RlcnNbMF07XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIHZhciB2aWV3ID0ge1xuICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICogICAnbm9kZSc6IGVsZW1lbnRcbiAgICogfTtcbiAgICpcbiAgICogdmFyIGNsb25lID0gXy5jbG9uZURlZXAodmlldywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICogICByZXR1cm4gXy5pc0VsZW1lbnQodmFsdWUpID8gdmFsdWUuY2xvbmVOb2RlKHRydWUpIDogdW5kZWZpbmVkO1xuICAgKiB9KTtcbiAgICpcbiAgICogY2xvbmUubm9kZSA9PSB2aWV3Lm5vZGU7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgdHJ1ZSwgdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgJiYgYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAxKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcbiAgICogYHByb3BlcnRpZXNgIG9iamVjdCBpcyBwcm92aWRlZCBpdHMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgYXNzaWduZWRcbiAgICogdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gVGhlIHByb3BlcnRpZXMgdG8gYXNzaWduIHRvIHRoZSBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgKiAgIHRoaXMueCA9IDA7XG4gICAqICAgdGhpcy55ID0gMDtcbiAgICogfVxuICAgKlxuICAgKiBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gICAqICAgU2hhcGUuY2FsbCh0aGlzKTtcbiAgICogfVxuICAgKlxuICAgKiBDaXJjbGUucHJvdG90eXBlID0gXy5jcmVhdGUoU2hhcGUucHJvdG90eXBlLCB7ICdjb25zdHJ1Y3Rvcic6IENpcmNsZSB9KTtcbiAgICpcbiAgICogdmFyIGNpcmNsZSA9IG5ldyBDaXJjbGU7XG4gICAqIGNpcmNsZSBpbnN0YW5jZW9mIENpcmNsZTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBTaGFwZTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgcmV0dXJuIHByb3BlcnRpZXMgPyBhc3NpZ24ocmVzdWx0LCBwcm9wZXJ0aWVzKSA6IHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QsXG4gICAqIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICogYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBDYWxsYmFja3MgbWF5IGV4aXRcbiAgICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHR5cGUgRnVuY3Rpb25cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICogICB0aGlzLnggPSAwO1xuICAgKiAgIHRoaXMueSA9IDA7XG4gICAqIH1cbiAgICpcbiAgICogU2hhcGUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAqICAgdGhpcy54ICs9IHg7XG4gICAqICAgdGhpcy55ICs9IHk7XG4gICAqIH07XG4gICAqXG4gICAqIF8uZm9ySW4obmV3IFNoYXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICogfSk7XG4gICAqIC8vID0+IGxvZ3MgJ3gnLCAneScsIGFuZCAnbW92ZScgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAqL1xuICB2YXIgZm9ySW4gPSBjcmVhdGVJdGVyYXRvcihlYWNoSXRlcmF0b3JPcHRpb25zLCBmb3JPd25JdGVyYXRvck9wdGlvbnMsIHtcbiAgICAndXNlSGFzJzogZmFsc2VcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QsIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2tcbiAgICogZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBDYWxsYmFja3MgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5XG4gICAqIGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHR5cGUgRnVuY3Rpb25cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmZvck93bih7ICcwJzogJ3plcm8nLCAnMSc6ICdvbmUnLCAnbGVuZ3RoJzogMiB9LCBmdW5jdGlvbihudW0sIGtleSkge1xuICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAqIH0pO1xuICAgKiAvLyA9PiBsb2dzICcwJywgJzEnLCBhbmQgJ2xlbmd0aCcgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAqL1xuICB2YXIgZm9yT3duID0gY3JlYXRlSXRlcmF0b3IoZWFjaEl0ZXJhdG9yT3B0aW9ucywgZm9yT3duSXRlcmF0b3JPcHRpb25zKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNvcnRlZCBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBvZiBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLFxuICAgKiBvd24gYW5kIGluaGVyaXRlZCwgb2YgYG9iamVjdGAgdGhhdCBoYXZlIGZ1bmN0aW9uIHZhbHVlcy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAYWxpYXMgbWV0aG9kc1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHRoYXQgaGF2ZSBmdW5jdGlvbiB2YWx1ZXMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uZnVuY3Rpb25zKF8pO1xuICAgKiAvLyA9PiBbJ2FsbCcsICdhbnknLCAnYmluZCcsICdiaW5kQWxsJywgJ2Nsb25lJywgJ2NvbXBhY3QnLCAnY29tcG9zZScsIC4uLl1cbiAgICovXG4gIGZ1bmN0aW9uIGZ1bmN0aW9ucyhvYmplY3QpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0LnNvcnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBlbXB0eS4gQXJyYXlzLCBzdHJpbmdzLCBvciBgYXJndW1lbnRzYCBvYmplY3RzIHdpdGggYVxuICAgKiBsZW5ndGggb2YgYDBgIGFuZCBvYmplY3RzIHdpdGggbm8gb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgY29uc2lkZXJlZFxuICAgKiBcImVtcHR5XCIuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzRW1wdHkoe30pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNFbXB0eSgnJyk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbCh2YWx1ZSksXG4gICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICAgIGlmICgoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MgfHwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8XG4gICAgICAgIChzdXBwb3J0LmFyZ3NDbGFzcyA/IGNsYXNzTmFtZSA9PSBhcmdzQ2xhc3MgOiBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB8fFxuICAgICAgICAoY2xhc3NOYW1lID09IG9iamVjdENsYXNzICYmIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgaXNGdW5jdGlvbih2YWx1ZS5zcGxpY2UpKSkge1xuICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgfVxuICAgIGZvck93bih2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9IGZhbHNlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAgICogZXF1aXZhbGVudCB0byBlYWNoIG90aGVyLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWRcbiAgICogdG8gY29tcGFyZSB2YWx1ZXMuIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgIGNvbXBhcmlzb25zIHdpbGxcbiAgICogYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOyAoYSwgYikuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHsqfSBhIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0geyp9IGIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgdmFsdWVzLlxuICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICogdmFyIGNvcHkgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAqXG4gICAqIG9iamVjdCA9PSBjb3B5O1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzRXF1YWwob2JqZWN0LCBjb3B5KTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiB2YXIgd29yZHMgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAgICogdmFyIG90aGVyV29yZHMgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAgICpcbiAgICogXy5pc0VxdWFsKHdvcmRzLCBvdGhlcldvcmRzLCBmdW5jdGlvbihhLCBiKSB7XG4gICAqICAgdmFyIHJlR3JlZXQgPSAvXig/OmhlbGxvfGhpKSQvaSxcbiAgICogICAgICAgYUdyZWV0ID0gXy5pc1N0cmluZyhhKSAmJiByZUdyZWV0LnRlc3QoYSksXG4gICAqICAgICAgIGJHcmVldCA9IF8uaXNTdHJpbmcoYikgJiYgcmVHcmVldC50ZXN0KGIpO1xuICAgKlxuICAgKiAgIHJldHVybiAoYUdyZWV0IHx8IGJHcmVldCkgPyAoYUdyZWV0ID09IGJHcmVldCkgOiB1bmRlZmluZWQ7XG4gICAqIH0pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICBmdW5jdGlvbiBpc0VxdWFsKGEsIGIsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGJhc2VJc0VxdWFsKGEsIGIsIHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nICYmIGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMikpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJztcbiAgfVxuICAvLyBmYWxsYmFjayBmb3Igb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmlcbiAgaWYgKGlzRnVuY3Rpb24oL3gvKSkge1xuICAgIGlzRnVuY3Rpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGZ1bmNDbGFzcztcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBsYW5ndWFnZSB0eXBlIG9mIE9iamVjdC5cbiAgICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc09iamVjdCh7fSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNPYmplY3QoMSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIC8vIGNoZWNrIGlmIHRoZSB2YWx1ZSBpcyB0aGUgRUNNQVNjcmlwdCBsYW5ndWFnZSB0eXBlIG9mIE9iamVjdFxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4OFxuICAgIC8vIGFuZCBhdm9pZCBhIFY4IGJ1Z1xuICAgIC8vIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTFcbiAgICByZXR1cm4gISEodmFsdWUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIHZhbHVlXSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzU3RyaW5nKCdmcmVkJyk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICAgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN0cmluZ0NsYXNzIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgY29tcG9zZWQgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy52YWx1ZXMoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSk7XG4gICAqIC8vID0+IFsxLCAyLCAzXSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICovXG4gIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gb2JqZWN0W3Byb3BzW2luZGV4XV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgcHJlc2VudCBpbiBhIGNvbGxlY3Rpb24gdXNpbmcgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0IGlzIHVzZWQgYXMgdGhlXG4gICAqIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGFsaWFzIGluY2x1ZGVcbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBjaGVjayBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdGFyZ2V0YCBlbGVtZW50IGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uY29udGFpbnMoWzEsIDIsIDNdLCAxKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmNvbnRhaW5zKFsxLCAyLCAzXSwgMSwgMik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uY29udGFpbnMoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sICdmcmVkJyk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5jb250YWlucygncGViYmxlcycsICdlYicpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICBmdW5jdGlvbiBjb250YWlucyhjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KDAsIGxlbmd0aCArIGZyb21JbmRleCkgOiBmcm9tSW5kZXgpIHx8IDA7XG4gICAgaWYgKGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgIHJlc3VsdCA9IGluZGV4T2YoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpID4gLTE7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICByZXN1bHQgPSAoaXNTdHJpbmcoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uLmluZGV4T2YodGFyZ2V0LCBmcm9tSW5kZXgpIDogaW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkpID4gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICgrK2luZGV4ID49IGZyb21JbmRleCkge1xuICAgICAgICAgIHJldHVybiAhKHJlc3VsdCA9IHZhbHVlID09PSB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgKiB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleSBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICpcbiAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICpcbiAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAqIGVsc2UgYGZhbHNlYC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAYWxpYXMgc2VsZWN0XG4gICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBwYXNzZWQgdGhlIGNhbGxiYWNrIGNoZWNrLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgZXZlbnMgPSBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICUgMiA9PSAwOyB9KTtcbiAgICogLy8gPT4gWzIsIDQsIDZdXG4gICAqXG4gICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XG4gICAqIF07XG4gICAqXG4gICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgKiBfLmZpbHRlcihjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfV1cbiAgICpcbiAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAqIF8uZmlsdGVyKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfV1cbiAgICovXG4gIGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdFxuICAgKiB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleSBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICpcbiAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICpcbiAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAqIGVsc2UgYGZhbHNlYC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAYWxpYXMgZGV0ZWN0LCBmaW5kV2hlcmVcbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAqIF07XG4gICAqXG4gICAqIF8uZmluZChjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgKiB9KTtcbiAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfVxuICAgKlxuICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICogXy5maW5kKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDEgfSk7XG4gICAqIC8vID0+ICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAqXG4gICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgKiBfLmZpbmQoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfVxuICAgKi9cbiAgZnVuY3Rpb24gZmluZChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBhIGNvbGxlY3Rpb24sIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2sgZm9yIGVhY2hcbiAgICogZWxlbWVudC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLiBDYWxsYmFja3MgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5XG4gICAqIGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAqXG4gICAqIE5vdGU6IEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIGBsZW5ndGhgIHByb3BlcnR5XG4gICAqIGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciBgXy5mb3JJbmAgb3IgYF8uZm9yT3duYFxuICAgKiBtYXkgYmUgdXNlZCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAYWxpYXMgZWFjaFxuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8oWzEsIDIsIDNdKS5mb3JFYWNoKGZ1bmN0aW9uKG51bSkgeyBjb25zb2xlLmxvZyhudW0pOyB9KS5qb2luKCcsJyk7XG4gICAqIC8vID0+IGxvZ3MgZWFjaCBudW1iZXIgYW5kIHJldHVybnMgJzEsMiwzJ1xuICAgKlxuICAgKiBfLmZvckVhY2goeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSwgZnVuY3Rpb24obnVtKSB7IGNvbnNvbGUubG9nKG51bSk7IH0pO1xuICAgKiAvLyA9PiBsb2dzIGVhY2ggbnVtYmVyIGFuZCByZXR1cm5zIHRoZSBvYmplY3QgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAqL1xuICBmdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnICYmIGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uXG4gICAqIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICogdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAqXG4gICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAqXG4gICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgKiBlbHNlIGBmYWxzZWAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGFsaWFzIGNvbGxlY3RcbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLm1hcChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICogMzsgfSk7XG4gICAqIC8vID0+IFszLCA2LCA5XVxuICAgKlxuICAgKiBfLm1hcCh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9LCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAqIDM7IH0pO1xuICAgKiAvLyA9PiBbMywgNiwgOV0gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAqXG4gICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgKiBdO1xuICAgKlxuICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICogXy5tYXAoY2hhcmFjdGVycywgJ25hbWUnKTtcbiAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAqL1xuICBmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IDApO1xuXG4gICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVsZW1lbnRzIG9mIGFcbiAgICogY29sbGVjdGlvbiB0aGF0IHRoZSBjYWxsYmFjayBkb2VzICoqbm90KiogcmV0dXJuIHRydWV5IGZvci5cbiAgICpcbiAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICpcbiAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAqIGVsc2UgYGZhbHNlYC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIHRoYXQgZmFpbGVkIHRoZSBjYWxsYmFjayBjaGVjay5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9kZHMgPSBfLnJlamVjdChbMSwgMiwgMywgNCwgNSwgNl0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICUgMiA9PSAwOyB9KTtcbiAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAqXG4gICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XG4gICAqIF07XG4gICAqXG4gICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgKiBfLnJlamVjdChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfV1cbiAgICpcbiAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAqIF8ucmVqZWN0KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfV1cbiAgICovXG4gIGZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICByZXR1cm4gZmlsdGVyKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuICFjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIHJhbmRvbSBlbGVtZW50IG9yIGBuYCByYW5kb20gZWxlbWVudHMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbl0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBBbGxvd3Mgd29ya2luZyB3aXRoIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGBcbiAgICogIHdpdGhvdXQgdXNpbmcgdGhlaXIgYGluZGV4YCBhcmd1bWVudHMgYXMgYG5gLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBzYW1wbGUocykgb2YgYGNvbGxlY3Rpb25gLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xuICAgKiAvLyA9PiAyXG4gICAqXG4gICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSwgMik7XG4gICAqIC8vID0+IFszLCAxXVxuICAgKi9cbiAgZnVuY3Rpb24gc2FtcGxlKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gJiYgdHlwZW9mIGNvbGxlY3Rpb24ubGVuZ3RoICE9ICdudW1iZXInKSB7XG4gICAgICBjb2xsZWN0aW9uID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC51bmluZGV4ZWRDaGFycyAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKSkge1xuICAgICAgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uc3BsaXQoJycpO1xuICAgIH1cbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb25bYmFzZVJhbmRvbSgwLCBjb2xsZWN0aW9uLmxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHNodWZmbGUoY29sbGVjdGlvbik7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IG5hdGl2ZU1pbihuYXRpdmVNYXgoMCwgbiksIHJlc3VsdC5sZW5ndGgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGUgRmlzaGVyLVlhdGVzXG4gICAqIHNodWZmbGUuIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IHNodWZmbGVkIGNvbGxlY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNCwgNSwgNl0pO1xuICAgKiAvLyA9PiBbNCwgMSwgNiwgMywgNSwgMl1cbiAgICovXG4gIGZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICByZXN1bHQgPSBBcnJheSh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDogMCk7XG5cbiAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgcmFuZCA9IGJhc2VSYW5kb20oMCwgKytpbmRleCk7XG4gICAgICByZXN1bHRbaW5kZXhdID0gcmVzdWx0W3JhbmRdO1xuICAgICAgcmVzdWx0W3JhbmRdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzaXplIG9mIHRoZSBgY29sbGVjdGlvbmAgYnkgcmV0dXJuaW5nIGBjb2xsZWN0aW9uLmxlbmd0aGAgZm9yIGFycmF5c1xuICAgKiBhbmQgYXJyYXktbGlrZSBvYmplY3RzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYGNvbGxlY3Rpb24ubGVuZ3RoYCBvciBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5zaXplKFsxLCAyXSk7XG4gICAqIC8vID0+IDJcbiAgICpcbiAgICogXy5zaXplKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgKiAvLyA9PiAzXG4gICAqXG4gICAqIF8uc2l6ZSgncGViYmxlcycpO1xuICAgKiAvLyA9PiA3XG4gICAqL1xuICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcbiAgICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IGtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGlzIG1ldGhvZFxuICAgKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCB3aWxsIHByZXNlcnZlIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyXG4gICAqIG9mIGVxdWFsIGVsZW1lbnRzLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICogdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAqXG4gICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAqXG4gICAqIElmIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjb2xsZWN0aW9uXG4gICAqIHdpbGwgYmUgc29ydGVkIGJ5IGVhY2ggcHJvcGVydHkgdmFsdWUuXG4gICAqXG4gICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgKiBlbHNlIGBmYWxzZWAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBzb3J0ZWQgZWxlbWVudHMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLnNpbihudW0pOyB9KTtcbiAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAqXG4gICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLnNpbihudW0pOyB9LCBNYXRoKTtcbiAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAqXG4gICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAyNiB9LFxuICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiAzMCB9XG4gICAqIF07XG4gICAqXG4gICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgKiBfLm1hcChfLnNvcnRCeShjaGFyYWN0ZXJzLCAnYWdlJyksIF8udmFsdWVzKTtcbiAgICogLy8gPT4gW1snYmFybmV5JywgMjZdLCBbJ2ZyZWQnLCAzMF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0MF1dXG4gICAqXG4gICAqIC8vIHNvcnRpbmcgYnkgbXVsdGlwbGUgcHJvcGVydGllc1xuICAgKiBfLm1hcChfLnNvcnRCeShjaGFyYWN0ZXJzLCBbJ25hbWUnLCAnYWdlJ10pLCBfLnZhbHVlcyk7XG4gICAqIC8vID0gPiBbWydiYXJuZXknLCAyNl0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCAzMF0sIFsnZnJlZCcsIDQwXV1cbiAgICovXG4gIGZ1bmN0aW9uIHNvcnRCeShjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpc0FyciA9IGlzQXJyYXkoY2FsbGJhY2spLFxuICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICByZXN1bHQgPSBBcnJheSh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDogMCk7XG5cbiAgICBpZiAoIWlzQXJyKSB7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgfVxuICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgdmFyIG9iamVjdCA9IHJlc3VsdFsrK2luZGV4XSA9IGdldE9iamVjdCgpO1xuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIG9iamVjdC5jcml0ZXJpYSA9IG1hcChjYWxsYmFjaywgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChvYmplY3QuY3JpdGVyaWEgPSBnZXRBcnJheSgpKVswXSA9IGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgfVxuICAgICAgb2JqZWN0LmluZGV4ID0gaW5kZXg7XG4gICAgICBvYmplY3QudmFsdWUgPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgcmVzdWx0LnNvcnQoY29tcGFyZUFzY2VuZGluZyk7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gcmVzdWx0W2xlbmd0aF07XG4gICAgICByZXN1bHRbbGVuZ3RoXSA9IG9iamVjdC52YWx1ZTtcbiAgICAgIGlmICghaXNBcnIpIHtcbiAgICAgICAgcmVsZWFzZUFycmF5KG9iamVjdC5jcml0ZXJpYSk7XG4gICAgICB9XG4gICAgICByZWxlYXNlT2JqZWN0KG9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogRmxhdHRlbnMgYSBuZXN0ZWQgYXJyYXkgKHRoZSBuZXN0aW5nIGNhbiBiZSB0byBhbnkgZGVwdGgpLiBJZiBgaXNTaGFsbG93YFxuICAgKiBpcyB0cnVleSwgdGhlIGFycmF5IHdpbGwgb25seSBiZSBmbGF0dGVuZWQgYSBzaW5nbGUgbGV2ZWwuIElmIGEgY2FsbGJhY2tcbiAgICogaXMgcHJvdmlkZWQgZWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheSBpcyBwYXNzZWQgdGhyb3VnaCB0aGUgY2FsbGJhY2sgYmVmb3JlXG4gICAqIGZsYXR0ZW5pbmcuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICpcbiAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICpcbiAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAqIGVsc2UgYGZhbHNlYC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NoYWxsb3c9ZmFsc2VdIEEgZmxhZyB0byByZXN0cmljdCBmbGF0dGVuaW5nIHRvIGEgc2luZ2xlIGxldmVsLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmZsYXR0ZW4oWzEsIFsyXSwgWzMsIFtbNF1dXV0pO1xuICAgKiAvLyA9PiBbMSwgMiwgMywgNF07XG4gICAqXG4gICAqIF8uZmxhdHRlbihbMSwgWzJdLCBbMywgW1s0XV1dXSwgdHJ1ZSk7XG4gICAqIC8vID0+IFsxLCAyLCAzLCBbWzRdXV07XG4gICAqXG4gICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDMwLCAncGV0cyc6IFsnaG9wcHknXSB9LFxuICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XG4gICAqIF07XG4gICAqXG4gICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgKiBfLmZsYXR0ZW4oY2hhcmFjdGVycywgJ3BldHMnKTtcbiAgICogLy8gPT4gWydob3BweScsICdiYWJ5IHB1c3MnLCAnZGlubyddXG4gICAqL1xuICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5LCBpc1NoYWxsb3csIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgLy8ganVnZ2xlIGFyZ3VtZW50c1xuICAgIGlmICh0eXBlb2YgaXNTaGFsbG93ICE9ICdib29sZWFuJyAmJiBpc1NoYWxsb3cgIT0gbnVsbCkge1xuICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrO1xuICAgICAgY2FsbGJhY2sgPSAodHlwZW9mIGlzU2hhbGxvdyAhPSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgJiYgdGhpc0FyZ1tpc1NoYWxsb3ddID09PSBhcnJheSkgPyBudWxsIDogaXNTaGFsbG93O1xuICAgICAgaXNTaGFsbG93ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICBhcnJheSA9IG1hcChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZUZsYXR0ZW4oYXJyYXksIGlzU2hhbGxvdyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCB1c2luZ1xuICAgKiBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiB0aGUgYXJyYXkgaXMgYWxyZWFkeSBzb3J0ZWRcbiAgICogcHJvdmlkaW5nIGB0cnVlYCBmb3IgYGZyb21JbmRleGAgd2lsbCBydW4gYSBmYXN0ZXIgYmluYXJ5IHNlYXJjaC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tIG9yIGB0cnVlYFxuICAgKiAgdG8gcGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb24gYSBzb3J0ZWQgYXJyYXkuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIpO1xuICAgKiAvLyA9PiAxXG4gICAqXG4gICAqIF8uaW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIsIDMpO1xuICAgKiAvLyA9PiA0XG4gICAqXG4gICAqIF8uaW5kZXhPZihbMSwgMSwgMiwgMiwgMywgM10sIDIsIHRydWUpO1xuICAgKiAvLyA9PiAyXG4gICAqL1xuICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggPT0gJ251bWJlcicpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heCgwLCBsZW5ndGggKyBmcm9tSW5kZXgpIDogZnJvbUluZGV4IHx8IDApO1xuICAgIH0gZWxzZSBpZiAoZnJvbUluZGV4KSB7XG4gICAgICB2YXIgaW5kZXggPSBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIGFycmF5W2luZGV4XSA9PT0gdmFsdWUgPyBpbmRleCA6IC0xO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvciBsYXN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYSBjYWxsYmFjayBpc1xuICAgKiBwcm92aWRlZCBlbGVtZW50cyBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheSBhcmUgcmV0dXJuZWQgYXMgbG9uZyBhcyB0aGVcbiAgICogY2FsbGJhY2sgcmV0dXJucyB0cnVleS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgKlxuICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKlxuICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICogZWxzZSBgZmFsc2VgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxudW1iZXJ8c3RyaW5nfSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmV0dXJuLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICogIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50KHMpIG9mIGBhcnJheWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgKiAvLyA9PiAzXG4gICAqXG4gICAqIF8ubGFzdChbMSwgMiwgM10sIDIpO1xuICAgKiAvLyA9PiBbMiwgM11cbiAgICpcbiAgICogXy5sYXN0KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAqICAgcmV0dXJuIG51bSA+IDE7XG4gICAqIH0pO1xuICAgKiAvLyA9PiBbMiwgM11cbiAgICpcbiAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnbmEnIH1cbiAgICogXTtcbiAgICpcbiAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAqIF8ucGx1Y2soXy5sYXN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyksICduYW1lJyk7XG4gICAqIC8vID0+IFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICpcbiAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAqIF8ubGFzdChjaGFyYWN0ZXJzLCB7ICdlbXBsb3llcic6ICduYScgfSk7XG4gICAqIC8vID0+IFt7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICduYScgfV1cbiAgICovXG4gIGZ1bmN0aW9uIGxhc3QoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdmFyIG4gPSAwLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlIChpbmRleC0tICYmIGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICBuKys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBjYWxsYmFjaztcbiAgICAgIGlmIChuID09IG51bGwgfHwgdGhpc0FyZykge1xuICAgICAgICByZXR1cm4gYXJyYXkgPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNsaWNlKGFycmF5LCBuYXRpdmVNYXgoMCwgbGVuZ3RoIC0gbikpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAqIGBzdGFydGAgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgYGVuZGAuIElmIGBzdGFydGAgaXMgbGVzcyB0aGFuIGBzdG9wYCBhXG4gICAqIHplcm8tbGVuZ3RoIHJhbmdlIGlzIGNyZWF0ZWQgdW5sZXNzIGEgbmVnYXRpdmUgYHN0ZXBgIGlzIHNwZWNpZmllZC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgcmFuZ2UgYXJyYXkuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ucmFuZ2UoNCk7XG4gICAqIC8vID0+IFswLCAxLCAyLCAzXVxuICAgKlxuICAgKiBfLnJhbmdlKDEsIDUpO1xuICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICpcbiAgICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gICAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gICAqXG4gICAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAqXG4gICAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gICAqIC8vID0+IFsxLCAxLCAxXVxuICAgKlxuICAgKiBfLnJhbmdlKDApO1xuICAgKiAvLyA9PiBbXVxuICAgKi9cbiAgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG4gICAgc3RlcCA9IHR5cGVvZiBzdGVwID09ICdudW1iZXInID8gc3RlcCA6ICgrc3RlcCB8fCAxKTtcblxuICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIC8vIHVzZSBgQXJyYXkobGVuZ3RoKWAgc28gZW5naW5lcyBsaWtlIENoYWtyYSBhbmQgVjggYXZvaWQgc2xvd2VyIG1vZGVzXG4gICAgLy8gaHR0cDovL3lvdXR1LmJlL1hBcUlwR1U4WlprI3Q9MTdtMjVzXG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heCgwLCBjZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSkpLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBzdGFydDtcbiAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaCBhIHZhbHVlXG4gICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGEgZ2l2ZW4gc29ydGVkIGFycmF5IGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBzb3J0XG4gICAqIG9yZGVyIG9mIHRoZSBhcnJheS4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGZvclxuICAgKiBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlXG4gICAqIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICpcbiAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICpcbiAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAqIGVsc2UgYGZhbHNlYC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICogIGludG8gYGFycmF5YC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5zb3J0ZWRJbmRleChbMjAsIDMwLCA1MF0sIDQwKTtcbiAgICogLy8gPT4gMlxuICAgKlxuICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICogXy5zb3J0ZWRJbmRleChbeyAneCc6IDIwIH0sIHsgJ3gnOiAzMCB9LCB7ICd4JzogNTAgfV0sIHsgJ3gnOiA0MCB9LCAneCcpO1xuICAgKiAvLyA9PiAyXG4gICAqXG4gICAqIHZhciBkaWN0ID0ge1xuICAgKiAgICd3b3JkVG9OdW1iZXInOiB7ICd0d2VudHknOiAyMCwgJ3RoaXJ0eSc6IDMwLCAnZm91cnR5JzogNDAsICdmaWZ0eSc6IDUwIH1cbiAgICogfTtcbiAgICpcbiAgICogXy5zb3J0ZWRJbmRleChbJ3R3ZW50eScsICd0aGlydHknLCAnZmlmdHknXSwgJ2ZvdXJ0eScsIGZ1bmN0aW9uKHdvcmQpIHtcbiAgICogICByZXR1cm4gZGljdC53b3JkVG9OdW1iZXJbd29yZF07XG4gICAqIH0pO1xuICAgKiAvLyA9PiAyXG4gICAqXG4gICAqIF8uc29ydGVkSW5kZXgoWyd0d2VudHknLCAndGhpcnR5JywgJ2ZpZnR5J10sICdmb3VydHknLCBmdW5jdGlvbih3b3JkKSB7XG4gICAqICAgcmV0dXJuIHRoaXMud29yZFRvTnVtYmVyW3dvcmRdO1xuICAgKiB9LCBkaWN0KTtcbiAgICogLy8gPT4gMlxuICAgKi9cbiAgZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIHZhciBsb3cgPSAwLFxuICAgICAgICBoaWdoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiBsb3c7XG5cbiAgICAvLyBleHBsaWNpdGx5IHJlZmVyZW5jZSBgaWRlbnRpdHlgIGZvciBiZXR0ZXIgaW5saW5pbmcgaW4gRmlyZWZveFxuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpIDogaWRlbnRpdHk7XG4gICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSk7XG5cbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMTtcbiAgICAgIChjYWxsYmFjayhhcnJheVttaWRdKSA8IHZhbHVlKVxuICAgICAgICA/IGxvdyA9IG1pZCArIDFcbiAgICAgICAgOiBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5IHVzaW5nIHN0cmljdCBlcXVhbGl0eVxuICAgKiBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIHRoZSBhcnJheSBpcyBzb3J0ZWQsIHByb3ZpZGluZ1xuICAgKiBgdHJ1ZWAgZm9yIGBpc1NvcnRlZGAgd2lsbCB1c2UgYSBmYXN0ZXIgYWxnb3JpdGhtLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkXG4gICAqIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBjYWxsYmFjayBiZWZvcmUgdW5pcXVlbmVzc1xuICAgKiBpcyBjb21wdXRlZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgKlxuICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKlxuICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICogZWxzZSBgZmFsc2VgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBhbGlhcyB1bmlxdWVcbiAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaXNTb3J0ZWQ9ZmFsc2VdIEEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IGBhcnJheWAgaXMgc29ydGVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy51bmlxKFsxLCAyLCAxLCAzLCAxXSk7XG4gICAqIC8vID0+IFsxLCAyLCAzXVxuICAgKlxuICAgKiBfLnVuaXEoWzEsIDEsIDIsIDIsIDNdLCB0cnVlKTtcbiAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAqXG4gICAqIF8udW5pcShbJ0EnLCAnYicsICdDJywgJ2EnLCAnQicsICdjJ10sIGZ1bmN0aW9uKGxldHRlcikgeyByZXR1cm4gbGV0dGVyLnRvTG93ZXJDYXNlKCk7IH0pO1xuICAgKiAvLyA9PiBbJ0EnLCAnYicsICdDJ11cbiAgICpcbiAgICogXy51bmlxKFsxLCAyLjUsIDMsIDEuNSwgMiwgMy41XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgKiAvLyA9PiBbMSwgMi41LCAzXVxuICAgKlxuICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICogXy51bmlxKFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAqL1xuICBmdW5jdGlvbiB1bmlxKGFycmF5LCBpc1NvcnRlZCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAvLyBqdWdnbGUgYXJndW1lbnRzXG4gICAgaWYgKHR5cGVvZiBpc1NvcnRlZCAhPSAnYm9vbGVhbicgJiYgaXNTb3J0ZWQgIT0gbnVsbCkge1xuICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrO1xuICAgICAgY2FsbGJhY2sgPSAodHlwZW9mIGlzU29ydGVkICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2lzU29ydGVkXSA9PT0gYXJyYXkpID8gbnVsbCA6IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2VVbmlxKGFycmF5LCBpc1NvcnRlZCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCBwcm92aWRlZCB2YWx1ZXMgdXNpbmcgc3RyaWN0IGVxdWFsaXR5IGZvclxuICAgKiBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWx0ZXIuXG4gICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ud2l0aG91dChbMSwgMiwgMSwgMCwgMywgMSwgNF0sIDAsIDEpO1xuICAgKiAvLyA9PiBbMiwgMywgNF1cbiAgICovXG4gIGZ1bmN0aW9uIHdpdGhvdXQoYXJyYXkpIHtcbiAgICByZXR1cm4gYmFzZURpZmZlcmVuY2UoYXJyYXksIHNsaWNlKGFyZ3VtZW50cywgMSkpO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgXG4gICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCBwcmVwZW5kcyBhbnkgYWRkaXRpb25hbCBgYmluZGAgYXJndW1lbnRzIHRvIHRob3NlXG4gICAqIHByb3ZpZGVkIHRvIHRoZSBib3VuZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIGZ1bmMgPSBmdW5jdGlvbihncmVldGluZykge1xuICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMubmFtZTtcbiAgICogfTtcbiAgICpcbiAgICogZnVuYyA9IF8uYmluZChmdW5jLCB7ICduYW1lJzogJ2ZyZWQnIH0sICdoaScpO1xuICAgKiBmdW5jKCk7XG4gICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgKi9cbiAgZnVuY3Rpb24gYmluZChmdW5jLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyXG4gICAgICA/IGNyZWF0ZVdyYXBwZXIoZnVuYywgMTcsIHNsaWNlKGFyZ3VtZW50cywgMiksIG51bGwsIHRoaXNBcmcpXG4gICAgICA6IGNyZWF0ZVdyYXBwZXIoZnVuYywgMSwgbnVsbCwgbnVsbCwgdGhpc0FyZyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBkZWxheSB0aGUgZXhlY3V0aW9uIG9mIGBmdW5jYCB1bnRpbCBhZnRlclxuICAgKiBgd2FpdGAgbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIGl0IHdhcyBpbnZva2VkLlxuICAgKiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvIGluZGljYXRlIHRoYXQgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uXG4gICAqIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gU3Vic2VxdWVudCBjYWxsc1xuICAgKiB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGNhbGwuXG4gICAqXG4gICAqIE5vdGU6IElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAgYGZ1bmNgIHdpbGwgYmUgY2FsbGVkXG4gICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gaXNcbiAgICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF0gVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGNhbGxlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAvLyBhdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4XG4gICAqIHZhciBsYXp5TGF5b3V0ID0gXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCk7XG4gICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBsYXp5TGF5b3V0KTtcbiAgICpcbiAgICogLy8gZXhlY3V0ZSBgc2VuZE1haWxgIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHNcbiAgICogalF1ZXJ5KCcjcG9zdGJveCcpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gZW5zdXJlIGBiYXRjaExvZ2AgaXMgZXhlY3V0ZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHNcbiAgICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICAgKiBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwge1xuICAgKiAgICdtYXhXYWl0JzogMTAwMFxuICAgKiB9LCBmYWxzZSk7XG4gICAqL1xuICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGFyZ3MsXG4gICAgICAgIG1heFRpbWVvdXRJZCxcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBzdGFtcCxcbiAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgdGltZW91dElkLFxuICAgICAgICB0cmFpbGluZ0NhbGwsXG4gICAgICAgIGxhc3RDYWxsZWQgPSAwLFxuICAgICAgICBtYXhXYWl0ID0gZmFsc2UsXG4gICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICB9XG4gICAgd2FpdCA9IG5hdGl2ZU1heCgwLCB3YWl0KSB8fCAwO1xuICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICB2YXIgbGVhZGluZyA9IHRydWU7XG4gICAgICB0cmFpbGluZyA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIGxlYWRpbmcgPSBvcHRpb25zLmxlYWRpbmc7XG4gICAgICBtYXhXYWl0ID0gJ21heFdhaXQnIGluIG9wdGlvbnMgJiYgKG5hdGl2ZU1heCh3YWl0LCBvcHRpb25zLm1heFdhaXQpIHx8IDApO1xuICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgfVxuICAgIHZhciBkZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3coKSAtIHN0YW1wKTtcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCkge1xuICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzQ2FsbGVkID0gdHJhaWxpbmdDYWxsO1xuICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpc0NhbGxlZCkge1xuICAgICAgICAgIGxhc3RDYWxsZWQgPSBub3coKTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG1heERlbGF5ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICB9XG4gICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAodHJhaWxpbmcgfHwgKG1heFdhaXQgIT09IHdhaXQpKSB7XG4gICAgICAgIGxhc3RDYWxsZWQgPSBub3coKTtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgc3RhbXAgPSBub3coKTtcbiAgICAgIHRoaXNBcmcgPSB0aGlzO1xuICAgICAgdHJhaWxpbmdDYWxsID0gdHJhaWxpbmcgJiYgKHRpbWVvdXRJZCB8fCAhbGVhZGluZyk7XG5cbiAgICAgIGlmIChtYXhXYWl0ID09PSBmYWxzZSkge1xuICAgICAgICB2YXIgbGVhZGluZ0NhbGwgPSBsZWFkaW5nICYmICF0aW1lb3V0SWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIW1heFRpbWVvdXRJZCAmJiAhbGVhZGluZykge1xuICAgICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVtYWluaW5nID0gbWF4V2FpdCAtIChzdGFtcCAtIGxhc3RDYWxsZWQpLFxuICAgICAgICAgICAgaXNDYWxsZWQgPSByZW1haW5pbmcgPD0gMDtcblxuICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgIG1heFRpbWVvdXRJZCA9IHNldFRpbWVvdXQobWF4RGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQ2FsbGVkICYmIHRpbWVvdXRJZCkge1xuICAgICAgICB0aW1lb3V0SWQgPSBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCF0aW1lb3V0SWQgJiYgd2FpdCAhPT0gbWF4V2FpdCkge1xuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHdhaXQpO1xuICAgICAgfVxuICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XG4gICAgICAgIGlzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0NhbGxlZCAmJiAhdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGV4ZWN1dGVkLCB3aWxsIG9ubHkgY2FsbCB0aGUgYGZ1bmNgIGZ1bmN0aW9uXG4gICAqIGF0IG1vc3Qgb25jZSBwZXIgZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gUHJvdmlkZSBhbiBvcHRpb25zIG9iamVjdCB0b1xuICAgKiBpbmRpY2F0ZSB0aGF0IGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZVxuICAgKiBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsXG4gICAqIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBjYWxsLlxuICAgKlxuICAgKiBOb3RlOiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgIGBmdW5jYCB3aWxsIGJlIGNhbGxlZFxuICAgKiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGlzXG4gICAqIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBleGVjdXRpb25zIHRvLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogLy8gYXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZ1xuICAgKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKTtcbiAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIHRocm90dGxlZCk7XG4gICAqXG4gICAqIC8vIGV4ZWN1dGUgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlc1xuICAgKiBqUXVlcnkoJy5pbnRlcmFjdGl2ZScpLm9uKCdjbGljaycsIF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7XG4gICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICogfSkpO1xuICAgKi9cbiAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgIGxlYWRpbmcgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgfVxuICAgIGRlYm91bmNlT3B0aW9ucy5sZWFkaW5nID0gbGVhZGluZztcbiAgICBkZWJvdW5jZU9wdGlvbnMubWF4V2FpdCA9IHdhaXQ7XG4gICAgZGVib3VuY2VPcHRpb25zLnRyYWlsaW5nID0gdHJhaWxpbmc7XG5cbiAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwgZGVib3VuY2VPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBgdmFsdWVgIHRvIHRoZSB3cmFwcGVyIGZ1bmN0aW9uIGFzIGl0c1xuICAgKiBmaXJzdCBhcmd1bWVudC4gQWRkaXRpb25hbCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGZ1bmN0aW9uIGFyZSBhcHBlbmRlZFxuICAgKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbi4gVGhlIHdyYXBwZXIgaXMgZXhlY3V0ZWQgd2l0aFxuICAgKiB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIHAgPSBfLndyYXAoXy5lc2NhcGUsIGZ1bmN0aW9uKGZ1bmMsIHRleHQpIHtcbiAgICogICByZXR1cm4gJzxwPicgKyBmdW5jKHRleHQpICsgJzwvcD4nO1xuICAgKiB9KTtcbiAgICpcbiAgICogcCgnRnJlZCwgV2lsbWEsICYgUGViYmxlcycpO1xuICAgKiAvLyA9PiAnPHA+RnJlZCwgV2lsbWEsICZhbXA7IFBlYmJsZXM8L3A+J1xuICAgKi9cbiAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKHdyYXBwZXIsIDE2LCBbdmFsdWVdKTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyBhIGNhbGxiYWNrIGJvdW5kIHRvIGFuIG9wdGlvbmFsIGB0aGlzQXJnYC4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHlcbiAgICogbmFtZSB0aGUgY3JlYXRlZCBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gZWxlbWVudC5cbiAgICogSWYgYGZ1bmNgIGlzIGFuIG9iamVjdCB0aGUgY3JlYXRlZCBjYWxsYmFjayB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzXG4gICAqIHRoYXQgY29udGFpbiB0aGUgZXF1aXZhbGVudCBvYmplY3QgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHdpbGwgcmV0dXJuIGBmYWxzZWAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgKiBAcGFyYW0geyp9IFtmdW5jPWlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJnQ291bnRdIFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRoZSBjYWxsYmFjayBhY2NlcHRzLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAqIF07XG4gICAqXG4gICAqIC8vIHdyYXAgdG8gY3JlYXRlIGN1c3RvbSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAqIF8uY3JlYXRlQ2FsbGJhY2sgPSBfLndyYXAoXy5jcmVhdGVDYWxsYmFjaywgZnVuY3Rpb24oZnVuYywgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICogICB2YXIgbWF0Y2ggPSAvXiguKz8pX18oW2dsXXQpKC4rKSQvLmV4ZWMoY2FsbGJhY2spO1xuICAgKiAgIHJldHVybiAhbWF0Y2ggPyBmdW5jKGNhbGxiYWNrLCB0aGlzQXJnKSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgKiAgICAgcmV0dXJuIG1hdGNoWzJdID09ICdndCcgPyBvYmplY3RbbWF0Y2hbMV1dID4gbWF0Y2hbM10gOiBvYmplY3RbbWF0Y2hbMV1dIDwgbWF0Y2hbM107XG4gICAqICAgfTtcbiAgICogfSk7XG4gICAqXG4gICAqIF8uZmlsdGVyKGNoYXJhY3RlcnMsICdhZ2VfX2d0MzgnKTtcbiAgICogLy8gPT4gW3sgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9XVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBmdW5jO1xuICAgIGlmIChmdW5jID09IG51bGwgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gYmFzZUNyZWF0ZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KTtcbiAgICB9XG4gICAgLy8gaGFuZGxlIFwiXy5wbHVja1wiIHN0eWxlIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICBpZiAodHlwZSAhPSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHByb3BlcnR5KGZ1bmMpO1xuICAgIH1cbiAgICB2YXIgcHJvcHMgPSBrZXlzKGZ1bmMpLFxuICAgICAgICBrZXkgPSBwcm9wc1swXSxcbiAgICAgICAgYSA9IGZ1bmNba2V5XTtcblxuICAgIC8vIGhhbmRsZSBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgaWYgKHByb3BzLmxlbmd0aCA9PSAxICYmIGEgPT09IGEgJiYgIWlzT2JqZWN0KGEpKSB7XG4gICAgICAvLyBmYXN0IHBhdGggdGhlIGNvbW1vbiBjYXNlIG9mIHByb3ZpZGluZyBhbiBvYmplY3Qgd2l0aCBhIHNpbmdsZVxuICAgICAgLy8gcHJvcGVydHkgY29udGFpbmluZyBhIHByaW1pdGl2ZSB2YWx1ZVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgYiA9IG9iamVjdFtrZXldO1xuICAgICAgICByZXR1cm4gYSA9PT0gYiAmJiAoYSAhPT0gMCB8fCAoMSAvIGEgPT0gMSAvIGIpKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIShyZXN1bHQgPSBiYXNlSXNFcXVhbChvYmplY3RbcHJvcHNbbGVuZ3RoXV0sIGZ1bmNbcHJvcHNbbGVuZ3RoXV0sIG51bGwsIHRydWUpKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gaXQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICogXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3Q7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgZnVuY3Rpb24gcHJvcGVydGllcyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICogSWYgYG9iamVjdGAgaXMgYSBmdW5jdGlvbiBtZXRob2RzIHdpbGwgYmUgYWRkZWQgdG8gaXRzIHByb3RvdHlwZSBhcyB3ZWxsLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9bG9kYXNoXSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIGZ1bmN0aW9ucyB0byBhZGQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoYWluPXRydWVdIFNwZWNpZnkgd2hldGhlciB0aGUgZnVuY3Rpb25zIGFkZGVkIGFyZSBjaGFpbmFibGUuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAqICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKS50b0xvd2VyQ2FzZSgpO1xuICAgKiB9XG4gICAqXG4gICAqIF8ubWl4aW4oeyAnY2FwaXRhbGl6ZSc6IGNhcGl0YWxpemUgfSk7XG4gICAqIF8uY2FwaXRhbGl6ZSgnZnJlZCcpO1xuICAgKiAvLyA9PiAnRnJlZCdcbiAgICpcbiAgICogXygnZnJlZCcpLmNhcGl0YWxpemUoKS52YWx1ZSgpO1xuICAgKiAvLyA9PiAnRnJlZCdcbiAgICpcbiAgICogXy5taXhpbih7ICdjYXBpdGFsaXplJzogY2FwaXRhbGl6ZSB9LCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuICAgKiBfKCdmcmVkJykuY2FwaXRhbGl6ZSgpO1xuICAgKiAvLyA9PiAnRnJlZCdcbiAgICovXG4gIGZ1bmN0aW9uIG1peGluKG9iamVjdCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgdmFyIGNoYWluID0gdHJ1ZSxcbiAgICAgICAgbWV0aG9kTmFtZXMgPSBzb3VyY2UgJiYgZnVuY3Rpb25zKHNvdXJjZSk7XG5cbiAgICBpZiAoIXNvdXJjZSB8fCAoIW9wdGlvbnMgJiYgIW1ldGhvZE5hbWVzLmxlbmd0aCkpIHtcbiAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IHNvdXJjZTtcbiAgICAgIH1cbiAgICAgIGN0b3IgPSBsb2Rhc2hXcmFwcGVyO1xuICAgICAgc291cmNlID0gb2JqZWN0O1xuICAgICAgb2JqZWN0ID0gbG9kYXNoO1xuICAgICAgbWV0aG9kTmFtZXMgPSBmdW5jdGlvbnMoc291cmNlKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICBjaGFpbiA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykgJiYgJ2NoYWluJyBpbiBvcHRpb25zKSB7XG4gICAgICBjaGFpbiA9IG9wdGlvbnMuY2hhaW47XG4gICAgfVxuICAgIHZhciBjdG9yID0gb2JqZWN0LFxuICAgICAgICBpc0Z1bmMgPSBpc0Z1bmN0aW9uKGN0b3IpO1xuXG4gICAgZm9yRWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBvYmplY3RbbWV0aG9kTmFtZV0gPSBzb3VyY2VbbWV0aG9kTmFtZV07XG4gICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgIGN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICAgICAgYXJncyA9IFt2YWx1ZV07XG5cbiAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkob2JqZWN0LCBhcmdzKTtcbiAgICAgICAgICBpZiAoY2hhaW4gfHwgY2hhaW5BbGwpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gcmVzdWx0ICYmIGlzT2JqZWN0KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgY3RvcihyZXN1bHQpO1xuICAgICAgICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IGNoYWluQWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbm8tb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICogXy5ub29wKG9iamVjdCkgPT09IHVuZGVmaW5lZDtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAvLyBubyBvcGVyYXRpb24gcGVyZm9ybWVkXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgVW5peCBlcG9jaFxuICAgKiAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBzdGFtcCA9IF8ubm93KCk7XG4gICAqIF8uZGVmZXIoZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7IH0pO1xuICAgKiAvLyA9PiBsb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICovXG4gIHZhciBub3cgPSBpc05hdGl2ZShub3cgPSBEYXRlLm5vdykgJiYgbm93IHx8IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFwiXy5wbHVja1wiIHN0eWxlIGZ1bmN0aW9uLCB3aGljaCByZXR1cm5zIHRoZSBga2V5YCB2YWx1ZSBvZiBhXG4gICAqIGdpdmVuIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJldHJpZXZlLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAqIF07XG4gICAqXG4gICAqIHZhciBnZXROYW1lID0gXy5wcm9wZXJ0eSgnbmFtZScpO1xuICAgKlxuICAgKiBfLm1hcChjaGFyYWN0ZXJzLCBnZXROYW1lKTtcbiAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAqXG4gICAqIF8uc29ydEJ5KGNoYXJhY3RlcnMsIGdldE5hbWUpO1xuICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSwgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfV1cbiAgICovXG4gIGZ1bmN0aW9uIHByb3BlcnR5KGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICB9O1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3QgdGhhdCB3cmFwcyB0aGUgZ2l2ZW4gdmFsdWUgd2l0aCBleHBsaWNpdFxuICAgKiBtZXRob2QgY2hhaW5pbmcgZW5hYmxlZC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICogXTtcbiAgICpcbiAgICogdmFyIHlvdW5nZXN0ID0gXy5jaGFpbihjaGFyYWN0ZXJzKVxuICAgKiAgICAgLnNvcnRCeSgnYWdlJylcbiAgICogICAgIC5tYXAoZnVuY3Rpb24oY2hyKSB7IHJldHVybiBjaHIubmFtZSArICcgaXMgJyArIGNoci5hZ2U7IH0pXG4gICAqICAgICAuZmlyc3QoKVxuICAgKiAgICAgLnZhbHVlKCk7XG4gICAqIC8vID0+ICdwZWJibGVzIGlzIDEnXG4gICAqL1xuICBmdW5jdGlvbiBjaGFpbih2YWx1ZSkge1xuICAgIHZhbHVlID0gbmV3IGxvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgIHZhbHVlLl9fY2hhaW5fXyA9IHRydWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgZXhwbGljaXQgbWV0aG9kIGNoYWluaW5nIG9uIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICpcbiAgICogQG5hbWUgY2hhaW5cbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAqIF07XG4gICAqXG4gICAqIC8vIHdpdGhvdXQgZXhwbGljaXQgY2hhaW5pbmdcbiAgICogXyhjaGFyYWN0ZXJzKS5maXJzdCgpO1xuICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAqXG4gICAqIC8vIHdpdGggZXhwbGljaXQgY2hhaW5pbmdcbiAgICogXyhjaGFyYWN0ZXJzKS5jaGFpbigpXG4gICAqICAgLmZpcnN0KClcbiAgICogICAucGljaygnYWdlJylcbiAgICogICAudmFsdWUoKTtcbiAgICogLy8gPT4geyAnYWdlJzogMzYgfVxuICAgKi9cbiAgZnVuY3Rpb24gd3JhcHBlckNoYWluKCkge1xuICAgIHRoaXMuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyB0aGUgYHRvU3RyaW5nYCByZXN1bHQgb2YgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAqXG4gICAqIEBuYW1lIHRvU3RyaW5nXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcgcmVzdWx0LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfKFsxLCAyLCAzXSkudG9TdHJpbmcoKTtcbiAgICogLy8gPT4gJzEsMiwzJ1xuICAgKi9cbiAgZnVuY3Rpb24gd3JhcHBlclRvU3RyaW5nKCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy5fX3dyYXBwZWRfXyk7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdHMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAqXG4gICAqIEBuYW1lIHZhbHVlT2ZcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGFsaWFzIHZhbHVlXG4gICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXyhbMSwgMiwgM10pLnZhbHVlT2YoKTtcbiAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAqL1xuICBmdW5jdGlvbiB3cmFwcGVyVmFsdWVPZigpIHtcbiAgICByZXR1cm4gdGhpcy5fX3dyYXBwZWRfXztcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIGxvZGFzaC5hc3NpZ24gPSBhc3NpZ247XG4gIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgbG9kYXNoLmNoYWluID0gY2hhaW47XG4gIGxvZGFzaC5jcmVhdGUgPSBjcmVhdGU7XG4gIGxvZGFzaC5jcmVhdGVDYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrO1xuICBsb2Rhc2guZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgbG9kYXNoLmZpbHRlciA9IGZpbHRlcjtcbiAgbG9kYXNoLmZsYXR0ZW4gPSBmbGF0dGVuO1xuICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gIGxvZGFzaC5mb3JJbiA9IGZvckluO1xuICBsb2Rhc2guZm9yT3duID0gZm9yT3duO1xuICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gIGxvZGFzaC5tYXAgPSBtYXA7XG4gIGxvZGFzaC5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICBsb2Rhc2gucmFuZ2UgPSByYW5nZTtcbiAgbG9kYXNoLnJlamVjdCA9IHJlamVjdDtcbiAgbG9kYXNoLnNodWZmbGUgPSBzaHVmZmxlO1xuICBsb2Rhc2guc29ydEJ5ID0gc29ydEJ5O1xuICBsb2Rhc2gudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgbG9kYXNoLnVuaXEgPSB1bmlxO1xuICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG4gIGxvZGFzaC53cmFwID0gd3JhcDtcblxuICAvLyBhZGQgYWxpYXNlc1xuICBsb2Rhc2guY29sbGVjdCA9IG1hcDtcbiAgbG9kYXNoLmVhY2ggPSBmb3JFYWNoO1xuICBsb2Rhc2guZXh0ZW5kID0gYXNzaWduO1xuICBsb2Rhc2gubWV0aG9kcyA9IGZ1bmN0aW9ucztcbiAgbG9kYXNoLnNlbGVjdCA9IGZpbHRlcjtcbiAgbG9kYXNoLnVuaXF1ZSA9IHVuaXE7XG5cbiAgLy8gYWRkIGZ1bmN0aW9ucyB0byBgbG9kYXNoLnByb3RvdHlwZWBcbiAgbWl4aW4obG9kYXNoKTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBhZGQgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZ1xuICBsb2Rhc2guY2xvbmUgPSBjbG9uZTtcbiAgbG9kYXNoLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcbiAgbG9kYXNoLmNvbnRhaW5zID0gY29udGFpbnM7XG4gIGxvZGFzaC5maW5kID0gZmluZDtcbiAgbG9kYXNoLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gIGxvZGFzaC5pbmRleE9mID0gaW5kZXhPZjtcbiAgbG9kYXNoLmlzQXJndW1lbnRzID0gaXNBcmd1bWVudHM7XG4gIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xuICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG4gIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcbiAgbG9kYXNoLm5vb3AgPSBub29wO1xuICBsb2Rhc2gubm93ID0gbm93O1xuICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gIGxvZGFzaC5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuXG4gIGxvZGFzaC5kZXRlY3QgPSBmaW5kO1xuICBsb2Rhc2guZmluZFdoZXJlID0gZmluZDtcbiAgbG9kYXNoLmluY2x1ZGUgPSBjb250YWlucztcblxuICBtaXhpbihmdW5jdGlvbigpIHtcbiAgICB2YXIgc291cmNlID0ge31cbiAgICBmb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICBpZiAoIWxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgc291cmNlW21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc291cmNlO1xuICB9KCksIGZhbHNlKTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gIGxvZGFzaC5zYW1wbGUgPSBzYW1wbGU7XG5cbiAgZm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgIHZhciBjYWxsYmFja2FibGUgPSBtZXRob2ROYW1lICE9PSAnc2FtcGxlJztcbiAgICBpZiAoIWxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV09IGZ1bmN0aW9uKG4sIGd1YXJkKSB7XG4gICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYyh0aGlzLl9fd3JhcHBlZF9fLCBuLCBndWFyZCk7XG5cbiAgICAgICAgcmV0dXJuICFjaGFpbkFsbCAmJiAobiA9PSBudWxsIHx8IChndWFyZCAmJiAhKGNhbGxiYWNrYWJsZSAmJiB0eXBlb2YgbiA9PSAnZnVuY3Rpb24nKSkpXG4gICAgICAgICAgPyByZXN1bHRcbiAgICAgICAgICA6IG5ldyBsb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBUaGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHR5cGUgc3RyaW5nXG4gICAqL1xuICBsb2Rhc2guVkVSU0lPTiA9ICcyLjQuMSc7XG5cbiAgLy8gYWRkIFwiQ2hhaW5pbmdcIiBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXJcbiAgbG9kYXNoLnByb3RvdHlwZS5jaGFpbiA9IHdyYXBwZXJDaGFpbjtcbiAgbG9kYXNoLnByb3RvdHlwZS50b1N0cmluZyA9IHdyYXBwZXJUb1N0cmluZztcbiAgbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZU9mO1xuICBsb2Rhc2gucHJvdG90eXBlLnZhbHVlT2YgPSB3cmFwcGVyVmFsdWVPZjtcblxuICAvLyBhZGQgYEFycmF5YCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlc1xuICBiYXNlRWFjaChbJ2pvaW4nLCAncG9wJywgJ3NoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgZnVuYyA9IGFycmF5UmVmW21ldGhvZE5hbWVdO1xuICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcy5fX3dyYXBwZWRfXywgYXJndW1lbnRzKTtcblxuICAgICAgcmV0dXJuIGNoYWluQWxsXG4gICAgICAgID8gbmV3IGxvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbClcbiAgICAgICAgOiByZXN1bHQ7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHRoZSBleGlzdGluZyB3cmFwcGVkIHZhbHVlXG4gIGJhc2VFYWNoKFsncHVzaCcsICdyZXZlcnNlJywgJ3NvcnQnLCAndW5zaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgdmFyIGZ1bmMgPSBhcnJheVJlZlttZXRob2ROYW1lXTtcbiAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jLmFwcGx5KHRoaXMuX193cmFwcGVkX18sIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9KTtcblxuICAvLyBhZGQgYEFycmF5YCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gbmV3IHdyYXBwZWQgdmFsdWVzXG4gIGJhc2VFYWNoKFsnY29uY2F0JywgJ3NsaWNlJywgJ3NwbGljZSddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgdmFyIGZ1bmMgPSBhcnJheVJlZlttZXRob2ROYW1lXTtcbiAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IGxvZGFzaFdyYXBwZXIoZnVuYy5hcHBseSh0aGlzLl9fd3JhcHBlZF9fLCBhcmd1bWVudHMpLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gYXZvaWQgYXJyYXktbGlrZSBvYmplY3QgYnVncyB3aXRoIGBBcnJheSNzaGlmdGAgYW5kIGBBcnJheSNzcGxpY2VgXG4gIC8vIGluIElFIDwgOSwgRmlyZWZveCA8IDEwLCBOYXJ3aGFsLCBhbmQgUmluZ29KU1xuICBpZiAoIXN1cHBvcnQuc3BsaWNlT2JqZWN0cykge1xuICAgIGJhc2VFYWNoKFsncG9wJywgJ3NoaWZ0JywgJ3NwbGljZSddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UmVmW21ldGhvZE5hbWVdLFxuICAgICAgICAgIGlzU3BsaWNlID0gbWV0aG9kTmFtZSA9PSAnc3BsaWNlJztcblxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSB2YWx1ZVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNoYWluQWxsIHx8IGlzU3BsaWNlKVxuICAgICAgICAgID8gbmV3IGxvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbClcbiAgICAgICAgICA6IHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBzb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzIGxpa2Ugci5qcyBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIExvLURhc2ggdG8gdGhlIGdsb2JhbCBvYmplY3QgZXZlbiB3aGVuIGFuIEFNRCBsb2FkZXIgaXMgcHJlc2VudCBpblxuICAgIC8vIGNhc2UgTG8tRGFzaCBpcyBsb2FkZWQgd2l0aCBhIFJlcXVpcmVKUyBzaGltIGNvbmZpZy5cbiAgICAvLyBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9hcGkuaHRtbCNjb25maWctc2hpbVxuICAgIHJvb3QuXyA9IGxvZGFzaDtcblxuICAgIC8vIGRlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvLCB0aHJvdWdoIHBhdGggbWFwcGluZywgaXQgY2FuIGJlXG4gICAgLy8gcmVmZXJlbmNlZCBhcyB0aGUgXCJ1bmRlcnNjb3JlXCIgbW9kdWxlXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGxvZGFzaDtcbiAgICB9KTtcbiAgfVxuICAvLyBjaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBhbiBgZXhwb3J0c2Agb2JqZWN0XG4gIGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcbiAgICAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlNcbiAgICBpZiAobW9kdWxlRXhwb3J0cykge1xuICAgICAgKGZyZWVNb2R1bGUuZXhwb3J0cyA9IGxvZGFzaCkuXyA9IGxvZGFzaDtcbiAgICB9XG4gICAgLy8gaW4gTmFyd2hhbCBvciBSaGlubyAtcmVxdWlyZVxuICAgIGVsc2Uge1xuICAgICAgZnJlZUV4cG9ydHMuXyA9IGxvZGFzaDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gaW4gYSBicm93c2VyIG9yIFJoaW5vXG4gICAgcm9vdC5fID0gbG9kYXNoO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwiLyohIEhhbW1lci5KUyAtIHYxLjEuMyAtIDIwMTQtMDUtMjJcbiAqIGh0dHA6Ly9laWdodG1lZGlhLmdpdGh1Yi5pby9oYW1tZXIuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgSm9yaWsgVGFuZ2VsZGVyIDxqLnRhbmdlbGRlckBnbWFpbC5jb20+O1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlICovXG5cbihmdW5jdGlvbih3aW5kb3csIHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG1haW5cbiAqIEBtb2R1bGUgaGFtbWVyXG4gKlxuICogQGNsYXNzIEhhbW1lclxuICogQHN0YXRpY1xuICovXG5cbi8qKlxuICogSGFtbWVyLCB1c2UgdGhpcyB0byBjcmVhdGUgaW5zdGFuY2VzXG4gKiBgYGBgXG4gKiB2YXIgaGFtbWVydGltZSA9IG5ldyBIYW1tZXIobXlFbGVtZW50KTtcbiAqIGBgYGBcbiAqXG4gKiBAbWV0aG9kIEhhbW1lclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICogQHJldHVybiB7SGFtbWVyLkluc3RhbmNlfVxuICovXG52YXIgSGFtbWVyID0gZnVuY3Rpb24gSGFtbWVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEhhbW1lci5JbnN0YW5jZShlbGVtZW50LCBvcHRpb25zIHx8IHt9KTtcbn07XG5cbi8qKlxuICogdmVyc2lvbiwgYXMgZGVmaW5lZCBpbiBwYWNrYWdlLmpzb25cbiAqIHRoZSB2YWx1ZSB3aWxsIGJlIHNldCBhdCBlYWNoIGJ1aWxkXG4gKiBAcHJvcGVydHkgVkVSU0lPTlxuICogQGZpbmFsXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5IYW1tZXIuVkVSU0lPTiA9ICcxLjEuMyc7XG5cbi8qKlxuICogZGVmYXVsdCBzZXR0aW5ncy5cbiAqIG1vcmUgc2V0dGluZ3MgYXJlIGRlZmluZWQgcGVyIGdlc3R1cmUgYXQgYC9nZXN0dXJlc2AuIEVhY2ggZ2VzdHVyZSBjYW4gYmUgZGlzYWJsZWQvZW5hYmxlZFxuICogYnkgc2V0dGluZyBpdCdzIG5hbWUgKGxpa2UgYHN3aXBlYCkgdG8gZmFsc2UuXG4gKiBZb3UgY2FuIHNldCB0aGUgZGVmYXVsdHMgZm9yIGFsbCBpbnN0YW5jZXMgYnkgY2hhbmdpbmcgdGhpcyBvYmplY3QgYmVmb3JlIGNyZWF0aW5nIGFuIGluc3RhbmNlLlxuICogQGV4YW1wbGVcbiAqIGBgYGBcbiAqICBIYW1tZXIuZGVmYXVsdHMuZHJhZyA9IGZhbHNlO1xuICogIEhhbW1lci5kZWZhdWx0cy5iZWhhdmlvci50b3VjaEFjdGlvbiA9ICdwYW4teSc7XG4gKiAgZGVsZXRlIEhhbW1lci5kZWZhdWx0cy5iZWhhdmlvci51c2VyU2VsZWN0O1xuICogYGBgYFxuICogQHByb3BlcnR5IGRlZmF1bHRzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5IYW1tZXIuZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogdGhpcyBzZXR0aW5nIG9iamVjdCBhZGRzIHN0eWxlcyBhbmQgYXR0cmlidXRlcyB0byB0aGUgZWxlbWVudCB0byBwcmV2ZW50IHRoZSBicm93c2VyIGZyb20gZG9pbmdcbiAgICAgKiBpdHMgbmF0aXZlIGJlaGF2aW9yLiBUaGUgY3NzIHByb3BlcnRpZXMgYXJlIGF1dG8gcHJlZml4ZWQgZm9yIHRoZSBicm93c2VycyB3aGVuIG5lZWRlZC5cbiAgICAgKiBAcHJvcGVydHkgZGVmYXVsdHMuYmVoYXZpb3JcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGJlaGF2aW9yOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyB0ZXh0IHNlbGVjdGlvbiB0byBpbXByb3ZlIHRoZSBkcmFnZ2luZyBnZXN0dXJlLiBXaGVuIHRoZSB2YWx1ZSBpcyBgbm9uZWAgaXQgYWxzbyBzZXRzXG4gICAgICAgICAqIGBvbnNlbGVjdHN0YXJ0PWZhbHNlYCBmb3IgSUUgb24gdGhlIGVsZW1lbnQuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICogQHByb3BlcnR5IGRlZmF1bHRzLmJlaGF2aW9yLnVzZXJTZWxlY3RcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIGFuZCBob3cgYSBnaXZlbiByZWdpb24gY2FuIGJlIG1hbmlwdWxhdGVkIGJ5IHRoZSB1c2VyIChmb3IgaW5zdGFuY2UsIGJ5IHBhbm5pbmcgb3Igem9vbWluZykuXG4gICAgICAgICAqIFVzZWQgYnkgQ2hyb21lIDM1PiBhbmQgSUUxMD4uIEJ5IGRlZmF1bHQgdGhpcyBtYWtlcyB0aGUgZWxlbWVudCBibG9ja2luZyBhbnkgdG91Y2ggZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkZWZhdWx0cy5iZWhhdmlvci50b3VjaEFjdGlvblxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdDogJ3Bhbi15J1xuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hBY3Rpb246ICdwYW4teScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRoZSBkZWZhdWx0IGNhbGxvdXQgc2hvd24gd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQuXG4gICAgICAgICAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xuICAgICAgICAgKiBhIGNhbGxvdXQgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGluay4gVGhpcyBwcm9wZXJ0eSBhbGxvd3MgeW91IHRvIGRpc2FibGUgdGhhdCBjYWxsb3V0LlxuICAgICAgICAgKiBAcHJvcGVydHkgZGVmYXVsdHMuYmVoYXZpb3IudG91Y2hDYWxsb3V0XG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxuICAgICAgICAgKiBAcHJvcGVydHkgZGVmYXVsdHMuYmVoYXZpb3IuY29udGVudFpvb21pbmdcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICBjb250ZW50Wm9vbWluZzogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhhdCBhbiBlbnRpcmUgZWxlbWVudCBzaG91bGQgYmUgZHJhZ2dhYmxlIGluc3RlYWQgb2YgaXRzIGNvbnRlbnRzLlxuICAgICAgICAgKiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkZWZhdWx0cy5iZWhhdmlvci51c2VyRHJhZ1xuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHVzZXJEcmFnOiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJyaWRlcyB0aGUgaGlnaGxpZ2h0IGNvbG9yIHNob3duIHdoZW4gdGhlIHVzZXIgdGFwcyBhIGxpbmsgb3IgYSBKYXZhU2NyaXB0XG4gICAgICAgICAqIGNsaWNrYWJsZSBlbGVtZW50IGluIFNhZmFyaSBvbiBpUGhvbmUuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHlvdSBkb24ndCBzcGVjaWZ5IGFuIGFscGhhIHZhbHVlLCBTYWZhcmkgb24gaVBob25lIGFwcGxpZXMgYSBkZWZhdWx0IGFscGhhIHZhbHVlXG4gICAgICAgICAqIHRvIHRoZSBjb2xvci4gVG8gZGlzYWJsZSB0YXAgaGlnaGxpZ2h0aW5nLCBzZXQgdGhlIGFscGhhIHZhbHVlIHRvIDAgKGludmlzaWJsZSkuXG4gICAgICAgICAqIElmIHlvdSBzZXQgdGhlIGFscGhhIHZhbHVlIHRvIDEuMCAob3BhcXVlKSwgdGhlIGVsZW1lbnQgaXMgbm90IHZpc2libGUgd2hlbiB0YXBwZWQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkZWZhdWx0cy5iZWhhdmlvci50YXBIaWdobGlnaHRDb2xvclxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAncmdiYSgwLDAsMCwwKSdcbiAgICAgICAgICovXG4gICAgICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcbiAgICB9XG59O1xuXG4vKipcbiAqIGhhbW1lciBkb2N1bWVudCB3aGVyZSB0aGUgYmFzZSBldmVudHMgYXJlIGFkZGVkIGF0XG4gKiBAcHJvcGVydHkgRE9DVU1FTlRcbiAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAqIEBkZWZhdWx0IHdpbmRvdy5kb2N1bWVudFxuICovXG5IYW1tZXIuRE9DVU1FTlQgPSBkb2N1bWVudDtcblxuLyoqXG4gKiBkZXRlY3Qgc3VwcG9ydCBmb3IgcG9pbnRlciBldmVudHNcbiAqIEBwcm9wZXJ0eSBIQVNfUE9JTlRFUkVWRU5UU1xuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkhhbW1lci5IQVNfUE9JTlRFUkVWRU5UUyA9IG5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCB8fCBuYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZDtcblxuLyoqXG4gKiBkZXRlY3Qgc3VwcG9ydCBmb3IgdG91Y2ggZXZlbnRzXG4gKiBAcHJvcGVydHkgSEFTX1RPVUNIRVZFTlRTXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuSGFtbWVyLkhBU19UT1VDSEVWRU5UUyA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xuXG4vKipcbiAqIGRldGVjdCBtb2JpbGUgYnJvd3NlcnNcbiAqIEBwcm9wZXJ0eSBJU19NT0JJTEVcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5IYW1tZXIuSVNfTU9CSUxFID0gL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZHxzaWxrL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBkZXRlY3QgaWYgd2Ugd2FudCB0byBzdXBwb3J0IG1vdXNlZXZlbnRzIGF0IGFsbFxuICogQHByb3BlcnR5IE5PX01PVVNFRVZFTlRTXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuSGFtbWVyLk5PX01PVVNFRVZFTlRTID0gKEhhbW1lci5IQVNfVE9VQ0hFVkVOVFMgJiYgSGFtbWVyLklTX01PQklMRSkgfHwgSGFtbWVyLkhBU19QT0lOVEVSRVZFTlRTO1xuXG4vKipcbiAqIGludGVydmFsIGluIHdoaWNoIEhhbW1lciByZWNhbGN1bGF0ZXMgY3VycmVudCB2ZWxvY2l0eS9kaXJlY3Rpb24vYW5nbGUgaW4gbXNcbiAqIEBwcm9wZXJ0eSBDQUxDVUxBVEVfSU5URVJWQUxcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAZGVmYXVsdCAyNVxuICovXG5IYW1tZXIuQ0FMQ1VMQVRFX0lOVEVSVkFMID0gMjU7XG5cbi8qKlxuICogZXZlbnR0eXBlcyBwZXIgdG91Y2hldmVudCAoc3RhcnQsIG1vdmUsIGVuZCkgYXJlIGZpbGxlZCBieSBgRXZlbnQuZGV0ZXJtaW5lRXZlbnRUeXBlc2Agb24gYHNldHVwYFxuICogdGhlIG9iamVjdCBjb250YWlucyB0aGUgRE9NIGV2ZW50IG5hbWVzIHBlciB0eXBlIChgRVZFTlRfU1RBUlRgLCBgRVZFTlRfTU9WRWAsIGBFVkVOVF9FTkRgKVxuICogQHByb3BlcnR5IEVWRU5UX1RZUEVTXG4gKiBAcHJpdmF0ZVxuICogQHdyaXRlT25jZVxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIEVWRU5UX1RZUEVTID0ge307XG5cbi8qKlxuICogZGlyZWN0aW9uIHN0cmluZ3MsIGZvciBzYWZlIGNvbXBhcmlzb25zXG4gKiBAcHJvcGVydHkgRElSRUNUSU9OX0RPV058TEVGVHxVUHxSSUdIVFxuICogQGZpbmFsXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgJ2Rvd24nICdsZWZ0JyAndXAnICdyaWdodCdcbiAqL1xudmFyIERJUkVDVElPTl9ET1dOID0gSGFtbWVyLkRJUkVDVElPTl9ET1dOID0gJ2Rvd24nO1xudmFyIERJUkVDVElPTl9MRUZUID0gSGFtbWVyLkRJUkVDVElPTl9MRUZUID0gJ2xlZnQnO1xudmFyIERJUkVDVElPTl9VUCA9IEhhbW1lci5ESVJFQ1RJT05fVVAgPSAndXAnO1xudmFyIERJUkVDVElPTl9SSUdIVCA9IEhhbW1lci5ESVJFQ1RJT05fUklHSFQgPSAncmlnaHQnO1xuXG4vKipcbiAqIHBvaW50ZXJ0eXBlIHN0cmluZ3MsIGZvciBzYWZlIGNvbXBhcmlzb25zXG4gKiBAcHJvcGVydHkgUE9JTlRFUl9NT1VTRXxUT1VDSHxQRU5cbiAqIEBmaW5hbFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0ICdtb3VzZScgJ3RvdWNoJyAncGVuJ1xuICovXG52YXIgUE9JTlRFUl9NT1VTRSA9IEhhbW1lci5QT0lOVEVSX01PVVNFID0gJ21vdXNlJztcbnZhciBQT0lOVEVSX1RPVUNIID0gSGFtbWVyLlBPSU5URVJfVE9VQ0ggPSAndG91Y2gnO1xudmFyIFBPSU5URVJfUEVOID0gSGFtbWVyLlBPSU5URVJfUEVOID0gJ3Blbic7XG5cbi8qKlxuICogZXZlbnR0eXBlc1xuICogQHByb3BlcnR5IEVWRU5UX1NUQVJUfE1PVkV8RU5EfFJFTEVBU0V8VE9VQ0hcbiAqIEBmaW5hbFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0ICdzdGFydCcgJ2NoYW5nZScgJ21vdmUnICdlbmQnICdyZWxlYXNlJyAndG91Y2gnXG4gKi9cbnZhciBFVkVOVF9TVEFSVCA9IEhhbW1lci5FVkVOVF9TVEFSVCA9ICdzdGFydCc7XG52YXIgRVZFTlRfTU9WRSA9IEhhbW1lci5FVkVOVF9NT1ZFID0gJ21vdmUnO1xudmFyIEVWRU5UX0VORCA9IEhhbW1lci5FVkVOVF9FTkQgPSAnZW5kJztcbnZhciBFVkVOVF9SRUxFQVNFID0gSGFtbWVyLkVWRU5UX1JFTEVBU0UgPSAncmVsZWFzZSc7XG52YXIgRVZFTlRfVE9VQ0ggPSBIYW1tZXIuRVZFTlRfVE9VQ0ggPSAndG91Y2gnO1xuXG4vKipcbiAqIGlmIHRoZSB3aW5kb3cgZXZlbnRzIGFyZSBzZXQuLi5cbiAqIEBwcm9wZXJ0eSBSRUFEWVxuICogQHdyaXRlT25jZVxuICogQHR5cGUge0Jvb2xlYW59XG4gKiBAZGVmYXVsdCBmYWxzZVxuICovXG5IYW1tZXIuUkVBRFkgPSBmYWxzZTtcblxuLyoqXG4gKiBwbHVnaW5zIG5hbWVzcGFjZVxuICogQHByb3BlcnR5IHBsdWdpbnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkhhbW1lci5wbHVnaW5zID0gSGFtbWVyLnBsdWdpbnMgfHwge307XG5cbi8qKlxuICogZ2VzdHVyZXMgbmFtZXNwYWNlXG4gKiBzZWUgYC9nZXN0dXJlc2AgZm9yIHRoZSBkZWZpbml0aW9uc1xuICogQHByb3BlcnR5IGdlc3R1cmVzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5IYW1tZXIuZ2VzdHVyZXMgPSBIYW1tZXIuZ2VzdHVyZXMgfHwge307XG5cbi8qKlxuICogc2V0dXAgZXZlbnRzIHRvIGRldGVjdCBnZXN0dXJlcyBvbiB0aGUgZG9jdW1lbnRcbiAqIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gY3JlYXRpbmcgYW4gbmV3IGluc3RhbmNlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICBpZihIYW1tZXIuUkVBRFkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGZpbmQgd2hhdCBldmVudHR5cGVzIHdlIGFkZCBsaXN0ZW5lcnMgdG9cbiAgICBFdmVudC5kZXRlcm1pbmVFdmVudFR5cGVzKCk7XG5cbiAgICAvLyBSZWdpc3RlciBhbGwgZ2VzdHVyZXMgaW5zaWRlIEhhbW1lci5nZXN0dXJlc1xuICAgIFV0aWxzLmVhY2goSGFtbWVyLmdlc3R1cmVzLCBmdW5jdGlvbihnZXN0dXJlKSB7XG4gICAgICAgIERldGVjdGlvbi5yZWdpc3RlcihnZXN0dXJlKTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCB0b3VjaCBldmVudHMgb24gdGhlIGRvY3VtZW50XG4gICAgRXZlbnQub25Ub3VjaChIYW1tZXIuRE9DVU1FTlQsIEVWRU5UX01PVkUsIERldGVjdGlvbi5kZXRlY3QpO1xuICAgIEV2ZW50Lm9uVG91Y2goSGFtbWVyLkRPQ1VNRU5ULCBFVkVOVF9FTkQsIERldGVjdGlvbi5kZXRlY3QpO1xuXG4gICAgLy8gSGFtbWVyIGlzIHJlYWR5Li4uIVxuICAgIEhhbW1lci5SRUFEWSA9IHRydWU7XG59XG5cbi8qKlxuICogQG1vZHVsZSBoYW1tZXJcbiAqXG4gKiBAY2xhc3MgVXRpbHNcbiAqIEBzdGF0aWNcbiAqL1xudmFyIFV0aWxzID0gSGFtbWVyLnV0aWxzID0ge1xuICAgIC8qKlxuICAgICAqIGV4dGVuZCBtZXRob2QsIGNvdWxkIGFsc28gYmUgdXNlZCBmb3IgY2xvbmluZyB3aGVuIGBkZXN0YCBpcyBhbiBlbXB0eSBvYmplY3QuXG4gICAgICogY2hhbmdlcyB0aGUgZGVzdCBvYmplY3RcbiAgICAgKiBAbWV0aG9kIGV4dGVuZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21lcmdlPWZhbHNlXSAgZG8gYSBtZXJnZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gZGVzdFxuICAgICAqL1xuICAgIGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYywgbWVyZ2UpIHtcbiAgICAgICAgZm9yKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgICAgICAgICBpZighc3JjLmhhc093blByb3BlcnR5KGtleSkgfHwgKGRlc3Rba2V5XSAhPT0gdW5kZWZpbmVkICYmIG1lcmdlKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdFtrZXldID0gc3JjW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNpbXBsZSBhZGRFdmVudExpc3RlbmVyIHdyYXBwZXJcbiAgICAgKiBAbWV0aG9kIG9uXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbiBvbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNpbXBsZSByZW1vdmVFdmVudExpc3RlbmVyIHdyYXBwZXJcbiAgICAgKiBAbWV0aG9kIG9mZlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKi9cbiAgICBvZmY6IGZ1bmN0aW9uIG9mZihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGZvckVhY2ggb3ZlciBhcnJheXMgYW5kIG9iamVjdHNcbiAgICAgKiBAbWV0aG9kIGVhY2hcbiAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAgICAgKiBAcGFyYW0ge2FueX0gaXRlcmF0b3IuaXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpdGVyYXRvci5pbmRleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBpdGVyYXRvci5vYmogdGhlIHNvdXJjZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCB2YWx1ZSB0byB1c2UgYXMgYHRoaXNgIGluIHRoZSBpdGVyYXRvclxuICAgICAqL1xuICAgIGVhY2g6IGZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgICAgICB2YXIgaSwgbGVuO1xuXG4gICAgICAgIC8vIG5hdGl2ZSBmb3JFYWNoIG9uIGFycmF5c1xuICAgICAgICBpZignZm9yRWFjaCcgaW4gb2JqKSB7XG4gICAgICAgICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgICAgIC8vIGFycmF5c1xuICAgICAgICB9IGVsc2UgaWYob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IoaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3RzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IoaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZihvYmouaGFzT3duUHJvcGVydHkoaSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZmluZCBpZiBhIHN0cmluZyBjb250YWlucyB0aGUgc3RyaW5nIHVzaW5nIGluZGV4T2ZcbiAgICAgKiBAbWV0aG9kIGluU3RyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNyY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAgICAgKi9cbiAgICBpblN0cjogZnVuY3Rpb24gaW5TdHIoc3JjLCBmaW5kKSB7XG4gICAgICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKSA+IC0xO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlmaWxsXG4gICAgICogQG1ldGhvZCBpbkFycmF5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNyY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gICAgICogQHJldHVybiB7Qm9vbGVhbnxOdW1iZXJ9IGZhbHNlIHdoZW4gbm90IGZvdW5kLCBvciB0aGUgaW5kZXhcbiAgICAgKi9cbiAgICBpbkFycmF5OiBmdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCkge1xuICAgICAgICBpZihzcmMuaW5kZXhPZikge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gc3JjLmluZGV4T2YoZmluZCk7XG4gICAgICAgICAgICByZXR1cm4gKGluZGV4ID09PSAtMSkgPyBmYWxzZSA6IGluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gc3JjLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYoc3JjW2ldID09PSBmaW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0IChgYXJndW1lbnRzYCwgYHRvdWNobGlzdGApIHRvIGFuIGFycmF5XG4gICAgICogQG1ldGhvZCB0b0FycmF5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBmaW5kIGlmIGEgbm9kZSBpcyBpbiB0aGUgZ2l2ZW4gcGFyZW50XG4gICAgICogQG1ldGhvZCBoYXNQYXJlbnRcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAgICAgKi9cbiAgICBoYXNQYXJlbnQ6IGZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgd2hpbGUobm9kZSkge1xuICAgICAgICAgICAgaWYobm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHRvdWNoZXNcbiAgICAgKiBAbWV0aG9kIGdldENlbnRlclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRvdWNoZXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBjb250YWlucyBgcGFnZVhgLCBgcGFnZVlgLCBgY2xpZW50WGAgYW5kIGBjbGllbnRZYCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0Q2VudGVyOiBmdW5jdGlvbiBnZXRDZW50ZXIodG91Y2hlcykge1xuICAgICAgICB2YXIgcGFnZVggPSBbXSxcbiAgICAgICAgICAgIHBhZ2VZID0gW10sXG4gICAgICAgICAgICBjbGllbnRYID0gW10sXG4gICAgICAgICAgICBjbGllbnRZID0gW10sXG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbixcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4O1xuXG4gICAgICAgIC8vIG5vIG5lZWQgdG8gbG9vcCB3aGVuIG9ubHkgb25lIHRvdWNoXG4gICAgICAgIGlmKHRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhZ2VYOiB0b3VjaGVzWzBdLnBhZ2VYLFxuICAgICAgICAgICAgICAgIHBhZ2VZOiB0b3VjaGVzWzBdLnBhZ2VZLFxuICAgICAgICAgICAgICAgIGNsaWVudFg6IHRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICBjbGllbnRZOiB0b3VjaGVzWzBdLmNsaWVudFlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBVdGlscy5lYWNoKHRvdWNoZXMsIGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAgICAgICBwYWdlWC5wdXNoKHRvdWNoLnBhZ2VYKTtcbiAgICAgICAgICAgIHBhZ2VZLnB1c2godG91Y2gucGFnZVkpO1xuICAgICAgICAgICAgY2xpZW50WC5wdXNoKHRvdWNoLmNsaWVudFgpO1xuICAgICAgICAgICAgY2xpZW50WS5wdXNoKHRvdWNoLmNsaWVudFkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFnZVg6IChtaW4uYXBwbHkoTWF0aCwgcGFnZVgpICsgbWF4LmFwcGx5KE1hdGgsIHBhZ2VYKSkgLyAyLFxuICAgICAgICAgICAgcGFnZVk6IChtaW4uYXBwbHkoTWF0aCwgcGFnZVkpICsgbWF4LmFwcGx5KE1hdGgsIHBhZ2VZKSkgLyAyLFxuICAgICAgICAgICAgY2xpZW50WDogKG1pbi5hcHBseShNYXRoLCBjbGllbnRYKSArIG1heC5hcHBseShNYXRoLCBjbGllbnRYKSkgLyAyLFxuICAgICAgICAgICAgY2xpZW50WTogKG1pbi5hcHBseShNYXRoLCBjbGllbnRZKSArIG1heC5hcHBseShNYXRoLCBjbGllbnRZKSkgLyAyXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cbiAgICAgKiBAbWV0aG9kIGdldFZlbG9jaXR5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFZXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxuICAgICAqL1xuICAgIGdldFZlbG9jaXR5OiBmdW5jdGlvbiBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBNYXRoLmFicyhkZWx0YVggLyBkZWx0YVRpbWUpIHx8IDAsXG4gICAgICAgICAgICB5OiBNYXRoLmFicyhkZWx0YVkgLyBkZWx0YVRpbWUpIHx8IDBcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICAgICAqIEBtZXRob2QgZ2V0QW5nbGVcbiAgICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDFcbiAgICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlXG4gICAgICovXG4gICAgZ2V0QW5nbGU6IGZ1bmN0aW9uIGdldEFuZ2xlKHRvdWNoMSwgdG91Y2gyKSB7XG4gICAgICAgIHZhciB4ID0gdG91Y2gyLmNsaWVudFggLSB0b3VjaDEuY2xpZW50WCxcbiAgICAgICAgICAgIHkgPSB0b3VjaDIuY2xpZW50WSAtIHRvdWNoMS5jbGllbnRZO1xuXG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZG8gYSBzbWFsbCBjb21wYXJpc2lvbiB0byBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byB0b3VjaGVzLlxuICAgICAqIEBtZXRob2QgZ2V0RGlyZWN0aW9uXG4gICAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gxXG4gICAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gyXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBkaXJlY3Rpb24gbWF0Y2hlcyBgRElSRUNUSU9OX0xFRlR8UklHSFR8VVB8RE9XTmBcbiAgICAgKi9cbiAgICBnZXREaXJlY3Rpb246IGZ1bmN0aW9uIGdldERpcmVjdGlvbih0b3VjaDEsIHRvdWNoMikge1xuICAgICAgICB2YXIgeCA9IE1hdGguYWJzKHRvdWNoMS5jbGllbnRYIC0gdG91Y2gyLmNsaWVudFgpLFxuICAgICAgICAgICAgeSA9IE1hdGguYWJzKHRvdWNoMS5jbGllbnRZIC0gdG91Y2gyLmNsaWVudFkpO1xuXG4gICAgICAgIGlmKHggPj0geSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvdWNoMS5jbGllbnRYIC0gdG91Y2gyLmNsaWVudFggPiAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdWNoMS5jbGllbnRZIC0gdG91Y2gyLmNsaWVudFkgPiAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gdG91Y2hlc1xuICAgICAqIEBtZXRob2QgZ2V0RGlzdGFuY2VcbiAgICAgKiBAcGFyYW0ge1RvdWNofXRvdWNoMVxuICAgICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAgICAgKi9cbiAgICBnZXREaXN0YW5jZTogZnVuY3Rpb24gZ2V0RGlzdGFuY2UodG91Y2gxLCB0b3VjaDIpIHtcbiAgICAgICAgdmFyIHggPSB0b3VjaDIuY2xpZW50WCAtIHRvdWNoMS5jbGllbnRYLFxuICAgICAgICAgICAgeSA9IHRvdWNoMi5jbGllbnRZIC0gdG91Y2gxLmNsaWVudFk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHRvdWNoTGlzdHNcbiAgICAgKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAgICAgKiBAbWV0aG9kIGdldFNjYWxlXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgdG91Y2hlc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiB0b3VjaGVzXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICAgICAqL1xuICAgIGdldFNjYWxlOiBmdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XG4gICAgICAgIC8vIG5lZWQgdHdvIGZpbmdlcnMuLi5cbiAgICAgICAgaWYoc3RhcnQubGVuZ3RoID49IDIgJiYgZW5kLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSkgLyB0aGlzLmdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB0aGUgcm90YXRpb24gZGVncmVlcyBiZXR3ZWVuIHR3byB0b3VjaExpc3RzXG4gICAgICogQG1ldGhvZCBnZXRSb3RhdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHRvdWNoZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgdG91Y2hlc1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gcm90YXRpb25cbiAgICAgKi9cbiAgICBnZXRSb3RhdGlvbjogZnVuY3Rpb24gZ2V0Um90YXRpb24oc3RhcnQsIGVuZCkge1xuICAgICAgICAvLyBuZWVkIHR3byBmaW5nZXJzXG4gICAgICAgIGlmKHN0YXJ0Lmxlbmd0aCA+PSAyICYmIGVuZC5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QW5nbGUoZW5kWzFdLCBlbmRbMF0pIC0gdGhpcy5nZXRBbmdsZShzdGFydFsxXSwgc3RhcnRbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBmaW5kIG91dCBpZiB0aGUgZGlyZWN0aW9uIGlzIHZlcnRpY2FsICAgKlxuICAgICAqIEBtZXRob2QgaXNWZXJ0aWNhbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gbWF0Y2hlcyBgRElSRUNUSU9OX1VQfERPV05gXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gaXNfdmVydGljYWxcbiAgICAgKi9cbiAgICBpc1ZlcnRpY2FsOiBmdW5jdGlvbiBpc1ZlcnRpY2FsKGRpcmVjdGlvbikge1xuICAgICAgICByZXR1cm4gZGlyZWN0aW9uID09IERJUkVDVElPTl9VUCB8fCBkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0RPV047XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNldCBjc3MgcHJvcGVydGllcyB3aXRoIHRoZWlyIHByZWZpeGVzXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbdG9nZ2xlPXRydWVdXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzZXRQcmVmaXhlZENzczogZnVuY3Rpb24gc2V0UHJlZml4ZWRDc3MoZWxlbWVudCwgcHJvcCwgdmFsdWUsIHRvZ2dsZSkge1xuICAgICAgICB2YXIgcHJlZml4ZXMgPSBbJycsICdXZWJraXQnLCAnTW96JywgJ08nLCAnbXMnXTtcbiAgICAgICAgcHJvcCA9IFV0aWxzLnRvQ2FtZWxDYXNlKHByb3ApO1xuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHAgPSBwcm9wO1xuICAgICAgICAgICAgLy8gcHJlZml4ZXNcbiAgICAgICAgICAgIGlmKHByZWZpeGVzW2ldKSB7XG4gICAgICAgICAgICAgICAgcCA9IHByZWZpeGVzW2ldICsgcC5zbGljZSgwLCAxKS50b1VwcGVyQ2FzZSgpICsgcC5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgc3R5bGVcbiAgICAgICAgICAgIGlmKHAgaW4gZWxlbWVudC5zdHlsZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbcF0gPSAodG9nZ2xlID09IG51bGwgfHwgdG9nZ2xlKSAmJiB2YWx1ZSB8fCAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0b2dnbGUgYnJvd3NlciBkZWZhdWx0IGJlaGF2aW9yIGJ5IHNldHRpbmcgY3NzIHByb3BlcnRpZXMuXG4gICAgICogYHVzZXJTZWxlY3Q9J25vbmUnYCBhbHNvIHNldHMgYGVsZW1lbnQub25zZWxlY3RzdGFydGAgdG8gZmFsc2VcbiAgICAgKiBgdXNlckRyYWc9J25vbmUnYCBhbHNvIHNldHMgYGVsZW1lbnQub25kcmFnc3RhcnRgIHRvIGZhbHNlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvZ2dsZUJlaGF2aW9yXG4gICAgICogQHBhcmFtIHtIdG1sRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3RvZ2dsZT10cnVlXVxuICAgICAqL1xuICAgIHRvZ2dsZUJlaGF2aW9yOiBmdW5jdGlvbiB0b2dnbGVCZWhhdmlvcihlbGVtZW50LCBwcm9wcywgdG9nZ2xlKSB7XG4gICAgICAgIGlmKCFwcm9wcyB8fCAhZWxlbWVudCB8fCAhZWxlbWVudC5zdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHRoZSBjc3MgcHJvcGVydGllc1xuICAgICAgICBVdGlscy5lYWNoKHByb3BzLCBmdW5jdGlvbih2YWx1ZSwgcHJvcCkge1xuICAgICAgICAgICAgVXRpbHMuc2V0UHJlZml4ZWRDc3MoZWxlbWVudCwgcHJvcCwgdmFsdWUsIHRvZ2dsZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBmYWxzZUZuID0gdG9nZ2xlICYmIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFsc28gdGhlIGRpc2FibGUgb25zZWxlY3RzdGFydFxuICAgICAgICBpZihwcm9wcy51c2VyU2VsZWN0ID09ICdub25lJykge1xuICAgICAgICAgICAgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ID0gZmFsc2VGbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbmQgZGlzYWJsZSBvbmRyYWdzdGFydFxuICAgICAgICBpZihwcm9wcy51c2VyRHJhZyA9PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGVsZW1lbnQub25kcmFnc3RhcnQgPSBmYWxzZUZuO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnQgYSBzdHJpbmcgd2l0aCB1bmRlcnNjb3JlcyB0byBjYW1lbENhc2VcbiAgICAgKiBzbyBwcmV2ZW50X2RlZmF1bHQgYmVjb21lcyBwcmV2ZW50RGVmYXVsdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGNhbWVsQ2FzZVN0clxuICAgICAqL1xuICAgIHRvQ2FtZWxDYXNlOiBmdW5jdGlvbiB0b0NhbWVsQ2FzZShzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXy1dKFthLXpdKS9nLCBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICByZXR1cm4gc1sxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5cbi8qKlxuICogQG1vZHVsZSBoYW1tZXJcbiAqL1xuLyoqXG4gKiBAY2xhc3MgRXZlbnRcbiAqIEBzdGF0aWNcbiAqL1xudmFyIEV2ZW50ID0gSGFtbWVyLmV2ZW50ID0ge1xuICAgIC8qKlxuICAgICAqIHdoZW4gdG91Y2ggZXZlbnRzIGhhdmUgYmVlbiBmaXJlZCwgdGhpcyBpcyB0cnVlXG4gICAgICogdGhpcyBpcyB1c2VkIHRvIHN0b3AgbW91c2UgZXZlbnRzXG4gICAgICogQHByb3BlcnR5IHByZXZlbnRfbW91c2VldmVudHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHByZXZlbnRNb3VzZUV2ZW50czogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBpZiBFVkVOVF9TVEFSVCBoYXMgYmVlbiBmaXJlZFxuICAgICAqIEBwcm9wZXJ0eSBzdGFydGVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGFydGVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIHdoZW4gdGhlIG1vdXNlIGlzIGhvbGQgZG93biwgdGhpcyBpcyB0cnVlXG4gICAgICogQHByb3BlcnR5IHNob3VsZF9kZXRlY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNob3VsZERldGVjdDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBzaW1wbGUgZXZlbnQgYmluZGVyIHdpdGggYSBob29rIGFuZCBzdXBwb3J0IGZvciBtdWx0aXBsZSB0eXBlc1xuICAgICAqIEBtZXRob2Qgb25cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hvb2tdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhvb2sudHlwZVxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbiBvbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBob29rKSB7XG4gICAgICAgIHZhciB0eXBlcyA9IHR5cGUuc3BsaXQoJyAnKTtcbiAgICAgICAgVXRpbHMuZWFjaCh0eXBlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgVXRpbHMub24oZWxlbWVudCwgdHlwZSwgaGFuZGxlcik7XG4gICAgICAgICAgICBob29rICYmIGhvb2sodHlwZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzaW1wbGUgZXZlbnQgdW5iaW5kZXIgd2l0aCBhIGhvb2sgYW5kIHN1cHBvcnQgZm9yIG11bHRpcGxlIHR5cGVzXG4gICAgICogQG1ldGhvZCBvZmZcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hvb2tdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhvb2sudHlwZVxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24gb2ZmKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIGhvb2spIHtcbiAgICAgICAgdmFyIHR5cGVzID0gdHlwZS5zcGxpdCgnICcpO1xuICAgICAgICBVdGlscy5lYWNoKHR5cGVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICBVdGlscy5vZmYoZWxlbWVudCwgdHlwZSwgaGFuZGxlcik7XG4gICAgICAgICAgICBob29rICYmIGhvb2sodHlwZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0aGUgY29yZSB0b3VjaCBldmVudCBoYW5kbGVyLlxuICAgICAqIHRoaXMgZmluZHMgb3V0IGlmIHdlIHNob3VsZCB0byBkZXRlY3QgZ2VzdHVyZXNcbiAgICAgKiBAbWV0aG9kIG9uVG91Y2hcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogQHJldHVybiBvblRvdWNoSGFuZGxlciB7RnVuY3Rpb259IHRoZSBjb3JlIGV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBvblRvdWNoOiBmdW5jdGlvbiBvblRvdWNoKGVsZW1lbnQsIGV2ZW50VHlwZSwgaGFuZGxlcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG9uVG91Y2hIYW5kbGVyID0gZnVuY3Rpb24gb25Ub3VjaEhhbmRsZXIoZXYpIHtcbiAgICAgICAgICAgIHZhciBzcmNUeXBlID0gZXYudHlwZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgIGlzUG9pbnRlciA9IEhhbW1lci5IQVNfUE9JTlRFUkVWRU5UUyxcbiAgICAgICAgICAgICAgICBpc01vdXNlID0gVXRpbHMuaW5TdHIoc3JjVHlwZSwgJ21vdXNlJyksXG4gICAgICAgICAgICAgICAgdHJpZ2dlclR5cGU7XG5cbiAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBpbiBhIG1vdXNlZXZlbnQsIGJ1dCB0aGVyZSBoYXMgYmVlbiBhIHRvdWNoZXZlbnQgdHJpZ2dlcmVkIGluIHRoaXMgc2Vzc2lvblxuICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBkbyBub3RoaW5nLiBzaW1wbHkgYnJlYWsgb3V0IG9mIHRoZSBldmVudC5cbiAgICAgICAgICAgIGlmKGlzTW91c2UgJiYgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIG1vdXNlYnV0dG9uIG11c3QgYmUgZG93blxuICAgICAgICAgICAgfSBlbHNlIGlmKGlzTW91c2UgJiYgZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNlbGYucHJldmVudE1vdXNlRXZlbnRzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGlzUG9pbnRlciAmJiBldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNob3VsZERldGVjdCA9IChldi5idXR0b25zID09PSAxIHx8IFBvaW50ZXJFdmVudC5tYXRjaFR5cGUoUE9JTlRFUl9UT1VDSCwgZXYpKTtcbiAgICAgICAgICAgIC8vIGp1c3QgYSB2YWxpZCBzdGFydCBldmVudCwgYnV0IG5vIG1vdXNlXG4gICAgICAgICAgICB9IGVsc2UgaWYoIWlzTW91c2UgJiYgZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBwb2ludGVyIGV2ZW50IGJlZm9yZSBlbnRlcmluZyB0aGUgZGV0ZWN0aW9uXG4gICAgICAgICAgICBpZihpc1BvaW50ZXIgJiYgZXZlbnRUeXBlICE9IEVWRU5UX0VORCkge1xuICAgICAgICAgICAgICAgIFBvaW50ZXJFdmVudC51cGRhdGVQb2ludGVyKGV2ZW50VHlwZSwgZXYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3ZSBhcmUgaW4gYSB0b3VjaC9kb3duIHN0YXRlLCBzbyBhbGxvd2VkIGRldGVjdGlvbiBvZiBnZXN0dXJlc1xuICAgICAgICAgICAgaWYoc2VsZi5zaG91bGREZXRlY3QpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyVHlwZSA9IHNlbGYuZG9EZXRlY3QuY2FsbChzZWxmLCBldiwgZXZlbnRUeXBlLCBlbGVtZW50LCBoYW5kbGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gLi4uYW5kIHdlIGFyZSBkb25lIHdpdGggdGhlIGRldGVjdGlvblxuICAgICAgICAgICAgLy8gc28gcmVzZXQgZXZlcnl0aGluZyB0byBzdGFydCBlYWNoIGRldGVjdGlvbiB0b3RhbGx5IGZyZXNoXG4gICAgICAgICAgICBpZih0cmlnZ2VyVHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgUG9pbnRlckV2ZW50LnJlc2V0KCk7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHBvaW50ZXJldmVudCBvYmplY3QgYWZ0ZXIgdGhlIGRldGVjdGlvblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihpc1BvaW50ZXIgJiYgZXZlbnRUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgICAgICAgICAgIFBvaW50ZXJFdmVudC51cGRhdGVQb2ludGVyKGV2ZW50VHlwZSwgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMub24oZWxlbWVudCwgRVZFTlRfVFlQRVNbZXZlbnRUeXBlXSwgb25Ub3VjaEhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gb25Ub3VjaEhhbmRsZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRoZSBjb3JlIGRldGVjdGlvbiBtZXRob2RcbiAgICAgKiB0aGlzIGZpbmRzIG91dCB3aGF0IGhhbW1lci10b3VjaC1ldmVudHMgdG8gdHJpZ2dlclxuICAgICAqIEBtZXRob2QgZG9EZXRlY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0cmlnZ2VyVHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICAgKi9cbiAgICBkb0RldGVjdDogZnVuY3Rpb24gZG9EZXRlY3QoZXYsIGV2ZW50VHlwZSwgZWxlbWVudCwgaGFuZGxlcikge1xuICAgICAgICB2YXIgdG91Y2hMaXN0ID0gdGhpcy5nZXRUb3VjaExpc3QoZXYsIGV2ZW50VHlwZSk7XG4gICAgICAgIHZhciB0b3VjaExpc3RMZW5ndGggPSB0b3VjaExpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgdHJpZ2dlclR5cGUgPSBldmVudFR5cGU7XG4gICAgICAgIHZhciB0cmlnZ2VyQ2hhbmdlID0gdG91Y2hMaXN0LnRyaWdnZXI7IC8vIHVzZWQgYnkgZmFrZU11bHRpdG91Y2ggcGx1Z2luXG4gICAgICAgIHZhciBjaGFuZ2VkTGVuZ3RoID0gdG91Y2hMaXN0TGVuZ3RoO1xuXG4gICAgICAgIC8vIGF0IGVhY2ggdG91Y2hzdGFydC1saWtlIGV2ZW50IHdlIHdhbnQgYWxzbyB3YW50IHRvIHRyaWdnZXIgYSBUT1VDSCBldmVudC4uLlxuICAgICAgICBpZihldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2UgPSBFVkVOVF9UT1VDSDtcbiAgICAgICAgLy8gLi4udGhlIHNhbWUgZm9yIGEgdG91Y2hlbmQtbGlrZSBldmVudFxuICAgICAgICB9IGVsc2UgaWYoZXZlbnRUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgICAgICAgdHJpZ2dlckNoYW5nZSA9IEVWRU5UX1JFTEVBU0U7XG5cbiAgICAgICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdG91Y2hlcyBoYXZlIGJlZW4gcmVtb3ZlZFxuICAgICAgICAgICAgY2hhbmdlZExlbmd0aCA9IHRvdWNoTGlzdC5sZW5ndGggLSAoKGV2LmNoYW5nZWRUb3VjaGVzKSA/IGV2LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA6IDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWZ0ZXIgdGhlcmUgYXJlIHN0aWxsIHRvdWNoZXMgb24gdGhlIHNjcmVlbixcbiAgICAgICAgLy8gd2UganVzdCB3YW50IHRvIHRyaWdnZXIgYSBNT1ZFIGV2ZW50LiBzbyBjaGFuZ2UgdGhlIFNUQVJUIG9yIEVORCB0byBhIE1PVkVcbiAgICAgICAgLy8gYnV0IG9ubHkgYWZ0ZXIgZGV0ZWN0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQsIHRoZSBmaXJzdCB0aW1lIHdlIGFjdHVhbHkgd2FudCBhIFNUQVJUXG4gICAgICAgIGlmKGNoYW5nZWRMZW5ndGggPiAwICYmIHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgdHJpZ2dlclR5cGUgPSBFVkVOVF9NT1ZFO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGV0ZWN0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQsIHdlIGtlZXAgdHJhY2sgb2YgdGhpcywgc2VlIGFib3ZlXG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG5cbiAgICAgICAgLy8gZ2VuZXJhdGUgc29tZSBldmVudCBkYXRhLCBzb21lIGJhc2ljIGluZm9ybWF0aW9uXG4gICAgICAgIHZhciBldkRhdGEgPSB0aGlzLmNvbGxlY3RFdmVudERhdGEoZWxlbWVudCwgdHJpZ2dlclR5cGUsIHRvdWNoTGlzdCwgZXYpO1xuXG4gICAgICAgIC8vIHRyaWdnZXIgdGhlIHRyaWdnZXJUeXBlIGV2ZW50IGJlZm9yZSB0aGUgY2hhbmdlIChUT1VDSCwgUkVMRUFTRSkgZXZlbnRzXG4gICAgICAgIC8vIGJ1dCB0aGUgRU5EIGV2ZW50IHNob3VsZCBiZSBhdCBsYXN0XG4gICAgICAgIGlmKGV2ZW50VHlwZSAhPSBFVkVOVF9FTkQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbChEZXRlY3Rpb24sIGV2RGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmlnZ2VyIGEgY2hhbmdlIChUT1VDSCwgUkVMRUFTRSkgZXZlbnQsIHRoaXMgbWVhbnMgdGhlIGxlbmd0aCBvZiB0aGUgdG91Y2hlcyBjaGFuZ2VkXG4gICAgICAgIGlmKHRyaWdnZXJDaGFuZ2UpIHtcbiAgICAgICAgICAgIGV2RGF0YS5jaGFuZ2VkTGVuZ3RoID0gY2hhbmdlZExlbmd0aDtcbiAgICAgICAgICAgIGV2RGF0YS5ldmVudFR5cGUgPSB0cmlnZ2VyQ2hhbmdlO1xuXG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwoRGV0ZWN0aW9uLCBldkRhdGEpO1xuXG4gICAgICAgICAgICBldkRhdGEuZXZlbnRUeXBlID0gdHJpZ2dlclR5cGU7XG4gICAgICAgICAgICBkZWxldGUgZXZEYXRhLmNoYW5nZWRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmlnZ2VyIHRoZSBFTkQgZXZlbnRcbiAgICAgICAgaWYodHJpZ2dlclR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwoRGV0ZWN0aW9uLCBldkRhdGEpO1xuXG4gICAgICAgICAgICAvLyAuLi5hbmQgd2UgYXJlIGRvbmUgd2l0aCB0aGUgZGV0ZWN0aW9uXG4gICAgICAgICAgICAvLyBzbyByZXNldCBldmVyeXRoaW5nIHRvIHN0YXJ0IGVhY2ggZGV0ZWN0aW9uIHRvdGFsbHkgZnJlc2hcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRyaWdnZXJUeXBlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB3ZSBoYXZlIGRpZmZlcmVudCBldmVudHMgZm9yIGVhY2ggZGV2aWNlL2Jyb3dzZXJcbiAgICAgKiBkZXRlcm1pbmUgd2hhdCB3ZSBuZWVkIGFuZCBzZXQgdGhlbSBpbiB0aGUgRVZFTlRfVFlQRVMgY29uc3RhbnRcbiAgICAgKiB0aGUgYG9uVG91Y2hgIG1ldGhvZCBpcyBiaW5kIHRvIHRoZXNlIHByb3BlcnRpZXMuXG4gICAgICogQG1ldGhvZCBkZXRlcm1pbmVFdmVudFR5cGVzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBldmVudHNcbiAgICAgKi9cbiAgICBkZXRlcm1pbmVFdmVudFR5cGVzOiBmdW5jdGlvbiBkZXRlcm1pbmVFdmVudFR5cGVzKCkge1xuICAgICAgICB2YXIgdHlwZXM7XG4gICAgICAgIGlmKEhhbW1lci5IQVNfUE9JTlRFUkVWRU5UUykge1xuICAgICAgICAgICAgaWYod2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgICAgICAgICAgICAgIHR5cGVzID0gW1xuICAgICAgICAgICAgICAgICAgICAncG9pbnRlcmRvd24nLFxuICAgICAgICAgICAgICAgICAgICAncG9pbnRlcm1vdmUnLFxuICAgICAgICAgICAgICAgICAgICAncG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwgbG9zdHBvaW50ZXJjYXB0dXJlJ1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGVzID0gW1xuICAgICAgICAgICAgICAgICAgICAnTVNQb2ludGVyRG93bicsXG4gICAgICAgICAgICAgICAgICAgICdNU1BvaW50ZXJNb3ZlJyxcbiAgICAgICAgICAgICAgICAgICAgJ01TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCBNU0xvc3RQb2ludGVyQ2FwdHVyZSdcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoSGFtbWVyLk5PX01PVVNFRVZFTlRTKSB7XG4gICAgICAgICAgICB0eXBlcyA9IFtcbiAgICAgICAgICAgICAgICAndG91Y2hzdGFydCcsXG4gICAgICAgICAgICAgICAgJ3RvdWNobW92ZScsXG4gICAgICAgICAgICAgICAgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJ1xuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR5cGVzID0gW1xuICAgICAgICAgICAgICAgICd0b3VjaHN0YXJ0IG1vdXNlZG93bicsXG4gICAgICAgICAgICAgICAgJ3RvdWNobW92ZSBtb3VzZW1vdmUnLFxuICAgICAgICAgICAgICAgICd0b3VjaGVuZCB0b3VjaGNhbmNlbCBtb3VzZXVwJ1xuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIEVWRU5UX1RZUEVTW0VWRU5UX1NUQVJUXSA9IHR5cGVzWzBdO1xuICAgICAgICBFVkVOVF9UWVBFU1tFVkVOVF9NT1ZFXSA9IHR5cGVzWzFdO1xuICAgICAgICBFVkVOVF9UWVBFU1tFVkVOVF9FTkRdID0gdHlwZXNbMl07XG4gICAgICAgIHJldHVybiBFVkVOVF9UWVBFUztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIHRvdWNoTGlzdCBkZXBlbmRpbmcgb24gdGhlIGV2ZW50XG4gICAgICogQG1ldGhvZCBnZXRUb3VjaExpc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG4gICAgICogQHJldHVybiB7QXJyYXl9IHRvdWNoZXNcbiAgICAgKi9cbiAgICBnZXRUb3VjaExpc3Q6IGZ1bmN0aW9uIGdldFRvdWNoTGlzdChldiwgZXZlbnRUeXBlKSB7XG4gICAgICAgIC8vIGdldCB0aGUgZmFrZSBwb2ludGVyRXZlbnQgdG91Y2hsaXN0XG4gICAgICAgIGlmKEhhbW1lci5IQVNfUE9JTlRFUkVWRU5UUykge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXJFdmVudC5nZXRUb3VjaExpc3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB0aGUgdG91Y2hsaXN0XG4gICAgICAgIGlmKGV2LnRvdWNoZXMpIHtcbiAgICAgICAgICAgIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9NT1ZFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2LnRvdWNoZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpZGVudGlmaWVycyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNvbmNhdCA9IFtdLmNvbmNhdChVdGlscy50b0FycmF5KGV2LnRvdWNoZXMpLCBVdGlscy50b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKSk7XG4gICAgICAgICAgICB2YXIgdG91Y2hMaXN0ID0gW107XG5cbiAgICAgICAgICAgIFV0aWxzLmVhY2goY29uY2F0LCBmdW5jdGlvbih0b3VjaCkge1xuICAgICAgICAgICAgICAgIGlmKFV0aWxzLmluQXJyYXkoaWRlbnRpZmllcnMsIHRvdWNoLmlkZW50aWZpZXIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0b3VjaExpc3QucHVzaCh0b3VjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXJzLnB1c2godG91Y2guaWRlbnRpZmllcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRvdWNoTGlzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1ha2UgZmFrZSB0b3VjaExpc3QgZnJvbSBtb3VzZSBwb3NpdGlvblxuICAgICAgICBldi5pZGVudGlmaWVyID0gMTtcbiAgICAgICAgcmV0dXJuIFtldl07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNvbGxlY3QgYmFzaWMgZXZlbnQgZGF0YVxuICAgICAqIEBtZXRob2QgY29sbGVjdEV2ZW50RGF0YVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRvdWNoZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGV2XG4gICAgICovXG4gICAgY29sbGVjdEV2ZW50RGF0YTogZnVuY3Rpb24gY29sbGVjdEV2ZW50RGF0YShlbGVtZW50LCBldmVudFR5cGUsIHRvdWNoZXMsIGV2KSB7XG4gICAgICAgIC8vIGZpbmQgb3V0IHBvaW50ZXJUeXBlXG4gICAgICAgIHZhciBwb2ludGVyVHlwZSA9IFBPSU5URVJfVE9VQ0g7XG4gICAgICAgIGlmKFV0aWxzLmluU3RyKGV2LnR5cGUsICdtb3VzZScpIHx8IFBvaW50ZXJFdmVudC5tYXRjaFR5cGUoUE9JTlRFUl9NT1VTRSwgZXYpKSB7XG4gICAgICAgICAgICBwb2ludGVyVHlwZSA9IFBPSU5URVJfTU9VU0U7XG4gICAgICAgIH0gZWxzZSBpZihQb2ludGVyRXZlbnQubWF0Y2hUeXBlKFBPSU5URVJfUEVOLCBldikpIHtcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gUE9JTlRFUl9QRU47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2VudGVyOiBVdGlscy5nZXRDZW50ZXIodG91Y2hlcyksXG4gICAgICAgICAgICB0aW1lU3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICB0YXJnZXQ6IGV2LnRhcmdldCxcbiAgICAgICAgICAgIHRvdWNoZXM6IHRvdWNoZXMsXG4gICAgICAgICAgICBldmVudFR5cGU6IGV2ZW50VHlwZSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldixcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBwcmV2ZW50IHRoZSBicm93c2VyIGRlZmF1bHQgYWN0aW9uc1xuICAgICAgICAgICAgICogbW9zdGx5IHVzZWQgdG8gZGlzYWJsZSBzY3JvbGxpbmcgb2YgdGhlIGJyb3dzZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzcmNFdmVudCA9IHRoaXMuc3JjRXZlbnQ7XG4gICAgICAgICAgICAgICAgc3JjRXZlbnQucHJldmVudE1hbmlwdWxhdGlvbiAmJiBzcmNFdmVudC5wcmV2ZW50TWFuaXB1bGF0aW9uKCk7XG4gICAgICAgICAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQgJiYgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogc3RvcCBidWJibGluZyB0aGUgZXZlbnQgdXAgdG8gaXRzIHBhcmVudHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNyY0V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBpbW1lZGlhdGVseSBzdG9wIGdlc3R1cmUgZGV0ZWN0aW9uXG4gICAgICAgICAgICAgKiBtaWdodCBiZSB1c2VmdWwgYWZ0ZXIgYSBzd2lwZSB3YXMgZGV0ZWN0ZWRcbiAgICAgICAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHN0b3BEZXRlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBEZXRlY3Rpb24uc3RvcERldGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIGhhbW1lclxuICpcbiAqIEBjbGFzcyBQb2ludGVyRXZlbnRcbiAqIEBzdGF0aWNcbiAqL1xudmFyIFBvaW50ZXJFdmVudCA9IEhhbW1lci5Qb2ludGVyRXZlbnQgPSB7XG4gICAgLyoqXG4gICAgICogaG9sZHMgYWxsIHBvaW50ZXJzLCBieSBgaWRlbnRpZmllcmBcbiAgICAgKiBAcHJvcGVydHkgcG9pbnRlcnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHBvaW50ZXJzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgcG9pbnRlcnMgYXMgYW4gYXJyYXlcbiAgICAgKiBAbWV0aG9kIGdldFRvdWNoTGlzdFxuICAgICAqIEByZXR1cm4ge0FycmF5fSB0b3VjaGxpc3RcbiAgICAgKi9cbiAgICBnZXRUb3VjaExpc3Q6IGZ1bmN0aW9uIGdldFRvdWNoTGlzdCgpIHtcbiAgICAgICAgdmFyIHRvdWNobGlzdCA9IFtdO1xuICAgICAgICAvLyB3ZSBjYW4gdXNlIGZvckVhY2ggc2luY2UgcG9pbnRlckV2ZW50cyBvbmx5IGlzIGluIElFMTBcbiAgICAgICAgVXRpbHMuZWFjaCh0aGlzLnBvaW50ZXJzLCBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICAgICAgICB0b3VjaGxpc3QucHVzaChwb2ludGVyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRvdWNobGlzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSBwb3NpdGlvbiBvZiBhIHBvaW50ZXJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVBvaW50ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyRXZlbnRcbiAgICAgKi9cbiAgICB1cGRhdGVQb2ludGVyOiBmdW5jdGlvbiB1cGRhdGVQb2ludGVyKGV2ZW50VHlwZSwgcG9pbnRlckV2ZW50KSB7XG4gICAgICAgIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBvaW50ZXJzW3BvaW50ZXJFdmVudC5wb2ludGVySWRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRlckV2ZW50LmlkZW50aWZpZXIgPSBwb2ludGVyRXZlbnQucG9pbnRlcklkO1xuICAgICAgICAgICAgdGhpcy5wb2ludGVyc1twb2ludGVyRXZlbnQucG9pbnRlcklkXSA9IHBvaW50ZXJFdmVudDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjaGVjayBpZiBldiBtYXRjaGVzIHBvaW50ZXJ0eXBlXG4gICAgICogQG1ldGhvZCBtYXRjaFR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcG9pbnRlclR5cGUgbWF0Y2hlcyBgUE9JTlRFUl9NT1VTRXxUT1VDSHxQRU5gXG4gICAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGV2XG4gICAgICovXG4gICAgbWF0Y2hUeXBlOiBmdW5jdGlvbiBtYXRjaFR5cGUocG9pbnRlclR5cGUsIGV2KSB7XG4gICAgICAgIGlmKCFldi5wb2ludGVyVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHB0ID0gZXYucG9pbnRlclR5cGUsXG4gICAgICAgICAgICB0eXBlcyA9IHt9O1xuXG4gICAgICAgIHR5cGVzW1BPSU5URVJfTU9VU0VdID0gKHB0ID09PSAoZXYuTVNQT0lOVEVSX1RZUEVfTU9VU0UgfHwgUE9JTlRFUl9NT1VTRSkpO1xuICAgICAgICB0eXBlc1tQT0lOVEVSX1RPVUNIXSA9IChwdCA9PT0gKGV2Lk1TUE9JTlRFUl9UWVBFX1RPVUNIIHx8IFBPSU5URVJfVE9VQ0gpKTtcbiAgICAgICAgdHlwZXNbUE9JTlRFUl9QRU5dID0gKHB0ID09PSAoZXYuTVNQT0lOVEVSX1RZUEVfUEVOIHx8IFBPSU5URVJfUEVOKSk7XG4gICAgICAgIHJldHVybiB0eXBlc1twb2ludGVyVHlwZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlc2V0IHRoZSBzdG9yZWQgcG9pbnRlcnNcbiAgICAgKiBAbWV0aG9kIHJlc2V0XG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0TGlzdCgpIHtcbiAgICAgICAgdGhpcy5wb2ludGVycyA9IHt9O1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIGhhbW1lclxuICpcbiAqIEBjbGFzcyBEZXRlY3Rpb25cbiAqIEBzdGF0aWNcbiAqL1xudmFyIERldGVjdGlvbiA9IEhhbW1lci5kZXRlY3Rpb24gPSB7XG4gICAgLy8gY29udGFpbnMgYWxsIHJlZ2lzdHJlZCBIYW1tZXIuZ2VzdHVyZXMgaW4gdGhlIGNvcnJlY3Qgb3JkZXJcbiAgICBnZXN0dXJlczogW10sXG5cbiAgICAvLyBkYXRhIG9mIHRoZSBjdXJyZW50IEhhbW1lci5nZXN0dXJlIGRldGVjdGlvbiBzZXNzaW9uXG4gICAgY3VycmVudDogbnVsbCxcblxuICAgIC8vIHRoZSBwcmV2aW91cyBIYW1tZXIuZ2VzdHVyZSBzZXNzaW9uIGRhdGFcbiAgICAvLyBpcyBhIGZ1bGwgY2xvbmUgb2YgdGhlIHByZXZpb3VzIGdlc3R1cmUuY3VycmVudCBvYmplY3RcbiAgICBwcmV2aW91czogbnVsbCxcblxuICAgIC8vIHdoZW4gdGhpcyBiZWNvbWVzIHRydWUsIG5vIGdlc3R1cmVzIGFyZSBmaXJlZFxuICAgIHN0b3BwZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogc3RhcnQgSGFtbWVyLmdlc3R1cmUgZGV0ZWN0aW9uXG4gICAgICogQG1ldGhvZCBzdGFydERldGVjdFxuICAgICAqIEBwYXJhbSB7SGFtbWVyLkluc3RhbmNlfSBpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RGF0YVxuICAgICAqL1xuICAgIHN0YXJ0RGV0ZWN0OiBmdW5jdGlvbiBzdGFydERldGVjdChpbnN0LCBldmVudERhdGEpIHtcbiAgICAgICAgLy8gYWxyZWFkeSBidXN5IHdpdGggYSBIYW1tZXIuZ2VzdHVyZSBkZXRlY3Rpb24gb24gYW4gZWxlbWVudFxuICAgICAgICBpZih0aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGhvbGRzIGN1cnJlbnQgc2Vzc2lvblxuICAgICAgICB0aGlzLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICBpbnN0OiBpbnN0LCAvLyByZWZlcmVuY2UgdG8gSGFtbWVySW5zdGFuY2Ugd2UncmUgd29ya2luZyBmb3JcbiAgICAgICAgICAgIHN0YXJ0RXZlbnQ6IFV0aWxzLmV4dGVuZCh7fSwgZXZlbnREYXRhKSwgLy8gc3RhcnQgZXZlbnREYXRhIGZvciBkaXN0YW5jZXMsIHRpbWluZyBldGNcbiAgICAgICAgICAgIGxhc3RFdmVudDogZmFsc2UsIC8vIGxhc3QgZXZlbnREYXRhXG4gICAgICAgICAgICBsYXN0Q2FsY0V2ZW50OiBmYWxzZSwgLy8gbGFzdCBldmVudERhdGEgZm9yIGNhbGN1bGF0aW9ucy5cbiAgICAgICAgICAgIGZ1dHVyZUNhbGNFdmVudDogZmFsc2UsIC8vIGxhc3QgZXZlbnREYXRhIGZvciBjYWxjdWxhdGlvbnMuXG4gICAgICAgICAgICBsYXN0Q2FsY0RhdGE6IHt9LCAvLyBsYXN0IGxhc3RDYWxjRGF0YVxuICAgICAgICAgICAgbmFtZTogJycgLy8gY3VycmVudCBnZXN0dXJlIHdlJ3JlIGluL2RldGVjdGVkLCBjYW4gYmUgJ3RhcCcsICdob2xkJyBldGNcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRldGVjdChldmVudERhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIYW1tZXIuZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICAgKiBAbWV0aG9kIGRldGVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudERhdGFcbiAgICAgKiBAcmV0dXJuIHthbnl9XG4gICAgICovXG4gICAgZGV0ZWN0OiBmdW5jdGlvbiBkZXRlY3QoZXZlbnREYXRhKSB7XG4gICAgICAgIGlmKCF0aGlzLmN1cnJlbnQgfHwgdGhpcy5zdG9wcGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBleHRlbmQgZXZlbnQgZGF0YSB3aXRoIGNhbGN1bGF0aW9ucyBhYm91dCBzY2FsZSwgZGlzdGFuY2UgZXRjXG4gICAgICAgIGV2ZW50RGF0YSA9IHRoaXMuZXh0ZW5kRXZlbnREYXRhKGV2ZW50RGF0YSk7XG5cbiAgICAgICAgLy8gaGFtbWVyIGluc3RhbmNlIGFuZCBpbnN0YW5jZSBvcHRpb25zXG4gICAgICAgIHZhciBpbnN0ID0gdGhpcy5jdXJyZW50Lmluc3QsXG4gICAgICAgICAgICBpbnN0T3B0aW9ucyA9IGluc3Qub3B0aW9ucztcblxuICAgICAgICAvLyBjYWxsIEhhbW1lci5nZXN0dXJlIGhhbmRsZXJzXG4gICAgICAgIFV0aWxzLmVhY2godGhpcy5nZXN0dXJlcywgZnVuY3Rpb24gdHJpZ2dlckdlc3R1cmUoZ2VzdHVyZSkge1xuICAgICAgICAgICAgLy8gb25seSB3aGVuIHRoZSBpbnN0YW5jZSBvcHRpb25zIGhhdmUgZW5hYmxlZCB0aGlzIGdlc3R1cmVcbiAgICAgICAgICAgIGlmKCF0aGlzLnN0b3BwZWQgJiYgaW5zdC5lbmFibGVkICYmIGluc3RPcHRpb25zW2dlc3R1cmUubmFtZV0pIHtcbiAgICAgICAgICAgICAgICBnZXN0dXJlLmhhbmRsZXIuY2FsbChnZXN0dXJlLCBldmVudERhdGEsIGluc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAvLyBzdG9yZSBhcyBwcmV2aW91cyBldmVudCBldmVudFxuICAgICAgICBpZih0aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5sYXN0RXZlbnQgPSBldmVudERhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZihldmVudERhdGEuZXZlbnRUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wRGV0ZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXZlbnREYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjbGVhciB0aGUgSGFtbWVyLmdlc3R1cmUgdmFyc1xuICAgICAqIHRoaXMgaXMgY2FsbGVkIG9uIGVuZERldGVjdCwgYnV0IGNhbiBhbHNvIGJlIHVzZWQgd2hlbiBhIGZpbmFsIEhhbW1lci5nZXN0dXJlIGhhcyBiZWVuIGRldGVjdGVkXG4gICAgICogdG8gc3RvcCBvdGhlciBIYW1tZXIuZ2VzdHVyZXMgZnJvbSBiZWluZyBmaXJlZFxuICAgICAqIEBtZXRob2Qgc3RvcERldGVjdFxuICAgICAqL1xuICAgIHN0b3BEZXRlY3Q6IGZ1bmN0aW9uIHN0b3BEZXRlY3QoKSB7XG4gICAgICAgIC8vIGNsb25lIGN1cnJlbnQgZGF0YSB0byB0aGUgc3RvcmUgYXMgdGhlIHByZXZpb3VzIGdlc3R1cmVcbiAgICAgICAgLy8gdXNlZCBmb3IgdGhlIGRvdWJsZSB0YXAgZ2VzdHVyZSwgc2luY2UgdGhpcyBpcyBhbiBvdGhlciBnZXN0dXJlIGRldGVjdCBzZXNzaW9uXG4gICAgICAgIHRoaXMucHJldmlvdXMgPSBVdGlscy5leHRlbmQoe30sIHRoaXMuY3VycmVudCk7XG5cbiAgICAgICAgLy8gcmVzZXQgdGhlIGN1cnJlbnRcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHZlbG9jaXR5LCBhbmdsZSBhbmQgZGlyZWN0aW9uXG4gICAgICogQG1ldGhvZCBnZXRWZWxvY2l0eURhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2VudGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFZXG4gICAgICovXG4gICAgZ2V0Q2FsY3VsYXRlZERhdGE6IGZ1bmN0aW9uIGdldENhbGN1bGF0ZWREYXRhKGV2LCBjZW50ZXIsIGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgICAgICAgdmFyIGN1ciA9IHRoaXMuY3VycmVudCxcbiAgICAgICAgICAgIHJlY2FsYyA9IGZhbHNlLFxuICAgICAgICAgICAgY2FsY0V2ID0gY3VyLmxhc3RDYWxjRXZlbnQsXG4gICAgICAgICAgICBjYWxjRGF0YSA9IGN1ci5sYXN0Q2FsY0RhdGE7XG5cbiAgICAgICAgaWYoY2FsY0V2ICYmIGV2LnRpbWVTdGFtcCAtIGNhbGNFdi50aW1lU3RhbXAgPiBIYW1tZXIuQ0FMQ1VMQVRFX0lOVEVSVkFMKSB7XG4gICAgICAgICAgICBjZW50ZXIgPSBjYWxjRXYuY2VudGVyO1xuICAgICAgICAgICAgZGVsdGFUaW1lID0gZXYudGltZVN0YW1wIC0gY2FsY0V2LnRpbWVTdGFtcDtcbiAgICAgICAgICAgIGRlbHRhWCA9IGV2LmNlbnRlci5jbGllbnRYIC0gY2FsY0V2LmNlbnRlci5jbGllbnRYO1xuICAgICAgICAgICAgZGVsdGFZID0gZXYuY2VudGVyLmNsaWVudFkgLSBjYWxjRXYuY2VudGVyLmNsaWVudFk7XG4gICAgICAgICAgICByZWNhbGMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIIHx8IGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICAgICAgICBjdXIuZnV0dXJlQ2FsY0V2ZW50ID0gZXY7XG4gICAgICAgIH1cblxuICAgICAgICBpZighY3VyLmxhc3RDYWxjRXZlbnQgfHwgcmVjYWxjKSB7XG4gICAgICAgICAgICBjYWxjRGF0YS52ZWxvY2l0eSA9IFV0aWxzLmdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICAgICAgY2FsY0RhdGEuYW5nbGUgPSBVdGlscy5nZXRBbmdsZShjZW50ZXIsIGV2LmNlbnRlcik7XG4gICAgICAgICAgICBjYWxjRGF0YS5kaXJlY3Rpb24gPSBVdGlscy5nZXREaXJlY3Rpb24oY2VudGVyLCBldi5jZW50ZXIpO1xuXG4gICAgICAgICAgICBjdXIubGFzdENhbGNFdmVudCA9IGN1ci5mdXR1cmVDYWxjRXZlbnQgfHwgZXY7XG4gICAgICAgICAgICBjdXIuZnV0dXJlQ2FsY0V2ZW50ID0gZXY7XG4gICAgICAgIH1cblxuICAgICAgICBldi52ZWxvY2l0eVggPSBjYWxjRGF0YS52ZWxvY2l0eS54O1xuICAgICAgICBldi52ZWxvY2l0eVkgPSBjYWxjRGF0YS52ZWxvY2l0eS55O1xuICAgICAgICBldi5pbnRlcmltQW5nbGUgPSBjYWxjRGF0YS5hbmdsZTtcbiAgICAgICAgZXYuaW50ZXJpbURpcmVjdGlvbiA9IGNhbGNEYXRhLmRpcmVjdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZXh0ZW5kIGV2ZW50RGF0YSBmb3IgSGFtbWVyLmdlc3R1cmVzXG4gICAgICogQG1ldGhvZCBleHRlbmRFdmVudERhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGV2XG4gICAgICovXG4gICAgZXh0ZW5kRXZlbnREYXRhOiBmdW5jdGlvbiBleHRlbmRFdmVudERhdGEoZXYpIHtcbiAgICAgICAgdmFyIGN1ciA9IHRoaXMuY3VycmVudCxcbiAgICAgICAgICAgIHN0YXJ0RXYgPSBjdXIuc3RhcnRFdmVudCxcbiAgICAgICAgICAgIGxhc3RFdiA9IGN1ci5sYXN0RXZlbnQgfHwgc3RhcnRFdjtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHN0YXJ0IHRvdWNobGlzdCB0byBjYWxjdWxhdGUgdGhlIHNjYWxlL3JvdGF0aW9uXG4gICAgICAgIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9UT1VDSCB8fCBldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgICAgICAgc3RhcnRFdi50b3VjaGVzID0gW107XG4gICAgICAgICAgICBVdGlscy5lYWNoKGV2LnRvdWNoZXMsIGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRFdi50b3VjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiB0b3VjaC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRZOiB0b3VjaC5jbGllbnRZXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWx0YVRpbWUgPSBldi50aW1lU3RhbXAgLSBzdGFydEV2LnRpbWVTdGFtcCxcbiAgICAgICAgICAgIGRlbHRhWCA9IGV2LmNlbnRlci5jbGllbnRYIC0gc3RhcnRFdi5jZW50ZXIuY2xpZW50WCxcbiAgICAgICAgICAgIGRlbHRhWSA9IGV2LmNlbnRlci5jbGllbnRZIC0gc3RhcnRFdi5jZW50ZXIuY2xpZW50WTtcblxuICAgICAgICB0aGlzLmdldENhbGN1bGF0ZWREYXRhKGV2LCBsYXN0RXYuY2VudGVyLCBkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcblxuICAgICAgICBVdGlscy5leHRlbmQoZXYsIHtcbiAgICAgICAgICAgIHN0YXJ0RXZlbnQ6IHN0YXJ0RXYsXG5cbiAgICAgICAgICAgIGRlbHRhVGltZTogZGVsdGFUaW1lLFxuICAgICAgICAgICAgZGVsdGFYOiBkZWx0YVgsXG4gICAgICAgICAgICBkZWx0YVk6IGRlbHRhWSxcblxuICAgICAgICAgICAgZGlzdGFuY2U6IFV0aWxzLmdldERpc3RhbmNlKHN0YXJ0RXYuY2VudGVyLCBldi5jZW50ZXIpLFxuICAgICAgICAgICAgYW5nbGU6IFV0aWxzLmdldEFuZ2xlKHN0YXJ0RXYuY2VudGVyLCBldi5jZW50ZXIpLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBVdGlscy5nZXREaXJlY3Rpb24oc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICAgICAgICBzY2FsZTogVXRpbHMuZ2V0U2NhbGUoc3RhcnRFdi50b3VjaGVzLCBldi50b3VjaGVzKSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBVdGlscy5nZXRSb3RhdGlvbihzdGFydEV2LnRvdWNoZXMsIGV2LnRvdWNoZXMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBldjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVnaXN0ZXIgbmV3IGdlc3R1cmVcbiAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdlc3R1cmUgb2JqZWN0LCBzZWUgYGdlc3R1cmVzL2AgZm9yIGRvY3VtZW50YXRpb25cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gZ2VzdHVyZXNcbiAgICAgKi9cbiAgICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoZ2VzdHVyZSkge1xuICAgICAgICAvLyBhZGQgYW4gZW5hYmxlIGdlc3R1cmUgb3B0aW9ucyBpZiB0aGVyZSBpcyBubyBnaXZlblxuICAgICAgICB2YXIgb3B0aW9ucyA9IGdlc3R1cmUuZGVmYXVsdHMgfHwge307XG4gICAgICAgIGlmKG9wdGlvbnNbZ2VzdHVyZS5uYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zW2dlc3R1cmUubmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXh0ZW5kIEhhbW1lciBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgSGFtbWVyLmdlc3R1cmUgb3B0aW9uc1xuICAgICAgICBVdGlscy5leHRlbmQoSGFtbWVyLmRlZmF1bHRzLCBvcHRpb25zLCB0cnVlKTtcblxuICAgICAgICAvLyBzZXQgaXRzIGluZGV4XG4gICAgICAgIGdlc3R1cmUuaW5kZXggPSBnZXN0dXJlLmluZGV4IHx8IDEwMDA7XG5cbiAgICAgICAgLy8gYWRkIEhhbW1lci5nZXN0dXJlIHRvIHRoZSBsaXN0XG4gICAgICAgIHRoaXMuZ2VzdHVyZXMucHVzaChnZXN0dXJlKTtcblxuICAgICAgICAvLyBzb3J0IHRoZSBsaXN0IGJ5IGluZGV4XG4gICAgICAgIHRoaXMuZ2VzdHVyZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICBpZihhLmluZGV4IDwgYi5pbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGEuaW5kZXggPiBiLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VzdHVyZXM7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgaGFtbWVyXG4gKi9cblxuLyoqXG4gKiBjcmVhdGUgbmV3IGhhbW1lciBpbnN0YW5jZVxuICogYWxsIG1ldGhvZHMgc2hvdWxkIHJldHVybiB0aGUgaW5zdGFuY2UgaXRzZWxmLCBzbyBpdCBpcyBjaGFpbmFibGUuXG4gKlxuICogQGNsYXNzIEluc3RhbmNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gb3B0aW9ucyBhcmUgbWVyZ2VkIHdpdGggYEhhbW1lci5kZWZhdWx0c2BcbiAqIEByZXR1cm4ge0hhbW1lci5JbnN0YW5jZX1cbiAqL1xuSGFtbWVyLkluc3RhbmNlID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIHNldHVwIEhhbW1lckpTIHdpbmRvdyBldmVudHMgYW5kIHJlZ2lzdGVyIGFsbCBnZXN0dXJlc1xuICAgIC8vIHRoaXMgYWxzbyBzZXRzIHVwIHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAgICBzZXR1cCgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGVsZW1lbnRcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBlbmFibGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBvcHRpb25zLCBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdHNcbiAgICAgKiBvcHRpb25zIHdpdGggYW4gXyBhcmUgY29udmVydGVkIHRvIGNhbWVsQ2FzZVxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBVdGlscy5lYWNoKG9wdGlvbnMsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zW25hbWVdO1xuICAgICAgICBvcHRpb25zW1V0aWxzLnRvQ2FtZWxDYXNlKG5hbWUpXSA9IHZhbHVlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5vcHRpb25zID0gVXRpbHMuZXh0ZW5kKFV0aWxzLmV4dGVuZCh7fSwgSGFtbWVyLmRlZmF1bHRzKSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICAvLyBhZGQgc29tZSBjc3MgdG8gdGhlIGVsZW1lbnQgdG8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIGRvaW5nIGl0cyBuYXRpdmUgYmVoYXZvaXJcbiAgICBpZih0aGlzLm9wdGlvbnMuYmVoYXZpb3IpIHtcbiAgICAgICAgVXRpbHMudG9nZ2xlQmVoYXZpb3IodGhpcy5lbGVtZW50LCB0aGlzLm9wdGlvbnMuYmVoYXZpb3IsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGV2ZW50IHN0YXJ0IGhhbmRsZXIgb24gdGhlIGVsZW1lbnQgdG8gc3RhcnQgdGhlIGRldGVjdGlvblxuICAgICAqIEBwcm9wZXJ0eSBldmVudFN0YXJ0SGFuZGxlclxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5ldmVudFN0YXJ0SGFuZGxlciA9IEV2ZW50Lm9uVG91Y2goZWxlbWVudCwgRVZFTlRfU1RBUlQsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmKHNlbGYuZW5hYmxlZCAmJiBldi5ldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgICAgICAgIERldGVjdGlvbi5zdGFydERldGVjdChzZWxmLCBldik7XG4gICAgICAgIH0gZWxzZSBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfVE9VQ0gpIHtcbiAgICAgICAgICAgIERldGVjdGlvbi5kZXRlY3QoZXYpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBrZWVwIGEgbGlzdCBvZiB1c2VyIGV2ZW50IGhhbmRsZXJzIHdoaWNoIG5lZWRzIHRvIGJlIHJlbW92ZWQgd2hlbiBjYWxsaW5nICdkaXNwb3NlJ1xuICAgICAqIEBwcm9wZXJ0eSBldmVudEhhbmRsZXJzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IFtdO1xufTtcblxuSGFtbWVyLkluc3RhbmNlLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBiaW5kIGV2ZW50cyB0byB0aGUgaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kIG9uXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBnZXN0dXJlcyBtdWx0aXBsZSBnZXN0dXJlcyBieSBzcGxpdHRpbmcgd2l0aCBhIHNwYWNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyLmV2IGV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbiBvbkV2ZW50KGdlc3R1cmVzLCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgRXZlbnQub24oc2VsZi5lbGVtZW50LCBnZXN0dXJlcywgaGFuZGxlciwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgc2VsZi5ldmVudEhhbmRsZXJzLnB1c2goeyBnZXN0dXJlOiB0eXBlLCBoYW5kbGVyOiBoYW5kbGVyIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVuYmluZCBldmVudHMgdG8gdGhlIGluc3RhbmNlXG4gICAgICogQG1ldGhvZCBvZmZcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGdlc3R1cmVzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24gb2ZmRXZlbnQoZ2VzdHVyZXMsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIEV2ZW50Lm9mZihzZWxmLmVsZW1lbnQsIGdlc3R1cmVzLCBoYW5kbGVyLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBVdGlscy5pbkFycmF5KHsgZ2VzdHVyZTogdHlwZSwgaGFuZGxlcjogaGFuZGxlciB9KTtcbiAgICAgICAgICAgIGlmKGluZGV4ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuZXZlbnRIYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRyaWdnZXIgZ2VzdHVyZSBldmVudFxuICAgICAqIEBtZXRob2QgdHJpZ2dlclxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZ2VzdHVyZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnREYXRhXVxuICAgICAqL1xuICAgIHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXJFdmVudChnZXN0dXJlLCBldmVudERhdGEpIHtcbiAgICAgICAgLy8gb3B0aW9uYWxcbiAgICAgICAgaWYoIWV2ZW50RGF0YSkge1xuICAgICAgICAgICAgZXZlbnREYXRhID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgRE9NIGV2ZW50XG4gICAgICAgIHZhciBldmVudCA9IEhhbW1lci5ET0NVTUVOVC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgZXZlbnQuaW5pdEV2ZW50KGdlc3R1cmUsIHRydWUsIHRydWUpO1xuICAgICAgICBldmVudC5nZXN0dXJlID0gZXZlbnREYXRhO1xuXG4gICAgICAgIC8vIHRyaWdnZXIgb24gdGhlIHRhcmdldCBpZiBpdCBpcyBpbiB0aGUgaW5zdGFuY2UgZWxlbWVudCxcbiAgICAgICAgLy8gdGhpcyBpcyBmb3IgZXZlbnQgZGVsZWdhdGlvbiB0cmlja3NcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIGlmKFV0aWxzLmhhc1BhcmVudChldmVudERhdGEudGFyZ2V0LCBlbGVtZW50KSkge1xuICAgICAgICAgICAgZWxlbWVudCA9IGV2ZW50RGF0YS50YXJnZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZW5hYmxlIG9mIGRpc2FibGUgaGFtbWVyLmpzIGRldGVjdGlvblxuICAgICAqIEBtZXRob2QgZW5hYmxlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RhdGVcbiAgICAgKi9cbiAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShzdGF0ZSkge1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSBzdGF0ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRpc3Bvc2UgdGhpcyBoYW1tZXIgaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kIGRpc3Bvc2VcbiAgICAgKiBAcmV0dXJuIHtOdWxsfVxuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAgIHZhciBpLCBlaDtcblxuICAgICAgICAvLyB1bmRvIGFsbCBjaGFuZ2VzIG1hZGUgYnkgc3RvcF9icm93c2VyX2JlaGF2aW9yXG4gICAgICAgIFV0aWxzLnRvZ2dsZUJlaGF2aW9yKHRoaXMuZWxlbWVudCwgdGhpcy5vcHRpb25zLmJlaGF2aW9yLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gdW5iaW5kIGFsbCBjdXN0b20gZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgZm9yKGkgPSAtMTsgKGVoID0gdGhpcy5ldmVudEhhbmRsZXJzWysraV0pOykge1xuICAgICAgICAgICAgVXRpbHMub2ZmKHRoaXMuZWxlbWVudCwgZWguZ2VzdHVyZSwgZWguaGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBbXTtcblxuICAgICAgICAvLyB1bmJpbmQgdGhlIHN0YXJ0IGV2ZW50IGxpc3RlbmVyXG4gICAgICAgIEV2ZW50Lm9mZih0aGlzLmVsZW1lbnQsIEVWRU5UX1RZUEVTW0VWRU5UX1NUQVJUXSwgdGhpcy5ldmVudFN0YXJ0SGFuZGxlcik7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAqL1xuLyoqXG4gKiBNb3ZlIHdpdGggeCBmaW5nZXJzIChkZWZhdWx0IDEpIGFyb3VuZCBvbiB0aGUgcGFnZS5cbiAqIFByZXZlbnRpbmcgdGhlIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciBpcyBhIGdvb2Qgd2F5IHRvIGltcHJvdmUgZmVlbCBhbmQgd29ya2luZy5cbiAqIGBgYGBcbiAqICBoYW1tZXJ0aW1lLm9uKFwiZHJhZ1wiLCBmdW5jdGlvbihldikge1xuICogICAgY29uc29sZS5sb2coZXYpO1xuICogICAgZXYuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICogIH0pO1xuICogYGBgYFxuICpcbiAqIEBjbGFzcyBEcmFnXG4gKiBAc3RhdGljXG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFnc3RhcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFnZW5kXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhcGxlZnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFncmlnaHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFndXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFnZG93blxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICovXG4oZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB0cmlnZ2VyZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGRyYWdHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICAgIHZhciBjdXIgPSBEZXRlY3Rpb24uY3VycmVudDtcblxuICAgICAgICAvLyBtYXggdG91Y2hlc1xuICAgICAgICBpZihpbnN0Lm9wdGlvbnMuZHJhZ01heFRvdWNoZXMgPiAwICYmXG4gICAgICAgICAgICBldi50b3VjaGVzLmxlbmd0aCA+IGluc3Qub3B0aW9ucy5kcmFnTWF4VG91Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoKGV2LmV2ZW50VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBFVkVOVF9TVEFSVDpcbiAgICAgICAgICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBFVkVOVF9NT1ZFOlxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGRpc3RhbmNlIHdlIG1vdmVkIGlzIHRvbyBzbWFsbCB3ZSBza2lwIHRoaXMgZ2VzdHVyZVxuICAgICAgICAgICAgICAgIC8vIG9yIHdlIGNhbiBiZSBhbHJlYWR5IGluIGRyYWdnaW5nXG4gICAgICAgICAgICAgICAgaWYoZXYuZGlzdGFuY2UgPCBpbnN0Lm9wdGlvbnMuZHJhZ01pbkRpc3RhbmNlICYmXG4gICAgICAgICAgICAgICAgICAgIGN1ci5uYW1lICE9IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzdGFydENlbnRlciA9IGN1ci5zdGFydEV2ZW50LmNlbnRlcjtcblxuICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBkcmFnZ2luZyFcbiAgICAgICAgICAgICAgICBpZihjdXIubmFtZSAhPSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYoaW5zdC5vcHRpb25zLmRyYWdEaXN0YW5jZUNvcnJlY3Rpb24gJiYgZXYuZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGEgZHJhZyBpcyB0cmlnZ2VyZWQsIHNldCB0aGUgZXZlbnQgY2VudGVyIHRvIGRyYWdNaW5EaXN0YW5jZSBwaXhlbHMgZnJvbSB0aGUgb3JpZ2luYWwgZXZlbnQgY2VudGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2l0aG91dCB0aGlzIGNvcnJlY3Rpb24sIHRoZSBkcmFnZ2VkIGRpc3RhbmNlIHdvdWxkIGp1bXBzdGFydCBhdCBkcmFnTWluRGlzdGFuY2UgcGl4ZWxzIGluc3RlYWQgb2YgYXQgMC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0IG1pZ2h0IGJlIHVzZWZ1bCB0byBzYXZlIHRoZSBvcmlnaW5hbCBzdGFydCBwb2ludCBzb21ld2hlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3IgPSBNYXRoLmFicyhpbnN0Lm9wdGlvbnMuZHJhZ01pbkRpc3RhbmNlIC8gZXYuZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDZW50ZXIucGFnZVggKz0gZXYuZGVsdGFYICogZmFjdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDZW50ZXIucGFnZVkgKz0gZXYuZGVsdGFZICogZmFjdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDZW50ZXIuY2xpZW50WCArPSBldi5kZWx0YVggKiBmYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydENlbnRlci5jbGllbnRZICs9IGV2LmRlbHRhWSAqIGZhY3RvcjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjYWxjdWxhdGUgZXZlbnQgZGF0YSB1c2luZyBuZXcgc3RhcnQgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ID0gRGV0ZWN0aW9uLmV4dGVuZEV2ZW50RGF0YShldik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBsb2NrIGRyYWcgdG8gYXhpcz9cbiAgICAgICAgICAgICAgICBpZihjdXIubGFzdEV2ZW50LmRyYWdMb2NrVG9BeGlzIHx8XG4gICAgICAgICAgICAgICAgICAgICggaW5zdC5vcHRpb25zLmRyYWdMb2NrVG9BeGlzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0Lm9wdGlvbnMuZHJhZ0xvY2tNaW5EaXN0YW5jZSA8PSBldi5kaXN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICBldi5kcmFnTG9ja1RvQXhpcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8ga2VlcCBkaXJlY3Rpb24gb24gdGhlIGF4aXMgdGhhdCB0aGUgZHJhZyBnZXN0dXJlIHN0YXJ0ZWQgb25cbiAgICAgICAgICAgICAgICB2YXIgbGFzdERpcmVjdGlvbiA9IGN1ci5sYXN0RXZlbnQuZGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgIGlmKGV2LmRyYWdMb2NrVG9BeGlzICYmIGxhc3REaXJlY3Rpb24gIT09IGV2LmRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZihVdGlscy5pc1ZlcnRpY2FsKGxhc3REaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldi5kaXJlY3Rpb24gPSAoZXYuZGVsdGFZIDwgMCkgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2LmRpcmVjdGlvbiA9IChldi5kZWx0YVggPCAwKSA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgdGltZSwgdHJpZ2dlciBkcmFnc3RhcnQgZXZlbnRcbiAgICAgICAgICAgICAgICBpZighdHJpZ2dlcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ3N0YXJ0JywgZXYpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgZXZlbnRzXG4gICAgICAgICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUsIGV2KTtcbiAgICAgICAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArIGV2LmRpcmVjdGlvbiwgZXYpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGlzVmVydGljYWwgPSBVdGlscy5pc1ZlcnRpY2FsKGV2LmRpcmVjdGlvbik7XG5cbiAgICAgICAgICAgICAgICAvLyBibG9jayB0aGUgYnJvd3NlciBldmVudHNcbiAgICAgICAgICAgICAgICBpZigoaW5zdC5vcHRpb25zLmRyYWdCbG9ja1ZlcnRpY2FsICYmIGlzVmVydGljYWwpIHx8XG4gICAgICAgICAgICAgICAgICAgIChpbnN0Lm9wdGlvbnMuZHJhZ0Jsb2NrSG9yaXpvbnRhbCAmJiAhaXNWZXJ0aWNhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRVZFTlRfUkVMRUFTRTpcbiAgICAgICAgICAgICAgICBpZih0cmlnZ2VyZWQgJiYgZXYuY2hhbmdlZExlbmd0aCA8PSBpbnN0Lm9wdGlvbnMuZHJhZ01heFRvdWNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyAnZW5kJywgZXYpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRVZFTlRfRU5EOlxuICAgICAgICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgSGFtbWVyLmdlc3R1cmVzLkRyYWcgPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGluZGV4OiA1MCxcbiAgICAgICAgaGFuZGxlcjogZHJhZ0dlc3R1cmUsXG4gICAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIG1pbmltYWwgbW92ZW1lbnQgdGhhdCBoYXZlIHRvIGJlIG1hZGUgYmVmb3JlIHRoZSBkcmFnIGV2ZW50IGdldHMgdHJpZ2dlcmVkXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ01pbkRpc3RhbmNlXG4gICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICogQGRlZmF1bHQgMTBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZHJhZ01pbkRpc3RhbmNlOiAxMCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbiB0byB0cnVlIHRvIG1ha2UgdGhlIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBkcmFnXG4gICAgICAgICAgICAgKiBiZSBjYWxjdWxhdGVkIGZyb20gd2hlcmUgdGhlIGRyYWcgd2FzIHRyaWdnZXJlZCwgbm90IGZyb20gd2hlcmUgdGhlIHRvdWNoIHN0YXJ0ZWQuXG4gICAgICAgICAgICAgKiBVc2VmdWwgdG8gYXZvaWQgYSBqZXJrLXN0YXJ0aW5nIGRyYWcsIHdoaWNoIGNhbiBtYWtlIGZpbmUtYWRqdXN0bWVudHNcbiAgICAgICAgICAgICAqIHRocm91Z2ggZHJhZ2dpbmcgZGlmZmljdWx0LCBhbmQgYmUgdmlzdWFsbHkgdW5hcHBlYWxpbmcuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvblxuICAgICAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRyYWdEaXN0YW5jZUNvcnJlY3Rpb246IHRydWUsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogc2V0IDAgZm9yIHVubGltaXRlZCwgYnV0IHRoaXMgY2FuIGNvbmZsaWN0IHdpdGggdHJhbnNmb3JtXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ01heFRvdWNoZXNcbiAgICAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRyYWdNYXhUb3VjaGVzOiAxLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHByZXZlbnQgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIHdoZW4gZHJhZ2dpbmcgb2NjdXJzXG4gICAgICAgICAgICAgKiBiZSBjYXJlZnVsIHdpdGggaXQsIGl0IG1ha2VzIHRoZSBlbGVtZW50IGEgYmxvY2tpbmcgZWxlbWVudFxuICAgICAgICAgICAgICogd2hlbiB5b3UgYXJlIHVzaW5nIHRoZSBkcmFnIGdlc3R1cmUsIGl0IGlzIGEgZ29vZCBwcmFjdGljZSB0byBzZXQgdGhpcyB0cnVlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0Jsb2NrSG9yaXpvbnRhbFxuICAgICAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkcmFnQmxvY2tIb3Jpem9udGFsOiBmYWxzZSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBzYW1lIGFzIGBkcmFnQmxvY2tIb3Jpem9udGFsYCwgYnV0IGZvciB2ZXJ0aWNhbCBtb3ZlbWVudFxuICAgICAgICAgICAgICogQHByb3BlcnR5IGRyYWdCbG9ja1ZlcnRpY2FsXG4gICAgICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRyYWdCbG9ja1ZlcnRpY2FsOiBmYWxzZSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBkcmFnTG9ja1RvQXhpcyBrZWVwcyB0aGUgZHJhZyBnZXN0dXJlIG9uIHRoZSBheGlzIHRoYXQgaXQgc3RhcnRlZCBvbixcbiAgICAgICAgICAgICAqIEl0IGRpc2FsbG93cyB2ZXJ0aWNhbCBkaXJlY3Rpb25zIGlmIHRoZSBpbml0aWFsIGRpcmVjdGlvbiB3YXMgaG9yaXpvbnRhbCwgYW5kIHZpY2UgdmVyc2EuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0xvY2tUb0F4aXNcbiAgICAgICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZHJhZ0xvY2tUb0F4aXM6IGZhbHNlLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGRyYWcgbG9jayBvbmx5IGtpY2tzIGluIHdoZW4gZGlzdGFuY2UgPiBkcmFnTG9ja01pbkRpc3RhbmNlXG4gICAgICAgICAgICAgKiBUaGlzIHdheSwgbG9ja2luZyBvY2N1cnMgb25seSB3aGVuIHRoZSBkaXN0YW5jZSBoYXMgYmVjb21lIGxhcmdlIGVub3VnaCB0byByZWxpYWJseSBkZXRlcm1pbmUgdGhlIGRpcmVjdGlvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IGRyYWdMb2NrTWluRGlzdGFuY2VcbiAgICAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCAyNVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkcmFnTG9ja01pbkRpc3RhbmNlOiAyNVxuICAgICAgICB9XG4gICAgfTtcbn0pKCdkcmFnJyk7XG5cbi8qKlxuICogQG1vZHVsZSBnZXN0dXJlc1xuICovXG4vKipcbiAqIHRyaWdnZXIgYSBzaW1wbGUgZ2VzdHVyZSBldmVudCwgc28geW91IGNhbiBkbyBhbnl0aGluZyBpbiB5b3VyIGhhbmRsZXIuXG4gKiBvbmx5IHVzYWJsZSBpZiB5b3Uga25vdyB3aGF0IHlvdXIgZG9pbmcuLi5cbiAqXG4gKiBAY2xhc3MgR2VzdHVyZVxuICogQHN0YXRpY1xuICovXG4vKipcbiAqIEBldmVudCBnZXN0dXJlXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuSGFtbWVyLmdlc3R1cmVzLkdlc3R1cmUgPSB7XG4gICAgbmFtZTogJ2dlc3R1cmUnLFxuICAgIGluZGV4OiAxMzM3LFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIHJlbGVhc2VHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAqL1xuLyoqXG4gKiBUb3VjaCBzdGF5cyBhdCB0aGUgc2FtZSBwbGFjZSBmb3IgeCB0aW1lXG4gKlxuICogQGNsYXNzIEhvbGRcbiAqIEBzdGF0aWNcbiAqL1xuLyoqXG4gKiBAZXZlbnQgaG9sZFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICovXG4oZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB0aW1lcjtcblxuICAgIGZ1bmN0aW9uIGhvbGRHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gaW5zdC5vcHRpb25zLFxuICAgICAgICAgICAgY3VycmVudCA9IERldGVjdGlvbi5jdXJyZW50O1xuXG4gICAgICAgIHN3aXRjaChldi5ldmVudFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgZ2VzdHVyZSBzbyB3ZSBjYW4gY2hlY2sgaW4gdGhlIHRpbWVvdXQgaWYgaXQgc3RpbGwgaXNcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm5hbWUgPSBuYW1lO1xuXG4gICAgICAgICAgICAgICAgLy8gc2V0IHRpbWVyIGFuZCBpZiBhZnRlciB0aGUgdGltZW91dCBpdCBzdGlsbCBpcyBob2xkLFxuICAgICAgICAgICAgICAgIC8vIHdlIHRyaWdnZXIgdGhlIGhvbGQgZXZlbnRcbiAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGN1cnJlbnQgJiYgY3VycmVudC5uYW1lID09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lLCBldik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zLmhvbGRUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBFVkVOVF9NT1ZFOlxuICAgICAgICAgICAgICAgIGlmKGV2LmRpc3RhbmNlID4gb3B0aW9ucy5ob2xkVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEVWRU5UX1JFTEVBU0U6XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEhhbW1lci5nZXN0dXJlcy5Ib2xkID0ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBpbmRleDogMTAsXG4gICAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBob2xkVGltZW91dFxuICAgICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IDUwMFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBob2xkVGltZW91dDogNTAwLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIG1vdmVtZW50IGFsbG93ZWQgd2hpbGUgaG9sZGluZ1xuICAgICAgICAgICAgICogQHByb3BlcnR5IGhvbGRUaHJlc2hvbGRcbiAgICAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCAyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGhvbGRUaHJlc2hvbGQ6IDJcbiAgICAgICAgfSxcbiAgICAgICAgaGFuZGxlcjogaG9sZEdlc3R1cmVcbiAgICB9O1xufSkoJ2hvbGQnKTtcblxuLyoqXG4gKiBAbW9kdWxlIGdlc3R1cmVzXG4gKi9cbi8qKlxuICogd2hlbiBhIHRvdWNoIGlzIGJlaW5nIHJlbGVhc2VkIGZyb20gdGhlIHBhZ2VcbiAqXG4gKiBAY2xhc3MgUmVsZWFzZVxuICogQHN0YXRpY1xuICovXG4vKipcbiAqIEBldmVudCByZWxlYXNlXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuSGFtbWVyLmdlc3R1cmVzLlJlbGVhc2UgPSB7XG4gICAgbmFtZTogJ3JlbGVhc2UnLFxuICAgIGluZGV4OiBJbmZpbml0eSxcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiByZWxlYXNlR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSwgZXYpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbW9kdWxlIGdlc3R1cmVzXG4gKi9cbi8qKlxuICogdHJpZ2dlcnMgc3dpcGUgZXZlbnRzIHdoZW4gdGhlIGVuZCB2ZWxvY2l0eSBpcyBhYm92ZSB0aGUgdGhyZXNob2xkXG4gKiBmb3IgYmVzdCB1c2FnZSwgc2V0IGBwcmV2ZW50RGVmYXVsdGAgKG9uIHRoZSBkcmFnIGdlc3R1cmUpIHRvIGB0cnVlYFxuICogYGBgYFxuICogIGhhbW1lcnRpbWUub24oXCJkcmFnbGVmdCBzd2lwZWxlZnRcIiwgZnVuY3Rpb24oZXYpIHtcbiAqICAgIGNvbnNvbGUubG9nKGV2KTtcbiAqICAgIGV2Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAqICB9KTtcbiAqIGBgYGBcbiAqXG4gKiBAY2xhc3MgU3dpcGVcbiAqIEBzdGF0aWNcbiAqL1xuLyoqXG4gKiBAZXZlbnQgc3dpcGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBzd2lwZWxlZnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBzd2lwZXJpZ2h0XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgc3dpcGV1cFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IHN3aXBlZG93blxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbkhhbW1lci5nZXN0dXJlcy5Td2lwZSA9IHtcbiAgICBuYW1lOiAnc3dpcGUnLFxuICAgIGluZGV4OiA0MCxcbiAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IHN3aXBlTWluVG91Y2hlc1xuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICBzd2lwZU1pblRvdWNoZXM6IDEsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBzd2lwZU1heFRvdWNoZXNcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgc3dpcGVNYXhUb3VjaGVzOiAxLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBob3Jpem9udGFsIHN3aXBlIHZlbG9jaXR5XG4gICAgICAgICAqIEBwcm9wZXJ0eSBzd2lwZVZlbG9jaXR5WFxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwLjZcbiAgICAgICAgICovXG4gICAgICAgIHN3aXBlVmVsb2NpdHlYOiAwLjYsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHZlcnRpY2FsIHN3aXBlIHZlbG9jaXR5XG4gICAgICAgICAqIEBwcm9wZXJ0eSBzd2lwZVZlbG9jaXR5WVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwLjZcbiAgICAgICAgICovXG4gICAgICAgIHN3aXBlVmVsb2NpdHlZOiAwLjZcbiAgICB9LFxuXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gc3dpcGVHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICAgIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICAgICAgICB2YXIgdG91Y2hlcyA9IGV2LnRvdWNoZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBpbnN0Lm9wdGlvbnM7XG5cbiAgICAgICAgICAgIC8vIG1heCB0b3VjaGVzXG4gICAgICAgICAgICBpZih0b3VjaGVzIDwgb3B0aW9ucy5zd2lwZU1pblRvdWNoZXMgfHxcbiAgICAgICAgICAgICAgICB0b3VjaGVzID4gb3B0aW9ucy5zd2lwZU1heFRvdWNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIGRpc3RhbmNlIHdlIG1vdmVkIGlzIHRvbyBzbWFsbCB3ZSBza2lwIHRoaXMgZ2VzdHVyZVxuICAgICAgICAgICAgLy8gb3Igd2UgY2FuIGJlIGFscmVhZHkgaW4gZHJhZ2dpbmdcbiAgICAgICAgICAgIGlmKGV2LnZlbG9jaXR5WCA+IG9wdGlvbnMuc3dpcGVWZWxvY2l0eVggfHxcbiAgICAgICAgICAgICAgICBldi52ZWxvY2l0eVkgPiBvcHRpb25zLnN3aXBlVmVsb2NpdHlZKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlciBzd2lwZSBldmVudHNcbiAgICAgICAgICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7XG4gICAgICAgICAgICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSArIGV2LmRpcmVjdGlvbiwgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbW9kdWxlIGdlc3R1cmVzXG4gKi9cbi8qKlxuICogU2luZ2xlIHRhcCBhbmQgYSBkb3VibGUgdGFwIG9uIGEgcGxhY2VcbiAqXG4gKiBAY2xhc3MgVGFwXG4gKiBAc3RhdGljXG4gKi9cbi8qKlxuICogQGV2ZW50IHRhcFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRvdWJsZXRhcFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICovXG4oZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBoYXNNb3ZlZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gdGFwR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGluc3Qub3B0aW9ucyxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBEZXRlY3Rpb24uY3VycmVudCxcbiAgICAgICAgICAgIHByZXYgPSBEZXRlY3Rpb24ucHJldmlvdXMsXG4gICAgICAgICAgICBzaW5jZVByZXYsXG4gICAgICAgICAgICBkaWREb3VibGVUYXA7XG5cbiAgICAgICAgc3dpdGNoKGV2LmV2ZW50VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBFVkVOVF9TVEFSVDpcbiAgICAgICAgICAgICAgICBoYXNNb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSBoYXNNb3ZlZCB8fCAoZXYuZGlzdGFuY2UgPiBvcHRpb25zLnRhcE1heERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBFVkVOVF9FTkQ6XG4gICAgICAgICAgICAgICAgaWYoIVV0aWxzLmluU3RyKGV2LnNyY0V2ZW50LnR5cGUsICdjYW5jZWwnKSAmJiBldi5kZWx0YVRpbWUgPCBvcHRpb25zLnRhcE1heFRpbWUgJiYgIWhhc01vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIGdlc3R1cmUsIGZvciB0aGUgZG91YmxlIHRhcCBzaW5jZSB0aGVzZSBhcmUgdHdvIGRpZmZlcmVudCBnZXN0dXJlIGRldGVjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgc2luY2VQcmV2ID0gcHJldiAmJiBwcmV2Lmxhc3RFdmVudCAmJiBldi50aW1lU3RhbXAgLSBwcmV2Lmxhc3RFdmVudC50aW1lU3RhbXA7XG4gICAgICAgICAgICAgICAgICAgIGRpZERvdWJsZVRhcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGRvdWJsZSB0YXBcbiAgICAgICAgICAgICAgICAgICAgaWYocHJldiAmJiBwcmV2Lm5hbWUgPT0gbmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHNpbmNlUHJldiAmJiBzaW5jZVByZXYgPCBvcHRpb25zLmRvdWJsZVRhcEludGVydmFsKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZXYuZGlzdGFuY2UgPCBvcHRpb25zLmRvdWJsZVRhcERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0LnRyaWdnZXIoJ2RvdWJsZXRhcCcsIGV2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZERvdWJsZVRhcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBkbyBhIHNpbmdsZSB0YXBcbiAgICAgICAgICAgICAgICAgICAgaWYoIWRpZERvdWJsZVRhcCB8fCBvcHRpb25zLnRhcEFsd2F5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudC5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3QudHJpZ2dlcihjdXJyZW50Lm5hbWUsIGV2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEhhbW1lci5nZXN0dXJlcy5UYXAgPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGluZGV4OiAxMDAsXG4gICAgICAgIGhhbmRsZXI6IHRhcEdlc3R1cmUsXG4gICAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIG1heCB0aW1lIG9mIGEgdGFwLCB0aGlzIGlzIGZvciB0aGUgc2xvdyB0YXBwZXJzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgdGFwTWF4VGltZVxuICAgICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IDI1MFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0YXBNYXhUaW1lOiAyNTAsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogbWF4IGRpc3RhbmNlIG9mIG1vdmVtZW50IG9mIGEgdGFwLCB0aGlzIGlzIGZvciB0aGUgc2xvdyB0YXBwZXJzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgdGFwTWF4RGlzdGFuY2VcbiAgICAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCAxMFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0YXBNYXhEaXN0YW5jZTogMTAsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogYWx3YXlzIHRyaWdnZXIgdGhlIGB0YXBgIGV2ZW50LCBldmVuIHdoaWxlIGRvdWJsZS10YXBwaW5nXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgdGFwQWx3YXlzXG4gICAgICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGFwQWx3YXlzOiB0cnVlLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIG1heCBkaXN0YW5jZSBiZXR3ZWVuIHR3byB0YXBzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgZG91YmxlVGFwRGlzdGFuY2VcbiAgICAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCAyMFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkb3VibGVUYXBEaXN0YW5jZTogMjAsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogbWF4IHRpbWUgYmV0d2VlbiB0d28gdGFwc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IGRvdWJsZVRhcEludGVydmFsXG4gICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICogQGRlZmF1bHQgMzAwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRvdWJsZVRhcEludGVydmFsOiAzMDBcbiAgICAgICAgfVxuICAgIH07XG59KSgndGFwJyk7XG5cbi8qKlxuICogQG1vZHVsZSBnZXN0dXJlc1xuICovXG4vKipcbiAqIHdoZW4gYSB0b3VjaCBpcyBiZWluZyB0b3VjaGVkIGF0IHRoZSBwYWdlXG4gKlxuICogQGNsYXNzIFRvdWNoXG4gKiBAc3RhdGljXG4gKi9cbi8qKlxuICogQGV2ZW50IHRvdWNoXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuSGFtbWVyLmdlc3R1cmVzLlRvdWNoID0ge1xuICAgIG5hbWU6ICd0b3VjaCcsXG4gICAgaW5kZXg6IC1JbmZpbml0eSxcbiAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCBhdCB0b3VjaHN0YXJ0LCBhbmQgbWFrZXMgdGhlIGVsZW1lbnQgYmxvY2tpbmcgYnkgZGlzYWJsaW5nIHRoZSBzY3JvbGxpbmcgb2YgdGhlIHBhZ2UsXG4gICAgICAgICAqIGJ1dCBpdCBpbXByb3ZlcyBnZXN0dXJlcyBsaWtlIHRyYW5zZm9ybWluZyBhbmQgZHJhZ2dpbmcuXG4gICAgICAgICAqIGJlIGNhcmVmdWwgd2l0aCB1c2luZyB0aGlzLCBpdCBjYW4gYmUgdmVyeSBhbm5veWluZyBmb3IgdXNlcnMgdG8gYmUgc3R1Y2sgb24gdGhlIHBhZ2VcbiAgICAgICAgICogQHByb3BlcnR5IHByZXZlbnREZWZhdWx0XG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgcHJldmVudERlZmF1bHQ6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkaXNhYmxlIG1vdXNlIGV2ZW50cywgc28gb25seSB0b3VjaCAob3IgcGVuISkgaW5wdXQgdHJpZ2dlcnMgZXZlbnRzXG4gICAgICAgICAqIEBwcm9wZXJ0eSBwcmV2ZW50TW91c2VcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBwcmV2ZW50TW91c2U6IGZhbHNlXG4gICAgfSxcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiB0b3VjaEdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgICAgaWYoaW5zdC5vcHRpb25zLnByZXZlbnRNb3VzZSAmJiBldi5wb2ludGVyVHlwZSA9PSBQT0lOVEVSX01PVVNFKSB7XG4gICAgICAgICAgICBldi5zdG9wRGV0ZWN0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZihpbnN0Lm9wdGlvbnMucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfVE9VQ0gpIHtcbiAgICAgICAgICAgIGluc3QudHJpZ2dlcigndG91Y2gnLCBldik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAqL1xuLyoqXG4gKiBVc2VyIHdhbnQgdG8gc2NhbGUgb3Igcm90YXRlIHdpdGggMiBmaW5nZXJzXG4gKiBQcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3IgaXMgYSBnb29kIHdheSB0byBpbXByb3ZlIGZlZWwgYW5kIHdvcmtpbmcuIFRoaXMgY2FuIGJlIGRvbmUgd2l0aCB0aGVcbiAqIGBwcmV2ZW50RGVmYXVsdGAgb3B0aW9uLlxuICpcbiAqIEBjbGFzcyBUcmFuc2Zvcm1cbiAqIEBzdGF0aWNcbiAqL1xuLyoqXG4gKiBAZXZlbnQgdHJhbnNmb3JtXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgdHJhbnNmb3Jtc3RhcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCB0cmFuc2Zvcm1lbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBwaW5jaGluXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgcGluY2hvdXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCByb3RhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqL1xuKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdHJpZ2dlcmVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1HZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICAgIHN3aXRjaChldi5ldmVudFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICAgICAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRVZFTlRfTU9WRTpcbiAgICAgICAgICAgICAgICAvLyBhdCBsZWFzdCBtdWx0aXRvdWNoXG4gICAgICAgICAgICAgICAgaWYoZXYudG91Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc2NhbGVUaHJlc2hvbGQgPSBNYXRoLmFicygxIC0gZXYuc2NhbGUpO1xuICAgICAgICAgICAgICAgIHZhciByb3RhdGlvblRocmVzaG9sZCA9IE1hdGguYWJzKGV2LnJvdGF0aW9uKTtcblxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGRpc3RhbmNlIHdlIG1vdmVkIGlzIHRvbyBzbWFsbCB3ZSBza2lwIHRoaXMgZ2VzdHVyZVxuICAgICAgICAgICAgICAgIC8vIG9yIHdlIGNhbiBiZSBhbHJlYWR5IGluIGRyYWdnaW5nXG4gICAgICAgICAgICAgICAgaWYoc2NhbGVUaHJlc2hvbGQgPCBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluU2NhbGUgJiZcbiAgICAgICAgICAgICAgICAgICAgcm90YXRpb25UaHJlc2hvbGQgPCBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluUm90YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHdlIGFyZSB0cmFuc2Zvcm1pbmchXG4gICAgICAgICAgICAgICAgRGV0ZWN0aW9uLmN1cnJlbnQubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgICAgICAgICAvLyBmaXJzdCB0aW1lLCB0cmlnZ2VyIGRyYWdzdGFydCBldmVudFxuICAgICAgICAgICAgICAgIGlmKCF0cmlnZ2VyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyAnc3RhcnQnLCBldik7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUsIGV2KTsgLy8gYmFzaWMgdHJhbnNmb3JtIGV2ZW50XG5cbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIHJvdGF0ZSBldmVudFxuICAgICAgICAgICAgICAgIGlmKHJvdGF0aW9uVGhyZXNob2xkID4gaW5zdC5vcHRpb25zLnRyYW5zZm9ybU1pblJvdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3QudHJpZ2dlcigncm90YXRlJywgZXYpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgcGluY2ggZXZlbnRcbiAgICAgICAgICAgICAgICBpZihzY2FsZVRocmVzaG9sZCA+IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1NaW5TY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3BpbmNoJywgZXYpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3BpbmNoJyArIChldi5zY2FsZSA8IDEgPyAnaW4nIDogJ291dCcpLCBldik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEVWRU5UX1JFTEVBU0U6XG4gICAgICAgICAgICAgICAgaWYodHJpZ2dlcmVkICYmIGV2LmNoYW5nZWRMZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ2VuZCcsIGV2KTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgSGFtbWVyLmdlc3R1cmVzLlRyYW5zZm9ybSA9IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgaW5kZXg6IDQ1LFxuICAgICAgICBkZWZhdWx0czoge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBtaW5pbWFsIHNjYWxlIGZhY3Rvciwgbm8gc2NhbGUgaXMgMSwgem9vbWluIGlzIHRvIDAgYW5kIHpvb21vdXQgdW50aWwgaGlnaGVyIHRoZW4gMVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHRyYW5zZm9ybU1pblNjYWxlXG4gICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICogQGRlZmF1bHQgMC4wMVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0cmFuc2Zvcm1NaW5TY2FsZTogMC4wMSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgdHJhbnNmb3JtTWluUm90YXRpb25cbiAgICAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRyYW5zZm9ybU1pblJvdGF0aW9uOiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcjogdHJhbnNmb3JtR2VzdHVyZVxuICAgIH07XG59KSgndHJhbnNmb3JtJyk7XG5cbi8qKlxuICogQG1vZHVsZSBoYW1tZXJcbiAqL1xuXG4vLyBBTUQgZXhwb3J0XG5pZih0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEhhbW1lcjtcbiAgICB9KTtcbi8vIGNvbW1vbmpzIGV4cG9ydFxufSBlbHNlIGlmKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIYW1tZXI7XG4vLyBicm93c2VyIGV4cG9ydFxufSBlbHNlIHtcbiAgICB3aW5kb3cuSGFtbWVyID0gSGFtbWVyO1xufVxuXG59KSh3aW5kb3cpOyIsIi8vIGJhc2UgbG9jYWxlXG5cbm1vZHVsZS5leHBvcnRzID0gd2luZG93LmJsb2NrbHkuY29tbW9uX2xvY2FsZTtcbiIsImV4cG9ydHMuYWRkUmVhZHlMaXN0ZW5lciA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGNhbGxiYWNrLCBmYWxzZSk7XG4gIH1cbn07XG5cbmV4cG9ydHMuZ2V0VG91Y2hFdmVudE5hbWUgPSBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgdmFyIGlzSUUxMVRvdWNoID0gd2luZG93Lm5hdmlnYXRvci5wb2ludGVyRW5hYmxlZDtcbiAgdmFyIGlzSUUxMFRvdWNoID0gd2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkO1xuICB2YXIgaXNTdGFuZGFyZFRvdWNoID0gJ29udG91Y2hlbmQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICB2YXIga2V5O1xuICBpZiAoaXNJRTExVG91Y2gpIHtcbiAgICBrZXkgPSBcImllMTFcIjtcbiAgfSBlbHNlIGlmIChpc0lFMTBUb3VjaCkge1xuICAgIGtleSA9IFwiaWUxMFwiO1xuICB9IGVsc2UgaWYgKGlzU3RhbmRhcmRUb3VjaCkge1xuICAgIGtleSA9IFwic3RhbmRhcmRcIjtcbiAgfVxuICBpZiAoa2V5ICYmIFRPVUNIX01BUFtldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIFRPVUNIX01BUFtldmVudE5hbWVdW2tleV07XG4gIH1cbn07XG5cbnZhciBhZGRFdmVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAvLyBTY29wZSBib3VuZCBldmVudCBtYXAgdG8gdGhpcyBhZGRFdmVudCBjYWxsIC0gd2Ugb25seSBwcm92aWRlIGZvciB1bmJpbmRpbmdcbiAgLy8gd2hhdCB3ZSBiaW5kIHJpZ2h0IGhlcmUuXG4gIHZhciBib3VuZEV2ZW50cyA9IHt9O1xuXG4gIHZhciBiaW5kRXZlbnQgPSBmdW5jdGlvbiAodHlwZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIGJvdW5kRXZlbnRzW3R5cGVdID0geyBuYW1lOiBldmVudE5hbWUsIGhhbmRsZXI6IGhhbmRsZXIgfTtcbiAgfTtcblxuICB2YXIgdW5iaW5kRXZlbnQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBldmVudEluZm8gPSBib3VuZEV2ZW50c1t0eXBlXTtcbiAgICBpZiAoZXZlbnRJbmZvKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRJbmZvLm5hbWUsIGV2ZW50SW5mby5oYW5kbGVyKTtcbiAgICAgIGRlbGV0ZSBib3VuZEV2ZW50c1t0eXBlXTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQWRkIGNsaWNrIGhhbmRsZXJcbiAgYmluZEV2ZW50KCdjbGljaycsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG5cbiAgLy8gT3B0aW9uYWxseSBhZGQgdG91Y2ggaGFuZGxlclxuICB2YXIgdG91Y2hFdmVudCA9IGV4cG9ydHMuZ2V0VG91Y2hFdmVudE5hbWUoZXZlbnROYW1lKTtcbiAgaWYgKHRvdWNoRXZlbnQpIHtcbiAgICBiaW5kRXZlbnQoJ3RvdWNoJywgdG91Y2hFdmVudCwgZnVuY3Rpb24oZSkge1xuICAgICAgLy8gU3RvcCBtb3VzZSBldmVudHMgYW5kIHN1cHByZXNzIGRlZmF1bHQgZXZlbnQgaGFuZGxlciB0byBwcmV2ZW50XG4gICAgICAvLyB1bmludGVudGlvbmFsIGRvdWJsZS1jbGlja2luZ1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdW5iaW5kRXZlbnQoJ2NsaWNrJyk7XG4gICAgICBoYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBSZXR1cm4gZnVuY3Rpb24gdGhhdCB1bmJpbmRzIGFsbCBoYW5kbGVyc1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHVuYmluZEV2ZW50KCdjbGljaycpO1xuICAgIHVuYmluZEV2ZW50KCd0b3VjaCcpO1xuICB9O1xufTtcblxuZXhwb3J0cy5hZGRNb3VzZURvd25Ub3VjaEV2ZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgaGFuZGxlcikge1xuICByZXR1cm4gYWRkRXZlbnQoZWxlbWVudCwgJ21vdXNlZG93bicsIGhhbmRsZXIpO1xufTtcblxuZXhwb3J0cy5hZGRNb3VzZVVwVG91Y2hFdmVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGhhbmRsZXIpIHtcbiAgcmV0dXJuIGFkZEV2ZW50KGVsZW1lbnQsICdtb3VzZXVwJywgaGFuZGxlcik7XG59O1xuXG5leHBvcnRzLmFkZE1vdXNlTW92ZVRvdWNoRXZlbnQgPSBmdW5jdGlvbihlbGVtZW50LCBoYW5kbGVyKSB7XG4gIHJldHVybiBhZGRFdmVudChlbGVtZW50LCAnbW91c2Vtb3ZlJywgaGFuZGxlcik7XG59O1xuXG5leHBvcnRzLmFkZENsaWNrVG91Y2hFdmVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGhhbmRsZXIpIHtcbiAgcmV0dXJuIGFkZEV2ZW50KGVsZW1lbnQsICdjbGljaycsIGhhbmRsZXIpO1xufTtcblxuLy8gQSBtYXAgZnJvbSBzdGFuZGFyZCB0b3VjaCBldmVudHMgdG8gdmFyaW91cyBhbGlhc2VzLlxudmFyIFRPVUNIX01BUCA9IHtcbiAgLy8gIEluY29tcGxldGUgbGlzdCwgYWRkIGFzIG5lZWRlZC5cbiAgY2xpY2s6IHtcbiAgICBzdGFuZGFyZDogJ3RvdWNoc3RhcnQnLFxuICAgIGllMTA6ICdNU1BvaW50ZXJEb3duJyxcbiAgICBpZTExOiAncG9pbnRlcmRvd24nXG4gIH0sXG4gIG1vdXNlZG93bjoge1xuICAgIHN0YW5kYXJkOiAndG91Y2hzdGFydCcsXG4gICAgaWUxMDogJ01TUG9pbnRlckRvd24nLFxuICAgIGllMTE6ICdwb2ludGVyZG93bidcbiAgfSxcbiAgbW91c2V1cDoge1xuICAgIHN0YW5kYXJkOiAndG91Y2hlbmQnLFxuICAgIGllMTA6ICdNU1BvaW50ZXJVcCcsXG4gICAgaWUxMTogJ3BvaW50ZXJ1cCdcbiAgfSxcbiAgbW91c2Vtb3ZlOiB7XG4gICAgc3RhbmRhcmQ6ICd0b3VjaG1vdmUnLFxuICAgIGllMTA6ICdNU1BvaW50ZXJNb3ZlJyxcbiAgICBpZTExOiAncG9pbnRlcm1vdmUnXG4gIH1cbn07XG5cbmV4cG9ydHMuaXNNb2JpbGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlZyA9IC9Nb2JpbGV8aVAoaG9uZXxvZHxhZCl8QW5kcm9pZHxCbGFja0JlcnJ5fElFTW9iaWxlLztcbiAgcmV0dXJuIHJlZy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbn07XG5cbmV4cG9ydHMuaXNXaW5kb3dzVG91Y2ggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlZyA9IC9NU0lFLipUb3VjaC87XG4gIHJldHVybiByZWcudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59O1xuXG5leHBvcnRzLmlzQW5kcm9pZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVnID0gL0FuZHJvaWQvO1xuICByZXR1cm4gcmVnLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xufTtcblxuZXhwb3J0cy5pc0lPUyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVnID0gL2lQKGhvbmV8b2R8YWQpLztcbiAgcmV0dXJuIHJlZy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbn07XG5cbmV4cG9ydHMuaXNJUGFkID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZWcgPSAvaVBhZC9pO1xuICByZXR1cm4gcmVnLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xufTtcbiIsIi8qKiBAZmlsZSBQcm92aWRlIGJyb3dzYWJsZSBjb21tYW5kIGhpc3RvcnkgdG8gYSB0ZXh0Ym94IHdpdGggbGltaXRlZCBkZXB0aC4gKi9cbi8vIFN0cmljdCBsaW50aW5nOiBBYnNvcmIgaW50byBnbG9iYWwgY29uZmlnIHdoZW4gcG9zc2libGVcbi8qIGpzaGludFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG4gbWF4bGVuOiAxMjBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29tbWFuZEhpc3RvcnkgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIE9yZGVyZWQgY29sbGVjdGlvbiBvZiBjb21tYW5kIGVudHJpZXMuXG4gICAqIEBwcml2YXRlIHtzdHJpbmdbXX1cbiAgICovXG4gIHRoaXMuY29tbWFuZHNfID0gW107XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgaW5kZXggaW50byBjb21tYW5kc18sIHdoZXJlIDAgaXMgdGhlIG9sZGVzdCBjb21tYW5kIHN0b3JlZFxuICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5jdXJyZW50SW5kZXhfID0gMDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgdG8gc3RvcmUgaW4gdGhlIGNvbW1hbmQgaGlzdG9yeSwgdG9cbiAgICogcHJldmVudCBldmVyLWluY3JlYXNpbmcgbWVtb3J5IGZvciB0aGlzIGZlYXR1cmUuXG4gICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLm1heEVudHJpZXNfID0gNjQ7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gY29tbWFuZCB0byB0aGUgY3VycmVudCBjb21tYW5kIGhpc3RvcnkuICBJZiB0aGUgY29tbWFuZFxuICogaGlzdG9yeSBoYXMgYWxyZWFkeSByZWFjaGVkIGl0cyBtYXhpbXVtIGRlcHRoLCB0aGUgb2xkZXN0IGNvbW1hbmQgd2lsbFxuICogZHJvcCBvZmYgc28gdGhhdCB0aGUgbmV3ZXN0IGNvbW1hbmQgY2FuIGJlIGFkZGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbW1hbmRcbiAqL1xuQ29tbWFuZEhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY29tbWFuZCkge1xuICBpZiAodGhpcy5jb21tYW5kc18ubGVuZ3RoID49IHRoaXMubWF4RW50cmllc18pIHtcbiAgICB0aGlzLmNvbW1hbmRzXy5zaGlmdCgpO1xuICAgIHRoaXMuY3VycmVudEluZGV4XyAtPSAxO1xuICB9XG4gIHRoaXMuY29tbWFuZHNfLnB1c2goY29tbWFuZCk7XG4gIHRoaXMuY3VycmVudEluZGV4XyA9IHRoaXMuY29tbWFuZHNfLmxlbmd0aDtcbn07XG5cbi8qKlxuICogTW92ZSBiYWNrIGluIHRpbWUgYnkgb25lIGVudHJ5LCByZXR1cm5pbmcgdGhlIGNvbW1hbmQgYXQgdGhlIG5ld1xuICogY29tbWFuZCBpbmRleC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyZW50SW5wdXRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbkNvbW1hbmRIaXN0b3J5LnByb3RvdHlwZS5nb0JhY2sgPSBmdW5jdGlvbiAoY3VycmVudElucHV0KSB7XG4gIHRoaXMuYWx0ZXJIaXN0b3J5Xyh0aGlzLmN1cnJlbnRJbmRleF8sIGN1cnJlbnRJbnB1dCk7XG5cbiAgaWYgKHRoaXMuY3VycmVudEluZGV4XyA+IDApIHtcbiAgICB0aGlzLmN1cnJlbnRJbmRleF8gLT0gMTtcbiAgfVxuICBpZiAodHlwZW9mIHRoaXMuY29tbWFuZHNfW3RoaXMuY3VycmVudEluZGV4X10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZHNfW3RoaXMuY3VycmVudEluZGV4X107XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnRJbnB1dDtcbn07XG5cbi8qKlxuICogTW92ZSBmb3J3YXJkIGluIHRpbWUgYnkgb25lIGVudHJ5LCByZXR1cm5pbmcgdGhlIGNvbW1hbmQgYXQgdGhlIG5ld1xuICogY29tbWFuZCBpbmRleC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyZW50SW5wdXRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbkNvbW1hbmRIaXN0b3J5LnByb3RvdHlwZS5nb0ZvcndhcmQgPSBmdW5jdGlvbiAoY3VycmVudElucHV0KSB7XG4gIHRoaXMuYWx0ZXJIaXN0b3J5Xyh0aGlzLmN1cnJlbnRJbmRleF8sIGN1cnJlbnRJbnB1dCk7XG5cbiAgaWYgKHRoaXMuY3VycmVudEluZGV4XyA8IHRoaXMuY29tbWFuZHNfLmxlbmd0aCkge1xuICAgIHRoaXMuY3VycmVudEluZGV4XyArPSAxO1xuICB9XG4gIGlmICh0aGlzLmN1cnJlbnRJbmRleF8gPT09IHRoaXMuY29tbWFuZHNfLmxlbmd0aCAmJlxuICAgICAgY3VycmVudElucHV0ID09PSB0aGlzLmNvbW1hbmRzX1t0aGlzLmN1cnJlbnRJbmRleF8gLSAxXSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBpZiAodHlwZW9mIHRoaXMuY29tbWFuZHNfW3RoaXMuY3VycmVudEluZGV4X10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZHNfW3RoaXMuY3VycmVudEluZGV4X107XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnRJbnB1dDtcbn07XG5cbi8qKlxuICogT3ZlcndyaXRlcyB0aGUgY3VycmVudGx5IHZpZXdlZCBjb21tYW5kIGVudHJ5IGluIHRoZSBoaXN0b3J5IHdpdGggYSBuZXdcbiAqIHZhbHVlLiAgV2lsbCBkbyBub3RoaW5nIGlmIGF0dGVtcHRpbmcgb3ZlcndyaXRlIGFuIGVtcHR5IGVudHJ5LlxuICogQHBhcmFtIHshbnVtYmVyfSBpbmRleCAtIHBvc2l0aW9uIGluIGNvbW1hbmQgaGlzdG9yeSB0byByZXdyaXRlXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5ld1ZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5Db21tYW5kSGlzdG9yeS5wcm90b3R5cGUuYWx0ZXJIaXN0b3J5XyA9IGZ1bmN0aW9uIChpbmRleCwgbmV3VmFsdWUpIHtcbiAgaWYgKHRoaXMuY29tbWFuZHNfW2luZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5jb21tYW5kc19baW5kZXhdID0gbmV3VmFsdWU7XG4gIH1cbn07XG4iXX0=
