<!DOCTYPE html>
<!-- Text compression widget. Original code written by Baker Franke. -->
<html>
<head>
  <style>
    #input {
      float: left;
      width: 33%;
    }
    #output {
      float: left;
      width: 67%
    }
    #compressedPoem {
      box-sizing: border-box;
      height: 200px;
      padding: 10px;
      border: solid 1px #ddd;
      font-size: 14pt;
      white-space: pre-wrap;
      word-wrap: break-word;
      background-color: #fff;
    }
    #data {
      padding: 5px;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: monospace;
      background-color: #000;
      color: #0c0;
    }
    #dictEntries {
      float: left;
      width: 30px;
      text-align: right;
      padding: 10px 5px;
      font-size: 14pt;
      line-height: 1.2em;
      margin: 0;
      white-space: pre-wrap;
      border: none;
      height: 350px;
      font-family: monospace;
      font-weight: bold;
    }
    #dictionary {
      box-sizing: border-box;
      width: calc(100% - 40px);
      font-size: 14pt;
      line-height: 1.2em;
    }
    #compressedPoem, #dictEntries {
      -moz-user-select: text;
      -webkit-user-select: text;
      -ms-user-select: text;
      user-select: text;
    }
    mark, #dictEntries {
      background-color: #ff9;
    }
    #selfEnteredPoem {
      box-sizing: border-box;
      width: 100%;
    }
    #outputWrapper {
      padding-right: 20px;
    }
  </style>
  <script type="text/javascript">
    var dictEntries = [9788, 9730, 9731, 9732, 9733, 9734, 9742, 9774, 9775, 9786, 9745, 9762, 9851, 9824, 9827, 9829, 9830, 9746, 9789, 9758]
        .map(function (c) { return String.fromCharCode(c); });
    var poemsList = [
        "Pitter_patter_pitter_patter_listen_to_the_rain_pitter_patter_pitter_patter_on_the_window_pane",
        "A_tutor_who_tooted_the_flute_Tried_to_tutor_two_tooters_to_toot_Said_the_two_to_their_tutor,_\"Is_it_harder_to_toot_Or_to_tutor_two_tooters_to_toot?\"",
        "She_sells_sea_shells_on_the_sea_shore_The_shells_that_she_sells_are_sea_shells_I\'m_sure_So_if_she_sells_sea_shells_on_the_sea_shore_I'm_sure_that_the_shells_are_sea_shore_shells_",
        "I_know_an_old_lady_who_swallowed_a_bird_How_absurd!_She_swallowed_a_bird!_She_swallowed_the_bird_to_catch_the_spider_That_wriggled_and_jiggled_and_tickled_inside_her_She_swallowed_the_spider_to_catch_the_fly_I_don't_know_why_she_swallowed_a_fly_Perhaps_she'll_die",
        "Pease_porridge_hot_Pease_porridge_cold_Pease_porridge_in_the_pot_Nine_days_old._Some_like_it_hot_Some_like_it_cold_Some_like_it_in_the_pot_Nine_days_old.",
        "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    ];
    var selectedPoem = 0;
    var poemCalc = poemsList[selectedPoem];
    var poemText = poemsList[selectedPoem];

    function init() {

      if (document.getElementById("poemsList").length == 0) {
        for (var i = 0; i < poemsList.length; i++) {
          var option = document.createElement("option");
          option.text = poemsList[i].substring(0, 20).replace(/_/g, " ") + "...";
          document.getElementById("poemsList").add(option, null);
        }
      }
      selectedPoem = document.getElementById("poemsList").selectedIndex;
      setupPoemWithText(poemsList[selectedPoem]);
    }

    function setupPoemWithText(text) {
      text = text.replace(/[ \n]/g, "_");
      document.getElementById("dictEntries").innerHTML = "";
      document.getElementById("compressedPoem").innerHTML = text;
      poemCalc = text;
      poemText = text;
      for (var i = 0; i < 16; i++) {
        document.getElementById("dictEntries").innerHTML += dictEntries[i] + "\n";
      }
      calculateData();
    }

    function calculateData() {
      var dictSize = document.getElementById("dictionary").value.length + 1;
      if (document.getElementById("dictionary").value.length == 0) {
        dictSize = 0;
      }

      var poemSize = poemCalc.length;
      var total = dictSize + poemSize;
      var compression = (1 - (total / poemText.length)) * 10000;
      compression = Math.round(compression);
      compression /= 100;
      document.getElementById("data").innerHTML = "      poem size: " + poemSize + " bytes\n";
      document.getElementById("data").innerHTML += "dictionary size: " + dictSize + " bytes\n";
      document.getElementById("data").innerHTML += "          total: " + total + " bytes\n";
      document.getElementById("data").innerHTML += "    compression: " + compression + "%\n";
    }

    // Recursively construct a self-referencing entry.
    function fillOutSelfReference(str, dict, maxIndex) {

      var nonascii = str.replace(/[?0-9A-z_'\"?.,!;:]/gi, "");
      if (nonascii.length == 0) {
        return str;
      }

      // For every nonascii character.
      for (var i = 0; i < nonascii.length; i++) {
        // Look it up in the dictionary.
        var dictIndex = dictEntries.indexOf(nonascii.charAt(i));
        if (dictIndex < maxIndex) {
          // Replace the first occurrence of it in the string.
          str = str.replace(nonascii.charAt(i), dict[dictIndex]);
        }
        else {
          return str;
        }
      }
      str = fillOutSelfReference(str, dict, maxIndex);
      return str;
    }

    function escapeRegExp(str) {
      return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    }

    function compress() {

      var poemDisplay = poemText;
      poemCalc = poemText;

      var poemDisplayHighlight = poemText;

      var dict = document.getElementById("dictionary").value.split("\n");
      // Go backwards through dict because self-referencing entries should go first.
      for (var i = dict.length - 1; i >= 0; i--) {
        if (dict[i] != "") {
          // First compute any self referencing -- this is the string we'll look for in the poem.
          var strToLookFor = fillOutSelfReference(dict[i], dict, i);

          //NOTE: poemDisplayHighlight is a kludge fix needed to support entry of your own text.  Problem was previous version was
          // embedding <mark> tags for highlighting, and then continuing to calculate on that version.  Notice that 'poemDisplay'
          // and 'poemDisplay' highlight both operate on poemDisplay and just substitute slightly different things.  The working version
          // of the poem for this computation is poemDisplay.
          poemDisplayHighlight = poemDisplay.replace(new RegExp(escapeRegExp(strToLookFor), "gi"), "<mark>" + dictEntries[i] + "</mark>");
          poemDisplay = poemDisplay.replace(new RegExp(escapeRegExp(strToLookFor), "gi"), "" + dictEntries[i]);
          poemCalc = poemCalc.replace(new RegExp(strToLookFor, "gi"), "#");
        }
      }
      document.getElementById("compressedPoem").innerHTML = poemDisplayHighlight;
      calculateData();
    }
  </script>
</head>
<body>
<p><b>Directions:</b></p>
<ul>
  <li>Look at the poem for patterns (repeated words or phrases) in the text. Enter the patterns you see into the dictionary on the right.
  <li>As you type entries into the dictionary, the symbol for the entry is inserted into the poem in place of the pattern.
  <li>The dictionary is not case sensitive. Use _ for spaces.
  <li>At the bottom you'll see how much the compression you've achieved.
  <li>(NOTE: the dictionary only supports backwards self-referencing).
</ul>

<div>Choose a poem: <select id="poemsList" onChange="init();"></select></div>

<div id="output">
  <div id="outputWrapper">
    Compressed:<br>
    <div id="compressedPoem"></div>
    <div id="data">asdfas</div>
    <div id="enter your own" title="Enter your own poem text here">
      Enter your own poem Text:<br>
      <textarea id="selfEnteredPoem" onkeyup="setupPoemWithText(this.value);" rows="7"></textarea>
    </div>
  </div>
</div>
<div id="input">
  Dictionary:<br>
  <div id="dictEntries"></div>
  <textarea id="dictionary" onkeyup="compress();" rows="16"></textarea>
</div>
<script>
  init();
</script>
</body>
</html>
