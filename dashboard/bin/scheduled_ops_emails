#!/usr/bin/env ruby
require_relative '../../lib/cdo/only_one'
require_relative '../../lib/cdo/activity_constants'
require_relative '../config/environment'

def main
  Dir.chdir(dashboard_dir) do
    # Get all workshops that start two weeks or 3 days from today
    upcoming_workshops = DASHBOARD_DB.fetch('
      SELECT * FROM segments JOIN workshops ON workshops.id = workshop_id  GROUP BY workshop_id
      HAVING (DATE(MIN(start)) = (DATE_ADD(CURDATE(), INTERVAL 2 WEEK)))
      OR (DATE(MIN(start)) = (DATE_ADD(CURDATE(), INTERVAL 3 DAY)));
    ')
    completed_workshops = DASHBOARD_DB.fetch('
      SELECT * FROM segments JOIN workshops ON workshops.id = workshop_id  GROUP BY workshop_id
      HAVING (DATE(MAX(start)) = DATE_ADD(CURDATE(), INTERVAL -1 DAY));
    ')

    [upcoming_workshops, completed_workshops].each do |workshop_list|
      workshop_list.each do |workshop|
        workshop_segments = DASHBOARD_DB.fetch("SELECT * FROM segments WHERE workshop_id = #{workshop[:id]};")
        teachers = Workshop.find(workshop[:id]).teachers
        drop_ins = Workshop.find(workshop[:id]).unexpected_teachers
        facilitators = Workshop.find(workshop[:id]).facilitators
        [teachers, drop_ins, facilitators].each do |recipient_list|
          recipient_list.each do |recipient|
            workshop[:segments] = workshop_segments
            # workshop[:start] will be the start of the first workshop segment for upcoming workshops, and the start
            # of the last segment for completed workshops. See the group by clause of the workshop queries
            if workshop[:start].to_date == (Date.today - 1.day)
              puts("Sending exit survey info to #{recipient.properties['ops_first_name']}")
              OpsMailer.exit_survey_information(workshop, recipient).deliver
            else
              puts("Sending email reminder to #{recipient.properties['ops_first_name']}")
              OpsMailer.workshop_reminder(workshop, recipient).deliver
            end
          end
        end

      end
    end
  end
end

main if only_one_running?(__FILE__)
