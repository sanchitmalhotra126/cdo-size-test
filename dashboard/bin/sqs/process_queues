#!/usr/bin/env ruby
# A service for processing a set of SQS queues defined by a config file.
# Usage ./process_queues QUEUE_CONFIG.JSON

require_relative '../../config/environment'

require 'json'
require 'pp'

require 'sqs/queue_processor_config'
require 'sqs/queue_processor'

# A manager for starting and stopping a set of queue processors based
# on a JSON config file.
class QueueProcessorManager
  def initialize
    @processors = []
  end

  # Starts as set of queue processors based on a config hash.
  # @return [Hash<String, SQS::Metric] A map from name to metrics for each queue.
  def start_queue_processors(json)
    metrics_map = {}
    configs = SQS::QueueProcessorConfig::create_configs_from_json(json)
    configs.each do |config|
      puts "Starting queue processor for #{config.name}"
      sqs_metrics = SQS::Metrics.new
      metrics_map[config.name] = sqs_metrics
      processor = SQS::QueueProcessor.new(config, sqs_metrics)
      processor.start
      @processors << processor
    end
    metrics_map
  end

  # Stop all of the queue processors in parallel.
  # Blocks until they all have stopped.
  def stop_queue_processors
    threads = []
    @processors.each do |processor|
      threads << Thread.new {
        processor.stop
      }
    end
    threads.each do |thread|
      thread.join
    end
  end

  def main
    if ARGV.size != 1
      puts "Usage: #{$0} CONFIG_FILE.json"
      exit 0
    end

    manager = QueueProcessorManager.new
    json = File.open(ARGV[0]).read
    metrics_map = manager.start_queue_processors(json)

    # Run until SIGINT is received.
    stopping = false
    exit_proc = Proc.new {
      puts "Shutting down, please wait..."
      manager.stop_queue_processors unless stopping
      stopping = true
      exit
    }
    Signal.trap('SIGINT') {
      exit_proc.call
    }
    Signal.trap('SIGTERM') {
      exit_proc.call
    }

    puts "Press ^C to stop"
    loop do
      metrics_map.each do |k,v|
        puts "#{k}: #{v}"
      end
      interruptible_sleep 10
    end
  end

  private

  # Sleep but allow ^C to interrupt the sleep
  def interruptible_sleep(seconds)
    @_sleep_check, @_sleep_interrupt = IO.pipe
    IO.select([@_sleep_check], nil, nil, seconds)
  end
end

QueueProcessorManager.new.main
