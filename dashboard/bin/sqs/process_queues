#!/usr/bin/env ruby
# A service for processing a set of SQS queues defined by a config file.
# Usage ./process_queues QUEUE_CONFIG.JSON

require 'logger'

puts "Loading environment..."
require_relative '../../config/environment'

require 'json'
require 'pp'

require 'sqs/queue_processor_config'
require 'sqs/queue_processor'

# A manager for starting and stopping a set of queue processors based
# on a JSON config file.
class QueueProcessorManager
  attr_accessor :logger

  def initialize(logger = Logger.new(STDOUT))
    @processors = []
    @logger = logger
  end

  # Starts as set of queue processors based on a config hash.
  # @return [Hash<String, SQS::Metric] A map from name to metrics for each queue.
  def start_queue_processors(json)
    metrics_map = {}
    configs = SQS::QueueProcessorConfig::create_configs_from_json(json)
    configs.each do |config|
      logger.info "Starting queue processor for #{config.name}"
      sqs_metrics = SQS::Metrics.new
      metrics_map[config.name] = sqs_metrics
      processor = SQS::QueueProcessor.new(config, sqs_metrics)
      processor.start
      @processors << processor
    end
    metrics_map
  end

  # Stop all of the queue processors in parallel.
  # Blocks until they all have stopped.
  def stop_queue_processors
    threads = []
    @processors.each do |processor|
      threads << Thread.new {
        processor.stop
      }
    end
    threads.each do |thread|
      thread.join
    end
  end

  def run
    if ARGV.size < 1
      puts "Usage: #{$0} CONFIG_FILE.json [UPDATE-INTERVAL]"
      exit 0
    end
    config_file = ARGV[0]
    logger.info "Reading config file #{config_file}"
    json = File.open(config_file).read

    update_interval = (ARGV.size >= 2) ? ARGV[1].to_i : 10
    update_interval = 1 if update_interval < 1  # Don't update too quickly.

    metrics_map = start_queue_processors(json)

    # Run until SIGINT is received.
    stopping = false
    exit_proc = Proc.new {
      puts "Shutting down, please wait..."
      stop_queue_processors unless stopping
      stopping = true
      exit
    }
    Signal.trap('SIGINT') {
      exit_proc.call
    }
    Signal.trap('SIGTERM') {
      exit_proc.call
    }

    time = 0
    loop do
      metrics_map.each do |k,v|
        logger.info "#{k}: #{v}  time=#{time}"
        time += 1
      end
      interruptible_sleep update_interval
    end
  end

  private

  # Sleep but allow ^C to interrupt the sleep
  def interruptible_sleep(seconds)
    @_sleep_check, @_sleep_interrupt = IO.pipe
    IO.select([@_sleep_check], nil, nil, seconds)
  end
end

QueueProcessorManager.new.run
