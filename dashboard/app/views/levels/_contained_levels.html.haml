-# NOTE: we only show the first contained level for now, but this could be expanded to allow multiple levels
- unless @level.contained_levels.empty?
  #contained_levels
    - contained_level = @level.contained_levels.first
    %div{id: "containedLevel0"}
      - if @user && current_user && @user != current_user
        -# load other user's solution for teachers viewing their students' solution
        - sublevel_last_attempt = @user.last_attempt(contained_level).try(:level_source).try(:data)
      - elsif current_user
        -# load user's previous attempt at this puzzle.
        - sublevel_last_attempt = current_user.last_attempt(contained_level).try(:level_source).try(:data)

      - level_class = contained_level.class.to_s.underscore
      - if level_class == "multi"
        = render partial: 'levels/single_multi', locals: {standalone: false, contained_mode: true, last_attempt: sublevel_last_attempt, level: contained_level, tight_layout: false}
      - elsif level_class == "text_match"
        = render partial: 'levels/single_text_match', locals: {standalone: false, level: contained_level }
      - elsif level_class == "free_response"
        = render partial: 'levels/free_response', locals: {in_level_group: true, level: contained_level }
%div{style: 'clear: both;'}

:javascript
  // TEMP (move JS into code-studio)
  var submitSelector = "#submit_level_#{contained_level.id}";
  $(document).on('click', submitSelector, function () {
    var submitButton = $(submitSelector);
    if (submitButton.attr('disabled')) {
      return;
    }

    // Avoid multiple simultaneous submissions.
    submitButton.attr('disabled', true);

    var results = window.levelGroup.levels[#{contained_level.id}].getResult();
    var response = results.response;
    var result = results.result;
    var errorType = results.errorType;
    var testResult = results.testResult ? results.testResult : (result ? 100 : 0);
    var submitted = results.submitted || false;

    window.dashboard.reporting.sendReport({
      program: response,
      fallbackResponse: appOptions.report.fallbackResponse,
      callback: appOptions.report.sublevelCallback + "#{contained_level.id}",
      app: "#{contained_level.game.name}",
      level: "#{contained_level.level_num}",
      result: result,
      pass: result,
      testResult: testResult,
      submitted: submitted,
      onComplete: function () {
        var lastServerResponse = window.dashboard.reporting.getLastServerResponse();
        var willRedirect = !!lastServerResponse.nextRedirect;
        onSendReportComplete(willRedirect);

        if (lastServerResponse.nextRedirect) {
          window.location.href = lastServerResponse.nextRedirect;
        }

        /*
        if (lastServerResponse.videoInfo) {
          window.dashboard.videos.showVideoDialog(lastServerResponse.videoInfo);
        } else if (lastServerResponse.endOfStageExperience) {
          const body = document.createElement('div');
          const stageInfo = lastServerResponse.previousStageInfo;
          const stageName = `${window.dashboard.i18n.t('stage')} ${stageInfo.position}: ${stageInfo.name}`;
          ReactDOM.render(
            <PlayZone
              stageName={stageName}
              onContinue={() => { dialog.hide(); }}
              i18n={window.dashboard.i18n}/>,
            body
          );
          const dialog = new Dialog({
            body: body,
            width: 800,
            redirect: lastServerResponse.nextRedirect
          });
          dialog.show();
        } else if (lastServerResponse.nextRedirect) {
          if (appOptions.dialog.shouldShowDialog) {
            showDialog("success");
          } else {
            window.location.href = lastServerResponse.nextRedirect;
          }
        }
        */
      }
    });
  });
