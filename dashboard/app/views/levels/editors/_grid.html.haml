= hidden_field_tag :size, 8
= f.hidden_field :maze_data
.field
  = f.label 'level'
  :css
    .label { background-color: black }
    .border { background-color: dimgray !important }
    .path { background-color: darkgreen !important }
    .start { background-color: firebrick !important }
    .end { background-color: lime !important }
    .obstacle { background-color: gold !important }
    .dirt { background-color: #d1d567 !important }
    .conditional { background-color: green !important }
    tr {
      height: 40px;
    }
    td.start {
      background-image: url('/blockly/media/skins/birds/small_static_avatar.png');
      background-size: 100% 100%;
    }
    td.end {
      background-image: url('/blockly/media/skins/birds/goal.png');
      background-size: 100% 100%;
      background-repeat: no-repeat;
    }
    td.obstacle {
      background-image: url('/blockly/media/skins/birds/obstacle.png');
      background-size: 100% 100%;
    }
    td.dirt {
      background-image: url('/blockly/media/skins/farmer/dirt.png');
      background-size: 1100px 100%;
      text-shadow: -1px -1px 0 #FFF, 1px -1px 0 #FFF, -1px 1px 0 #FFF, 1px 1px 0 #FFF;
    }
    td.conditional {
      background-size: 100% 100%;
      text-shadow: -1px -1px 0 #FFF, 1px -1px 0 #FFF, -1px 1px 0 #FFF, 1px 1px 0 #FFF;
    }
    td.flower {
      background-image: url('/blockly/media/skins/bee/redFlower.png');
    }
    td.hive {
      background-image: url('/blockly/media/skins/bee/hive.png');
    }
    td.flower-or-nothing {
      background-image: url('/assets/editor/flower-or-nothing.png');
    }
    td.hive-or-nothing {
      background-image: url('/assets/editor/hive-or-nothing.png');
    }
    td.flower-or-hive {
      background-image: url('/assets/editor/hive-or-flower.png');
    }
    td.flower-hive-or-nothing {
      background-image: url('/assets/editor/flower-hive-or-nothing.png');
    }
    .htInvalid { background-color: orangered !important}
    .htNumeric { text-shadow: -1px -1px 0 #FFF, 1px -1px 0 #FFF, -1px 1px 0 #FFF, 1px 1px 0 #FFF }

  - if @level.is_a? Karel
    #gridEditor
    :javascript
      var maze = eval(#{@level.properties['maze'].try(:to_json)});
      var initialDirt = eval(#{@level.properties['initial_dirt'].try(:to_json)});
      var serializedMaze = eval(#{@level.properties['serialized_maze'].try(:to_json)});

      var renderGridEditor = function () {
        React.render(React.createElement(dashboard.GridEditor, {
          maze: maze,
          initialDirt: initialDirt,
          serializedMaze: serializedMaze,
          skin: $("select[name='level[skin]']").val(),
          onUpdate: function (serializedData) {
            $('#level_maze_data').val(JSON.stringify(serializedData));
          }
        }), document.getElementById('gridEditor'));
      };

      $("select[name='level[skin]']").on('change', renderGridEditor);
      renderGridEditor();
  - else
    .row
      #mazeTable.span5
      .label.span3.offset1
        WHAT THE NUMBERS MEAN:
        %ul(style="list-style-type:none;margin:0;")
          %li.border 0 = border/wall
          %li.path 1 = path
          %li.start 2 = start
          %li.end 3 = end (for Maze levels only)
          %li.obstacle 4 = obstacle
        PLAYLAB:
        %ul(style="list-style-type:none;margin:0;")
          %li.start 16 = character
          %li.path 1 = waypoint flag

    :javascript
      var data = eval(#{@level.properties['maze'].try(:to_json)})
      function mazeRenderer(instance, td, row, col, prop, value, cellProperties) {
        var dataValues = ['border','path','start','end','obstacle'];
        if (parseInt(value) < 5 && parseInt(value) >= 0) {
            Handsontable.renderers.NumericRenderer.apply(this, arguments);
            td.className += ' ' + dataValues[parseInt(value)];
        } else if (parseInt(value) === 16) {
            Handsontable.renderers.NumericRenderer.apply(this, arguments);
            td.className += ' start';
        }
      }
      $("#mazeTable").handsontable({
        data: data, startRows: 8, startCols: 8, maxRows: 8, maxCols: 8, stretchH: 'none',
        validator: function(value, callback) {
          callback(parseInt(value) % 1 == 0);
        }, afterChange: function(changes, source) {
          $('#level_maze_data').val(JSON.stringify(data));
        }, cells: function(row, col, prop) {
          return {renderer: mazeRenderer};
      }});
