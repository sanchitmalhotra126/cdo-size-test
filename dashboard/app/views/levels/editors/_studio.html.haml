.field
  = f.label :first_sprite_index, 'First sprite index'
  %p Integer representing which sprite to use for the first character. Default is 0.
  = f.number_field :first_sprite_index
.field
  = f.label :protaganist_sprite_index, 'Protaganist sprite index'
  %p Integer of the protaganist character (zero indexed, counting from the top left of the grid). This character must touch all the waypoint flags to complete the level. If no value is set, all sprites can collect flags.
  = f.number_field :protaganist_sprite_index
.field
  = f.label :timeout_failure_tick, 'Timeout failure tick'
  %p Number of 'ticks' to simulate before marking the level as failed. Default is unlimited.  Step speed (above) controls the length of a tick.
  = f.number_field :timeout_failure_tick
.field
  = f.label :timeout_after_when_run, 'Timeout after all blocks run'
  %p When set, if the only event block that had children is when_run, and those commands are finished executing, don't wait for the timeout. If we have additional event blocks that DO have children, we keeping running until timeoutFailureTick or a success/failure condition is met
  = boolean_check_box f, :timeout_after_when_run
.field
  = f.label :custom_game_type, 'Custom game type'
  %p Used to tell playlab we want to run some of our custom onTick logic.
  = f.select :custom_game_type, options_for_select(["", "Big Game", "Rocket Height", "Sam the Bat", "Ninja Cat"], @level.custom_game_type)
.field
  = f.label :success_condition, 'Success condition'
  %p Optional JavaScript function to run every tick. If the function ever return true, the level immediately succeeds.
  = f.text_area :success_condition, rows: 4
.field
  = f.label :failure_condition, 'Failure condition'
  %p Optional JavaScript function to run every tick. If the function ever return true, the level immediately fails.
  = f.text_area :failure_condition, rows: 4
.field
  = f.label :soft_buttons, 'Controls buttons'
  %p
    Select
    %a.select_all{href: '#'} all
    \/
    %a.select_none{href: '#'} none
    (shift-click or cmd-click to select multiple). Arrow buttons to display below the game canvas.
  = f.collection_select :soft_buttons, soft_button_options, :value, :name, {selected: @level.soft_buttons}, {multiple: true}
.field
  = f.label :background, 'Starting background'
  = f.select :background, options_for_select(@level.class.background_options, @level.background), {include_blank: true}
.field
  = f.label :edge_collisions, 'Edge collisions'
  = boolean_check_box f, :edge_collisions
.field
  = f.label :projectile_collisions, 'Projectile collisions'
  = boolean_check_box f, :projectile_collisions
.field
  = f.label :allow_sprites_outside_playspace, 'Allow sprites outside playspace'
  = boolean_check_box f, :allow_sprites_outside_playspace
.field
  = f.label :sprites_hidden_to_start, 'Sprites hidden to start'
  = boolean_check_box f, :sprites_hidden_to_start
.field
  = f.label :wall_map_collisions, 'Enable walls'
  = boolean_check_box f, :wall_map_collisions
.field
  = f.label :block_moving_into_walls, 'Prevent actors from moving into walls'
  = boolean_check_box f, :block_moving_into_walls
.field
  = f.label :wall_map, 'Start with pre-built wall map'
  %p Used to tell playlab we want to start with one of the pre-built wall maps (skin dependent).
  = f.select :wall_map, options_for_select(@level.class.wall_map_options, @level.wall_map), {include_blank: true}
.field
  = f.label :sort_draw_order, 'Sort the draw order of sprites, items, and tiles so top to bottom is back to front'
  = boolean_check_box f, :sort_draw_order

-#    Fields to be added:
-#
-#    grid_aligned_movement
-#    item_grid_aligned_movement
-#    remove_items_when_actor_collides
-#    slow_execution_factor
-#    marker_height
-#    marker_width
-#    delay_completion
-#    floating_score
-#    goal_override
-#    auto_arrow_steer
-#    tap_svg_to_run_and_reset
-#    msg_string_overrides
-#    music
-#    play_start_sound
-#    show_timeout_rect
-#    progress_conditions

:javascript
  CodeMirror.fromTextArea($('#level_success_condition').get(0), {
    mode: 'javascript',
    viewportMargin: Infinity,
    matchBrackets: true
  });
  CodeMirror.fromTextArea($('#level_failure_condition').get(0), {
    mode: 'javascript',
    viewportMargin: Infinity,
    matchBrackets: true
  });
